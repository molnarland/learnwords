{"version":3,"sources":["webpack:///webpack/bootstrap ccc4fe9130ad8c82e4ba","webpack:///./assets/javascripts/menu/index.js","webpack:///./assets/javascripts/menu/Menu.js","webpack:///./assets/javascripts/menu/Global.js","webpack:///./~/onsenui/js/onsenui.js","webpack:///./~/timers-browserify/main.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/process/browser.js","webpack:///./assets/javascripts/menu/List/ListWords.js","webpack:///./assets/javascripts/menu/List/List.js","webpack:///./assets/javascripts/menu/Form/WordsForm.js","webpack:///./assets/javascripts/menu/Form/Form.js","webpack:///./assets/javascripts/menu/List/ListLabels.js","webpack:///./assets/javascripts/menu/Form/LabelsForm.js","webpack:///./assets/javascripts/menu/GameSettings/SettingsLearn.js","webpack:///./assets/javascripts/menu/GameSettings/GameSettings.js","webpack:///./~/js-cookie/src/js.cookie.js","webpack:///./assets/javascripts/menu/Game/Learn.js","webpack:///./assets/javascripts/menu/Game/Game.js","webpack:///./assets/javascripts/menu/Game/Quiz.js","webpack:///./assets/javascripts/menu/Settings.js"],"names":["window","labels","posts","document","addEventListener","event","page","target","router","enterPage","id","postPushBack","routes","ignore","indexOf","currentRoute","console","error","Menu","INFO_OF_MAIN_PAGES","addWords","button","urlHash","onsPage","addLabels","learn","settings","goToPageByButtonClick","goToPageByHash","index","infoOfPage","initByClickPushPage","location","hash","infoOfCurrentPage","info","substring","q","click","Global","SELECTOR_OF_NAVIGATOR","SELECTOR_OF_TITLE","BACK_BUTTON","SELECTOR_OF_CLEANER","URL_OF_WORD_METHODS","URL_OF_LABEL_METHODS","DIRECTORY_OF_PHOTOS","AJAX_OF_GET_ALL_LABELS","URL","METHOD","COOKIE_NAME_OF_STYLE","COOKIE_NAME_OF_COLOUR","WINDOW_NAME_OF_WORDS","WINDOW_NAME_OF_LABELS","EVENT_ADD_NEW_ITEM","EVENT_REMOVE_AN_ITEM","EVENT_EDIT_AN_ITEM","initInputCleaners","cleaners","qAll","cleaner","input","parentNode","querySelector","value","focus","where","data","animation","pushPage","selectorOfButton","callback","Function","url","isEmptyObject","argumentInUrl","search","replace","object","JSON","stringify","method","success","file","replacePartsOfUrlWithData","ajaxGet","ajaxPostBased","Error","ajaxFileUpload","response","parse","e","message","formData","FormData","append","xobj","XMLHttpRequest","open","onreadystatechange","readyState","status","checkJson","responseText","send","urlParams","setRequestHeader","datas","returnHtml","after","html","setDomElement","_util","createElement","typeOfHtml","appendChild","innerHTML","warn","showWhere","showableHtml","store","showEveryDatas","selectorOfLabel","length","ajax","result","showLabelsInInput","labelInput","label","option","_id","text","name","add","selector","split","firstCharOfSelector","charAt","getElementById","querySelectorAll","pushBack","refresh","options","Promise","resolve","popPage","then","Cookies","set","expires","ListWords","plusButton","changeForm","titleOfNewForm","titleOfEditForm","selectorOfList","selectorOfChangeItem","ajaxOfGetAll","init","initOfPushToForm","showItems","word","native","learnable","createOnsElement","List","String","downAndShow","clickableItems","clickableItem","title","item","find","dataset","titleOfNew","titleOfEdit","newItem","removedId","remove","editedItem","labelId","photo","edited","WordsForm","SELECTOR_OF_NATIVE","SELECTOR_OF_LEARNABLE","SELECTOR_OF_UPLOAD_FILE","SELECTOR_OF_SHOWED_UPLOAD_INPUT","SELECTOR_OF_PHOTO_PREVIEW","SELECTOR_OF_SAVE_BUTTON","SELECTOR_OF_LABEL","ajaxOfSaveOne","ajaxOfEditOne","ajaxOfDeleteOne","ajaxOfSavePhoto","ajaxOfEditPhoto","getLabelsForSelect","handlingOfUploadFile","validate","getFile","getNative","getLearnable","getLabel","showPhoto","oldPhoto","files","showedUploadInput","type","removeAttribute","disabled","preShowPhoto","reader","FileReader","onload","readAsDataURL","setAttribute","Form","SELECTORS","SAVE_BUTTON","DELETE_BUTTON","DELETE_WRAPPER","listenerOfSaveButtonClick","setNewItem","bind","setValues","editItem","setUpDeleteButton","selectors","valid","insertedId","userId","push","log","deleteItem","ListLabels","LabelsForm","SELECTOR_OF_LABEL_INPUT","getLabelFromInput","oldLabel","newLabel","tihs","SettingsLearn","nextButton","SELECTOR_OF_SORT","SELECTOR_OF_SHOW_BOTH","SELECTOR_OF_WHICH_SHOW_FIRST","SELECTOR_OF_LOOP","sort","showBoth","checked","showFirst","loop","get","setCookie","GameSettings","setDefaultValue","initOfPushToGame","getValue","saveAsDefaultValues","Learn","AJAX_OF_GET_WORDS_FOR_LEARN","URL_OF_GAME_METHODS","CURRENT_PAGE_NAME","SELECTOR_OF_PROGRESS_BAR","SELECTOR_OF_PROGRAM_AREA","SELECTOR_OF_BACK_BUTTON_WHEN_NO_RESULT","SELECTOR_OF_NEXT_BUTTON","LEARNABLE","SELECTOR","SPACE_OF_WORD","IMAGE","NATIVE","animationDelay","Number","words","progressRate","getWords","addLearnClassToContentWrapper","first","_getProgressRate","_startTheLearn","_setNoResult","_setProgressValue","_setLearnContentTemplate","getLearnContentSelector","setTimeout","_nextWord","_setNextContent","next","disableNextButton","_deletePreviousContent","_setCurrentContent","hideNextButton","previous","classList","removeChild","currentContent","enableNextButton","currentContentSelector","innerText","pathOfPhoto","Boolean","src","_setBackButtonListener","className","contentWrapper","learnClass","wrapper","notShowBothClass","basic","previousIndex","nextIndex","cssClass","Game","Quiz","Settings","SELECTOR_OF_STYLE","SELECTOR_OF_COLOUR","setDefaultValues","styleChange","colourChange","save","_addChangeListener"],"mappings":"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,IAAIC,OAAJ,CAAY,UAACC,OAAD,EACzB;AACC7I,0BAAS4D,aAAT,CAAuB,OAAKvB,qBAA5B,EACGyG,OADH,CACWH,OADX,EAEGI,IAFH,CAEQF,OAFR;AAGA,cALY,CAAP;AAMH;;AAED;;;;;;;;;mCAMWZ,I,EAAMpE,K,EACjB;AACImF,qBAAQC,GAAR,CAAYhB,IAAZ,EAAkBpE,KAAlB,EAAyB,EAAEqF,SAAS,OAAX,EAAzB;AACH;;AAEJ;;;;;;;;sCAKc/I,I,EACX;AACI,kBAAKA,IAAL,GAAYA,IAAZ;AACH;;;;;;mBAjkBgBiC,M;;;;;;;;;ACFrB;;AAEA;AACA;AACA;AACA;AACA,EAAC,qBAAqB;;AAEtB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,sBAAqB;AACrB;AACA;;AAEA,yCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;AAMD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA,kBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA,8CAA6C,gBAAgB;;AAE7D;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAgB;;AAEhB;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,gBAAgB;AAC7B,cAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,oBAAmB,iBAAiB;AACpC;;AAEA,iDAAgD;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO,kBAAkB;AACzB;AACA,6BAA4B,wBAAwB;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,IAAG;AACH;AACA,mBAAkB,MAAM;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAc;;AAEd;AACA,cAAa,OAAO;AACpB,eAAc,YAAY;AAC1B;AACA;AACA;AACA,IAAG;;;AAGH;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,EAAC;;AAED;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;;AAGA;AACA;;;AAGA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,iBAAgB,OAAO;AACvB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA,2CAA0C,wDAAwD,0CAA0C,wBAAwB,KAAK;;AAEzK;;AAEA;AACA,kDAAiD;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,eAAc;;AAEd;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,MAAM;AACrB,gBAAe,MAAM;AACrB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT,QAAO;;AAEP;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,MAAM;AACrB,gBAAe,MAAM;AACrB,gBAAe,YAAY;AAC3B,gBAAe,OAAO;AACtB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;;AAET,wBAAuB,2BAA2B;AAClD;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,YAAY;AAC3B,gBAAe,OAAO;AACtB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,OAAO;AACtB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA,aAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,YAAW;AACX;;AAEA;AACA,0BAAyB,0BAA0B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,IAAG,0BAA0B;;AAE7B;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,qBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,sBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,YAAW,gBAAgB;AAC3B,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,gBAAgB;AAC3B,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,gBAAgB;AAC3B,aAAY;AACZ;AACA;AACA;;AAEA;AACA,kBAAiB,+BAA+B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,gBAAgB;AAC3B,aAAY;AACZ;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB;AACA;AACA,kBAAiB,+BAA+B;AAChD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,UAAU;AACrB,cAAa,OAAO;AACpB;AACA;AACA,qFAAoF,aAAa;AACjG;AACA;;AAEA,kBAAiB,iBAAiB;AAClC;AACA;AACA,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,aAAY,IAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,YAAY;AACvB,aAAY,iBAAiB;AAC7B;AACA;AACA;AACA;;AAEA;AACA,YAAW,YAAY;AACvB,aAAY,iBAAiB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAmB,0CAA0C;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,aAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,YAAW;AACX,aAAY;AACZ;AACA;;AAEA;AACA,YAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA,aAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,GAAG;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,mBAAmB;;AAEpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA,YAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA,iBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA,8BAA6B,aAAa;AAC1C,8BAA6B,aAAa,GAAG,cAAc;AAC3D,8BAA6B,MAAM,aAAa,gBAAgB;AAChE;AACA,cAAa,kCAAkC;AAC/C,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;;AAEA,wBAAuB,0BAA0B;AACjD;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,MAAM;AACnB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,sDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAW;;AAEX;AACA,UAAS;AACT,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAkC,0BAA0B;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAW,OAAO;AAClB;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAa,YAAY;AACzB,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAW;AACX,UAAS;;AAET;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,aAAY;AACZ;AACA;AACA,6DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,aAAa;AAC1B,cAAa,SAAS;AACtB,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,aAAa;AAC1B,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,oCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,QAAQ;AACtB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,eAAe;AAC7B;AACA;AACA;AACA,wCAAuC,SAAS;AAChD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL,wCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,YAAY;AACzB,cAAa,YAAY;AACzB,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,MAAM;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,MAAM;AACnB,cAAa,MAAM;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,MAAM;AACnB,cAAa,MAAM;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,MAAM;AACnB,cAAa,MAAM;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,MAAM;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,MAAM;AACnB,cAAa,MAAM;AACnB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,eAAc,QAAQ;AACtB;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc;AACd;AACA;AACA;AACA;;AAEA,oBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB,8BAA6B,SAAS;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,2CAA0C;AAC1C;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,YAAY;AACzB,cAAa,OAAO;AACpB,cAAa,MAAM;AACnB,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA,eAAc;;AAEd;AACA;AACA,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,cAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAa,yBAAyB;AACtC,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA;AACA,uBAAsB;AACtB;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB;AACrB,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;;AAEnC;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,IAAG;;AAEH;AACA;AACA,cAAa,OAAO;AACpB,eAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB,YAAW,OAAO,YAAY;AAC9B,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA,IAAG;;AAEH,8CAA6C,0CAA0C;;AAEvF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gCAA+B,kCAAkC;AACjE,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAqD,kCAAkC;AACvF;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAgB,8BAA8B;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA,YAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH,8BAA6B,uCAAuC;;AAEpE;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iDAAgD;AAChD;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uRAAsR,kBAAkB;AACxS;;AAEA;AACA;AACA;AACA,iTAAgT;AAChT,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,eAAe;AAC1B;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA,YAAW,MAAM;AACjB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,aAAY;AACZ;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,eAAe;AAC1B;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qDAAoD,cAAc,cAAc;AAChF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,oBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,4BAA2B,gCAAgC;AAC3D,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iCAAgC,yBAAyB;AACzD;AACA,UAAS;AACT,iCAAgC,yBAAyB;AACzD;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA,4BAA2B,gCAAgC;AAC3D;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,4FAA2F,aAAa;AACxG;AACA;;AAEA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,gGAA+F,eAAe;AAC9G;AACA;;AAEA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,YAAY;AACzB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAmC,8BAA8B;;AAEjE;AACA,IAAG;AACH;AACA;AACA;AACA,oCAAmC,8CAA8C;;AAEjF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,SAAS;AACvB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,SAAS;AACzB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA,gBAAe,IAAI;AACnB,gBAAe,QAAQ;AACvB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,mDAAkD;;AAElD,qBAAoB,6CAA6C;AACjE;AACA;AACA;;AAEA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,aAAa;AACxB;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,oBAAoB;AAC/B;AACA;AACA,YAAW,YAAY;AACvB;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAiD,eAAe;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,MAAM;AACjB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,QAAQ;AACnB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB,YAAY,EAAE;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA2C;AAC3C,EAAC;;AAED;AACA,gCAA+B;AAC/B,0CAAyC;AACzC,EAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,kCAAiC,QAAQ;AACzC;AACA,MAAK,EAAE;AACP,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAwD;AACxD;AACA,MAAK,EAAE;AACP,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG,YAAY;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;AACA;;AAEA,wBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAqF,wBAAwB;AAC7G,qEAAoE;AACpE,gEAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd,eAAc;AACd,eAAc;AACd,eAAc;AACd,gBAAe;AACf,gBAAe;AACf,gBAAe;AACf,iBAAgB;AAChB;;AAEA,aAAY;;AAEZ;AACA;AACA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG,YAAY;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,sCAAqC;AACrC;AACA;AACA,IAAG,GAAG;AACN;AACA;;AAEA;;AAEA,+BAA8B,gCAAgC;;AAE9D;;AAEA;AACA,qDAAoD;AACpD;AACA,wCAAuC;AACvC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,IAAG,YAAY;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,6DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,YAAY,gBAAgB;AACjC;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;;AAGA;AACA,+BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;;AAEA;;AAEA;AACA,0EAAyE,iCAAiC;AAC1G;;AAEA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA,6DAA4D,+BAA+B;AAC3F;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA,+CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8BAA6B;AAC7B,eAAc;AACd;AACA,EAAC;AACD;AACA;AACA;AACA,kCAAiC;AACjC;AACA;AACA,WAAU;AACV,EAAC;;AAED;AACA;AACA;AACA,4EAA2E;AAC3E;AACA;AACA;;AAEA;AACA,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAiC;AACjC,eAAc;AACd,kBAAiB;AACjB;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAwD,wBAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,wEAAuE,gBAAgB;AACvF;AACA;AACA,MAAK,4CAA4C,gCAAgC;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAmD;AACnD,IAAG;AACH;AACA,wBAAuB;AACvB;AACA,cAAa;AACb,QAAO,EAAE;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,qCAAoC;AACpC,2BAA0B;AAC1B,2BAA0B;AAC1B,sBAAqB;AACrB;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,0FAAyF,OAAO;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,qDAAoD;AACpD,sBAAqB;AACrB,2BAA0B;AAC1B,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAC,YAAY;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA,IAAG,YAAY;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL,sCAAqC;AACrC,MAAK;AACL,yCAAwC;AACxC,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,sDAAqD;AACrD;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK,EAAE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,wCAAuC,mCAAmC;;AAE1E;;;AAGA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK,EAAE;AACP;;AAEA;AACA;;AAEA;;;AAGA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA,MAAK,EAAE;AACP;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,EAAC;;AAED;;;AAGA,wCAAuC,mCAAmC;;AAE1E;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,YAAW,OAAO;AAClB,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,MAAM;AACjB,YAAW,MAAM;AACjB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAW,MAAM;AACjB,YAAW,oBAAoB;AAC/B,YAAW,YAAY;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAA+B,SAAS;;AAExC;;AAEA;AACA;AACA;AACA;AACA,qCAAoC,MAAM;AAC1C;AACA;AACA;;AAEA,kDAAiD,OAAO;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAgD,QAAQ;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,yBAAyB;AACxC;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAe,uCAAuC;AACtD;;AAEA,gBAAe,0CAA0C;AACzD;;AAEA,gBAAe,yBAAyB;AACxC;;AAEA,gBAAe,QAAQ;AACvB;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,yBAAyB;AACtC;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,gBAAe,UAAU;AACzB,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,gBAAe,iBAAiB;AAChC;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,MAAM;AACrB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,MAAM;AACrB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,sBAAqB,0BAA0B;AAC/C;AACA;AACA;;AAEA;AACA,gBAAe,MAAM;AACrB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP,sBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,gBAAe,MAAM;AACrB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP,sBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,MAAM;AACrB,gBAAe,YAAY;AAC3B;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,uCAAsC,MAAM;;AAE5C;AACA;;AAEA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,2CAA0C,MAAM;;AAEhD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;;AAEA,uBAAsB,sBAAsB;AAC5C;AACA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,wBAAwB;AACvC;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB,sBAAsB;AAC3C;AACA,wBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA,cAAa,EAAE;AACf;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA,cAAa,wBAAwB;AACrC;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,UAAU;AACvB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAiB,UAAU;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAkC,aAAa;;AAE/C;AACA;;AAEA;;AAEA;AACA,IAAG;AACH;;AAEA;AACA,YAAW,wBAAwB;AACnC,YAAW,QAAQ;AACnB,YAAW,yBAAyB;AACpC;AACA;AACA;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA,qEAAoE,aAAa;AACjF;AACA;;AAEA;AACA,sCAAqC,cAAc;AACnD;AACA;AACA,MAAK;;AAEL;;AAEA,oBAAmB,4BAA4B;AAC/C;AACA;;AAEA;AACA,uBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA,wEAAuE,eAAe;AACtF;AACA;;AAEA;AACA,sCAAqC,cAAc;AACnD;AACA;AACA,MAAK;;AAEL;;AAEA,oBAAmB,4BAA4B;AAC/C;AACA;;AAEA;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA,aAAY;AACZ,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA4B,SAAS;AACrC;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,aAAY;AACZ,cAAa,MAAM;AACnB,cAAa,SAAS;AACtB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA,aAAY;AACZ,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA4B,SAAS;AACrC;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA,YAAW,wBAAwB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ,cAAa,MAAM;AACnB,cAAa,MAAM;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,aAAY;AACZ,cAAa,MAAM;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,aAAY;AACZ,cAAa,SAAS;AACtB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,aAAY;AACZ,cAAa,MAAM;AACnB,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,aAAY;AACZ,cAAa,MAAM;AACnB,cAAa,MAAM;AACnB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,uBAAsB,KAAK;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,KAAK;AAC7B,sBAAqB,eAAe;AACpC;;AAEA,0BAAyB,4BAA4B;AACrD;AACA;;AAEA;AACA,UAAS;AACT,yBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA,YAAW,wBAAwB;AACnC,YAAW,QAAQ;AACnB,YAAW,wBAAwB;AACnC;AACA;AACA;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA,qEAAoE,aAAa;AACjF;AACA;;AAEA;AACA,sCAAqC,cAAc;AACnD;AACA;AACA,MAAK;;AAEL;;AAEA,oBAAmB,4BAA4B;AAC/C;AACA;;AAEA;AACA,uBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA,wEAAuE,eAAe;AACtF;AACA;;AAEA;AACA,sCAAqC,cAAc;AACnD;AACA;AACA,MAAK;;AAEL;;AAEA,oBAAmB,4BAA4B;AAC/C;AACA;;AAEA;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa,kBAAkB;AAC/B;AACA;AACA,wEAAuE,eAAe;AACtF;AACA;;AAEA;AACA,sCAAqC,cAAc;AACnD;AACA;AACA,MAAK;;AAEL;;AAEA;;AAEA,oBAAmB,4BAA4B;AAC/C;AACA;;AAEA;AACA;AACA,wBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA,eAAc;AACd,gBAAe,EAAE,cAAc;AAC/B,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAsB,QAAQ;AAC9B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;;AAEA;AACA,0BAAyB,4BAA4B;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;;AAEH,gBAAe,eAAe;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,QAAQ;AAChC;AACA,UAAS;AACT;AACA;AACA;AACA,yBAAwB,QAAQ;AAChC;AACA;AACA;AACA,sBAAqB,MAAM;AAC3B,oEAAmE,qBAAqB;AACxF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;;AAEA;AACA;AACA,aAAY;AACZ,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,aAAY;AACZ,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,aAAY;AACZ,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,aAAY;AACZ,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,eAAc;AACd,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB,iBAAgB;AAChB;AACA;AACA;AACA,wCAAuC,SAAS;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAa,wBAAwB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,cAAa,uBAAuB;AACpC;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAwD;AACxD;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA,4BAA2B,MAAM;AACjC;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAuB,0BAA0B;AACjD;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAU;AACV;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAqC,OAAO;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC,eAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC,eAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC,aAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAY,oBAAoB;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,oBAAoB;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAY,YAAY;AACxB,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,6BAA6B;AACzC,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY,MAAM;AAClB,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY,QAAQ;AACpB,aAAY,OAAO,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAsD,kCAAkC;AACxF;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAoB;AACpB;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sIAAqI,mDAAmD;AACxL;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,uFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gJAA+I,mDAAmD;;AAElM;AACA;AACA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,uFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kJAAiJ,mDAAmD;;AAEpM;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL,uEAAsE;AACtE;AACA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,sEAAqE,aAAa;AAClF;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,yEAAwE,eAAe;AACvF;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,yEAAwE,eAAe;AACvF;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,4BAA2B;AAC3B,4EAA2E;;AAE3E;AACA,iFAAgF;AAChF;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kFAAiF,kCAAkC;;AAEnH;AACA;AACA;;AAEA;AACA,cAAa;AACb,YAAW;AACX,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oFAAmF;AACnF;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oJAAmJ,eAAe;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,6FAA4F,2CAA2C;AACvI,oEAAmE,2CAA2C;AAC9G;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,4DAA2D,6CAA6C;AACxG,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB,QAAQ;AACxB;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,4DAA2D,6CAA6C;AACxG,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,oBAAoB;AACnC;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sIAAqI,mDAAmD;AACxL;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,uFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oJAAmJ,mDAAmD;AACtM;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,uFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4IAA2I,mDAAmD;AAC9L;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,6FAA4F,2CAA2C;AACvI,gEAA+D,2CAA2C;AAC1G;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,0EAAyE,6CAA6C;AACtH,iEAAgE,6CAA6C;AAC7G,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,+EAA8E,6CAA6C;AAC3H,iEAAgE,6CAA6C;AAC7G,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,eAAe;AAC9B;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,iBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,2CAA0C,2BAA2B;;AAErE;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,2CAA0C,6DAA6D;;AAEvG;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA,0EAAyE,6CAA6C;AACtH,4DAA2D,6CAA6C;AACxG;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;;;AAGA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAgB;;AAEhB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,0BAA0B;AAC/C;;AAEA;AACA;;AAEA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,yCAAwC;AACxC,yCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wFAAuF;AACvF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uEAAsE,2CAA2C;AACjH;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,oEAAmE,kBAAkB;AACrF;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gCAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,8BAA6B;AAC7B;;AAEA,6DAA4D,iBAAiB;AAC7E;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,iCAAgC;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAkC,iCAAiC,4DAA4D,EAAE;AACjI;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAAyC,oBAAoB,sDAAsD,EAAE;AACrH;AACA,4BAA2B,uDAAuD;AAClF;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA,gBAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAiD;AACjD,wIAAuI;;AAEvI;AACA,6CAA4C,0CAA0C;AACtF,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA0B,SAAS;AACnC;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA,4CAA2C,GAAG;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,2CAA0C;AAC1C;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,8FAA6F,2CAA2C;AACxI,iEAAgE,2CAA2C;AAC3G;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA,kDAAiD,6EAA6E;AAC9H;AACA,IAAG;AACH;AACA;AACA,kDAAiD,iBAAiB;AAClE;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA8C,sDAAsD,gCAAgC,kHAAkH;;AAEtP;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4HAA2H,mDAAmD;AAC9K;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,uFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0IAAyI,mDAAmD;AAC5L;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,uFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wIAAuI,mDAAmD;;AAE1L,oDAAmD;AACnD;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,uFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4IAA2I,mDAAmD;;AAE9L,oDAAmD;AACnD;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,6FAA4F,2CAA2C;AACvI,oEAAmE,2CAA2C;AAC9G;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,4DAA2D,6CAA6C;AACxG,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB,QAAQ;AACxB;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,4DAA2D,6CAA6C;AACxG,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,eAAe;AAC9B;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,qBAAoB,0DAA0D;AAC9E;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA,eAAc;AACd;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA,eAAc,mBAAmB;AACjC;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA,cAAa,QAAQ;AACrB,cAAa,mBAAmB;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,0BAAyB;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA,wFAAuF;AACvF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0FAAyF;AACzF;;AAEA,4CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA,4BAA2B,YAAY;AACvC;AACA;AACA;AACA,QAAO;AACP,qIAAoI;AACpI,6BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,gDAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA,0BAAyB,UAAU;AACnC;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,OAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,sBAAqB,0BAA0B;AAC/C;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT,oDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;;AAExB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iCAAgC;;AAEhC,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;;AAEP;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0HAAyH,mDAAmD;AAC5K;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kIAAiI,mDAAmD;AACpL;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kIAAiI,mDAAmD;AACpL;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,6FAA4F,2CAA2C;AACvI,yEAAwE,2CAA2C;AACnH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,iKAAgK;AAChK;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,0EAAyE,qBAAqB;AAC9F;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK,eAAe;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,gFAA+E,+BAA+B,aAAa,cAAc;AACzI;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uJAAsJ,mDAAmD;;AAEzM,uFAAsF,aAAa,cAAc,kCAAkC;;AAEnJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA,eAAc;AACd;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA,cAAa;AACb;AACA;AACA,YAAW;AACX;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA,cAAa;AACb;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX,mBAAkB,aAAa;AAC/B;AACA,YAAW;AACX,mBAAkB,aAAa;AAC/B;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,YAAW;AACX,mBAAkB,aAAa;AAC/B;AACA,YAAW;AACX,mBAAkB,aAAa;AAC/B;AACA;AACA,YAAW;AACX,UAAS;;AAET;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA,cAAa;AACb;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT,iBAAgB,aAAa;AAC7B;AACA,UAAS;AACT,iBAAgB,aAAa;AAC7B;AACA;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uJAAsJ,mDAAmD;;AAEzM;;AAEA,oFAAmF,cAAc,aAAa,aAAa,QAAQ,WAAW,aAAa,+HAA+H;;AAE1R;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,UAAS;;AAET;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sEAAqE,aAAa;AAClF;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yEAAwE,eAAe;AACvF;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qJAAoJ,mDAAmD;;AAEvM,uFAAsF,aAAa,cAAc,oDAAoD;AACrK;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gJAA+I,mDAAmD;AAClM;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qJAAoJ,mDAAmD;;AAEvM,uFAAsF,aAAa,cAAc,YAAY,kCAAkC,YAAY;AAC3K;AACA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mJAAkJ,mDAAmD;;AAErM,uFAAsF,aAAa,cAAc,kCAAkC;AACnJ;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mJAAkJ,mDAAmD;;AAErM;AACA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA,+FAA8F,2CAA2C;AACzI,sEAAqE,2CAA2C;AAChH;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,8BAA6B;AAC7B,6BAA4B;;AAE5B;AACA;AACA;AACA;AACA,+DAA8D,kCAAkC;AAChG,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAuB;;AAEvB;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,0BAAyB,yBAAyB;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,gBAAe;AACf,cAAa;AACb;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG,gBAAe,SAAS;AACxB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAiD,yEAAyE,gCAAgC;;AAE1J;AACA,0CAAyC,sBAAsB,oBAAoB;AACnF;;AAEA;AACA;AACA;;AAEA;AACA,0DAAyD,gEAAgE;;AAEzH;AACA;AACA;;AAEA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,4DAA2D,6CAA6C;AACxG,gBAAe,SAAS;AACxB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,qCAAoC,+DAA+D;AACnG;AACA;AACA,cAAa;AACb,YAAW;AACX,UAAS;AACT;;AAEA;AACA;AACA,oCAAmC,mDAAmD;AACtF;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,+BAA8B,oBAAoB,GAAG,qCAAqC;;AAE1F;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iDAAgD,+BAA+B,eAAe;AAC9F,wCAAuC,sBAAsB,oBAAoB;AACjF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb,2DAA0D,gEAAgE;;AAE1H;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA,YAAW;;AAEX,oDAAmD,uHAAuH;;AAE1K;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,cAAc;AAC7B;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+BAA8B,oBAAoB,YAAY,aAAa;;AAE3E,eAAc;AACd;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,0CAAyC,YAAY;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,QAAQ;AACvB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,0CAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA,yEAAwE,6CAA6C;AACrH,4DAA2D,6CAA6C;AACxG;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,+CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA,8DAA6D,kBAAkB;AAC/E;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA,UAAS;AACT;;AAEA,yCAAwC;AACxC,0DAAyD;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8HAA6H,mDAAmD;AAChL;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA,YAAW,eAAe;AAC1B,UAAS;AACT,IAAG;AACH;AACA,YAAW,aAAa;AACxB,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,oBAAmB;AACnB,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,6FAA4F,2CAA2C;AACvI,mEAAkE,2CAA2C;AAC7G;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA,eAAc;AACd;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,yBAAyB;AACxC;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,8BAA6B;AAC7B,QAAO;AACP,8BAA6B,YAAY,iBAAiB;AAC1D;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wCAAuC;;AAEvC;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,gBAAgB;AAC/B;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,oDAAmD,oCAAoC;AACvF,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,sDAAqD,sCAAsC;AAC3F,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,qCAAqC;AACzD;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB;AACvB;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,UAAS;AACT,iCAAgC,gBAAgB;AAChD;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA,uCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA,iCAAgC,gBAAgB;AAChD;AACA,QAAO;AACP;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oCAAmC,sDAAsD;AACzF;AACA;;AAEA,oCAAmC,uDAAuD;AAC1F;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,QAAQ;AACvB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,iBAAgB,OAAO;AACvB,iBAAgB,SAAS;AACzB,iBAAgB,SAAS,4CAA4C;AACrE,iBAAgB,SAAS;AACzB,iBAAgB,SAAS;AACzB;AACA;AACA,4CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;;AAEb;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc,cAAc;AAC5B,eAAc,OAAO,YAAY;AACjC,eAAc,QAAQ;AACtB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA,wBAAuB;AACvB,QAAO;AACP;;AAEA;AACA;AACA;AACA,eAAc,OAAO,YAAY;AACjC,eAAc,QAAQ;AACtB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+DAA8D,WAAW;AACzE,eAAc,QAAQ;AACtB,eAAc,OAAO;AACrB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA,gCAA+B,aAAa;AAC5C;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;;AAEA,eAAc;AACd;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAAyB,cAAc;AACvC,uCAAsC,aAAa;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,qCAAoC,iBAAiB;AACrD;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iDAAgD,YAAY;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;;AAEX;AACA,UAAS;AACT;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA,6CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,8EAA6E,gBAAgB;AAC7F;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA,2CAA0C;AAC1C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,sBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,2BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA,4BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA,4BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA,4BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,qBAAoB,gCAAgC;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,wBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;;;AAGA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAiC,6BAA6B;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;;AAEX;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,gBAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,yDAAwD;AACxD,UAAS;AACT;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,0CAAyC;AACzC;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gIAA+H,mDAAmD;AAClL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,QAAQ;AACvB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB;;AAEA,IAAG;AACH;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAAyC;;AAEzC;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,0CAAyC;;AAEzC;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,8DAA6D,6CAA6C;AAC1G,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAAyC;;AAEzC;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,yBAAwB,uCAAuC;AAC/D,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,6FAA4F,2CAA2C;AACvI,mEAAkE,2CAA2C;AAC7G;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;;AAEP;;AAEA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,sDAAqD,aAAa;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,yCAAwC;;AAExC;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA,uDAAsD,yBAAyB;AAC/E;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,2DAA0D,uBAAuB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;;;AAGA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,kCAAiC,6BAA6B;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAW;;AAEX;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,gBAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4DAA2D;;AAE3D;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,0DAAyD,uCAAuC;AAChG;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA,cAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,6FAA4F,2CAA2C;AACvI,mEAAkE,2CAA2C;AAC7G;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA,gCAA+B,8CAA8C;AAC7E;AACA;AACA,YAAW,aAAa;AACxB,UAAS;AACT;;AAEA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,yBAAwB,UAAU,kEAAkE;AACpG;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,sBAAqB;AACrB,sDAAqD;AACrD;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kEAAiE;AACjE;AACA;AACA;;AAEA;AACA;AACA,iDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA,gCAA+B;;AAE/B;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAoD,6DAA6D;AACjH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,0CAAyC,sDAAsD,sHAAsH,gCAAgC;AACrP,UAAS;AACT;AACA;AACA,UAAS;AACT,QAAO;AACP;;AAEA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;;;AAGA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC,iBAAiB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAwC,kBAAkB;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP,gDAA+C,gBAAgB;AAC/D;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,kCAAiC,6BAA6B;AAC9D,2EAA0E;AAC1E;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA,IAAG;AACH;;;AAGA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA,gBAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,mDAAkD,gEAAgE;AAClH,kFAAiF;AACjF;AACA;;AAEA;AACA,YAAW;AACX;;AAEA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0HAAyH,mDAAmD;AAC5K;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kIAAiI,mDAAmD;AACpL;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,2IAA0I,mDAAmD;;AAE7L,6DAA4D;AAC5D;AACA,4BAA2B;AAC3B,MAAK;AACL;AACA,8BAA6B;AAC7B,QAAO;AACP,8BAA6B;AAC7B,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uIAAsI,mDAAmD;;AAEzL,mDAAkD;AAClD;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uIAAsI,mDAAmD;;AAEzL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,cAAa,YAAY;AACzB,cAAa,SAAS;AACtB;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;;AAEA;AACA,gBAAe,YAAY;AAC3B,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA,6FAA4F,2CAA2C;AACvI,yEAAwE,2CAA2C;AACnH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;;AAEA;AACA,iCAAgC;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA,gBAAe,OAAO;AACtB,yEAAwE,6CAA6C;AACrH,2DAA0D,6CAA6C;AACvG;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA,2CAA0C,6DAA6D;;AAEvG;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;AAED;AACA;;AAEA;AACA,gBAAe;AACf;;AAEA;;AAEA,EAAC;AACD,4CAA2C,cAAc;;;;;;;;;;;ACji+BzD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;ACpDA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA0C,sBAAsB,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAU;AACV;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;;AAEA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,EAAC;;;;;;;;;;;ACzLD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC;;AAErC;AACA;AACA;;AAEA,4BAA2B;AAC3B;AACA;AACA;AACA,6BAA4B,UAAU;;;;;;;;;;;;;;;;;;;;ACvLtC;;;;;;;;;;;;KAEqB+G,S;;;AAEjB,wBAAahJ,IAAb,EACA;AAAA;;AAAA,2HACUA,IADV;;AAGI,eAAKiJ,UAAL,GAAkB,YAAlB;AACA,eAAKC,UAAL,GAAkB,mBAAlB;;AAEA,eAAKC,cAAL,GAAsB,UAAtB;AACA,eAAKC,eAAL,GAAuB,WAAvB;;AAEA,eAAKC,cAAL,GAAsB,qBAAtB;AACA,eAAKC,oBAAL,GAA+B,MAAKD,cAApC;;AAEA,eAAKE,YAAL,GAAoB;AAChBpF,kBAAQ,MAAK7B,mBAAb,MADgB;AAEhBqC,qBAAQ;AAFQ,UAApB;;AAKA,eAAK6E,IAAL;AAjBJ;AAkBC;;;;gCAGD;AACI,kBAAKC,gBAAL;AACA,kBAAKC,SAAL;AACH;;AA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","file":"menu.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ccc4fe9130ad8c82e4ba","import Menu from './Menu';\nimport ListWords from './List/ListWords';\nimport WordsForm from './Form/WordsForm';\nimport ListLabels from './List/ListLabels';\nimport LabelsForm from './Form/LabelsForm';\nimport SettingsLearn from './GameSettings/SettingsLearn';\nimport Learn from './Game/Learn';\nimport Quiz from './Game/Quiz';\nimport Settings from './Settings';\n\nwindow.labels = [];\nwindow.posts = [];\n\ndocument.addEventListener('init', (event) =>\n{\n    const page = event.target;\n\n    router(page, {\n        'menu': Menu,\n        'change-words': ListWords,\n        'change-words-form': WordsForm,\n        'change-labels': ListLabels,\n        'change-label-form': LabelsForm,\n        'settings-learn': SettingsLearn,\n        'learn': Learn,\n        'quiz': Quiz,\n        'settings': Settings\n    }, ['learnable', 'native']);\n});\n\ndocument.addEventListener('postpop', (event) =>\n{\n    window[event.enterPage.id].postPushBack(event.enterPage);\n});\n\n\n/**\n * @desc Call classes\n * @summary If require here these objects than will be slow!\n *\n * @param {object} page\n * @param {object} routes\n * @param {array} ignore\n */\nfunction router(page, routes, ignore)\n{\n    if (ignore.indexOf(page.id) < 0)\n    {\n        let id = page.id;\n        let currentRoute = routes[id];\n\n        if (!currentRoute)\n        {\n            return console.error(`This route id (${id}) does not exist!`);\n        }\n\n        if (typeof currentRoute === 'function')\n        {\n            window[id] = new currentRoute(page);\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/index.js","import Global from './Global';\n\nexport default class Menu extends Global\n{\n    constructor (page)\n    {\n        super(page);\n\n        /**\n         * @property INFO_OF_MAIN_PAGES\n         * @type {{\n         *          addWords: {button: string, urlHash: string, onsPage: string},\n         *          addLabels: {button: string, urlHash: string, onsPage: string},\n         *          learn: {button: string, urlHash: string, onsPage: string},\n         *          settings: {button: string, urlHash: string, onsPage: string}\n         * }}\n         */\n        this.INFO_OF_MAIN_PAGES = {\n            addWords: {\n                button: '#change-words',\n                urlHash: 'change_words',\n                onsPage: 'change-words'\n            },\n            addLabels: {\n                button: '#change-labels',\n                urlHash: 'change_labels',\n                onsPage: 'change-labels'\n            },\n            learn: {\n                button: '#settings-learn',\n                urlHash: 'learn',\n                onsPage: 'settings-learn'\n            },\n            settings: {\n                button: '#settings',\n                urlHash: 'settings',\n                onsPage: 'settings'\n            }\n        };\n\n        this.goToPageByButtonClick();\n        this.goToPageByHash();\n        /*if (\"onhashchange\" in window)\n        {\n            window.addEventListener(\"hashchange\", () => this.goToPageByHash(), false);\n        }*/\n    }\n\n    /**\n     * @desc Add click event listener for each button what will push to correct page\n     */\n    goToPageByButtonClick ()\n    {\n        for (let index in this.INFO_OF_MAIN_PAGES)\n        {\n            const infoOfPage = this.INFO_OF_MAIN_PAGES[index];\n            this.initByClickPushPage(infoOfPage.button, infoOfPage.onsPage, null, () =>\n            {\n                window.location.hash = infoOfPage.urlHash;\n            });\n        }\n    }\n\n    /**\n     * @desc At loading check hash in url and pass to there\n     */\n    goToPageByHash ()\n    {\n        let infoOfCurrentPage = null;\n        for (let index in this.INFO_OF_MAIN_PAGES)\n        {\n            const info = this.INFO_OF_MAIN_PAGES[index];\n            if (info.urlHash === window.location.hash.substring(1))\n            {\n                infoOfCurrentPage = info;\n                break;\n            }\n        }\n\n\n        if (infoOfCurrentPage)\n        {\n            this.q(infoOfCurrentPage.button).click();\n        }\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/Menu.js","import ons from 'onsenui';\n\nexport default class Global\n{\n    constructor(page)\n    {\n        this.page = page;\n\n        /**\n         * @property SELECTOR_OF_NAVIGATOR\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_NAVIGATOR = '#navigator';\n        /**\n         * @property SELECTOR_OF_TITLE\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_TITLE = 'ons-toolbar .center';\n        /**\n         * @property BACK_BUTTON\n         * @type {string}\n         * @const\n         */\n        this.BACK_BUTTON = 'ons-back-button';\n        /**\n         * @property SELECTOR_OF_CLEANER\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_CLEANER = '.input-cleaner';\n\n        /**\n         * @property URL_OF_WORD_METHODS\n         * @type {string}\n         * @const\n         */\n        this.URL_OF_WORD_METHODS = '/words';\n        /**\n         * @property URL_OF_LABEL_METHODS\n         * @type {string}\n         * @const\n         */\n        this.URL_OF_LABEL_METHODS = '/labels';\n\n        /**\n         * @property DIRECTORY_OF_PHOTOS\n         * @type {string}\n         * @const\n         */\n        this.DIRECTORY_OF_PHOTOS = '/photos';\n\n        /**\n         * @property AJAX_OF_GET_ALL_LABELS\n         * @type {{URL: string, METHOD: string}}\n         * @const\n         */\n        this.AJAX_OF_GET_ALL_LABELS = {\n            URL: `${this.URL_OF_LABEL_METHODS}/`,\n            METHOD: 'GET'\n        };\n\n        /**\n         * @property COOKIE_NAME_OF_STYLE\n         * @type {string}\n         * @const\n         */\n        this.COOKIE_NAME_OF_STYLE = 'style';\n        /**\n         * @property COOKIE_NAME_OF_COLOUR\n         * @type {string}\n         * @const\n         */\n        this.COOKIE_NAME_OF_COLOUR = 'colour';\n\t\t/**\n\t\t * @type {string}\n         * @const\n\t\t */\n\t\tthis.WINDOW_NAME_OF_WORDS = 'words';\n\t\t/**\n\t\t * @type {string}\n         * @const\n\t\t */\n\t\tthis.WINDOW_NAME_OF_LABELS = 'labels';\n\t\t/**\n\t\t * @type {string}\n         * @const\n\t\t */\n\t\tthis.EVENT_ADD_NEW_ITEM = 'add-new-item';\n\t\t/**\n\t\t * @type {string}\n         * @const\n\t\t */\n\t\tthis.EVENT_REMOVE_AN_ITEM = 'remove-item';\n\t\t/**\n\t\t * @type {string}\n         * @const\n\t\t */\n\t\tthis.EVENT_EDIT_AN_ITEM = 'edit-item';\n\n\n\n\n\n        this.initInputCleaners();\n    }\n\n    /**\n     * @desc Event listener for Xs on inputs\n     */\n    initInputCleaners ()\n    {\n        const cleaners = this.qAll(this.SELECTOR_OF_CLEANER);\n        for (const cleaner of cleaners)\n        {\n            cleaner.addEventListener('click', () =>\n            {\n                let input = cleaner.parentNode.querySelector('input');\n\n                input.value = '';\n                input.focus();\n            });\n        }\n    }\n\n    /**\n     * @desc Make sorter the ons's pushPage()\n     *\n     * @param {string} where - Next page\n     * @param {object} [data]\n     * @param {string} [animation]\n     */\n    pushPage (where, data = {}, animation = '')\n    {\n        document.querySelector(this.SELECTOR_OF_NAVIGATOR).pushPage(where, {\n            data: data,\n            animation: animation\n        });\n    }\n\n    /**\n     * @desc Add click eventListener for an element what will push next page\n     *\n     * @param {string} selectorOfButton\n     * @param {string} where - Next page\n     * @param {object} [data]\n     * @param {object} [callback]\n     */\n    initByClickPushPage (selectorOfButton, where, data = {}, callback = new Function())\n    {\n        this.q(selectorOfButton).addEventListener('click', () =>\n        {\n            document.querySelector(this.SELECTOR_OF_NAVIGATOR).pushPage(where, data);\n            callback();\n        });\n    }\n\n    /**\n     * @desc Replace ':variable' part in url with data.variable\n     *\n     * @param {string} url\n     * @param {object} data\n     * @param {function} callback\n     */\n    replacePartsOfUrlWithData (url, data, callback)\n    {\n        if (data && !this.isEmptyObject(data) && url)\n        {\n            for (let index in data)\n            {\n                const argumentInUrl = `:${index}`;\n                if (url.search(argumentInUrl) > -1)\n                {\n                    url = url.replace(argumentInUrl, data[index]);\n                    delete data[index];\n                }\n            }\n        }\n\n        callback(url, data);\n    }\n\n    /**\n     * @param {object} object\n     * @return boolean\n     */\n    isEmptyObject (object)\n    {\n        return JSON.stringify(object) === JSON.stringify({});\n    }\n\n    /**\n     * @desc Call correct method what depends from file and method variables\n     *\n     * @param {string} [method]\n     * @param {string} url\n     * @param {object} [data]\n     * @param {function} success\n     * @param {boolean} [file]\n     */\n    ajax ({method = 'POST', url, data = {}, success, file = false})\n    {\n        this.replacePartsOfUrlWithData(url, data, (url, data) =>\n        {\n            if (!file)\n            {\n                if (method === 'GET' || method === 'get')\n                {\n                    data = (this.isEmptyObject(data)) ? null : data;\n                    this.ajaxGet(url, success, data);\n                }\n                else\n                {\n                    this.ajaxPostBased(method, url, data, success);\n                }\n            }\n            else\n            {\n                if (method === 'GET' || method === 'get')\n                {\n                    throw new Error('Cannot run ajax with GET method');\n                }\n\n                this.ajaxFileUpload(method, url, data, success);\n            }\n        });\n    }\n\n\n    /**\n     * @desc Try return json in callback, if cannot return with official variable\n     *\n     * @param {string} response\n     * @param {function} callback\n     * @return {json|*}\n     */\n    checkJson (response, callback)\n    {\n        try\n        {\n            callback(JSON.parse(response));\n        }\n        catch (e)\n        {\n            console.error(e.message);\n            callback(response);\n        }\n    }\n\n    /**\n     * @desc For file upload through ajax\n     *\n     * @param {string} method\n     * @param {string} url\n     * @param {file}  file\n     * @param {function} success\n     */\n    ajaxFileUpload (method, url, file, success)\n    {\n        const formData = new FormData();\n        formData.append('file', file);\n\n        let xobj = new XMLHttpRequest();\n        xobj.open(method, `/ajax${url}`, true);\n        xobj.onreadystatechange = () =>\n        {\n            if (xobj.readyState == 4 && xobj.status == \"200\")\n            {\n                return this.checkJson(xobj.responseText, success)\n            }\n        };\n        xobj.send(formData);\n    }\n\n    /**\n     * @desc For GET ajax calls\n     *\n     * @param {string} url\n     * @param {function(object)} callback\n     * @param {object|null} [data]\n     */\n    ajaxGet (url, callback, data = null)\n    {\n        let urlParams = '';\n        /*if (data)\n        {\n            urlParams = '?';\n            for (let index in data)\n            {\n                urlParams += `${index}=${data[index]}&`\n            }\n\n            urlParams = urlParams.slice(0, urlParams.length - 1);\n        }*/\n\n        let xobj = new XMLHttpRequest();\n        xobj.open('GET', `/ajax${url}${urlParams}`, true);\n        xobj.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n        xobj.onreadystatechange = () =>\n        {\n            if (xobj.readyState == 4 && xobj.status == \"200\")\n            {\n                return this.checkJson(xobj.responseText, callback)\n            }\n        };\n        xobj.send(null);\n    }\n\n    /**\n     * @desc For POST, PUT, DELETE ajax calls\n     *\n     * @param {string} method\n     * @param {string} url\n     * @param {object} data\n     * @param{function(object)}  callback\n     */\n    ajaxPostBased(method, url, data, callback)\n    {\n        let xobj = new XMLHttpRequest();\n        xobj.open(method, `/ajax${url}`, true);\n        xobj.setRequestHeader(\"Content-Type\", \"application/json;charset=UTF-8\");\n        xobj.onreadystatechange = () =>\n        {\n            if (xobj.readyState == 4 && xobj.status == \"200\")\n            {\n                return this.checkJson(xobj.responseText, callback)\n            }\n        };\n        xobj.send(JSON.stringify(data));\n    }\n\n    /**\n     * @desc Call setDomElement() each data object and pass result of returnHtml with where variable\n     *\n     * @param {Element|string} where\n     * @param {object} datas\n     * @param {function} returnHtml\n     * @param {function} [after]\n     */\n    showEveryDatas ({where, datas, returnHtml, after = new Function()})\n    {\n        for (let data of datas)\n        {\n            const html = returnHtml(data);\n\n            this.setDomElement({\n                where: where,\n                html: html\n            });\n        }\n\n        return after();\n    }\n\n    /**\n     * @param {string} html\n     * @return {Element|*}\n     */\n    createOnsElement (html)\n    {\n        return ons._util.createElement(html);\n    }\n\n    /**\n     * @param {Element|string} where\n     * @param {Element|string} html\n     * @param {function} callback\n     */\n    setDomElement ({where, html, callback = new Function()})\n    {\n        if (typeof where === 'string')\n        {\n            where = this.q(where);\n        }\n\n\n        const typeOfHtml = typeof html;\n        if (typeOfHtml === 'object')\n        {\n            where.appendChild(html);\n        }\n        else if (typeOfHtml === 'string')\n        {\n            where.innerHTML += html;\n        }\n        else\n        {\n            console.warn('result of returnHtml does not object or string so I cannot add it to DOM');\n        }\n\n        return callback();\n    }\n\n    /**\n     * @desc Call showEveryDatas() after got data from server\n     *\n     * @param {string} url\n     * @param {string} showWhere\n     * @param {function} showableHtml\n     * @param {string} [store] - Name of variable on window object, data will save here\n     * @param {function} [after]\n     */\n    downAndShow ({url, showWhere, showableHtml, store = null, after})\n    {\n        this.ajaxGet(url, (response) =>\n        {\n            if (store)\n            {\n                window[store] = response;\n            }\n\n            return this.showEveryDatas({\n                where: showWhere,\n                datas: response,\n                returnHtml: showableHtml,\n                after: after\n            });\n        });\n    }\n\n    /*/**\n     * @desc Call downAndShow() after send data to server\n     *\n     * @param {string} upUrl\n     * @param {object} upData\n     * @param {string} downUrl\n     * @param {string} showWhere\n     * @param {function} showableHtml\n     * @param {function} [after]\n     *!/\n    upDownAndShow ({upUrl, upData, downUrl, showWhere, showableHtml, after})\n    {\n        this.postAjax(upUrl, upData, (response) =>\n        {\n            if (response)\n            {\n                return this.downAndShow({\n                    url: downUrl,\n                    showWhere: showWhere,\n                    showableHtml: showableHtml,\n                    after: after\n                });\n            }\n\n            return false;\n        });\n    }\n\n    /**\n     * @param {string} hash\n     *!/\n    changeHash (hash)\n    {\n        window.location.hash = hash;\n    }*/\n\n\n    /**\n     * @desc Call the showLabelsInInput() after got labels from backend\n     *\n     * @param {string} selectorOfLabel\n     * @param {function} [callback]\n     */\n    getLabelsForSelect (selectorOfLabel, callback = new Function())\n    {\n        if (window.labels.length === 0)\n        {\n            this.ajax({\n                method: this.AJAX_OF_GET_ALL_LABELS.METHOD,\n                url: this.AJAX_OF_GET_ALL_LABELS.URL,\n                success: (result) =>\n                {\n                    window.labels = result;\n\n                    return this.showLabelsInInput(selectorOfLabel, callback);\n                }\n            });\n        }\n\n        return this.showLabelsInInput(selectorOfLabel, callback);\n    }\n\n    /**\n     * @desc Put labels from window.labels to select input\n     *\n     * @param {string} selectorOfLabel\n     * @param {function} [callback]\n     */\n    showLabelsInInput (selectorOfLabel, callback = new Function())\n    {\n        const labelInput = this.q(selectorOfLabel);\n\n        for (const label of window.labels)\n        {\n            const option = document.createElement('option');\n            option.value = label._id;\n            option.text = label.name;\n\n            labelInput.add(option);\n        }\n\n        return callback();\n    }\n\n    /**\n     * @desc Make sorter the querySelector\n     *\n     * @param {string} selector\n     * @return {Element}\n     */\n    q (selector)\n    {\n        const length = selector.split(' ').length;\n        const firstCharOfSelector = selector.charAt(0);\n\n\n        if (length <= 1 && firstCharOfSelector === '#')\n        {\n            return document.getElementById(selector.substring(1));\n        }\n\n        return this.page.querySelector(selector);\n    }\n\n    /**\n     * @desc Make sorter the querySelectorAll\n     *\n     * @param {string} selector\n     * @return {NodeList}\n     */\n    qAll (selector)\n    {\n        return this.page.querySelectorAll(selector);\n    }\n\n    /**\n     * @desc If want to refresh elements from backend\n     */\n    pushBackWithRefresh ()\n    {\n        this.pushBack({refresh: true});\n    }\n\n    /**\n     * @desc It push back to previous page from current, back buttons automatically from ONS\n     *\n     * @param {object} [options]\n     * @return Promise<HTMLElement>\n     */\n    pushBack (options = {})\n    {\n        return new Promise((resolve) =>\n\t\t{\n\t\t\tdocument.querySelector(this.SELECTOR_OF_NAVIGATOR)\n\t\t\t\t\t.popPage(options)\n\t\t\t\t\t.then(resolve);\n\t\t});\n    }\n\n    /**\n     * @desc Set default expires time for do not forgot\n     *\n     * @param {string} name\n     * @param {string} value\n     */\n    setCookie (name, value)\n    {\n        Cookies.set(name, value, { expires: 1000000 });\n    }\n\n\t/**\n     * @desc Refresh the this.page object after pop event\n     *\n\t * @param {object} page\n\t */\n\tpostPushBack (page)\n    {\n        this.page = page;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/Global.js","/* onsenui v2.8.2 - 2017-11-22 */\n\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global.ons = factory());\n}(this, (function () { 'use strict';\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Add vendor prefix.\n *\n * @param {String} name\n * @return {String}\n */\nvar prefix = function () {\n  var styles = window.getComputedStyle(document.documentElement, '');\n  var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];\n\n  return function (name) {\n    return '-' + prefix + '-' + util.hyphenate(name);\n  };\n}();\n\n/**\n * Minimal utility library for manipulating element's style.\n * Set element's style.\n *\n * @param {Element} element\n * @param {Object} styles\n * @return {Element}\n */\nvar styler = function styler(element, style) {\n  Object.keys(style).forEach(function (key) {\n    if (key in element.style) {\n      element.style[key] = style[key];\n    } else if (prefix(key) in element.style) {\n      element.style[prefix(key)] = style[key];\n    } else {\n      util.warn('No such style property: ' + key);\n    }\n  });\n  return element;\n};\n\n/**\n * @param {Element} element\n * @param {String} styles Space-separated CSS properties to remove\n */\nstyler.clear = function (element) {\n  var styles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var clearlist = styles.split(/\\s+/).reduce(function (r, s) {\n    return r.concat([util.hyphenate(s), prefix(s)]);\n  }, []),\n      keys = [];\n\n  var _loop = function _loop(i) {\n    var key = element.style[i];\n    if (clearlist.length === 0 || clearlist.some(function (s) {\n      return key.indexOf(s) === 0;\n    })) {\n      keys.push(key); // Store the key to fix Safari style indexes\n    }\n  };\n\n  for (var i = element.style.length - 1; i >= 0; i--) {\n    _loop(i);\n  }\n\n  keys.forEach(function (key) {\n    return element.style[key] = '';\n  });\n  element.getAttribute('style') === '' && element.removeAttribute('style');\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n// Save HTMLElement object before Custom Elements polyfill patch global HTMLElement.\nvar NativeHTMLElement = window.HTMLElement;\n\n/**\n * @object ons.platform\n * @category util\n * @description\n *   [en]Utility methods to detect current platform.[/en]\n *   [ja]現在実行されているプラットフォームを検知するためのユーティリティメソッドを収めたオブジェクトです。[/ja]\n */\n\nvar Platform = function () {\n\n  /**\n   * All elements will be rendered as if the app was running on this platform.\n   * @type {String}\n   */\n  function Platform() {\n    classCallCheck(this, Platform);\n\n    this._selectedPlatform = null;\n    this._ignorePlatformSelect = false;\n  }\n\n  /**\n   * @method select\n   * @signature select(platform)\n   * @param  {string} platform Name of the platform.\n   *   [en]Possible values are: \"opera\", \"firefox\", \"safari\", \"chrome\", \"ie\", \"android\", \"blackberry\", \"ios\" or \"wp\".[/en]\n   *   [ja]\"opera\", \"firefox\", \"safari\", \"chrome\", \"ie\", \"android\", \"blackberry\", \"ios\", \"wp\"のいずれかを指定します。[/ja]\n   * @description\n   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]\n   *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]\n   */\n\n\n  createClass(Platform, [{\n    key: 'select',\n    value: function select(platform) {\n      if (typeof platform === 'string') {\n        this._selectedPlatform = platform.trim().toLowerCase();\n      }\n    }\n  }, {\n    key: '_getSelectedPlatform',\n    value: function _getSelectedPlatform() {\n      return this._ignorePlatformSelect ? null : this._selectedPlatform;\n    }\n  }, {\n    key: '_runOnActualPlatform',\n    value: function _runOnActualPlatform(fn) {\n      this._ignorePlatformSelect = true;\n      var result = fn();\n      this._ignorePlatformSelect = false;\n\n      return result;\n    }\n\n    //----------------\n    // General\n    //----------------\n    /**\n     * @method isWebView\n     * @signature isWebView()\n     * @description\n     *   [en]Returns whether app is running in Cordova.[/en]\n     *   [ja]Cordova内で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isWebView',\n    value: function isWebView() {\n      if (document.readyState === 'loading' || document.readyState == 'uninitialized') {\n        throw new Error('isWebView() method is available after dom contents loaded.');\n      }\n\n      return !!(window.cordova || window.phonegap || window.PhoneGap);\n    }\n\n    //----------------\n    // iOS devices\n    //----------------\n    /**\n     * @method isIPhone\n     * @signature isIPhone()\n     * @description\n     *   [en]Returns whether the device is iPhone.[/en]\n     *   [ja]iPhone上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isIPhone',\n    value: function isIPhone() {\n      return (/iPhone/i.test(navigator.userAgent)\n      );\n    }\n\n    /**\n     * @method isIPhoneX\n     * @signature isIPhoneX()\n     * @description\n     *   [en]Returns whether the device is iPhone X.[/en]\n     *   [ja]iPhone X上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isIPhoneX',\n    value: function isIPhoneX() {\n      // iPhone 8 and iPhone X have a same user agent. We cannot avoid using window.screen.\n      // This works well both in iOS Safari and (UI|WK)WebView of iPhone X.\n      return this.isIPhone() && window.screen.width === 375 && window.screen.height === 812;\n    }\n\n    /**\n     * @method isIPad\n     * @signature isIPad()\n     * @description\n     *   [en]Returns whether the device is iPad.[/en]\n     *   [ja]iPad上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isIPad',\n    value: function isIPad() {\n      return (/iPad/i.test(navigator.userAgent)\n      );\n    }\n\n    /**\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isIPod',\n    value: function isIPod() {\n      return (/iPod/i.test(navigator.userAgent)\n      );\n    }\n\n    //----------------\n    // iOS versions\n    //----------------\n    /**\n     * @method isIOS\n     * @signature isIOS()\n     * @description\n     *   [en]Returns whether the OS is iOS.[/en]\n     *   [ja]iOS上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isIOS',\n    value: function isIOS() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'ios';\n      }\n\n      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {\n        return (/iOS/i.test(device.platform)\n        );\n      } else {\n        return (/iPhone|iPad|iPod/i.test(navigator.userAgent)\n        );\n      }\n    }\n\n    /**\n     * @method isIOS7above\n     * @signature isIOS7above()\n     * @description\n     *   [en]Returns whether the iOS version is 7 or above.[/en]\n     *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isIOS7above',\n    value: function isIOS7above() {\n      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {\n        return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7\n        );\n      } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {\n        var ver = (navigator.userAgent.match(/\\b[0-9]+_[0-9]+(?:_[0-9]+)?\\b/) || [''])[0].replace(/_/g, '.');\n        return parseInt(ver.split('.')[0]) >= 7;\n      }\n      return false;\n    }\n\n    //----------------\n    // iOS browsers\n    //----------------\n    /**\n     * @method isIOSSafari\n     * @signature isIOSSafari()\n     * @description\n     *   [en]Returns whether app is running in iOS Safari.[/en]\n     *   [ja]iOS Safariで実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isIOSSafari',\n    value: function isIOSSafari() {\n      var navigator = window.navigator;\n      var ua = navigator.userAgent;\n\n      return !!(this.isIOS() && ua.indexOf('Safari') !== -1 && ua.indexOf('Version') !== -1 && !navigator.standalone);\n    }\n\n    /**\n     * @method isWKWebView\n     * @signature isWKWebView()\n     * @description\n     *   [en]Returns whether app is running in WKWebView.[/en]\n     *   [ja]WKWebViewで実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isWKWebView',\n    value: function isWKWebView() {\n      var lte9 = /constructor/i.test(NativeHTMLElement);\n      return !!(this.isIOS() && window.webkit && window.webkit.messageHandlers && window.indexedDB && !lte9);\n    }\n\n    /**\n     * @method isUIWebView\n     * @signature isUIWebView()\n     * @description\n     *   [en]Returns whether app is running in UIWebView.[/en]\n     *   [ja]UIWebViewで実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUIWebView',\n    value: function isUIWebView() {\n      return !!(this.isIOS() && !this.isIOSSafari() && !this.isWKWebView());\n    }\n\n    //----------------\n    // Android devices\n    //----------------\n    /**\n     * @method isAndroidPhone\n     * @signature isAndroidPhone()\n     * @description\n     *   [en]Returns whether the device is Android phone.[/en]\n     *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAndroidPhone',\n    value: function isAndroidPhone() {\n      return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)\n      );\n    }\n\n    /**\n     * @method isAndroidTablet\n     * @signature isAndroidTablet()\n     * @description\n     *   [en]Returns whether the device is Android tablet.[/en]\n     *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAndroidTablet',\n    value: function isAndroidTablet() {\n      return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)\n      );\n    }\n\n    //----------------\n    // Android versions\n    //----------------\n    /**\n     * @method isAndroid\n     * @signature isAndroid()\n     * @description\n     *   [en]Returns whether the OS is Android.[/en]\n     *   [ja]Android上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAndroid',\n    value: function isAndroid() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'android';\n      }\n\n      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {\n        return (/Android/i.test(device.platform)\n        );\n      } else {\n        return (/Android/i.test(navigator.userAgent)\n        );\n      }\n    }\n\n    //----------------\n    // Other devices\n    //----------------\n    /**\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isWP',\n    value: function isWP() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'wp';\n      }\n\n      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {\n        return (/Win32NT|WinCE/i.test(device.platform)\n        );\n      } else {\n        return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)\n        );\n      }\n    }\n\n    /**\n     * @method isBlackBerry\n     * @signature isBlackBerry()\n     * @description\n     *   [en]Returns whether the device is BlackBerry.[/en]\n     *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlackBerry',\n    value: function isBlackBerry() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'blackberry';\n      }\n\n      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {\n        return (/BlackBerry/i.test(device.platform)\n        );\n      } else {\n        return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)\n        );\n      }\n    }\n\n    //----------------\n    // Other browsers\n    //----------------\n    /**\n     * @method isOpera\n     * @signature isOpera()\n     * @description\n     *   [en]Returns whether the browser is Opera.[/en]\n     *   [ja]Opera上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isOpera',\n    value: function isOpera() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'opera';\n      }\n\n      return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n    }\n\n    /**\n     * @method isFirefox\n     * @signature isFirefox()\n     * @description\n     *   [en]Returns whether the browser is Firefox.[/en]\n     *   [ja]Firefox上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isFirefox',\n    value: function isFirefox() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'firefox';\n      }\n\n      return typeof InstallTrigger !== 'undefined';\n    }\n\n    /**\n     * @method isSafari\n     * @signature isSafari()\n     * @description\n     *   [en]Returns whether the browser is Safari.[/en]\n     *   [ja]Safari上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSafari',\n    value: function isSafari() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'safari';\n      }\n\n      return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0 || function (p) {\n        return p.toString() === '[object SafariRemoteNotification]';\n      }(!window['safari'] || safari.pushNotification);\n    }\n\n    /**\n     * @method isChrome\n     * @signature isChrome()\n     * @description\n     *   [en]Returns whether the browser is Chrome.[/en]\n     *   [ja]Chrome上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isChrome',\n    value: function isChrome() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'chrome';\n      }\n\n      return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);\n    }\n\n    /**\n     * @method isIE\n     * @signature isIE()\n     * @description\n     *   [en]Returns whether the browser is Internet Explorer.[/en]\n     *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isIE',\n    value: function isIE() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'ie';\n      }\n\n      return false || !!document.documentMode;\n    }\n\n    /**\n     * @method isEdge\n     * @signature isEdge()\n     * @description\n     *   [en]Returns whether the browser is Edge.[/en]\n     *   [ja]Edge上で実行されているかどうかを返します。[/ja]\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isEdge',\n    value: function isEdge() {\n      if (this._getSelectedPlatform()) {\n        return this._getSelectedPlatform() === 'edge';\n      }\n\n      return navigator.userAgent.indexOf(' Edge/') >= 0;\n    }\n\n    //----------------\n    // Utility functions\n    //----------------\n    /**\n     * @return {String}\n     */\n\n  }, {\n    key: 'getMobileOS',\n    value: function getMobileOS() {\n      if (this.isAndroid()) {\n        return 'android';\n      } else if (this.isIOS()) {\n        return 'ios';\n      } else if (this.isWP()) {\n        return 'wp';\n      } else {\n        return 'other';\n      }\n    }\n\n    /**\n     * @return {String}\n     */\n\n  }, {\n    key: 'getIOSDevice',\n    value: function getIOSDevice() {\n      if (this.isIPhone()) {\n        return 'iphone';\n      } else if (this.isIPad()) {\n        return 'ipad';\n      } else if (this.isIPod()) {\n        return 'ipod';\n      } else {\n        return 'na';\n      }\n    }\n  }]);\n  return Platform;\n}();\n\nvar platform = new Platform();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar pageAttributeExpression = {\n  _variables: {},\n\n  /**\n   * Define a variable.\n   *\n   * @param {String} name Name of the variable\n   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.\n   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.\n   */\n  defineVariable: function defineVariable(name, value) {\n    var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (typeof name !== 'string') {\n      throw new Error('Variable name must be a string.');\n    } else if (typeof value !== 'string' && typeof value !== 'function') {\n      throw new Error('Variable value must be a string or a function.');\n    } else if (this._variables.hasOwnProperty(name) && !overwrite) {\n      throw new Error('\"' + name + '\" is already defined.');\n    }\n    this._variables[name] = value;\n  },\n\n  /**\n   * Get a variable.\n   *\n   * @param {String} name Name of the variable.\n   * @return {String|Function|null}\n   */\n  getVariable: function getVariable(name) {\n    if (!this._variables.hasOwnProperty(name)) {\n      return null;\n    }\n\n    return this._variables[name];\n  },\n\n  /**\n   * Remove a variable.\n   *\n   * @param {String} name Name of the varaible.\n   */\n  removeVariable: function removeVariable(name) {\n    delete this._variables[name];\n  },\n\n  /**\n   * Get all variables.\n   *\n   * @return {Object}\n   */\n  getAllVariables: function getAllVariables() {\n    return this._variables;\n  },\n  _parsePart: function _parsePart(part) {\n    var c = void 0,\n        inInterpolation = false,\n        currentIndex = 0;\n\n    var tokens = [];\n\n    if (part.length === 0) {\n      throw new Error('Unable to parse empty string.');\n    }\n\n    for (var i = 0; i < part.length; i++) {\n      c = part.charAt(i);\n\n      if (c === '$' && part.charAt(i + 1) === '{') {\n        if (inInterpolation) {\n          throw new Error('Nested interpolation not supported.');\n        }\n\n        var token = part.substring(currentIndex, i);\n        if (token.length > 0) {\n          tokens.push(part.substring(currentIndex, i));\n        }\n\n        currentIndex = i;\n        inInterpolation = true;\n      } else if (c === '}') {\n        if (!inInterpolation) {\n          throw new Error('} must be preceeded by ${');\n        }\n\n        var _token = part.substring(currentIndex, i + 1);\n        if (_token.length > 0) {\n          tokens.push(part.substring(currentIndex, i + 1));\n        }\n\n        currentIndex = i + 1;\n        inInterpolation = false;\n      }\n    }\n\n    if (inInterpolation) {\n      throw new Error('Unterminated interpolation.');\n    }\n\n    tokens.push(part.substring(currentIndex, part.length));\n\n    return tokens;\n  },\n  _replaceToken: function _replaceToken(token) {\n    var re = /^\\${(.*?)}$/,\n        match = token.match(re);\n\n    if (match) {\n      var name = match[1].trim();\n      var variable = this.getVariable(name);\n\n      if (variable === null) {\n        throw new Error('Variable \"' + name + '\" does not exist.');\n      } else if (typeof variable === 'string') {\n        return variable;\n      } else {\n        var rv = variable();\n\n        if (typeof rv !== 'string') {\n          throw new Error('Must return a string.');\n        }\n\n        return rv;\n      }\n    } else {\n      return token;\n    }\n  },\n  _replaceTokens: function _replaceTokens(tokens) {\n    return tokens.map(this._replaceToken.bind(this));\n  },\n  _parseExpression: function _parseExpression(expression) {\n    return expression.split(',').map(function (part) {\n      return part.trim();\n    }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {\n      return part.join('');\n    });\n  },\n\n  /**\n   * Evaluate an expression.\n   *\n   * @param {String} expression An page attribute expression.\n   * @return {Array}\n   */\n  evaluate: function evaluate(expression) {\n    if (!expression) {\n      return [];\n    }\n\n    return this._parseExpression(expression);\n  }\n};\n\n// Define default variables.\npageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());\npageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());\npageAttributeExpression.defineVariable('runtime', function () {\n  return platform.isWebView() ? 'cordova' : 'browser';\n});\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar internal$1 = {};\n\ninternal$1.config = {\n  autoStatusBarFill: true,\n  animationsDisabled: false,\n  warningsDisabled: false\n};\n\ninternal$1.nullElement = window.document.createElement('div');\n\n/**\n * @return {Boolean}\n */\ninternal$1.isEnabledAutoStatusBarFill = function () {\n  return !!internal$1.config.autoStatusBarFill;\n};\n\n/**\n * @param {String} html\n * @return {String}\n */\ninternal$1.normalizePageHTML = function (html) {\n  return ('' + html).trim();\n};\n\ninternal$1.waitDOMContentLoaded = function (callback) {\n  if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {\n    var wrappedCallback = function wrappedCallback() {\n      callback();\n      window.document.removeEventListener('DOMContentLoaded', wrappedCallback);\n    };\n    window.document.addEventListener('DOMContentLoaded', wrappedCallback);\n  } else {\n    setImmediate(callback);\n  }\n};\n\ninternal$1.autoStatusBarFill = function (action) {\n  var onReady = function onReady() {\n    if (internal$1.shouldFillStatusBar()) {\n      action();\n    }\n    document.removeEventListener('deviceready', onReady);\n  };\n\n  if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object') {\n    document.addEventListener('deviceready', onReady);\n  } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {\n    internal$1.waitDOMContentLoaded(onReady);\n  } else {\n    onReady();\n  }\n};\n\ninternal$1.shouldFillStatusBar = function () {\n  return internal$1.isEnabledAutoStatusBarFill() && (platform.isWebView() && platform.isIOS7above() && !platform.isIPhoneX() || document.body.querySelector('.ons-status-bar-mock.ios'));\n};\n\ninternal$1.templateStore = {\n  _storage: {},\n\n  /**\n   * @param {String} key\n   * @return {String/null} template\n   */\n  get: function get$$1(key) {\n    return internal$1.templateStore._storage[key] || null;\n  },\n\n\n  /**\n   * @param {String} key\n   * @param {String} template\n   */\n  set: function set$$1(key, template) {\n    internal$1.templateStore._storage[key] = template;\n  }\n};\n\nwindow.document.addEventListener('_templateloaded', function (e) {\n  if (e.target.nodeName.toLowerCase() === 'ons-template') {\n    internal$1.templateStore.set(e.templateId, e.template);\n  }\n}, false);\n\ninternal$1.waitDOMContentLoaded(function () {\n  register('script[type=\"text/ons-template\"]');\n  register('script[type=\"text/template\"]');\n  register('script[type=\"text/ng-template\"]');\n  register('template');\n\n  function register(query) {\n    var templates = window.document.querySelectorAll(query);\n    for (var i = 0; i < templates.length; i++) {\n      internal$1.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent || templates[i].content);\n    }\n  }\n});\n\n/**\n * @param {String} page\n * @return {Promise}\n */\ninternal$1.getTemplateHTMLAsync = function (page) {\n  return new Promise(function (resolve, reject) {\n    internal$1.waitDOMContentLoaded(function () {\n      var cache = internal$1.templateStore.get(page);\n      if (cache) {\n        if (cache instanceof DocumentFragment) {\n          return resolve(cache);\n        }\n\n        var html = typeof cache === 'string' ? cache : cache[1];\n        return resolve(internal$1.normalizePageHTML(html));\n      }\n\n      var local = window.document.getElementById(page);\n      if (local) {\n        var _html = local.textContent || local.content;\n        return resolve(_html);\n      }\n\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', page, true);\n      xhr.onload = function () {\n        var html = xhr.responseText;\n        if (xhr.status >= 400 && xhr.status < 600) {\n          reject(html);\n        } else {\n          // Refresh script tags\n          var fragment = util.createFragment(html);\n          util.arrayFrom(fragment.querySelectorAll('script')).forEach(function (el) {\n            var script = document.createElement('script');\n            script.type = el.type || 'text/javascript';\n            script.appendChild(document.createTextNode(el.text || el.textContent || el.innerHTML));\n            el.parentNode.replaceChild(script, el);\n          });\n\n          internal$1.templateStore.set(page, fragment);\n          resolve(fragment);\n        }\n      };\n      xhr.onerror = function () {\n        throw new Error('The page is not found: ' + page);\n      };\n      xhr.send(null);\n    });\n  });\n};\n\n/**\n * @param {String} page\n * @return {Promise}\n */\ninternal$1.getPageHTMLAsync = function (page) {\n  var pages = pageAttributeExpression.evaluate(page);\n\n  var getPage = function getPage(page) {\n    if (typeof page !== 'string') {\n      return Promise.reject('Must specify a page.');\n    }\n\n    return internal$1.getTemplateHTMLAsync(page).catch(function (error) {\n      if (pages.length === 0) {\n        return Promise.reject(error);\n      }\n\n      return getPage(pages.shift());\n    });\n  };\n\n  return getPage(pages.shift());\n};\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar AnimatorFactory = function () {\n\n  /**\n   * @param {Object} opts\n   * @param {Object} opts.animators The dictionary for animator classes\n   * @param {Function} opts.baseClass The base class of animators\n   * @param {String} [opts.baseClassName] The name of the base class of animators\n   * @param {String} [opts.defaultAnimation] The default animation name\n   * @param {Object} [opts.defaultAnimationOptions] The default animation options\n   */\n  function AnimatorFactory(opts) {\n    classCallCheck(this, AnimatorFactory);\n\n    this._animators = opts.animators;\n    this._baseClass = opts.baseClass;\n    this._baseClassName = opts.baseClassName || opts.baseClass.name;\n    this._animation = opts.defaultAnimation || 'default';\n    this._animationOptions = opts.defaultAnimationOptions || {};\n\n    if (!this._animators[this._animation]) {\n      throw new Error('No such animation: ' + this._animation);\n    }\n  }\n\n  /**\n   * @param {String} jsonString\n   * @return {Object/null}\n   */\n\n\n  createClass(AnimatorFactory, [{\n    key: 'setAnimationOptions',\n\n\n    /**\n     * @param {Object} options\n     */\n    value: function setAnimationOptions(options) {\n      this._animationOptions = options;\n    }\n\n    /**\n     * @param {Object} options\n     * @param {String} [options.animation] The animation name\n     * @param {Object} [options.animationOptions] The animation options\n     * @param {Object} defaultAnimator The default animator instance\n     * @return {Object} An animator instance\n     */\n\n  }, {\n    key: 'newAnimator',\n    value: function newAnimator() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var defaultAnimator = arguments[1];\n\n\n      var animator = null;\n\n      if (options.animation instanceof this._baseClass) {\n        return options.animation;\n      }\n\n      var Animator = null;\n\n      if (typeof options.animation === 'string') {\n        Animator = this._animators[options.animation];\n      }\n\n      if (!Animator && defaultAnimator) {\n        animator = defaultAnimator;\n      } else {\n        Animator = Animator || this._animators[this._animation];\n\n        var animationOpts = util.extend({}, this._animationOptions, options.animationOptions || {}, internal$1.config.animationsDisabled ? { duration: 0, delay: 0 } : {});\n\n        animator = new Animator(animationOpts);\n\n        if (typeof animator === 'function') {\n          animator = new animator(animationOpts); // eslint-disable-line new-cap\n        }\n      }\n\n      if (!(animator instanceof this._baseClass)) {\n        throw new Error('\"animator\" is not an instance of ' + this._baseClassName + '.');\n      }\n\n      return animator;\n    }\n  }], [{\n    key: 'parseAnimationOptionsString',\n    value: function parseAnimationOptionsString(jsonString) {\n      try {\n        if (typeof jsonString === 'string') {\n          var result = util.animationOptionsParse(jsonString);\n          if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {\n            return result;\n          } else {\n            console.error('\"animation-options\" attribute must be a JSON object string: ' + jsonString);\n          }\n        }\n        return {};\n      } catch (e) {\n        console.error('\"animation-options\" attribute must be a JSON object string: ' + jsonString);\n        return {};\n      }\n    }\n  }]);\n  return AnimatorFactory;\n}();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar autoStyleEnabled = true;\n\n// Modifiers\nvar modifiersMap = {\n  'quiet': 'material--flat',\n  'light': 'material--flat',\n  'outline': 'material--flat',\n  'cta': '',\n  'large--quiet': 'material--flat large',\n  'large--cta': 'large',\n  'noborder': '',\n  'tappable': ''\n};\n\nvar platforms = {};\n\nplatforms.android = function (element) {\n\n  var elementName = element.tagName.toLowerCase();\n\n  if (!util.hasModifier(element, 'material')) {\n    var oldModifier = element.getAttribute('modifier') || '';\n\n    var newModifier = oldModifier.trim().split(/\\s+/).map(function (e) {\n      return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;\n    });\n    newModifier.unshift('material');\n\n    element.setAttribute('modifier', newModifier.join(' ').trim());\n  }\n\n  var elements = ['ons-alert-dialog-button', 'ons-toolbar-button', 'ons-back-button', 'ons-button', 'ons-list-item', 'ons-fab', 'ons-speed-dial', 'ons-speed-dial-item', 'ons-tab'];\n\n  // Effects\n  if (elements.indexOf(elementName) !== -1 && !element.hasAttribute('ripple') && !element.querySelector('ons-ripple')) {\n\n    if (elementName === 'ons-list-item') {\n      if (element.hasAttribute('tappable')) {\n        element.setAttribute('ripple', '');\n        element.removeAttribute('tappable');\n      }\n    } else {\n      element.setAttribute('ripple', '');\n    }\n  }\n};\n\nplatforms.ios = function (element) {\n\n  // Modifiers\n  if (util.removeModifier(element, 'material')) {\n    if (util.removeModifier(element, 'material--flat')) {\n      util.addModifier(element, util.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');\n    }\n\n    if (!element.getAttribute('modifier')) {\n      element.removeAttribute('modifier');\n    }\n  }\n\n  // Effects\n  if (element.hasAttribute('ripple')) {\n    if (element.tagName.toLowerCase() === 'ons-list-item') {\n      element.setAttribute('tappable', '');\n    }\n\n    element.removeAttribute('ripple');\n  }\n};\n\nvar unlocked = {\n  android: true\n};\n\nvar getPlatform = function getPlatform(element, force) {\n  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {\n    var mobileOS = platform.getMobileOS();\n    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {\n      return mobileOS;\n    }\n  }\n  return null;\n};\n\nvar prepare = function prepare(element, force) {\n  var p = getPlatform(element, force);\n  p && platforms[p](element);\n};\n\nvar mapModifier = function mapModifier(modifier, element, force) {\n  if (getPlatform(element, force)) {\n    return modifier.split(/\\s+/).map(function (m) {\n      return modifiersMap.hasOwnProperty(m) ? modifiersMap[m] : m;\n    }).join(' ');\n  }\n  return modifier;\n};\n\nvar restoreModifier = function restoreModifier(element) {\n  if (getPlatform(element) === 'android') {\n    var modifier = element.getAttribute('modifier') || '';\n    var newModifier = mapModifier(modifier, element);\n\n    if (!/(^|\\s+)material($|\\s+)/i.test(modifier)) {\n      newModifier = 'material ' + newModifier;\n    }\n\n    if (newModifier !== modifier) {\n      element.setAttribute('modifier', newModifier.trim());\n      return true;\n    }\n  }\n  return false;\n};\n\nvar autoStyle = {\n  isEnabled: function isEnabled() {\n    return autoStyleEnabled;\n  },\n  enable: function enable() {\n    return autoStyleEnabled = true;\n  },\n  disable: function disable() {\n    return autoStyleEnabled = false;\n  },\n  prepare: prepare,\n  mapModifier: mapModifier,\n  getPlatform: getPlatform,\n  restoreModifier: restoreModifier\n};\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar ModifierUtil = function () {\n  function ModifierUtil() {\n    classCallCheck(this, ModifierUtil);\n  }\n\n  createClass(ModifierUtil, null, [{\n    key: 'diff',\n\n    /**\n     * @param {String} last\n     * @param {String} current\n     */\n    value: function diff(last, current) {\n      last = makeDict(('' + last).trim());\n      current = makeDict(('' + current).trim());\n\n      var removed = Object.keys(last).reduce(function (result, token) {\n        if (!current[token]) {\n          result.push(token);\n        }\n        return result;\n      }, []);\n\n      var added = Object.keys(current).reduce(function (result, token) {\n        if (!last[token]) {\n          result.push(token);\n        }\n        return result;\n      }, []);\n\n      return { added: added, removed: removed };\n\n      function makeDict(modifier) {\n        var dict = {};\n        ModifierUtil.split(modifier).forEach(function (token) {\n          return dict[token] = token;\n        });\n        return dict;\n      }\n    }\n\n    /**\n     * @param {Object} diff\n     * @param {Array} diff.removed\n     * @param {Array} diff.added\n     * @param {Object} classList\n     * @param {String} template\n     */\n\n  }, {\n    key: 'applyDiffToClassList',\n    value: function applyDiffToClassList(diff, classList, template) {\n      diff.added.map(function (modifier) {\n        return template.replace(/\\*/g, modifier);\n      }).forEach(function (klass) {\n        return klass.split(/\\s+/).forEach(function (k) {\n          return classList.add(k);\n        });\n      });\n\n      diff.removed.map(function (modifier) {\n        return template.replace(/\\*/g, modifier);\n      }).forEach(function (klass) {\n        return klass.split(/\\s+/).forEach(function (k) {\n          return classList.remove(k);\n        });\n      });\n    }\n\n    /**\n     * @param {Object} diff\n     * @param {Array} diff.removed\n     * @param {Array} diff.added\n     * @param {HTMLElement} element\n     * @param {Object} scheme\n     */\n\n  }, {\n    key: 'applyDiffToElement',\n    value: function applyDiffToElement(diff, element, scheme) {\n      Object.keys(scheme).forEach(function (selector) {\n        var targetElements = !selector || util.match(element, selector) ? [element] : Array.prototype.filter.call(element.querySelectorAll(selector), function (targetElement) {\n          return !util.findParent(targetElement, element.tagName, function (parent) {\n            return parent === element;\n          });\n        });\n\n        for (var i = 0; i < targetElements.length; i++) {\n          ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);\n        }\n      });\n    }\n\n    /**\n     * @param {String} last\n     * @param {String} current\n     * @param {HTMLElement} element\n     * @param {Object} scheme\n     */\n\n  }, {\n    key: 'onModifierChanged',\n    value: function onModifierChanged(last, current, element, scheme) {\n      ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);\n      autoStyle.restoreModifier(element);\n    }\n  }, {\n    key: 'refresh',\n    value: function refresh(element, scheme) {\n      ModifierUtil.applyDiffToElement(ModifierUtil.diff('', element.getAttribute('modifier') || ''), element, scheme);\n    }\n\n    /**\n     * @param {HTMLElement} element\n     * @param {Object} scheme\n     */\n\n  }, {\n    key: 'initModifier',\n    value: function initModifier(element, scheme) {\n      var modifier = element.getAttribute('modifier');\n      if (typeof modifier !== 'string') {\n        return;\n      }\n\n      ModifierUtil.applyDiffToElement({\n        removed: [],\n        added: ModifierUtil.split(modifier)\n      }, element, scheme);\n    }\n  }, {\n    key: 'split',\n    value: function split(modifier) {\n      if (typeof modifier !== 'string') {\n        return [];\n      }\n\n      return modifier.trim().split(/ +/).filter(function (token) {\n        return token !== '';\n      });\n    }\n\n    /**\n     * Add modifier token to an element.\n     */\n\n  }, {\n    key: 'addModifier',\n    value: function addModifier(element, modifierToken) {\n      if (!element.hasAttribute('modifier')) {\n        element.setAttribute('modifier', modifierToken);\n      } else {\n        var tokens = ModifierUtil.split(element.getAttribute('modifier'));\n        if (tokens.indexOf(modifierToken) == -1) {\n          tokens.push(modifierToken);\n          element.setAttribute('modifier', tokens.join(' '));\n        }\n      }\n    }\n\n    /**\n     * Remove modifier token from an element.\n     */\n\n  }, {\n    key: 'removeModifier',\n    value: function removeModifier(element, modifierToken) {\n      if (element.hasAttribute('modifier')) {\n        var tokens = ModifierUtil.split(element.getAttribute('modifier'));\n        var index = tokens.indexOf(modifierToken);\n        if (index !== -1) {\n          tokens.splice(index, 1);\n          element.setAttribute('modifier', tokens.join(' '));\n        }\n      }\n    }\n  }]);\n  return ModifierUtil;\n}();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar util$2 = {\n  _ready: false,\n\n  _domContentLoaded: false,\n\n  _onDOMContentLoaded: function _onDOMContentLoaded() {\n    util$2._domContentLoaded = true;\n\n    if (platform.isWebView()) {\n      window.document.addEventListener('deviceready', function () {\n        util$2._ready = true;\n      }, false);\n    } else {\n      util$2._ready = true;\n    }\n  },\n\n  addBackButtonListener: function addBackButtonListener(fn) {\n    if (!this._domContentLoaded) {\n      throw new Error('This method is available after DOMContentLoaded');\n    }\n\n    if (this._ready) {\n      window.document.addEventListener('backbutton', fn, false);\n    } else {\n      window.document.addEventListener('deviceready', function () {\n        window.document.addEventListener('backbutton', fn, false);\n      });\n    }\n  },\n\n  removeBackButtonListener: function removeBackButtonListener(fn) {\n    if (!this._domContentLoaded) {\n      throw new Error('This method is available after DOMContentLoaded');\n    }\n\n    if (this._ready) {\n      window.document.removeEventListener('backbutton', fn, false);\n    } else {\n      window.document.addEventListener('deviceready', function () {\n        window.document.removeEventListener('backbutton', fn, false);\n      });\n    }\n  }\n};\nwindow.addEventListener('DOMContentLoaded', function () {\n  return util$2._onDOMContentLoaded();\n}, false);\n\nvar HandlerRepository = {\n  _store: {},\n\n  _genId: function () {\n    var i = 0;\n    return function () {\n      return i++;\n    };\n  }(),\n\n  set: function set$$1(element, handler) {\n    if (element.dataset.deviceBackButtonHandlerId) {\n      this.remove(element);\n    }\n    var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();\n    this._store[id] = handler;\n  },\n\n  remove: function remove(element) {\n    if (element.dataset.deviceBackButtonHandlerId) {\n      delete this._store[element.dataset.deviceBackButtonHandlerId];\n      delete element.dataset.deviceBackButtonHandlerId;\n    }\n  },\n\n  get: function get$$1(element) {\n    if (!element.dataset.deviceBackButtonHandlerId) {\n      return undefined;\n    }\n\n    var id = element.dataset.deviceBackButtonHandlerId;\n\n    if (!this._store[id]) {\n      throw new Error();\n    }\n\n    return this._store[id];\n  },\n\n  has: function has(element) {\n    if (!element.dataset) {\n      return false;\n    }\n\n    var id = element.dataset.deviceBackButtonHandlerId;\n\n    return !!this._store[id];\n  }\n};\n\nvar DeviceBackButtonDispatcher = function () {\n  function DeviceBackButtonDispatcher() {\n    classCallCheck(this, DeviceBackButtonDispatcher);\n\n    this._isEnabled = false;\n    this._boundCallback = this._callback.bind(this);\n  }\n\n  /**\n   * Enable to handle 'backbutton' events.\n   */\n\n\n  createClass(DeviceBackButtonDispatcher, [{\n    key: 'enable',\n    value: function enable() {\n      if (!this._isEnabled) {\n        util$2.addBackButtonListener(this._boundCallback);\n        this._isEnabled = true;\n      }\n    }\n\n    /**\n     * Disable to handle 'backbutton' events.\n     */\n\n  }, {\n    key: 'disable',\n    value: function disable() {\n      if (this._isEnabled) {\n        util$2.removeBackButtonListener(this._boundCallback);\n        this._isEnabled = false;\n      }\n    }\n\n    /**\n     * Fire a 'backbutton' event manually.\n     */\n\n  }, {\n    key: 'fireDeviceBackButtonEvent',\n    value: function fireDeviceBackButtonEvent() {\n      var event = document.createEvent('Event');\n      event.initEvent('backbutton', true, true);\n      document.dispatchEvent(event);\n    }\n  }, {\n    key: '_callback',\n    value: function _callback() {\n      this._dispatchDeviceBackButtonEvent();\n    }\n\n    /**\n     * @param {HTMLElement} element\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'createHandler',\n    value: function createHandler(element, callback) {\n      if (!(element instanceof HTMLElement)) {\n        throw new Error('element must be an instance of HTMLElement');\n      }\n\n      if (!(callback instanceof Function)) {\n        throw new Error('callback must be an instance of Function');\n      }\n\n      var handler = {\n        _callback: callback,\n        _element: element,\n\n        disable: function disable() {\n          HandlerRepository.remove(element);\n        },\n\n        setListener: function setListener(callback) {\n          this._callback = callback;\n        },\n\n        enable: function enable() {\n          HandlerRepository.set(element, this);\n        },\n\n        isEnabled: function isEnabled() {\n          return HandlerRepository.get(element) === this;\n        },\n\n        destroy: function destroy() {\n          HandlerRepository.remove(element);\n          this._callback = this._element = null;\n        }\n      };\n\n      handler.enable();\n\n      return handler;\n    }\n  }, {\n    key: '_dispatchDeviceBackButtonEvent',\n    value: function _dispatchDeviceBackButtonEvent() {\n      var tree = this._captureTree();\n\n      var element = this._findHandlerLeafElement(tree);\n\n      var handler = HandlerRepository.get(element);\n      handler._callback(createEvent(element));\n\n      function createEvent(element) {\n        return {\n          _element: element,\n          callParentHandler: function callParentHandler() {\n            var parent = this._element.parentNode;\n\n            while (parent) {\n              handler = HandlerRepository.get(parent);\n              if (handler) {\n                return handler._callback(createEvent(parent));\n              }\n              parent = parent.parentNode;\n            }\n          }\n        };\n      }\n    }\n\n    /**\n     * @return {Object}\n     */\n\n  }, {\n    key: '_captureTree',\n    value: function _captureTree() {\n      return createTree(document.body);\n\n      function createTree(element) {\n        var tree = {\n          element: element,\n          children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {\n\n            if (childElement.style.display === 'none' || childElement._isShown === false) {\n              return [];\n            }\n\n            if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {\n              return [];\n            }\n\n            var result = createTree(childElement);\n\n            if (result.children.length === 0 && !HandlerRepository.has(result.element)) {\n              return [];\n            }\n\n            return [result];\n          }))\n        };\n\n        if (!HandlerRepository.has(tree.element)) {\n          for (var i = 0; i < tree.children.length; i++) {\n            var subTree = tree.children[i];\n            if (HandlerRepository.has(subTree.element)) {\n              return subTree;\n            }\n          }\n        }\n\n        return tree;\n      }\n\n      function arrayOf(target) {\n        var result = [];\n        for (var i = 0; i < target.length; i++) {\n          result.push(target[i]);\n        }\n        return result;\n      }\n    }\n\n    /**\n     * @param {Object} tree\n     * @return {HTMLElement}\n     */\n\n  }, {\n    key: '_findHandlerLeafElement',\n    value: function _findHandlerLeafElement(tree) {\n      return find(tree);\n\n      function find(node) {\n        if (node.children.length === 0) {\n          return node.element;\n        }\n\n        if (node.children.length === 1) {\n          return find(node.children[0]);\n        }\n\n        return node.children.map(function (childNode) {\n          return childNode.element;\n        }).reduce(function (left, right) {\n          if (!left) {\n            return right;\n          }\n\n          var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);\n          var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);\n\n          if (!isNaN(leftZ) && !isNaN(rightZ)) {\n            return leftZ > rightZ ? left : right;\n          }\n\n          throw new Error('Capturing backbutton-handler is failure.');\n        }, null);\n      }\n    }\n  }]);\n  return DeviceBackButtonDispatcher;\n}();\n\nvar deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\ninternal$1.AnimatorFactory = AnimatorFactory;\ninternal$1.ModifierUtil = ModifierUtil;\ninternal$1.dbbDispatcher = deviceBackButtonDispatcher;\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar startsWith = function startsWith(s, c) {\n  return s.substr(0, c.length) === c;\n};\nvar endsWith = function endsWith(s, c) {\n  return s.substr(s.length - c.length, c.length) === c;\n};\nvar unwrap = function unwrap(s) {\n  return s.slice(1, -1);\n};\nvar isObjectString = function isObjectString(s) {\n  return startsWith(s, '{') && endsWith(s, '}');\n};\nvar isArrayString = function isArrayString(s) {\n  return startsWith(s, '[') && endsWith(s, ']');\n};\nvar isQuotedString = function isQuotedString(s) {\n  return startsWith(s, '\\'') && endsWith(s, '\\'') || startsWith(s, '\"') && endsWith(s, '\"');\n};\n\nvar error = function error(token, string, originalString) {\n  throw new Error('Unexpected token \\'' + token + '\\' at position ' + (originalString.length - string.length - 1) + ' in string: \\'' + originalString + '\\'');\n};\n\nvar processToken = function processToken(token, string, originalString) {\n  if (token === 'true' || token === 'false') {\n    return token === 'true';\n  } else if (isQuotedString(token)) {\n    return unwrap(token);\n  } else if (!isNaN(token)) {\n    return +token;\n  } else if (isObjectString(token)) {\n    return parseObject(unwrap(token));\n  } else if (isArrayString(token)) {\n    return parseArray(unwrap(token));\n  } else {\n    error(token, string, originalString);\n  }\n};\n\nvar nextToken = function nextToken(string) {\n  string = string.trim();\n  var limit = string.length;\n\n  if (string[0] === ':' || string[0] === ',') {\n\n    limit = 1;\n  } else if (string[0] === '{' || string[0] === '[') {\n\n    var c = string.charCodeAt(0);\n    var nestedObject = 1;\n    for (var i = 1; i < string.length; i++) {\n      if (string.charCodeAt(i) === c) {\n        nestedObject++;\n      } else if (string.charCodeAt(i) === c + 2) {\n        nestedObject--;\n        if (nestedObject === 0) {\n          limit = i + 1;\n          break;\n        }\n      }\n    }\n  } else if (string[0] === '\\'' || string[0] === '\"') {\n\n    for (var _i = 1; _i < string.length; _i++) {\n      if (string[_i] === string[0]) {\n        limit = _i + 1;\n        break;\n      }\n    }\n  } else {\n\n    for (var _i2 = 1; _i2 < string.length; _i2++) {\n      if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {\n        limit = _i2;\n        break;\n      }\n    }\n  }\n\n  return string.slice(0, limit);\n};\n\nvar parseObject = function parseObject(string) {\n  var isValidKey = function isValidKey(key) {\n    return (/^[A-Z_$][A-Z0-9_$]*$/i.test(key)\n    );\n  };\n\n  string = string.trim();\n  var originalString = string;\n  var object = {};\n  var readingKey = true,\n      key = void 0,\n      previousToken = void 0,\n      token = void 0;\n\n  while (string.length > 0) {\n    previousToken = token;\n    token = nextToken(string);\n    string = string.slice(token.length, string.length).trim();\n\n    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {\n      error(token, string, originalString);\n    } else if (token === ':' && readingKey && previousToken) {\n      previousToken = isQuotedString(previousToken) ? unwrap(previousToken) : previousToken;\n      if (isValidKey(previousToken)) {\n        key = previousToken;\n        readingKey = false;\n      } else {\n        throw new Error('Invalid key token \\'' + previousToken + '\\' at position 0 in string: \\'' + originalString + '\\'');\n      }\n    } else if (token === ',' && !readingKey && previousToken) {\n      object[key] = processToken(previousToken, string, originalString);\n      readingKey = true;\n    }\n  }\n\n  if (token) {\n    object[key] = processToken(token, string, originalString);\n  }\n\n  return object;\n};\n\nvar parseArray = function parseArray(string) {\n  string = string.trim();\n  var originalString = string;\n  var array = [];\n  var previousToken = void 0,\n      token = void 0;\n\n  while (string.length > 0) {\n    previousToken = token;\n    token = nextToken(string);\n    string = string.slice(token.length, string.length).trim();\n\n    if (token === ',' && (!previousToken || previousToken === ',')) {\n      error(token, string, originalString);\n    } else if (token === ',') {\n      array.push(processToken(previousToken, string, originalString));\n    }\n  }\n\n  if (token) {\n    if (token !== ',') {\n      array.push(processToken(token, string, originalString));\n    } else {\n      error(token, string, originalString);\n    }\n  }\n\n  return array;\n};\n\nvar parse = function parse(string) {\n  string = string.trim();\n\n  if (isObjectString(string)) {\n    return parseObject(unwrap(string));\n  } else if (isArrayString(string)) {\n    return parseArray(unwrap(string));\n  } else {\n    throw new Error('Provided string must be object or array like: ' + string);\n  }\n};\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar util = {};\n\nutil.globals = {\n  fabOffset: 0\n};\n\n/**\n * @param {String/Function} query dot class name or node name or matcher function.\n * @return {Function}\n */\nutil.prepareQuery = function (query) {\n  return query instanceof Function ? query : function (element) {\n    return util.match(element, query);\n  };\n};\n\n/**\n * @param {Element} e\n * @param {String/Function} s CSS Selector.\n * @return {Boolean}\n */\nutil.match = function (e, s) {\n  return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);\n};\n\n/**\n * @param {Element} element\n * @param {String/Function} query dot class name or node name or matcher function.\n * @return {HTMLElement/null}\n */\nutil.findChild = function (element, query) {\n  var match = util.prepareQuery(query);\n\n  // Caution: `element.children` is `undefined` in some environments if `element` is `svg`\n  for (var i = 0; i < element.childNodes.length; i++) {\n    var node = element.childNodes[i];\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n      // process only element nodes\n      continue;\n    }\n    if (match(node)) {\n      return node;\n    }\n  }\n  return null;\n};\n\n/**\n * @param {Element} element\n * @param {String/Function} query dot class name or node name or matcher function.\n * @return {HTMLElement/null}\n */\nutil.findParent = function (element, query, until) {\n  var match = util.prepareQuery(query);\n\n  var parent = element.parentNode;\n  for (;;) {\n    if (!parent || parent === document || parent instanceof DocumentFragment || until && until(parent)) {\n      return null;\n    } else if (match(parent)) {\n      return parent;\n    }\n    parent = parent.parentNode;\n  }\n};\n\n/**\n * @param {Element} element\n * @return {boolean}\n */\nutil.isAttached = function (element) {\n  return document.body.contains(element);\n};\n\n/**\n * @param {Element} element\n * @return {boolean}\n */\nutil.hasAnyComponentAsParent = function (element) {\n  while (element && document.documentElement !== element) {\n    element = element.parentNode;\n    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal)/)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * @param {Element} element\n * @return {boolean}\n */\nutil.isPageControl = function (element) {\n  return element.nodeName.match(/^ons-(navigator|splitter|tabbar|page)$/i);\n};\n\n/**\n * @param {Element} element\n * @param {String} action to propagate\n */\nutil.propagateAction = function (element, action) {\n  for (var i = 0; i < element.childNodes.length; i++) {\n    var child = element.childNodes[i];\n    if (child[action] instanceof Function) {\n      child[action]();\n    } else {\n      util.propagateAction(child, action);\n    }\n  }\n};\n\n/**\n * @param {String} string - string to be camelized\n * @return {String} Camelized string\n */\nutil.camelize = function (string) {\n  return string.toLowerCase().replace(/-([a-z])/g, function (m, l) {\n    return l.toUpperCase();\n  });\n};\n\n/**\n * @param {String} string - string to be hyphenated\n * @return {String} Hyphenated string\n */\nutil.hyphenate = function (string) {\n  return string.replace(/([a-zA-Z])([A-Z])/g, '$1-$2').toLowerCase();\n};\n\n/**\n * @param {String} selector - tag and class only\n * @param {Object} style\n * @param {Element}\n */\nutil.create = function () {\n  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var classList = selector.split('.');\n  var element = document.createElement(classList.shift() || 'div');\n\n  if (classList.length) {\n    element.className = classList.join(' ');\n  }\n\n  styler(element, style);\n\n  return element;\n};\n\n/**\n * @param {String} html\n * @return {Element}\n */\nutil.createElement = function (html) {\n  var wrapper = document.createElement('div');\n\n  if (html instanceof DocumentFragment) {\n    wrapper.appendChild(document.importNode(html, true));\n  } else {\n    wrapper.innerHTML = html.trim();\n  }\n\n  if (wrapper.children.length > 1) {\n    throw new Error('\"html\" must be one wrapper element.');\n  }\n\n  var element = wrapper.children[0];\n  wrapper.children[0].remove();\n  return element;\n};\n\n/**\n * @param {String} html\n * @return {HTMLFragment}\n */\nutil.createFragment = function (html) {\n  var template = document.createElement('template');\n  template.innerHTML = html;\n  return document.importNode(template.content, true);\n};\n\n/*\n * @param {Object} dst Destination object.\n * @param {...Object} src Source object(s).\n * @returns {Object} Reference to `dst`.\n */\nutil.extend = function (dst) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    if (args[i]) {\n      var keys = Object.keys(args[i]);\n      for (var j = 0; j < keys.length; j++) {\n        var key = keys[j];\n        dst[key] = args[i][key];\n      }\n    }\n  }\n\n  return dst;\n};\n\n/**\n * @param {Object} arrayLike\n * @return {Array}\n */\nutil.arrayFrom = function (arrayLike) {\n  return Array.prototype.slice.apply(arrayLike);\n};\n\n/**\n * @param {String} jsonString\n * @param {Object} [failSafe]\n * @return {Object}\n */\nutil.parseJSONObjectSafely = function (jsonString) {\n  var failSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  try {\n    var result = JSON.parse('' + jsonString);\n    if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {\n      return result;\n    }\n  } catch (e) {\n    return failSafe;\n  }\n  return failSafe;\n};\n\n/**\n * @param {String} path - path such as 'myApp.controllers.data.loadData'\n * @return {Any} - whatever is located at that path\n */\nutil.findFromPath = function (path) {\n  path = path.split('.');\n  var el = window,\n      key;\n  while (key = path.shift()) {\n    // eslint-disable-line no-cond-assign\n    el = el[key];\n  }\n  return el;\n};\n\n/**\n * @param {HTMLElement} container - Page or page-container that implements 'topPage'\n * @return {HTMLElement|null} - Visible page element or null if not found.\n */\nutil.getTopPage = function (container) {\n  return container && (container.tagName.toLowerCase() === 'ons-page' ? container : container.topPage) || null;\n};\n\n/**\n * @param {HTMLElement} container - Element where the search begins\n * @return {HTMLElement|null} - Page element that contains the visible toolbar or null.\n */\nutil.findToolbarPage = function (container) {\n  var page = util.getTopPage(container);\n\n  if (page) {\n    if (page._canAnimateToolbar()) {\n      return page;\n    }\n\n    for (var i = 0; i < page._contentElement.children.length; i++) {\n      var nextPage = util.getTopPage(page._contentElement.children[i]);\n      if (nextPage && !/ons-tabbar/i.test(page._contentElement.children[i].tagName)) {\n        return util.findToolbarPage(nextPage);\n      }\n    }\n  }\n\n  return null;\n};\n\n/**\n * @param {Element} element\n * @param {String} eventName\n * @param {Object} [detail]\n * @return {CustomEvent}\n */\nutil.triggerElementEvent = function (target, eventName) {\n  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\n  var event = new CustomEvent(eventName, {\n    bubbles: true,\n    cancelable: true,\n    detail: detail\n  });\n\n  Object.keys(detail).forEach(function (key) {\n    event[key] = detail[key];\n  });\n\n  target.dispatchEvent(event);\n\n  return event;\n};\n\n/**\n * @param {Element} target\n * @param {String} modifierName\n * @return {Boolean}\n */\nutil.hasModifier = function (target, modifierName) {\n  if (!target.hasAttribute('modifier')) {\n    return false;\n  }\n\n  return RegExp('(^|\\\\s+)' + modifierName + '($|\\\\s+)', 'i').test(target.getAttribute('modifier'));\n};\n\n/**\n * @param {Element} target\n * @param {String} modifierName\n * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.\n * @param {Object} options.forceAutoStyle Ignores platform limitation.\n * @return {Boolean} Whether it was added or not.\n */\nutil.addModifier = function (target, modifierName) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (options.autoStyle) {\n    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);\n  }\n\n  if (util.hasModifier(target, modifierName)) {\n    return false;\n  }\n\n  target.setAttribute('modifier', ((target.getAttribute('modifier') || '') + ' ' + modifierName).trim());\n  return true;\n};\n\n/**\n * @param {Element} target\n * @param {String} modifierName\n * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.\n * @param {Object} options.forceAutoStyle Ignores platform limitation.\n * @return {Boolean} Whether it was found or not.\n */\nutil.removeModifier = function (target, modifierName) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (options.autoStyle) {\n    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);\n  }\n\n  if (!target.getAttribute('modifier') || !util.hasModifier(target, modifierName)) {\n    return false;\n  }\n\n  var newModifiers = target.getAttribute('modifier').split(/\\s+/).filter(function (m) {\n    return m && m !== modifierName;\n  });\n  newModifiers.length ? target.setAttribute('modifier', newModifiers.join(' ')) : target.removeAttribute('modifier');\n  return true;\n};\n\n/**\n * @param {Element} target\n * @param {String} modifierName\n * @param {Boolean} options.force Forces modifier to be added or removed.\n * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.\n * @param {Boolean} options.forceAutoStyle Ignores platform limitation.\n * @return {Boolean} Whether it was found or not.\n */\nutil.toggleModifier = function () {\n  var options = arguments.length > 2 ? arguments.length <= 2 ? undefined : arguments[2] : {};\n  var force = typeof options === 'boolean' ? options : options.force;\n\n  var toggle = typeof force === 'boolean' ? force : !util.hasModifier.apply(util, arguments);\n  toggle ? util.addModifier.apply(util, arguments) : util.removeModifier.apply(util, arguments);\n};\n\n/**\n * @param {Element} el\n * @param {String} defaultClass\n * @param {Object} scheme\n */\nutil.restoreClass = function (el, defaultClass, scheme) {\n  defaultClass.split(/\\s+/).forEach(function (c) {\n    return c !== '' && !el.classList.contains(c) && el.classList.add(c);\n  });\n  el.hasAttribute('modifier') && ModifierUtil.refresh(el, scheme);\n};\n\n// TODO: FIX\nutil.updateParentPosition = function (el) {\n  if (!el._parentUpdated && el.parentElement) {\n    if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {\n      el.parentElement.style.position = 'relative';\n    }\n    el._parentUpdated = true;\n  }\n};\n\nutil.toggleAttribute = function (element, name, value) {\n  if (value) {\n    element.setAttribute(name, typeof value === 'boolean' ? '' : value);\n  } else {\n    element.removeAttribute(name);\n  }\n};\n\nutil.bindListeners = function (element, listenerNames) {\n  listenerNames.forEach(function (name) {\n    var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());\n    element[boundName] = element[boundName] || element[name].bind(element);\n  });\n};\n\nutil.each = function (obj, f) {\n  return Object.keys(obj).forEach(function (key) {\n    return f(key, obj[key]);\n  });\n};\n\n/**\n * @param {Element} target\n * @param {boolean} hasRipple\n * @param {Object} attrs\n */\nutil.updateRipple = function (target, hasRipple) {\n  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (hasRipple === undefined) {\n    hasRipple = target.hasAttribute('ripple');\n  }\n\n  var rippleElement = util.findChild(target, 'ons-ripple');\n\n  if (hasRipple) {\n    if (!rippleElement) {\n      var element = document.createElement('ons-ripple');\n      Object.keys(attrs).forEach(function (key) {\n        return element.setAttribute(key, attrs[key]);\n      });\n      target.insertBefore(element, target.firstChild);\n    }\n  } else if (rippleElement) {\n    rippleElement.remove();\n  }\n};\n\n/**\n * @param {String}\n * @return {Object}\n */\nutil.animationOptionsParse = parse;\n\n/**\n * @param {*} value\n */\nutil.isInteger = function (value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * @return {Object} Deferred promise.\n */\nutil.defer = function () {\n  var deferred = {};\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n};\n\n/**\n * Show warnings when they are enabled.\n *\n * @param {*} arguments to console.warn\n */\nutil.warn = function () {\n  if (!internal$1.config.warningsDisabled) {\n    var _console;\n\n    (_console = console).warn.apply(_console, arguments);\n  }\n};\n\n/**\n * Prevent scrolling while draging horizontally.\n *\n * @param {gd} GestureDetector instance\n */\nutil.preventScroll = function (gd) {\n  var prevent = function prevent(e) {\n    return e.cancelable && e.preventDefault();\n  };\n\n  var clean = function clean(e) {\n    gd.off('touchmove', prevent);\n    gd.off('dragend', clean);\n  };\n\n  gd.on('touchmove', prevent);\n  gd.on('dragend', clean);\n};\n\n/**\n * Distance and deltaTime filter some weird dragstart events that are not fired immediately.\n *\n * @param {event}\n */\nutil.isValidGesture = function (event) {\n  return event.gesture !== undefined && (event.gesture.distance <= 15 || event.gesture.deltaTime <= 100);\n};\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Minimal animation library for managing css transition on mobile browsers.\n */\nvar TIMEOUT_RATIO = 1.4;\n\nvar util$3 = {};\n\n// capitalize string\nutil$3.capitalize = function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\n/**\n * @param {Object} params\n * @param {String} params.property\n * @param {Float} params.duration\n * @param {String} params.timing\n */\nutil$3.buildTransitionValue = function (params) {\n  params.property = params.property || 'all';\n  params.duration = params.duration || 0.4;\n  params.timing = params.timing || 'linear';\n\n  var props = params.property.split(/ +/);\n\n  return props.map(function (prop) {\n    return prop + ' ' + params.duration + 's ' + params.timing;\n  }).join(', ');\n};\n\n/**\n * Add an event handler on \"transitionend\" event.\n */\nutil$3.onceOnTransitionEnd = function (element, callback) {\n  if (!element) {\n    return function () {};\n  }\n\n  var fn = function fn(event) {\n    if (element == event.target) {\n      event.stopPropagation();\n      removeListeners();\n\n      callback();\n    }\n  };\n\n  var removeListeners = function removeListeners() {\n    util$3._transitionEndEvents.forEach(function (eventName) {\n      element.removeEventListener(eventName, fn, false);\n    });\n  };\n\n  util$3._transitionEndEvents.forEach(function (eventName) {\n    element.addEventListener(eventName, fn, false);\n  });\n\n  return removeListeners;\n};\n\nutil$3._transitionEndEvents = function () {\n\n  if ('ontransitionend' in window) {\n    return ['transitionend'];\n  }\n\n  if ('onwebkittransitionend' in window) {\n    return ['webkitTransitionEnd'];\n  }\n\n  if (util$3.vendorPrefix === 'webkit' || util$3.vendorPrefix === 'o' || util$3.vendorPrefix === 'moz' || util$3.vendorPrefix === 'ms') {\n    return [util$3.vendorPrefix + 'TransitionEnd', 'transitionend'];\n  }\n\n  return [];\n}();\n\nutil$3._cssPropertyDict = function () {\n  var styles = window.getComputedStyle(document.documentElement, '');\n  var dict = {};\n  var a = 'A'.charCodeAt(0);\n  var z = 'z'.charCodeAt(0);\n\n  var upper = function upper(s) {\n    return s.substr(1).toUpperCase();\n  };\n\n  for (var i = 0; i < styles.length; i++) {\n\n    var key = styles[i].replace(/^[-]+/, '').replace(/[-][a-z]/g, upper).replace(/^moz/, 'Moz');\n\n    if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {\n      if (key !== 'cssText' && key !== 'parentText') {\n        dict[key] = true;\n      }\n    }\n  }\n\n  return dict;\n}();\n\nutil$3.hasCssProperty = function (name) {\n  return name in util$3._cssPropertyDict;\n};\n\n/**\n * Vendor prefix for css property.\n */\nutil$3.vendorPrefix = function () {\n  var styles = window.getComputedStyle(document.documentElement, ''),\n      pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];\n  return pre;\n}();\n\nutil$3.forceLayoutAtOnce = function (elements, callback) {\n  this.batchImmediate(function () {\n    elements.forEach(function (element) {\n      // force layout\n      element.offsetHeight;\n    });\n    callback();\n  });\n};\n\nutil$3.batchImmediate = function () {\n  var callbacks = [];\n\n  return function (callback) {\n    if (callbacks.length === 0) {\n      setImmediate(function () {\n        var concreateCallbacks = callbacks.slice(0);\n        callbacks = [];\n        concreateCallbacks.forEach(function (callback) {\n          callback();\n        });\n      });\n    }\n\n    callbacks.push(callback);\n  };\n}();\n\nutil$3.batchAnimationFrame = function () {\n  var callbacks = [];\n\n  var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n    setTimeout(callback, 1000 / 60);\n  };\n\n  return function (callback) {\n    if (callbacks.length === 0) {\n      raf(function () {\n        var concreateCallbacks = callbacks.slice(0);\n        callbacks = [];\n        concreateCallbacks.forEach(function (callback) {\n          callback();\n        });\n      });\n    }\n\n    callbacks.push(callback);\n  };\n}();\n\nutil$3.transitionPropertyName = function () {\n  if (util$3.hasCssProperty('transitionDuration')) {\n    return 'transition';\n  }\n\n  if (util$3.hasCssProperty(util$3.vendorPrefix + 'TransitionDuration')) {\n    return util$3.vendorPrefix + 'Transition';\n  }\n\n  throw new Error('Invalid state');\n}();\n\n/**\n * @param {HTMLElement} element\n */\nvar Animit = function Animit(element) {\n  if (!(this instanceof Animit)) {\n    return new Animit(element);\n  }\n\n  if (element instanceof HTMLElement) {\n    this.elements = [element];\n  } else if (Object.prototype.toString.call(element) === '[object Array]') {\n    this.elements = element;\n  } else {\n    throw new Error('First argument must be an array or an instance of HTMLElement.');\n  }\n\n  this.transitionQueue = [];\n  this.lastStyleAttributeDict = [];\n};\n\nAnimit.prototype = {\n\n  /**\n   * @property {Array}\n   */\n  transitionQueue: undefined,\n\n  /**\n   * @property {Array}\n   */\n  elements: undefined,\n\n  /**\n   * Start animation sequence with passed animations.\n   *\n   * @param {Function} callback\n   */\n  play: function play(callback) {\n    if (typeof callback === 'function') {\n      this.transitionQueue.push(function (done) {\n        callback();\n        done();\n      });\n    }\n\n    this.startAnimation();\n\n    return this;\n  },\n\n  /**\n   * Queue transition animations or other function.\n   *\n   * e.g. animit(elt).queue({color: 'red'})\n   * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})\n   * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})\n   *\n   * @param {Object|Animit.Transition|Function} transition\n   * @param {Object} [options]\n   */\n  queue: function queue(transition, options) {\n    var queue = this.transitionQueue;\n\n    if (transition && options) {\n      options.css = transition;\n      transition = new Animit.Transition(options);\n    }\n\n    if (!(transition instanceof Function || transition instanceof Animit.Transition)) {\n      if (transition.css) {\n        transition = new Animit.Transition(transition);\n      } else {\n        transition = new Animit.Transition({\n          css: transition\n        });\n      }\n    }\n\n    if (transition instanceof Function) {\n      queue.push(transition);\n    } else if (transition instanceof Animit.Transition) {\n      queue.push(transition.build());\n    } else {\n      throw new Error('Invalid arguments');\n    }\n\n    return this;\n  },\n\n  /**\n   * Queue transition animations.\n   *\n   * @param {Float} seconds\n   */\n  wait: function wait(seconds) {\n    if (seconds > 0) {\n      this.transitionQueue.push(function (done) {\n        setTimeout(done, 1000 * seconds);\n      });\n    }\n\n    return this;\n  },\n\n  saveStyle: function saveStyle() {\n\n    this.transitionQueue.push(function (done) {\n      this.elements.forEach(function (element, index) {\n        var css = this.lastStyleAttributeDict[index] = {};\n\n        for (var i = 0; i < element.style.length; i++) {\n          css[element.style[i]] = element.style[element.style[i]];\n        }\n      }.bind(this));\n      done();\n    }.bind(this));\n\n    return this;\n  },\n\n  /**\n   * Restore element's style.\n   *\n   * @param {Object} [options]\n   * @param {Float} [options.duration]\n   * @param {String} [options.timing]\n   * @param {String} [options.transition]\n   */\n  restoreStyle: function restoreStyle(options) {\n    options = options || {};\n    var self = this;\n\n    if (options.transition && !options.duration) {\n      throw new Error('\"options.duration\" is required when \"options.transition\" is enabled.');\n    }\n\n    var transitionName = util$3.transitionPropertyName;\n\n    if (options.transition || options.duration && options.duration > 0) {\n      var transitionValue = options.transition || 'all ' + options.duration + 's ' + (options.timing || 'linear');\n\n      this.transitionQueue.push(function (done) {\n        var elements = this.elements;\n        var timeoutId;\n\n        var clearTransition = function clearTransition() {\n          elements.forEach(function (element) {\n            element.style[transitionName] = '';\n          });\n        };\n\n        // add \"transitionend\" event handler\n        var removeListeners = util$3.onceOnTransitionEnd(elements[0], function () {\n          clearTimeout(timeoutId);\n          clearTransition();\n          done();\n        });\n\n        // for fail safe.\n        timeoutId = setTimeout(function () {\n          removeListeners();\n          clearTransition();\n          done();\n        }, options.duration * 1000 * TIMEOUT_RATIO);\n\n        // transition and style settings\n        elements.forEach(function (element, index) {\n\n          var css = self.lastStyleAttributeDict[index];\n\n          if (!css) {\n            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');\n          }\n\n          self.lastStyleAttributeDict[index] = undefined;\n\n          var name;\n          for (var i = 0, len = element.style.length; i < len; i++) {\n            name = element.style[i];\n            if (css[name] === undefined) {\n              css[name] = '';\n            }\n          }\n\n          element.style[transitionName] = transitionValue;\n\n          Object.keys(css).forEach(function (key) {\n            if (key !== transitionName) {\n              element.style[key] = css[key];\n            }\n          });\n\n          element.style[transitionName] = transitionValue;\n        });\n      });\n    } else {\n      this.transitionQueue.push(function (done) {\n        reset();\n        done();\n      });\n    }\n\n    return this;\n\n    function reset() {\n      // Clear transition animation settings.\n      self.elements.forEach(function (element, index) {\n        element.style[transitionName] = 'none';\n\n        var css = self.lastStyleAttributeDict[index];\n\n        if (!css) {\n          throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');\n        }\n\n        self.lastStyleAttributeDict[index] = undefined;\n\n        for (var i = 0, name = ''; i < element.style.length; i++) {\n          name = element.style[i];\n          if (typeof css[element.style[i]] === 'undefined') {\n            css[element.style[i]] = '';\n          }\n        }\n\n        Object.keys(css).forEach(function (key) {\n          element.style[key] = css[key];\n        });\n      });\n    }\n  },\n\n  /**\n   * Start animation sequence.\n   */\n  startAnimation: function startAnimation() {\n    this._dequeueTransition();\n\n    return this;\n  },\n\n  _dequeueTransition: function _dequeueTransition() {\n    var transition = this.transitionQueue.shift();\n    if (this._currentTransition) {\n      throw new Error('Current transition exists.');\n    }\n    this._currentTransition = transition;\n    var self = this;\n    var called = false;\n\n    var done = function done() {\n      if (!called) {\n        called = true;\n        self._currentTransition = undefined;\n        self._dequeueTransition();\n      } else {\n        throw new Error('Invalid state: This callback is called twice.');\n      }\n    };\n\n    if (transition) {\n      transition.call(this, done);\n    }\n  }\n\n};\n\n/**\n * @param {Animit} arguments\n */\nAnimit.runAll = function () /* arguments... */{\n  for (var i = 0; i < arguments.length; i++) {\n    arguments[i].play();\n  }\n};\n\n/**\n * @param {Object} options\n * @param {Float} [options.duration]\n * @param {String} [options.property]\n * @param {String} [options.timing]\n */\nAnimit.Transition = function (options) {\n  this.options = options || {};\n  this.options.duration = this.options.duration || 0;\n  this.options.timing = this.options.timing || 'linear';\n  this.options.css = this.options.css || {};\n  this.options.property = this.options.property || 'all';\n};\n\nAnimit.Transition.prototype = {\n\n  /**\n   * @param {HTMLElement} element\n   * @return {Function}\n   */\n  build: function build() {\n\n    if (Object.keys(this.options.css).length === 0) {\n      throw new Error('options.css is required.');\n    }\n\n    var css = createActualCssProps(this.options.css);\n\n    if (this.options.duration > 0) {\n      var transitionValue = util$3.buildTransitionValue(this.options);\n      var self = this;\n\n      return function (callback) {\n        var elements = this.elements;\n        var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;\n        var timeoutId;\n\n        var removeListeners = util$3.onceOnTransitionEnd(elements[0], function () {\n          clearTimeout(timeoutId);\n          callback();\n        });\n\n        timeoutId = setTimeout(function () {\n          removeListeners();\n          callback();\n        }, timeout);\n\n        elements.forEach(function (element) {\n          element.style[util$3.transitionPropertyName] = transitionValue;\n\n          Object.keys(css).forEach(function (name) {\n            element.style[name] = css[name];\n          });\n        });\n      };\n    }\n\n    if (this.options.duration <= 0) {\n      return function (callback) {\n        var elements = this.elements;\n\n        elements.forEach(function (element) {\n          element.style[util$3.transitionPropertyName] = '';\n\n          Object.keys(css).forEach(function (name) {\n            element.style[name] = css[name];\n          });\n        });\n\n        if (elements.length > 0) {\n          util$3.forceLayoutAtOnce(elements, function () {\n            util$3.batchAnimationFrame(callback);\n          });\n        } else {\n          util$3.batchAnimationFrame(callback);\n        }\n      };\n    }\n\n    function createActualCssProps(css) {\n      var result = {};\n\n      Object.keys(css).forEach(function (name) {\n        var value = css[name];\n\n        if (util$3.hasCssProperty(name)) {\n          result[name] = value;\n          return;\n        }\n\n        var prefixed = util$3.vendorPrefix + util$3.capitalize(name);\n        if (util$3.hasCssProperty(prefixed)) {\n          result[prefixed] = value;\n        } else {\n          result[prefixed] = value;\n          result[name] = value;\n        }\n      });\n\n      return result;\n    }\n  }\n};\n\n/*\n * Gesture detector library that forked from github.com/EightMedia/hammer.js.\n */\n\nvar Event$1;\nvar Utils;\nvar Detection;\nvar PointerEvent;\n\n/**\n * @object ons.GestureDetector\n * @category gesture\n * @description\n *   [en]Utility class for gesture detection.[/en]\n *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]\n */\n\n/**\n * @method constructor\n * @signature constructor(element[, options])\n * @description\n *  [en]Create a new GestureDetector instance.[/en]\n *  [ja]GestureDetectorのインスタンスを生成します。[/ja]\n * @param {Element} element\n *   [en]Name of the event.[/en]\n *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]\n * @param {Object} [options]\n *   [en]Options object.[/en]\n *   [ja]オプションを指定します。[/ja]\n * @return {ons.GestureDetector.Instance}\n */\nvar GestureDetector = function GestureDetector(element, options) {\n  return new GestureDetector.Instance(element, options || {});\n};\n\n/**\n * default settings.\n * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled\n * by setting it's name (like `swipe`) to false.\n * You can set the defaults for all instances by changing this object before creating an instance.\n * @example\n * ````\n *  GestureDetector.defaults.drag = false;\n *  GestureDetector.defaults.behavior.touchAction = 'pan-y';\n *  delete GestureDetector.defaults.behavior.userSelect;\n * ````\n * @property defaults\n * @type {Object}\n */\nGestureDetector.defaults = {\n  behavior: {\n    // userSelect: 'none', // Also disables selection in `input` children\n    touchAction: 'pan-y',\n    touchCallout: 'none',\n    contentZooming: 'none',\n    userDrag: 'none',\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n};\n\n/**\n * GestureDetector document where the base events are added at\n * @property DOCUMENT\n * @type {HTMLElement}\n * @default window.document\n */\nGestureDetector.DOCUMENT = document;\n\n/**\n * detect support for pointer events\n * @property HAS_POINTEREVENTS\n * @type {Boolean}\n */\nGestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;\n\n/**\n * detect support for touch events\n * @property HAS_TOUCHEVENTS\n * @type {Boolean}\n */\nGestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;\n\n/**\n * detect mobile browsers\n * @property IS_MOBILE\n * @type {Boolean}\n */\nGestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);\n\n/**\n * detect if we want to support mouseevents at all\n * @property NO_MOUSEEVENTS\n * @type {Boolean}\n */\nGestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;\n\n/**\n * interval in which GestureDetector recalculates current velocity/direction/angle in ms\n * @property CALCULATE_INTERVAL\n * @type {Number}\n * @default 25\n */\nGestureDetector.CALCULATE_INTERVAL = 25;\n\n/**\n * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`\n * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)\n * @property EVENT_TYPES\n * @private\n * @writeOnce\n * @type {Object}\n */\nvar EVENT_TYPES = {};\n\n/**\n * direction strings, for safe comparisons\n * @property DIRECTION_DOWN|LEFT|UP|RIGHT\n * @final\n * @type {String}\n * @default 'down' 'left' 'up' 'right'\n */\nvar DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';\nvar DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';\nvar DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';\nvar DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';\n\n/**\n * pointertype strings, for safe comparisons\n * @property POINTER_MOUSE|TOUCH|PEN\n * @final\n * @type {String}\n * @default 'mouse' 'touch' 'pen'\n */\nvar POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';\nvar POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';\nvar POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';\n\n/**\n * eventtypes\n * @property EVENT_START|MOVE|END|RELEASE|TOUCH\n * @final\n * @type {String}\n * @default 'start' 'change' 'move' 'end' 'release' 'touch'\n */\nvar EVENT_START = GestureDetector.EVENT_START = 'start';\nvar EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';\nvar EVENT_END = GestureDetector.EVENT_END = 'end';\nvar EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';\nvar EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';\n\n/**\n * if the window events are set...\n * @property READY\n * @writeOnce\n * @type {Boolean}\n * @default false\n */\nGestureDetector.READY = false;\n\n/**\n * plugins namespace\n * @property plugins\n * @type {Object}\n */\nGestureDetector.plugins = GestureDetector.plugins || {};\n\n/**\n * gestures namespace\n * see `/gestures` for the definitions\n * @property gestures\n * @type {Object}\n */\nGestureDetector.gestures = GestureDetector.gestures || {};\n\n/**\n * setup events to detect gestures on the document\n * this function is called when creating an new instance\n * @private\n */\nfunction setup() {\n  if (GestureDetector.READY) {\n    return;\n  }\n\n  // find what eventtypes we add listeners to\n  Event$1.determineEventTypes();\n\n  // Register all gestures inside GestureDetector.gestures\n  Utils.each(GestureDetector.gestures, function (gesture) {\n    Detection.register(gesture);\n  });\n\n  // Add touch events on the document\n  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect);\n  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect);\n\n  // GestureDetector is ready...!\n  GestureDetector.READY = true;\n}\n\n/**\n * @module GestureDetector\n *\n * @class Utils\n * @static\n */\nUtils = GestureDetector.utils = {\n  /**\n   * extend method, could also be used for cloning when `dest` is an empty object.\n   * changes the dest object\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]  do a merge\n   * @return {Object} dest\n   */\n  extend: function extend(dest, src, merge) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {\n        dest[key] = src[key];\n      }\n    }\n    return dest;\n  },\n\n  /**\n   * simple addEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  on: function on(element, type, handler) {\n    element.addEventListener(type, handler, false);\n  },\n\n  /**\n   * simple removeEventListener wrapper\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  off: function off(element, type, handler) {\n    element.removeEventListener(type, handler, false);\n  },\n\n  /**\n   * forEach over arrays and objects\n   * @param {Object|Array} obj\n   * @param {Function} iterator\n   * @param {any} iterator.item\n   * @param {Number} iterator.index\n   * @param {Object|Array} iterator.obj the source object\n   * @param {Object} context value to use as `this` in the iterator\n   */\n  each: function each(obj, iterator, context) {\n    var i, len;\n\n    // native forEach on arrays\n    if ('forEach' in obj) {\n      obj.forEach(iterator, context);\n      // arrays\n    } else if (obj.length !== undefined) {\n      for (i = 0, len = obj.length; i < len; i++) {\n        if (iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n      // objects\n    } else {\n      for (i in obj) {\n        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n\n  /**\n   * find if a string contains the string using indexOf\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean} found\n   */\n  inStr: function inStr(src, find) {\n    return src.indexOf(find) > -1;\n  },\n\n  /**\n   * find if a array contains the object using indexOf or a simple polyfill\n   * @param {String} src\n   * @param {String} find\n   * @return {Boolean|Number} false when not found, or the index\n   */\n  inArray: function inArray(src, find, deep) {\n    if (deep) {\n      for (var i = 0, len = src.length; i < len; i++) {\n        // Array.findIndex\n        if (Object.keys(find).every(function (key) {\n          return src[i][key] === find[key];\n        })) {\n          return i;\n        }\n      }\n      return -1;\n    }\n\n    if (src.indexOf) {\n      return src.indexOf(find);\n    } else {\n      for (var i = 0, len = src.length; i < len; i++) {\n        if (src[i] === find) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  },\n\n  /**\n   * convert an array-like object (`arguments`, `touchlist`) to an array\n   * @param {Object} obj\n   * @return {Array}\n   */\n  toArray: function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  },\n\n  /**\n   * find if a node is in the given parent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n  hasParent: function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  },\n\n  /**\n   * get the center of all the touches\n   * @param {Array} touches\n   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties\n   */\n  getCenter: function getCenter(touches) {\n    var pageX = [],\n        pageY = [],\n        clientX = [],\n        clientY = [],\n        min = Math.min,\n        max = Math.max;\n\n    // no need to loop when only one touch\n    if (touches.length === 1) {\n      return {\n        pageX: touches[0].pageX,\n        pageY: touches[0].pageY,\n        clientX: touches[0].clientX,\n        clientY: touches[0].clientY\n      };\n    }\n\n    Utils.each(touches, function (touch) {\n      pageX.push(touch.pageX);\n      pageY.push(touch.pageY);\n      clientX.push(touch.clientX);\n      clientY.push(touch.clientY);\n    });\n\n    return {\n      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,\n      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,\n      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,\n      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2\n    };\n  },\n\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   * @return {Object} velocity `x` and `y`\n   */\n  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {\n    return {\n      x: Math.abs(deltaX / deltaTime) || 0,\n      y: Math.abs(deltaY / deltaTime) || 0\n    };\n  },\n\n  /**\n   * calculate the angle between two coordinates\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {Number} angle\n   */\n  getAngle: function getAngle(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n        y = touch2.clientY - touch1.clientY;\n\n    return Math.atan2(y, x) * 180 / Math.PI;\n  },\n\n  /**\n   * do a small comparison to get the direction between two touches.\n   * @param {Touch} touch1\n   * @param {Touch} touch2\n   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`\n   */\n  getDirection: function getDirection(touch1, touch2) {\n    var x = Math.abs(touch1.clientX - touch2.clientX),\n        y = Math.abs(touch1.clientY - touch2.clientY);\n\n    if (x >= y) {\n      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  },\n\n  /**\n   * calculate the distance between two touches\n   * @param {Touch}touch1\n   * @param {Touch} touch2\n   * @return {Number} distance\n   */\n  getDistance: function getDistance(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX,\n        y = touch2.clientY - touch1.clientY;\n\n    return Math.sqrt(x * x + y * y);\n  },\n\n  /**\n   * calculate the scale factor between two touchLists\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} scale\n   */\n  getScale: function getScale(start, end) {\n    // need two fingers...\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);\n    }\n    return 1;\n  },\n\n  /**\n   * calculate the rotation degrees between two touchLists\n   * @param {Array} start array of touches\n   * @param {Array} end array of touches\n   * @return {Number} rotation\n   */\n  getRotation: function getRotation(start, end) {\n    // need two fingers\n    if (start.length >= 2 && end.length >= 2) {\n      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);\n    }\n    return 0;\n  },\n\n  /**\n   * find out if the direction is vertical   *\n   * @param {String} direction matches `DIRECTION_UP|DOWN`\n   * @return {Boolean} is_vertical\n   */\n  isVertical: function isVertical(direction) {\n    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;\n  },\n\n  /**\n   * set css properties with their prefixes\n   * @param {HTMLElement} element\n   * @param {String} prop\n   * @param {String} value\n   * @param {Boolean} [toggle=true]\n   * @return {Boolean}\n   */\n  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {\n    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];\n    prop = Utils.toCamelCase(prop);\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var p = prop;\n      // prefixes\n      if (prefixes[i]) {\n        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);\n      }\n\n      // test the style\n      if (p in element.style) {\n        element.style[p] = (toggle === null || toggle) && value || '';\n        break;\n      }\n    }\n  },\n\n  /**\n   * toggle browser default behavior by setting css properties.\n   * `userSelect='none'` also sets `element.onselectstart` to false\n   * `userDrag='none'` also sets `element.ondragstart` to false\n   *\n   * @param {HtmlElement} element\n   * @param {Object} props\n   * @param {Boolean} [toggle=true]\n   */\n  toggleBehavior: function toggleBehavior(element, props, toggle) {\n    if (!props || !element || !element.style) {\n      return;\n    }\n\n    // set the css properties\n    Utils.each(props, function (value, prop) {\n      Utils.setPrefixedCss(element, prop, value, toggle);\n    });\n\n    var falseFn = toggle && function () {\n      return false;\n    };\n\n    // also the disable onselectstart\n    if (props.userSelect == 'none') {\n      element.onselectstart = falseFn;\n    }\n    // and disable ondragstart\n    if (props.userDrag == 'none') {\n      element.ondragstart = falseFn;\n    }\n  },\n\n  /**\n   * convert a string with underscores to camelCase\n   * so prevent_default becomes preventDefault\n   * @param {String} str\n   * @return {String} camelCaseStr\n   */\n  toCamelCase: function toCamelCase(str) {\n    return str.replace(/[_-]([a-z])/g, function (s) {\n      return s[1].toUpperCase();\n    });\n  }\n};\n\n/**\n * @module GestureDetector\n */\n/**\n * @class Event\n * @static\n */\nEvent$1 = GestureDetector.event = {\n  /**\n   * when touch events have been fired, this is true\n   * this is used to stop mouse events\n   * @property prevent_mouseevents\n   * @private\n   * @type {Boolean}\n   */\n  preventMouseEvents: false,\n\n  /**\n   * if EVENT_START has been fired\n   * @property started\n   * @private\n   * @type {Boolean}\n   */\n  started: false,\n\n  /**\n   * when the mouse is hold down, this is true\n   * @property should_detect\n   * @private\n   * @type {Boolean}\n   */\n  shouldDetect: false,\n\n  /**\n   * simple event binder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  on: function on(element, type, handler, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function (type) {\n      Utils.on(element, type, handler);\n      hook && hook(type);\n    });\n  },\n\n  /**\n   * simple event unbinder with a hook and support for multiple types\n   * @param {HTMLElement} element\n   * @param {String} type\n   * @param {Function} handler\n   * @param {Function} [hook]\n   * @param {Object} hook.type\n   */\n  off: function off(element, type, handler, hook) {\n    var types = type.split(' ');\n    Utils.each(types, function (type) {\n      Utils.off(element, type, handler);\n      hook && hook(type);\n    });\n  },\n\n  /**\n   * the core touch event handler.\n   * this finds out if we should to detect gestures\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Function} handler\n   * @return onTouchHandler {Function} the core event handler\n   */\n  onTouch: function onTouch(element, eventType, handler) {\n    var self = this;\n\n    var onTouchHandler = function onTouchHandler(ev) {\n      var srcType = ev.type.toLowerCase(),\n          isPointer = GestureDetector.HAS_POINTEREVENTS,\n          isMouse = Utils.inStr(srcType, 'mouse'),\n          triggerType;\n\n      // if we are in a mouseevent, but there has been a touchevent triggered in this session\n      // we want to do nothing. simply break out of the event.\n      if (isMouse && self.preventMouseEvents) {\n        return;\n\n        // mousebutton must be down\n      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = true;\n      } else if (isPointer && eventType == EVENT_START) {\n        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);\n        // just a valid start event, but no mouse\n      } else if (!isMouse && eventType == EVENT_START) {\n        self.preventMouseEvents = true;\n        self.shouldDetect = true;\n      }\n\n      // update the pointer event before entering the detection\n      if (isPointer && eventType != EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      }\n\n      // we are in a touch/down state, so allowed detection of gestures\n      if (self.shouldDetect) {\n        triggerType = self.doDetect.call(self, ev, eventType, element, handler);\n      }\n\n      // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n      if (triggerType == EVENT_END) {\n        self.preventMouseEvents = false;\n        self.shouldDetect = false;\n        PointerEvent.reset();\n        // update the pointerevent object after the detection\n      }\n\n      if (isPointer && eventType == EVENT_END) {\n        PointerEvent.updatePointer(eventType, ev);\n      }\n    };\n\n    this.on(element, EVENT_TYPES[eventType], onTouchHandler);\n    return onTouchHandler;\n  },\n\n  /**\n   * the core detection method\n   * this finds out what GestureDetector-touch-events to trigger\n   * @param {Object} ev\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {HTMLElement} element\n   * @param {Function} handler\n   * @return {String} triggerType matches `EVENT_START|MOVE|END`\n   */\n  doDetect: function doDetect(ev, eventType, element, handler) {\n    var touchList = this.getTouchList(ev, eventType);\n    var touchListLength = touchList.length;\n    var triggerType = eventType;\n    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin\n    var changedLength = touchListLength;\n\n    // at each touchstart-like event we want also want to trigger a TOUCH event...\n    if (eventType == EVENT_START) {\n      triggerChange = EVENT_TOUCH;\n      // ...the same for a touchend-like event\n    } else if (eventType == EVENT_END) {\n      triggerChange = EVENT_RELEASE;\n\n      // keep track of how many touches have been removed\n      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);\n    }\n\n    // after there are still touches on the screen,\n    // we just want to trigger a MOVE event. so change the START or END to a MOVE\n    // but only after detection has been started, the first time we actually want a START\n    if (changedLength > 0 && this.started) {\n      triggerType = EVENT_MOVE;\n    }\n\n    // detection has been started, we keep track of this, see above\n    this.started = true;\n\n    // generate some event data, some basic information\n    var evData = this.collectEventData(element, triggerType, touchList, ev);\n\n    // trigger the triggerType event before the change (TOUCH, RELEASE) events\n    // but the END event should be at last\n    if (eventType != EVENT_END) {\n      handler.call(Detection, evData);\n    }\n\n    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed\n    if (triggerChange) {\n      evData.changedLength = changedLength;\n      evData.eventType = triggerChange;\n\n      handler.call(Detection, evData);\n\n      evData.eventType = triggerType;\n      delete evData.changedLength;\n    }\n\n    // trigger the END event\n    if (triggerType == EVENT_END) {\n      handler.call(Detection, evData);\n\n      // ...and we are done with the detection\n      // so reset everything to start each detection totally fresh\n      this.started = false;\n    }\n\n    return triggerType;\n  },\n\n  /**\n   * we have different events for each device/browser\n   * determine what we need and set them in the EVENT_TYPES constant\n   * the `onTouch` method is bind to these properties.\n   * @return {Object} events\n   */\n  determineEventTypes: function determineEventTypes() {\n    var types;\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      if (window.PointerEvent) {\n        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];\n      } else {\n        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];\n      }\n    } else if (GestureDetector.NO_MOUSEEVENTS) {\n      types = ['touchstart', 'touchmove', 'touchend touchcancel'];\n    } else {\n      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];\n    }\n\n    EVENT_TYPES[EVENT_START] = types[0];\n    EVENT_TYPES[EVENT_MOVE] = types[1];\n    EVENT_TYPES[EVENT_END] = types[2];\n    return EVENT_TYPES;\n  },\n\n  /**\n   * create touchList depending on the event\n   * @param {Object} ev\n   * @param {String} eventType\n   * @return {Array} touches\n   */\n  getTouchList: function getTouchList(ev, eventType) {\n    // get the fake pointerEvent touchlist\n    if (GestureDetector.HAS_POINTEREVENTS) {\n      return PointerEvent.getTouchList();\n    }\n\n    // get the touchlist\n    if (ev.touches) {\n      if (eventType == EVENT_MOVE) {\n        return ev.touches;\n      }\n\n      var identifiers = [];\n      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));\n      var touchList = [];\n\n      Utils.each(concat, function (touch) {\n        if (Utils.inArray(identifiers, touch.identifier) === -1) {\n          touchList.push(touch);\n        }\n        identifiers.push(touch.identifier);\n      });\n\n      return touchList;\n    }\n\n    // make fake touchList from mouse position\n    ev.identifier = 1;\n    return [ev];\n  },\n\n  /**\n   * collect basic event data\n   * @param {HTMLElement} element\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Array} touches\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  collectEventData: function collectEventData(element, eventType, touches, ev) {\n    // find out pointerType\n    var pointerType = POINTER_TOUCH;\n    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {\n      pointerType = POINTER_MOUSE;\n    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {\n      pointerType = POINTER_PEN;\n    }\n\n    return {\n      center: Utils.getCenter(touches),\n      timeStamp: Date.now(),\n      target: ev.target,\n      touches: touches,\n      eventType: eventType,\n      pointerType: pointerType,\n      srcEvent: ev,\n\n      /**\n       * prevent the browser default actions\n       * mostly used to disable scrolling of the browser\n       */\n      preventDefault: function preventDefault() {\n        var srcEvent = this.srcEvent;\n        srcEvent.preventManipulation && srcEvent.preventManipulation();\n        srcEvent.preventDefault && srcEvent.preventDefault();\n      },\n\n      /**\n       * stop bubbling the event up to its parents\n       */\n      stopPropagation: function stopPropagation() {\n        this.srcEvent.stopPropagation();\n      },\n\n      /**\n       * immediately stop gesture detection\n       * might be useful after a swipe was detected\n       * @return {*}\n       */\n      stopDetect: function stopDetect() {\n        return Detection.stopDetect();\n      }\n    };\n  }\n};\n\n/**\n * @module GestureDetector\n *\n * @class PointerEvent\n * @static\n */\nPointerEvent = GestureDetector.PointerEvent = {\n  /**\n   * holds all pointers, by `identifier`\n   * @property pointers\n   * @type {Object}\n   */\n  pointers: {},\n\n  /**\n   * get the pointers as an array\n   * @return {Array} touchlist\n   */\n  getTouchList: function getTouchList() {\n    var touchlist = [];\n    // we can use forEach since pointerEvents only is in IE10\n    Utils.each(this.pointers, function (pointer) {\n      touchlist.push(pointer);\n    });\n    return touchlist;\n  },\n\n  /**\n   * update the position of a pointer\n   * @param {String} eventType matches `EVENT_START|MOVE|END`\n   * @param {Object} pointerEvent\n   */\n  updatePointer: function updatePointer(eventType, pointerEvent) {\n    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {\n      delete this.pointers[pointerEvent.pointerId];\n    } else {\n      pointerEvent.identifier = pointerEvent.pointerId;\n      this.pointers[pointerEvent.pointerId] = pointerEvent;\n    }\n  },\n\n  /**\n   * check if ev matches pointertype\n   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`\n   * @param {PointerEvent} ev\n   */\n  matchType: function matchType(pointerType, ev) {\n    if (!ev.pointerType) {\n      return false;\n    }\n\n    var pt = ev.pointerType,\n        types = {};\n\n    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);\n    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);\n    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);\n    return types[pointerType];\n  },\n\n  /**\n   * reset the stored pointers\n   */\n  reset: function resetList() {\n    this.pointers = {};\n  }\n};\n\n/**\n * @module GestureDetector\n *\n * @class Detection\n * @static\n */\nDetection = GestureDetector.detection = {\n  // contains all registered GestureDetector.gestures in the correct order\n  gestures: [],\n\n  // data of the current GestureDetector.gesture detection session\n  current: null,\n\n  // the previous GestureDetector.gesture session data\n  // is a full clone of the previous gesture.current object\n  previous: null,\n\n  // when this becomes true, no gestures are fired\n  stopped: false,\n\n  /**\n   * start GestureDetector.gesture detection\n   * @param {GestureDetector.Instance} inst\n   * @param {Object} eventData\n   */\n  startDetect: function startDetect(inst, eventData) {\n    // already busy with a GestureDetector.gesture detection on an element\n    if (this.current) {\n      return;\n    }\n\n    this.stopped = false;\n\n    // holds current session\n    this.current = {\n      inst: inst, // reference to GestureDetectorInstance we're working for\n      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc\n      lastEvent: false, // last eventData\n      lastCalcEvent: false, // last eventData for calculations.\n      futureCalcEvent: false, // last eventData for calculations.\n      lastCalcData: {}, // last lastCalcData\n      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n    };\n\n    this.detect(eventData);\n  },\n\n  /**\n   * GestureDetector.gesture detection\n   * @param {Object} eventData\n   * @return {any}\n   */\n  detect: function detect(eventData) {\n    if (!this.current || this.stopped) {\n      return;\n    }\n\n    // extend event data with calculations about scale, distance etc\n    eventData = this.extendEventData(eventData);\n\n    // GestureDetector instance and instance options\n    var inst = this.current.inst,\n        instOptions = inst.options;\n\n    // call GestureDetector.gesture handlers\n    Utils.each(this.gestures, function triggerGesture(gesture) {\n      // only when the instance options have enabled this gesture\n      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {\n        gesture.handler.call(gesture, eventData, inst);\n      }\n    }, this);\n\n    // store as previous event event\n    if (this.current) {\n      this.current.lastEvent = eventData;\n    }\n\n    if (eventData.eventType == EVENT_END) {\n      this.stopDetect();\n    }\n\n    return eventData; // eslint-disable-line consistent-return\n  },\n\n  /**\n   * clear the GestureDetector.gesture vars\n   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected\n   * to stop other GestureDetector.gestures from being fired\n   */\n  stopDetect: function stopDetect() {\n    // clone current data to the store as the previous gesture\n    // used for the double tap gesture, since this is an other gesture detect session\n    this.previous = Utils.extend({}, this.current);\n\n    // reset the current\n    this.current = null;\n    this.stopped = true;\n  },\n\n  /**\n   * calculate velocity, angle and direction\n   * @param {Object} ev\n   * @param {Object} center\n   * @param {Number} deltaTime\n   * @param {Number} deltaX\n   * @param {Number} deltaY\n   */\n  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {\n    var cur = this.current,\n        recalc = false,\n        calcEv = cur.lastCalcEvent,\n        calcData = cur.lastCalcData;\n\n    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {\n      center = calcEv.center;\n      deltaTime = ev.timeStamp - calcEv.timeStamp;\n      deltaX = ev.center.clientX - calcEv.center.clientX;\n      deltaY = ev.center.clientY - calcEv.center.clientY;\n      recalc = true;\n    }\n\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      cur.futureCalcEvent = ev;\n    }\n\n    if (!cur.lastCalcEvent || recalc) {\n      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);\n      calcData.angle = Utils.getAngle(center, ev.center);\n      calcData.direction = Utils.getDirection(center, ev.center);\n\n      cur.lastCalcEvent = cur.futureCalcEvent || ev;\n      cur.futureCalcEvent = ev;\n    }\n\n    ev.velocityX = calcData.velocity.x;\n    ev.velocityY = calcData.velocity.y;\n    ev.interimAngle = calcData.angle;\n    ev.interimDirection = calcData.direction;\n  },\n\n  /**\n   * extend eventData for GestureDetector.gestures\n   * @param {Object} ev\n   * @return {Object} ev\n   */\n  extendEventData: function extendEventData(ev) {\n    var cur = this.current,\n        startEv = cur.startEvent,\n        lastEv = cur.lastEvent || startEv;\n\n    // update the start touchlist to calculate the scale/rotation\n    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {\n      startEv.touches = [];\n      Utils.each(ev.touches, function (touch) {\n        startEv.touches.push({\n          clientX: touch.clientX,\n          clientY: touch.clientY\n        });\n      });\n    }\n\n    var deltaTime = ev.timeStamp - startEv.timeStamp,\n        deltaX = ev.center.clientX - startEv.center.clientX,\n        deltaY = ev.center.clientY - startEv.center.clientY;\n\n    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);\n\n    Utils.extend(ev, {\n      startEvent: startEv,\n\n      deltaTime: deltaTime,\n      deltaX: deltaX,\n      deltaY: deltaY,\n\n      distance: Utils.getDistance(startEv.center, ev.center),\n      angle: Utils.getAngle(startEv.center, ev.center),\n      direction: Utils.getDirection(startEv.center, ev.center),\n      scale: Utils.getScale(startEv.touches, ev.touches),\n      rotation: Utils.getRotation(startEv.touches, ev.touches)\n    });\n\n    return ev;\n  },\n\n  /**\n   * register new gesture\n   * @param {Object} gesture object, see `gestures/` for documentation\n   * @return {Array} gestures\n   */\n  register: function register(gesture) {\n    // add an enable gesture options if there is no given\n    var options = gesture.defaults || {};\n    if (options[gesture.name] === undefined) {\n      options[gesture.name] = true;\n    }\n\n    // extend GestureDetector default options with the GestureDetector.gesture options\n    Utils.extend(GestureDetector.defaults, options, true);\n\n    // set its index\n    gesture.index = gesture.index || 1000;\n\n    // add GestureDetector.gesture to the list\n    this.gestures.push(gesture);\n\n    // sort the list by index\n    this.gestures.sort(function (a, b) {\n      if (a.index < b.index) {\n        return -1;\n      }\n      if (a.index > b.index) {\n        return 1;\n      }\n      return 0;\n    });\n\n    return this.gestures;\n  }\n};\n\n/**\n * @module GestureDetector\n */\n\n/**\n * create new GestureDetector instance\n * all methods should return the instance itself, so it is chainable.\n *\n * @class Instance\n * @constructor\n * @param {HTMLElement} element\n * @param {Object} [options={}] options are merged with `GestureDetector.defaults`\n * @return {GestureDetector.Instance}\n */\nGestureDetector.Instance = function (element, options) {\n  var self = this;\n\n  // setup GestureDetectorJS window events and register all gestures\n  // this also sets up the default options\n  setup();\n\n  /**\n   * @property element\n   * @type {HTMLElement}\n   */\n  this.element = element;\n\n  /**\n   * @property enabled\n   * @type {Boolean}\n   * @protected\n   */\n  this.enabled = true;\n\n  /**\n   * options, merged with the defaults\n   * options with an _ are converted to camelCase\n   * @property options\n   * @type {Object}\n   */\n  Utils.each(options, function (value, name) {\n    delete options[name];\n    options[Utils.toCamelCase(name)] = value;\n  });\n\n  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});\n\n  // add some css to the element to prevent the browser from doing its native behavior\n  if (this.options.behavior) {\n    Utils.toggleBehavior(this.element, this.options.behavior, true);\n  }\n\n  /**\n   * event start handler on the element to start the detection\n   * @property eventStartHandler\n   * @type {Object}\n   */\n  this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {\n    if (self.enabled && ev.eventType == EVENT_START) {\n      Detection.startDetect(self, ev);\n    } else if (ev.eventType == EVENT_TOUCH) {\n      Detection.detect(ev);\n    }\n  });\n\n  /**\n   * keep a list of user event handlers which needs to be removed when calling 'dispose'\n   * @property eventHandlers\n   * @type {Array}\n   */\n  this.eventHandlers = [];\n};\n\nGestureDetector.Instance.prototype = {\n  /**\n   * @method on\n   * @signature on(gestures, handler)\n   * @description\n   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]\n   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  on: function onEvent(gestures, handler) {\n    var self = this;\n    Event$1.on(self.element, gestures, handler, function (type) {\n      self.eventHandlers.push({ gesture: type, handler: handler });\n    });\n    return self;\n  },\n\n  /**\n   * @method off\n   * @signature off(gestures, handler)\n   * @description\n   *  [en]Remove an event listener.[/en]\n   *  [ja]イベントリスナーを削除します。[/ja]\n   * @param {String} gestures\n   *   [en]A space separated list of gestures.[/en]\n   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]\n   * @param {Function} handler\n   *   [en]An event handling function.[/en]\n   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]\n   */\n  off: function offEvent(gestures, handler) {\n    var self = this;\n\n    Event$1.off(self.element, gestures, handler, function (type) {\n      var index = Utils.inArray(self.eventHandlers, { gesture: type, handler: handler }, true);\n      if (index >= 0) {\n        self.eventHandlers.splice(index, 1);\n      }\n    });\n    return self;\n  },\n\n  /**\n   * trigger gesture event\n   * @method trigger\n   * @signature trigger(gesture, eventData)\n   * @param {String} gesture\n   * @param {Object} [eventData]\n   */\n  trigger: function triggerEvent(gesture, eventData) {\n    // optional\n    if (!eventData) {\n      eventData = {};\n    }\n\n    // create DOM event\n    var event = GestureDetector.DOCUMENT.createEvent('Event');\n    event.initEvent(gesture, true, true);\n    event.gesture = eventData;\n\n    // trigger on the target if it is in the instance element,\n    // this is for event delegation tricks\n    var element = this.element;\n    if (Utils.hasParent(eventData.target, element)) {\n      element = eventData.target;\n    }\n\n    element.dispatchEvent(event);\n    return this;\n  },\n\n  /**\n   * @method enable\n   * @signature enable(state)\n   * @description\n   *  [en]Enable or disable gesture detection.[/en]\n   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]\n   * @param {Boolean} state\n   *   [en]Specify if it should be enabled or not.[/en]\n   *   [ja]有効にするかどうかを指定します。[/ja]\n   */\n  enable: function enable(state) {\n    this.enabled = state;\n    return this;\n  },\n\n  /**\n   * @method dispose\n   * @signature dispose()\n   * @description\n   *  [en]Remove and destroy all event handlers for this instance.[/en]\n   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]\n   */\n  dispose: function dispose() {\n    var i, eh;\n\n    // undo all changes made by stop_browser_behavior\n    Utils.toggleBehavior(this.element, this.options.behavior, false);\n\n    // unbind all custom event handlers\n    for (i = -1; eh = this.eventHandlers[++i];) {\n      // eslint-disable-line no-cond-assign\n      Utils.off(this.element, eh.gesture, eh.handler);\n    }\n\n    this.eventHandlers = [];\n\n    // unbind the start event listener\n    Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);\n\n    return null;\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * Move with x fingers (default 1) around on the page.\n * Preventing the default browser behavior is a good way to improve feel and working.\n * ````\n *  GestureDetectortime.on(\"drag\", function(ev) {\n *    console.log(ev);\n *    ev.gesture.preventDefault();\n *  });\n * ````\n *\n * @class Drag\n * @static\n */\n/**\n * @event drag\n * @param {Object} ev\n */\n/**\n * @event dragstart\n * @param {Object} ev\n */\n/**\n * @event dragend\n * @param {Object} ev\n */\n/**\n * @event drapleft\n * @param {Object} ev\n */\n/**\n * @event dragright\n * @param {Object} ev\n */\n/**\n * @event dragup\n * @param {Object} ev\n */\n/**\n * @event dragdown\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function (name) {\n  var triggered = false;\n\n  function dragGesture(ev, inst) {\n    var cur = Detection.current;\n\n    // max touches\n    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {\n      return;\n    }\n\n    switch (ev.eventType) {\n      case EVENT_START:\n        triggered = false;\n        break;\n\n      case EVENT_MOVE:\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {\n          return;\n        }\n\n        var startCenter = cur.startEvent.center;\n\n        // we are dragging!\n        if (cur.name != name) {\n          cur.name = name;\n          if (inst.options.dragDistanceCorrection && ev.distance > 0) {\n            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.\n            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.\n            // It might be useful to save the original start point somewhere\n            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);\n            startCenter.pageX += ev.deltaX * factor;\n            startCenter.pageY += ev.deltaY * factor;\n            startCenter.clientX += ev.deltaX * factor;\n            startCenter.clientY += ev.deltaY * factor;\n\n            // recalculate event data using new start point\n            ev = Detection.extendEventData(ev);\n          }\n        }\n\n        // lock drag to axis?\n        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {\n          ev.dragLockToAxis = true;\n        }\n\n        // keep direction on the axis that the drag gesture started on\n        var lastDirection = cur.lastEvent.direction;\n        if (ev.dragLockToAxis && lastDirection !== ev.direction) {\n          if (Utils.isVertical(lastDirection)) {\n            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          } else {\n            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          }\n        }\n\n        // first time, trigger dragstart event\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        }\n\n        // trigger events\n        inst.trigger(name, ev);\n        inst.trigger(name + ev.direction, ev);\n\n        var isVertical = Utils.isVertical(ev.direction);\n\n        // block the browser events\n        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {\n          ev.preventDefault();\n        }\n        break;\n\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n        break;\n\n      case EVENT_END:\n        triggered = false;\n        break;\n    }\n  }\n\n  GestureDetector.gestures.Drag = {\n    name: name,\n    index: 50,\n    handler: dragGesture,\n    defaults: {\n      /**\n       * minimal movement that have to be made before the drag event gets triggered\n       * @property dragMinDistance\n       * @type {Number}\n       * @default 10\n       */\n      dragMinDistance: 10,\n\n      /**\n       * Set dragDistanceCorrection to true to make the starting point of the drag\n       * be calculated from where the drag was triggered, not from where the touch started.\n       * Useful to avoid a jerk-starting drag, which can make fine-adjustments\n       * through dragging difficult, and be visually unappealing.\n       * @property dragDistanceCorrection\n       * @type {Boolean}\n       * @default true\n       */\n      dragDistanceCorrection: true,\n\n      /**\n       * set 0 for unlimited, but this can conflict with transform\n       * @property dragMaxTouches\n       * @type {Number}\n       * @default 1\n       */\n      dragMaxTouches: 1,\n\n      /**\n       * prevent default browser behavior when dragging occurs\n       * be careful with it, it makes the element a blocking element\n       * when you are using the drag gesture, it is a good practice to set this true\n       * @property dragBlockHorizontal\n       * @type {Boolean}\n       * @default false\n       */\n      dragBlockHorizontal: false,\n\n      /**\n       * same as `dragBlockHorizontal`, but for vertical movement\n       * @property dragBlockVertical\n       * @type {Boolean}\n       * @default false\n       */\n      dragBlockVertical: false,\n\n      /**\n       * dragLockToAxis keeps the drag gesture on the axis that it started on,\n       * It disallows vertical directions if the initial direction was horizontal, and vice versa.\n       * @property dragLockToAxis\n       * @type {Boolean}\n       * @default false\n       */\n      dragLockToAxis: false,\n\n      /**\n       * drag lock only kicks in when distance > dragLockMinDistance\n       * This way, locking occurs only when the distance has become large enough to reliably determine the direction\n       * @property dragLockMinDistance\n       * @type {Number}\n       * @default 25\n       */\n      dragLockMinDistance: 25\n    }\n  };\n})('drag');\n\n/**\n * @module gestures\n */\n/**\n * trigger a simple gesture event, so you can do anything in your handler.\n * only usable if you know what your doing...\n *\n * @class Gesture\n * @static\n */\n/**\n * @event gesture\n * @param {Object} ev\n */\nGestureDetector.gestures.Gesture = {\n  name: 'gesture',\n  index: 1337,\n  handler: function releaseGesture(ev, inst) {\n    inst.trigger(this.name, ev);\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * Touch stays at the same place for x time\n *\n * @class Hold\n * @static\n */\n/**\n * @event hold\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function (name) {\n  var timer;\n\n  function holdGesture(ev, inst) {\n    var options = inst.options,\n        current = Detection.current;\n\n    switch (ev.eventType) {\n      case EVENT_START:\n        clearTimeout(timer);\n\n        // set the gesture so we can check in the timeout if it still is\n        current.name = name;\n\n        // set timer and if after the timeout it still is hold,\n        // we trigger the hold event\n        timer = setTimeout(function () {\n          if (current && current.name == name) {\n            inst.trigger(name, ev);\n          }\n        }, options.holdTimeout);\n        break;\n\n      case EVENT_MOVE:\n        if (ev.distance > options.holdThreshold) {\n          clearTimeout(timer);\n        }\n        break;\n\n      case EVENT_RELEASE:\n        clearTimeout(timer);\n        break;\n    }\n  }\n\n  GestureDetector.gestures.Hold = {\n    name: name,\n    index: 10,\n    defaults: {\n      /**\n       * @property holdTimeout\n       * @type {Number}\n       * @default 500\n       */\n      holdTimeout: 500,\n\n      /**\n       * movement allowed while holding\n       * @property holdThreshold\n       * @type {Number}\n       * @default 2\n       */\n      holdThreshold: 2\n    },\n    handler: holdGesture\n  };\n})('hold');\n\n/**\n * @module gestures\n */\n/**\n * when a touch is being released from the page\n *\n * @class Release\n * @static\n */\n/**\n * @event release\n * @param {Object} ev\n */\nGestureDetector.gestures.Release = {\n  name: 'release',\n  index: Infinity,\n  handler: function releaseGesture(ev, inst) {\n    if (ev.eventType == EVENT_RELEASE) {\n      inst.trigger(this.name, ev);\n    }\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * triggers swipe events when the end velocity is above the threshold\n * for best usage, set `preventDefault` (on the drag gesture) to `true`\n * ````\n *  GestureDetectortime.on(\"dragleft swipeleft\", function(ev) {\n *    console.log(ev);\n *    ev.gesture.preventDefault();\n *  });\n * ````\n *\n * @class Swipe\n * @static\n */\n/**\n * @event swipe\n * @param {Object} ev\n */\n/**\n * @event swipeleft\n * @param {Object} ev\n */\n/**\n * @event swiperight\n * @param {Object} ev\n */\n/**\n * @event swipeup\n * @param {Object} ev\n */\n/**\n * @event swipedown\n * @param {Object} ev\n */\nGestureDetector.gestures.Swipe = {\n  name: 'swipe',\n  index: 40,\n  defaults: {\n    /**\n     * @property swipeMinTouches\n     * @type {Number}\n     * @default 1\n     */\n    swipeMinTouches: 1,\n\n    /**\n     * @property swipeMaxTouches\n     * @type {Number}\n     * @default 1\n     */\n    swipeMaxTouches: 1,\n\n    /**\n     * horizontal swipe velocity\n     * @property swipeVelocityX\n     * @type {Number}\n     * @default 0.6\n     */\n    swipeVelocityX: 0.6,\n\n    /**\n     * vertical swipe velocity\n     * @property swipeVelocityY\n     * @type {Number}\n     * @default 0.6\n     */\n    swipeVelocityY: 0.6\n  },\n\n  handler: function swipeGesture(ev, inst) {\n    if (ev.eventType == EVENT_RELEASE) {\n      var touches = ev.touches.length,\n          options = inst.options;\n\n      // max touches\n      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {\n        return;\n      }\n\n      // when the distance we moved is too small we skip this gesture\n      // or we can be already in dragging\n      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {\n        // trigger swipe events\n        inst.trigger(this.name, ev);\n        inst.trigger(this.name + ev.direction, ev);\n      }\n    }\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * Single tap and a double tap on a place\n *\n * @class Tap\n * @static\n */\n/**\n * @event tap\n * @param {Object} ev\n */\n/**\n * @event doubletap\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function (name) {\n  var hasMoved = false;\n\n  function tapGesture(ev, inst) {\n    var options = inst.options,\n        current = Detection.current,\n        prev = Detection.previous,\n        sincePrev,\n        didDoubleTap;\n\n    switch (ev.eventType) {\n      case EVENT_START:\n        hasMoved = false;\n        break;\n\n      case EVENT_MOVE:\n        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;\n        break;\n\n      case EVENT_END:\n        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {\n          // previous gesture, for the double tap since these are two different gesture detections\n          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;\n          didDoubleTap = false;\n\n          // check if double tap\n          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {\n            inst.trigger('doubletap', ev);\n            didDoubleTap = true;\n          }\n\n          // do a single tap\n          if (!didDoubleTap || options.tapAlways) {\n            current.name = name;\n            inst.trigger(current.name, ev);\n          }\n        }\n        break;\n    }\n  }\n\n  GestureDetector.gestures.Tap = {\n    name: name,\n    index: 100,\n    handler: tapGesture,\n    defaults: {\n      /**\n       * max time of a tap, this is for the slow tappers\n       * @property tapMaxTime\n       * @type {Number}\n       * @default 250\n       */\n      tapMaxTime: 250,\n\n      /**\n       * max distance of movement of a tap, this is for the slow tappers\n       * @property tapMaxDistance\n       * @type {Number}\n       * @default 10\n       */\n      tapMaxDistance: 10,\n\n      /**\n       * always trigger the `tap` event, even while double-tapping\n       * @property tapAlways\n       * @type {Boolean}\n       * @default true\n       */\n      tapAlways: true,\n\n      /**\n       * max distance between two taps\n       * @property doubleTapDistance\n       * @type {Number}\n       * @default 20\n       */\n      doubleTapDistance: 20,\n\n      /**\n       * max time between two taps\n       * @property doubleTapInterval\n       * @type {Number}\n       * @default 300\n       */\n      doubleTapInterval: 300\n    }\n  };\n})('tap');\n\n/**\n * @module gestures\n */\n/**\n * when a touch is being touched at the page\n *\n * @class Touch\n * @static\n */\n/**\n * @event touch\n * @param {Object} ev\n */\nGestureDetector.gestures.Touch = {\n  name: 'touch',\n  index: -Infinity,\n  defaults: {\n    /**\n     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,\n     * but it improves gestures like transforming and dragging.\n     * be careful with using this, it can be very annoying for users to be stuck on the page\n     * @property preventDefault\n     * @type {Boolean}\n     * @default false\n     */\n    preventDefault: false,\n\n    /**\n     * disable mouse events, so only touch (or pen!) input triggers events\n     * @property preventMouse\n     * @type {Boolean}\n     * @default false\n     */\n    preventMouse: false\n  },\n  handler: function touchGesture(ev, inst) {\n    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {\n      ev.stopDetect();\n      return;\n    }\n\n    if (inst.options.preventDefault) {\n      ev.preventDefault();\n    }\n\n    if (ev.eventType == EVENT_TOUCH) {\n      inst.trigger('touch', ev);\n    }\n  }\n};\n\n/**\n * @module gestures\n */\n/**\n * User want to scale or rotate with 2 fingers\n * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the\n * `preventDefault` option.\n *\n * @class Transform\n * @static\n */\n/**\n * @event transform\n * @param {Object} ev\n */\n/**\n * @event transformstart\n * @param {Object} ev\n */\n/**\n * @event transformend\n * @param {Object} ev\n */\n/**\n * @event pinchin\n * @param {Object} ev\n */\n/**\n * @event pinchout\n * @param {Object} ev\n */\n/**\n * @event rotate\n * @param {Object} ev\n */\n\n/**\n * @param {String} name\n */\n(function (name) {\n  var triggered = false;\n\n  function transformGesture(ev, inst) {\n    switch (ev.eventType) {\n      case EVENT_START:\n        triggered = false;\n        break;\n\n      case EVENT_MOVE:\n        // at least multitouch\n        if (ev.touches.length < 2) {\n          return;\n        }\n\n        var scaleThreshold = Math.abs(1 - ev.scale);\n        var rotationThreshold = Math.abs(ev.rotation);\n\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {\n          return;\n        }\n\n        // we are transforming!\n        Detection.current.name = name;\n\n        // first time, trigger dragstart event\n        if (!triggered) {\n          inst.trigger(name + 'start', ev);\n          triggered = true;\n        }\n\n        inst.trigger(name, ev); // basic transform event\n\n        // trigger rotate event\n        if (rotationThreshold > inst.options.transformMinRotation) {\n          inst.trigger('rotate', ev);\n        }\n\n        // trigger pinch event\n        if (scaleThreshold > inst.options.transformMinScale) {\n          inst.trigger('pinch', ev);\n          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);\n        }\n        break;\n\n      case EVENT_RELEASE:\n        if (triggered && ev.changedLength < 2) {\n          inst.trigger(name + 'end', ev);\n          triggered = false;\n        }\n        break;\n    }\n  }\n\n  GestureDetector.gestures.Transform = {\n    name: name,\n    index: 45,\n    defaults: {\n      /**\n       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n       * @property transformMinScale\n       * @type {Number}\n       * @default 0.01\n       */\n      transformMinScale: 0.01,\n\n      /**\n       * rotation in degrees\n       * @property transformMinRotation\n       * @type {Number}\n       * @default 1\n       */\n      transformMinRotation: 1\n    },\n\n    handler: transformGesture\n  };\n})('transform');\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\nvar readyMap = new WeakMap();\nvar queueMap = new WeakMap();\n\nfunction isContentReady(element) {\n  if (element.childNodes.length > 0) {\n    setContentReady(element);\n  }\n  return readyMap.has(element);\n}\n\nfunction setContentReady(element) {\n  readyMap.set(element, true);\n}\n\nfunction addCallback(element, fn) {\n  if (!queueMap.has(element)) {\n    queueMap.set(element, []);\n  }\n  queueMap.get(element).push(fn);\n}\n\nfunction consumeQueue(element) {\n  var callbacks = queueMap.get(element, []) || [];\n  queueMap.delete(element);\n  callbacks.forEach(function (callback) {\n    return callback();\n  });\n}\n\nfunction contentReady(element) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n  addCallback(element, fn);\n\n  if (isContentReady(element)) {\n    consumeQueue(element);\n    return;\n  }\n\n  var observer = new MutationObserver(function (changes) {\n    setContentReady(element);\n    consumeQueue(element);\n  });\n  observer.observe(element, { childList: true, characterData: true });\n\n  // failback for elements has empty content.\n  setImmediate(function () {\n    setContentReady(element);\n    consumeQueue(element);\n  });\n}\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar ToastQueue = function () {\n  function ToastQueue() {\n    classCallCheck(this, ToastQueue);\n\n    this.queue = [];\n  }\n\n  createClass(ToastQueue, [{\n    key: \"add\",\n    value: function add(fn, promise) {\n      var _this = this;\n\n      this.queue.push(fn);\n\n      if (this.queue.length === 1) {\n        setImmediate(this.queue[0]);\n      }\n\n      promise.then(function () {\n        _this.queue.shift();\n\n        if (_this.queue.length > 0) {\n          setTimeout(_this.queue[0], 1000 / 30); // Apply some visual delay\n        }\n      });\n    }\n  }]);\n  return ToastQueue;\n}();\n\nvar ToastQueue$1 = new ToastQueue();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar _setAttributes = function _setAttributes(element, options) {\n  ['id', 'class', 'animation'].forEach(function (a) {\n    return options.hasOwnProperty(a) && element.setAttribute(a, options[a]);\n  });\n\n  if (options.modifier) {\n    util.addModifier(element, options.modifier);\n  }\n};\n\n/**\n * @object ons.notification\n * @category dialog\n * @tutorial vanilla/Reference/dialog\n * @description\n *   [en]\n *     Utility methods to create different kinds of notifications. There are three methods available:\n *\n *     * `ons.notification.alert()`\n *     * `ons.notification.confirm()`\n *     * `ons.notification.prompt()`\n *     * `ons.notification.toast()`\n *\n *     It will automatically display a Material Design dialog on Android devices.\n *   [/en]\n *   [ja]いくつかの種類のアラートダイアログを作成するためのユーティリティメソッドを収めたオブジェクトです。[/ja]\n * @example\n * ons.notification.alert('Hello, world!');\n *\n * ons.notification.confirm('Are you ready?')\n *   .then(\n *     function(answer) {\n *       if (answer === 1) {\n *         ons.notification.alert('Let\\'s go!');\n *       }\n *     }\n *   );\n *\n * ons.notification.prompt('How old are ?')\n *   .then(\n *     function(age) {\n *       ons.notification.alert('You are ' + age + ' years old.');\n *     }\n *   );\n */\nvar notification = {};\n\nnotification._createAlertDialog = function (options) {\n  // Prompt input string\n  var inputString = '';\n  if (options.isPrompt) {\n    inputString = '\\n      <input\\n        class=\"text-input text-input--underbar\"\\n        type=\"' + (options.inputType || 'text') + '\"\\n        placeholder=\"' + (options.placeholder || '') + '\"\\n        value=\"' + (options.defaultValue || '') + '\"\\n        style=\"width: 100%; margin-top: 10px;\"\\n      />\\n    ';\n  }\n\n  // Buttons string\n  var buttons = '';\n  options.buttonLabels.forEach(function (label, index) {\n    buttons += '\\n      <ons-alert-dialog-button\\n        class=\"\\n          ' + (index === options.primaryButtonIndex ? ' alert-dialog-button--primal' : '') + '\\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-button--rowfooter' : '') + '\\n        \" \\n        style=\"position: relative;\">\\n        ' + label + '\\n      </ons-alert-dialog-button>\\n    ';\n  });\n\n  // Dialog Element\n  var el = {};\n  var _destroyDialog = function _destroyDialog() {\n    if (el.dialog.onDialogCancel) {\n      el.dialog.removeEventListener('dialog-cancel', el.dialog.onDialogCancel);\n    }\n\n    Object.keys(el).forEach(function (key) {\n      return delete el[key];\n    });\n    el = null;\n\n    if (options.destroy instanceof Function) {\n      options.destroy();\n    }\n  };\n\n  el.dialog = document.createElement('ons-alert-dialog');\n  el.dialog.innerHTML = '\\n    <div class=\"alert-dialog-mask\"></div>\\n    <div class=\"alert-dialog\">\\n      <div class=\"alert-dialog-container\">\\n        <div class=\"alert-dialog-title\">\\n          ' + (options.title || '') + '\\n        </div>\\n        <div class=\"alert-dialog-content\">\\n          ' + (options.message || options.messageHTML) + '\\n          ' + inputString + '\\n        </div>\\n        <div class=\"\\n          alert-dialog-footer\\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-footer--rowfooter' : '') + '\\n        \">\\n          ' + buttons + '\\n        </div>\\n      </div>\\n    </div>\\n  ';\n  contentReady(el.dialog);\n\n  // Set attributes\n  _setAttributes(el.dialog, options);\n\n  var deferred = util.defer();\n\n  // Prompt events\n  if (options.isPrompt && options.submitOnEnter) {\n    el.input = el.dialog.querySelector('.text-input');\n    el.input.onkeypress = function (event) {\n      if (event.keyCode === 13) {\n        el.dialog.hide().then(function () {\n          if (el) {\n            var resolveValue = el.input.value;\n            _destroyDialog();\n            options.callback(resolveValue);\n            deferred.resolve(resolveValue);\n          }\n        });\n      }\n    };\n  }\n\n  // Button events\n  el.footer = el.dialog.querySelector('.alert-dialog-footer');\n  util.arrayFrom(el.dialog.querySelectorAll('.alert-dialog-button')).forEach(function (buttonElement, index) {\n    buttonElement.onclick = function () {\n      el.dialog.hide().then(function () {\n        if (el) {\n          var resolveValue = index;\n          if (options.isPrompt) {\n            resolveValue = index === options.primaryButtonIndex ? el.input.value : null;\n          }\n          el.dialog.remove();\n          _destroyDialog();\n          options.callback(resolveValue);\n          deferred.resolve(resolveValue);\n        }\n      });\n    };\n\n    el.footer.appendChild(buttonElement);\n  });\n\n  // Cancel events\n  if (options.cancelable) {\n    el.dialog.cancelable = true;\n    el.dialog.onDialogCancel = function () {\n      setImmediate(function () {\n        el.dialog.remove();\n        _destroyDialog();\n      });\n      var resolveValue = options.isPrompt ? null : -1;\n      options.callback(resolveValue);\n      deferred.resolve(resolveValue);\n    };\n    el.dialog.addEventListener('dialog-cancel', el.dialog.onDialogCancel, false);\n  }\n\n  // Show dialog\n  document.body.appendChild(el.dialog);\n  options.compile(el.dialog);\n  setImmediate(function () {\n    el.dialog.show().then(function () {\n      if (el.input && options.isPrompt && options.autofocus) {\n        el.input.focus();\n      }\n    });\n  });\n\n  return deferred.promise;\n};\n\nvar _normalizeArguments = function _normalizeArguments(message) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var defaults$$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  options = _extends({}, options);\n  typeof message === 'string' ? options.message = message : options = message;\n  if (!options.message && !options.messageHTML) {\n    throw new Error('Notifications must contain a message.');\n  }\n\n  if (options.hasOwnProperty('buttonLabels') || options.hasOwnProperty('buttonLabel')) {\n    options.buttonLabels = options.buttonLabels || options.buttonLabel;\n    if (!Array.isArray(options.buttonLabels)) {\n      options.buttonLabels = [options.buttonLabels || ''];\n    }\n  }\n\n  return util.extend({\n    compile: function compile(param) {\n      return param;\n    },\n    callback: function callback(param) {\n      return param;\n    },\n    animation: 'default',\n    cancelable: false,\n    primaryButtonIndex: (options.buttonLabels || defaults$$1.buttonLabels || []).length - 1\n  }, defaults$$1, options);\n};\n\n/**\n * @method alert\n * @signature alert(message [, options] | options)\n * @return {Promise}\n *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]\n *   [ja][/ja]\n * @param {String} message\n *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]\n *   [ja][/ja]\n * @param {Object} options\n *   [en]Parameter object.[/en]\n *   [ja]オプションを指定するオブジェクトです。[/ja]\n * @param {String} [options.message]\n *   [en]Notification message.[/en]\n *   [ja]アラートダイアログに表示する文字列を指定します。[/ja]\n * @param {String} [options.messageHTML]\n *   [en]Notification message in HTML.[/en]\n *   [ja]アラートダイアログに表示するHTMLを指定します。[/ja]\n * @param {String | Array} [options.buttonLabels]\n *   [en]Labels for the buttons. Default is `\"OK\"`.[/en]\n *   [ja]確認ボタンのラベルを指定します。\"OK\"がデフォルトです。[/ja]\n * @param {Number} [options.primaryButtonIndex]\n *   [en]Index of primary button. Default is the last one.[/en]\n *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]\n * @param {Boolean} [options.cancelable]\n *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]\n *   [ja]ダイアログがキャンセル可能かどうかを指定します。[/ja]\n * @param {String} [options.animation]\n *   [en]Animation name. Available animations are `none` and `fade`. Default is `fade`.[/en]\n *   [ja]アラートダイアログを表示する際のアニメーション名を指定します。\"none\", \"fade\"のいずれかを指定できます。[/ja]\n * @param {String} [options.id]\n *   [en]The `<ons-alert-dialog>` element's ID.[/en]\n *   [ja]ons-alert-dialog要素のID。[/ja]\n * @param {String} [options.class]\n *   [en]The `<ons-alert-dialog>` element's class.[/en]\n *   [ja]ons-alert-dialog要素のclass。[/ja]\n * @param {String} [options.title]\n *   [en]Dialog title. Default is `\"Alert\"`.[/en]\n *   [ja]アラートダイアログの上部に表示するタイトルを指定します。\"Alert\"がデフォルトです。[/ja]\n * @param {String} [options.modifier]\n *   [en]Modifier for the dialog.[/en]\n *   [ja]アラートダイアログのmodifier属性の値を指定します。[/ja]\n * @param {Function} [options.callback]\n *   [en]Function that executes after dialog has been closed.[/en]\n *   [ja]アラートダイアログが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]\n * @description\n *   [en]\n *     Display an alert dialog to show the user a message.\n *\n *     The content of the message can be either simple text or HTML.\n *\n *     It can be called in the following ways:\n *\n *     ```\n *     ons.notification.alert(message, options);\n *     ons.notification.alert(options);\n *     ```\n *\n *     Must specify either `message` or `messageHTML`.\n *   [/en]\n *   [ja]\n *     ユーザーへメッセージを見せるためのアラートダイアログを表示します。\n *     表示するメッセージは、テキストかもしくはHTMLを指定できます。\n *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。\n *   [/ja]\n */\nnotification.alert = function (message, options) {\n  options = _normalizeArguments(message, options, {\n    buttonLabels: ['OK'],\n    title: 'Alert'\n  });\n\n  return notification._createAlertDialog(options);\n};\n\n/**\n * @method confirm\n * @signature confirm(message [, options] | options)\n * @return {Promise}\n *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]\n *   [ja][/ja]\n * @param {String} message\n *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]\n *   [ja][/ja]\n * @param {Object} options\n *   [en]Parameter object.[/en]\n * @param {Array} [options.buttonLabels]\n *   [en]Labels for the buttons. Default is `[\"Cancel\", \"OK\"]`.[/en]\n *   [ja]ボタンのラベルの配列を指定します。[\"Cancel\", \"OK\"]がデフォルトです。[/ja]\n * @param {Number} [options.primaryButtonIndex]\n *   [en]Index of primary button. Default is the last one.[/en]\n *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]\n * @description\n *   [en]\n *     Display a dialog to ask the user for confirmation. Extends `alert()` parameters.\n *     The default button labels are `\"Cancel\"` and `\"OK\"` but they can be customized.\n *\n *     It can be called in the following ways:\n *\n *     ```\n *     ons.notification.confirm(message, options);\n *     ons.notification.confirm(options);\n *     ```\n *\n *     Must specify either `message` or `messageHTML`.\n *   [/en]\n *   [ja]\n *     ユーザに確認を促すダイアログを表示します。\n *     デオルとのボタンラベルは、\"Cancel\"と\"OK\"ですが、これはこのメソッドの引数でカスタマイズできます。\n *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。\n *   [/ja]\n */\nnotification.confirm = function (message, options) {\n  options = _normalizeArguments(message, options, {\n    buttonLabels: ['Cancel', 'OK'],\n    title: 'Confirm'\n  });\n\n  return notification._createAlertDialog(options);\n};\n\n/**\n * @method prompt\n * @signature prompt(message [, options] | options)\n * @param {String} message\n *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]\n *   [ja][/ja]\n * @return {Promise}\n *   [en]Will resolve to the input value when the dialog is closed or `null` when canceled.[/en]\n *   [ja][/ja]\n * @param {Object} options\n *   [en]Parameter object.[/en]\n *   [ja]オプションを指定するオブジェクトです。[/ja]\n * @param {String | Array} [options.buttonLabels]\n *   [en]Labels for the buttons. Default is `\"OK\"`.[/en]\n *   [ja]確認ボタンのラベルを指定します。\"OK\"がデフォルトです。[/ja]\n * @param {Number} [options.primaryButtonIndex]\n *   [en]Index of primary button. Default is the last one.[/en]\n *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]\n * @param {String} [options.placeholder]\n *   [en]Placeholder for the text input.[/en]\n *   [ja]テキスト欄のプレースホルダに表示するテキストを指定します。[/ja]\n * @param {String} [options.defaultValue]\n *   [en]Default value for the text input.[/en]\n *   [ja]テキスト欄のデフォルトの値を指定します。[/ja]\n * @param {String} [options.inputType]\n *   [en]Type of the input element (`password`, `date`...). Default is `text`.[/en]\n *   [ja][/ja]\n * @param {Boolean} [options.autofocus]\n *   [en]Autofocus the input element. Default is `true`. In Cordova, `KeyboardDisplayRequiresUserAction` in `config.xml` must be `false` to activate this feature.[/en]\n *   [ja]input要素に自動的にフォーカスするかどうかを指定します。デフォルトはtrueです。Cordova環境では、この機能を有効にするためには `config.xml` で `KeyboardDisplayRequiresUserAction` を `false` に設定する必要があります。[/ja]\n * @param {Boolean} [options.submitOnEnter]\n *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]\n *   [ja]Enterが押された際にそのformをsubmitするかどうかを指定します。デフォルトはtrueです。[/ja]\n * @description\n *   [en]\n *     Display a dialog with a prompt to ask the user a question. Extends `alert()` parameters.\n *\n *     It can be called in the following ways:\n *\n *     ```\n *     ons.notification.prompt(message, options);\n *     ons.notification.prompt(options);\n *     ```\n *\n *     Must specify either `message` or `messageHTML`.\n *   [/en]\n *   [ja]\n *     ユーザーに入力を促すダイアログを表示します。\n *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。\n *   [/ja]\n */\nnotification.prompt = function (message, options) {\n  options = _normalizeArguments(message, options, {\n    buttonLabels: ['OK'],\n    title: 'Alert',\n    isPrompt: true,\n    autofocus: true,\n    submitOnEnter: true\n  });\n\n  return notification._createAlertDialog(options);\n};\n\n/**\n * @method toast\n * @signature toast(message [, options] | options)\n * @return {Promise}\n *   [en]Will resolve when the toast is hidden.[/en]\n *   [ja][/ja]\n * @param {String} message\n *   [en]Toast message. This argument is optional but if it's not defined then `options.message` must be defined instead.[/en]\n *   [ja][/ja]\n * @param {Object} options\n *   [en]Parameter object.[/en]\n *   [ja]オプションを指定するオブジェクトです。[/ja]\n * @param {String} [options.message]\n *   [en]Notification message.[/en]\n *   [ja]トーストに表示する文字列を指定します。[/ja]\n * @param {String} [options.buttonLabel]\n *   [en]Label for the button.[/en]\n *   [ja]確認ボタンのラベルを指定します。[/ja]\n * @param {String} [options.animation]\n *   [en]Animation name. Available animations are `none`, `fade`, `ascend`, `lift` and `fall`. Default is `ascend` for Android and `lift` for iOS.[/en]\n *   [ja]トーストを表示する際のアニメーション名を指定します。\"none\", \"fade\", \"ascend\", \"lift\", \"fall\"のいずれかを指定できます。[/ja]\n * @param {Number} [options.timeout]\n *   [en]Number of miliseconds where the toast is visible before hiding automatically.[/en]\n *   [ja][/ja]\n * @param {Boolean} [options.force]\n *   [en]If `true`, the toast skips the notification queue and is shown immediately. Defaults to `false`.[/en]\n *   [ja][/ja]\n * @param {String} [options.id]\n *   [en]The `<ons-toast>` element's ID.[/en]\n *   [ja]ons-toast要素のID。[/ja]\n * @param {String} [options.class]\n *   [en]The `<ons-toast>` element's class.[/en]\n *   [ja]ons-toast要素のclass。[/ja]\n * @param {String} [options.modifier]\n *   [en]Modifier for the element.[/en]\n *   [ja]トーストのmodifier属性の値を指定します。[/ja]\n * @param {Function} [options.callback]\n *   [en]Function that executes after toast has been hidden.[/en]\n *   [ja]トーストが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]\n * @description\n *   [en]\n *     Display a simple notification toast with an optional button that can be used for simple actions.\n *\n *     It can be called in the following ways:\n *\n *     ```\n *     ons.notification.toast(message, options);\n *     ons.notification.toast(options);\n *     ```\n *   [/en]\n *   [ja][/ja]\n */\nnotification.toast = function (message, options) {\n  options = _normalizeArguments(message, options, {\n    timeout: 0,\n    force: false\n  });\n\n  var toast = util.createElement('\\n    <ons-toast>\\n      ' + options.message + '\\n      ' + (options.buttonLabels ? '<button>' + options.buttonLabels[0] + '</button>' : '') + '\\n    </ons-toast>\\n  ');\n\n  _setAttributes(toast, options);\n\n  var deferred = util.defer();\n  var resolve = function resolve(value) {\n    if (toast) {\n      toast.hide().then(function () {\n        if (toast) {\n          toast.remove();\n          toast = null;\n          options.callback(value);\n          deferred.resolve(value);\n        }\n      });\n    }\n  };\n\n  if (options.buttonLabels) {\n    util.findChild(toast._toast, 'button').onclick = function () {\n      return resolve(0);\n    };\n  }\n\n  document.body.appendChild(toast);\n  options.compile(toast);\n\n  var show = function show() {\n    toast.parentElement && toast.show(options).then(function () {\n      if (options.timeout) {\n        setTimeout(function () {\n          return resolve(-1);\n        }, options.timeout);\n      }\n    });\n  };\n\n  options.force ? show() : ToastQueue$1.add(show, deferred.promise);\n\n  return deferred.promise;\n};\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n// Validate parameters\nvar checkOptions = function checkOptions(options) {\n  if (!Object.hasOwnProperty.call(options, 'buttons') || !(options.buttons instanceof Array)) {\n    throw new Error('\"options.buttons\" must be an instance of Array.');\n  }\n  if (Object.hasOwnProperty.call(options, 'callback') && !(options.callback instanceof Function)) {\n    throw new Error('\"options.callback\" must be an instance of Function.');\n  }\n  if (Object.hasOwnProperty.call(options, 'compile') && !(options.compile instanceof Function)) {\n    throw new Error('\"options.compile\" must be an instance of Function.');\n  }\n  if (Object.hasOwnProperty.call(options, 'destroy') && !(options.destroy instanceof Function)) {\n    throw new Error('\"options.destroy\" must be an instance of Function.');\n  }\n};\n\n// Action Sheet\nvar actionSheet = (function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  checkOptions(options);\n\n  // Main component\n  var actionSheet = util.createElement('\\n    <ons-action-sheet\\n      ' + (options.title ? 'title=\"' + options.title + '\"' : '') + '\\n      ' + (options.cancelable ? 'cancelable' : '') + '\\n      ' + (options.modifier ? 'modifier=\"' + options.modifier + '\"' : '') + '\\n      ' + (options.maskColor ? 'mask-color=\"' + options.maskColor + '\"' : '') + '\\n      ' + (options.id ? 'id=\"' + options.id + '\"' : '') + '\\n      ' + (options.class ? 'class=\"' + options.class + '\"' : '') + '\\n    >\\n      <div class=\"action-sheet\"></div>\\n    </ons-action-sheet>\\n  ');\n\n  // Resolve action and clean up\n  var deferred = util.defer();\n  var resolver = function resolver(event) {\n    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n    if (actionSheet) {\n      options.destroy && options.destroy(actionSheet);\n\n      actionSheet.removeEventListener('dialog-cancel', resolver, false);\n      actionSheet.remove();\n      actionSheet = null;\n\n      options.callback && options.callback(index);\n      deferred.resolve(index);\n    }\n  };\n\n  // Link cancel handler\n  actionSheet.addEventListener('dialog-cancel', resolver, false);\n\n  // Create buttons and link action handler\n  var buttons = document.createDocumentFragment();\n  options.buttons.forEach(function (item, index) {\n    var buttonOptions = typeof item === 'string' ? { label: item } : _extends({}, item);\n    if (options.destructive === index) {\n      buttonOptions.modifier = (buttonOptions.modifier || '') + ' destructive';\n    }\n\n    var button = util.createElement('\\n      <ons-action-sheet-button\\n        ' + (buttonOptions.icon ? 'icon=\"' + buttonOptions.icon + '\"' : '') + '\\n        ' + (buttonOptions.modifier ? 'modifier=\"' + buttonOptions.modifier + '\"' : '') + '\\n      >\\n        ' + buttonOptions.label + '\\n      </ons-action-sheet-button>\\n    ');\n\n    button.onclick = function (event) {\n      return actionSheet.hide().then(function () {\n        return resolver(event, index);\n      });\n    };\n    buttons.appendChild(button);\n  });\n\n  // Finish component and attach\n  util.findChild(actionSheet, '.action-sheet').appendChild(buttons);\n  document.body.appendChild(actionSheet);\n  options.compile && options.compile(el.dialog);\n\n  // Show\n  setImmediate(function () {\n    return actionSheet.show({\n      animation: options.animation,\n      animationOptions: options.animationOptions\n    });\n  });\n\n  return deferred.promise;\n});\n\n/**\n * MicroEvent - to make any js object an event emitter (server or browser)\n *\n * - pure javascript - server compatible, browser compatible\n * - dont rely on the browser doms\n * - super simple - you get it immediately, no mystery, no magic involved\n *\n * - create a MicroEventDebug with goodies to debug\n *   - make it safer to use\n*/\n\n/** NOTE: This library is customized for Onsen UI. */\n\nvar MicroEvent = function MicroEvent() {};\nMicroEvent.prototype = {\n  on: function on(event, fct) {\n    this._events = this._events || {};\n    this._events[event] = this._events[event] || [];\n    this._events[event].push(fct);\n  },\n  once: function once(event, fct) {\n    var self = this;\n    var wrapper = function wrapper() {\n      self.off(event, wrapper);\n      return fct.apply(null, arguments);\n    };\n    this.on(event, wrapper);\n  },\n  off: function off(event, fct) {\n    this._events = this._events || {};\n    if (event in this._events === false) {\n      return;\n    }\n\n    this._events[event] = this._events[event].filter(function (_fct) {\n      if (fct) {\n        return fct !== _fct;\n      } else {\n        return false;\n      }\n    });\n  },\n  emit: function emit(event /* , args... */) {\n    this._events = this._events || {};\n    if (event in this._events === false) {\n      return;\n    }\n    for (var i = 0; i < this._events[event].length; i++) {\n      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));\n    }\n  }\n};\n\n/**\n * mixin will delegate all MicroEvent.js function in the destination object\n *\n * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent\n *\n * @param {Object} the object which will support MicroEvent\n*/\nMicroEvent.mixin = function (destObject) {\n  var props = ['on', 'once', 'off', 'emit'];\n  for (var i = 0; i < props.length; i++) {\n    if (typeof destObject === 'function') {\n      destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];\n    } else {\n      destObject[props[i]] = MicroEvent.prototype[props[i]];\n    }\n  }\n};\n\nwindow.MicroEvent = MicroEvent;\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar create = function create() {\n\n  /**\n   * @object ons.orientation\n   * @category util\n   * @description\n   *   [en]Utility methods for orientation detection.[/en]\n   *   [ja]画面のオリエンテーション検知のためのユーティリティメソッドを収めているオブジェクトです。[/ja]\n   */\n  var obj = {\n    /**\n     * @event change\n     * @description\n     *   [en]Fired when the device orientation changes.[/en]\n     *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]\n     * @param {Object} event\n     *   [en]Event object.[/en]\n     *   [ja]イベントオブジェクトです。[/ja]\n     * @param {Boolean} event.isPortrait\n     *   [en]Will be true if the current orientation is portrait mode.[/en]\n     *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]\n     */\n\n    /**\n     * @method on\n     * @signature on(eventName, listener)\n     * @description\n     *   [en]Add an event listener.[/en]\n     *   [ja]イベントリスナーを追加します。[/ja]\n     * @param {String} eventName\n     *   [en]Name of the event.[/en]\n     *   [ja]イベント名を指定します。[/ja]\n     * @param {Function} listener\n     *   [en]Function to execute when the event is triggered.[/en]\n     *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]\n     */\n\n    /**\n     * @method once\n     * @signature once(eventName, listener)\n     * @description\n     *  [en]Add an event listener that's only triggered once.[/en]\n     *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]\n     * @param {String} eventName\n     *   [en]Name of the event.[/en]\n     *   [ja]イベント名を指定します。[/ja]\n     * @param {Function} listener\n     *   [en]Function to execute when the event is triggered.[/en]\n     *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]\n     */\n\n    /**\n     * @method off\n     * @signature off(eventName, [listener])\n     * @description\n     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]\n     *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]\n     * @param {String} eventName\n     *   [en]Name of the event.[/en]\n     *   [ja]イベント名を指定します。[/ja]\n     * @param {Function} listener\n     *   [en]Function to execute when the event is triggered.[/en]\n     *   [ja]削除するイベントリスナーを指定します。[/ja]\n     */\n\n    // actual implementation to detect if whether current screen is portrait or not\n    _isPortrait: false,\n\n    /**\n     * @method isPortrait\n     * @signature isPortrait()\n     * @return {Boolean}\n     *   [en]Will be true if the current orientation is portrait mode.[/en]\n     *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]\n     * @description\n     *   [en]Returns whether the current screen orientation is portrait or not.[/en]\n     *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]\n     */\n    isPortrait: function isPortrait() {\n      return this._isPortrait();\n    },\n\n    /**\n     * @method isLandscape\n     * @signature isLandscape()\n     * @return {Boolean}\n     *   [en]Will be true if the current orientation is landscape mode.[/en]\n     *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]\n     * @description\n     *   [en]Returns whether the current screen orientation is landscape or not.[/en]\n     *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]\n     */\n    isLandscape: function isLandscape() {\n      return !this.isPortrait();\n    },\n\n    _init: function _init() {\n      document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);\n\n      if ('orientation' in window) {\n        window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);\n      } else {\n        window.addEventListener('resize', this._onResize.bind(this), false);\n      }\n\n      this._isPortrait = function () {\n        return window.innerHeight > window.innerWidth;\n      };\n\n      return this;\n    },\n\n    _onDOMContentLoaded: function _onDOMContentLoaded() {\n      this._installIsPortraitImplementation();\n      this.emit('change', { isPortrait: this.isPortrait() });\n    },\n\n    _installIsPortraitImplementation: function _installIsPortraitImplementation() {\n      var isPortrait = window.innerWidth < window.innerHeight;\n\n      if (!('orientation' in window)) {\n        this._isPortrait = function () {\n          return window.innerHeight > window.innerWidth;\n        };\n      } else if (window.orientation % 180 === 0) {\n        this._isPortrait = function () {\n          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;\n        };\n      } else {\n        this._isPortrait = function () {\n          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;\n        };\n      }\n    },\n\n    _onOrientationChange: function _onOrientationChange() {\n      var _this = this;\n\n      var isPortrait = this._isPortrait();\n\n      // Wait for the dimensions to change because\n      // of Android inconsistency.\n      var nIter = 0;\n      var interval = setInterval(function () {\n        nIter++;\n\n        var w = window.innerWidth;\n        var h = window.innerHeight;\n\n        if (isPortrait && w <= h || !isPortrait && w >= h) {\n          _this.emit('change', { isPortrait: isPortrait });\n          clearInterval(interval);\n        } else if (nIter === 50) {\n          _this.emit('change', { isPortrait: isPortrait });\n          clearInterval(interval);\n        }\n      }, 20);\n    },\n\n    // Run on not mobile browser.\n    _onResize: function _onResize() {\n      this.emit('change', { isPortrait: this.isPortrait() });\n    }\n  };\n\n  MicroEvent.mixin(obj);\n\n  return obj;\n};\n\nvar orientation = create()._init();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * @object ons.modifier\n * @category visual\n * @description\n *   [en]\n *     Utility methods to change modifier attributes of Onsen UI elements..\n *   [/en]\n *   [ja][/ja]\n * @example\n * ons.modifier.add(myOnsInputElement, 'underbar');\n * ons.modifier.toggle(myOnsToastElement, 'custom-modifier');\n *\n */\nvar modifier = {\n  /**\n   * @method add\n   * @signature add(element, modifier [, modifier])\n   * @description\n   *   [en]Add the specified modifiers to the element if they are not already included.[/en]\n   *   [ja][/ja]\n   * @param {HTMLElement} element\n   *   [en]Target element.[/en]\n   *   [ja][/ja]\n   * @param {String} modifier\n   *   [en]Name of the modifier.[/en]\n   *   [ja][/ja]\n   */\n  add: function add(element) {\n    for (var _len = arguments.length, modifiers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      modifiers[_key - 1] = arguments[_key];\n    }\n\n    return modifiers.forEach(function (modifier) {\n      return util.addModifier(element, modifier);\n    });\n  },\n  /**\n   * @method remove\n   * @signature remove(element, modifier [, modifier])\n   * @description\n   *   [en]Remove the specified modifiers from the element if they are included.[/en]\n   *   [ja][/ja]\n   * @param {HTMLElement} element\n   *   [en]Target element.[/en]\n   *   [ja][/ja]\n   * @param {String} modifier\n   *   [en]Name of the modifier.[/en]\n   *   [ja][/ja]\n   */\n  remove: function remove(element) {\n    for (var _len2 = arguments.length, modifiers = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      modifiers[_key2 - 1] = arguments[_key2];\n    }\n\n    return modifiers.forEach(function (modifier) {\n      return util.removeModifier(element, modifier);\n    });\n  },\n  /**\n   * @method contains\n   * @signature contains(element, modifier)\n   * @description\n   *   [en]Check whether the specified modifier is included in the element.[/en]\n   *   [ja][/ja]\n   * @param {HTMLElement} element\n   *   [en]Target element.[/en]\n   *   [ja][/ja]\n   * @param {String} modifier\n   *   [en]Name of the modifier.[/en]\n   *   [ja][/ja]\n   * @return {Boolean}\n   *   [en]`true` when the specified modifier is found in the element's `modifier` attribute. `false` otherwise.[/en]\n   *   [ja][/ja]\n   */\n  contains: util.hasModifier,\n  /**\n   * @method toggle\n   * @signature toggle(element, modifier [, force])\n   * @description\n   *   [en]Toggle the specified modifier.[/en]\n   *   [ja][/ja]\n   * @param {HTMLElement} element\n   *   [en]Target element.[/en]\n   *   [ja][/ja]\n   * @param {String} modifier\n   *   [en]Name of the modifier.[/en]\n   *   [ja][/ja]\n   * @param {String} force\n   *   [en]If it evaluates to true, add specified modifier value, and if it evaluates to false, remove it.[/en]\n   *   [ja][/ja]\n   */\n  toggle: util.toggleModifier\n};\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar softwareKeyboard = new MicroEvent();\nsoftwareKeyboard._visible = false;\n\nvar onShow = function onShow() {\n  softwareKeyboard._visible = true;\n  softwareKeyboard.emit('show');\n};\n\nvar onHide = function onHide() {\n  softwareKeyboard._visible = false;\n  softwareKeyboard.emit('hide');\n};\n\nvar bindEvents = function bindEvents() {\n  if (typeof Keyboard !== 'undefined') {\n    // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md\n    Keyboard.onshow = onShow;\n    Keyboard.onhide = onHide;\n    softwareKeyboard.emit('init', { visible: Keyboard.isVisible });\n\n    return true;\n  } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {\n    // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md\n    window.addEventListener('native.keyboardshow', onShow);\n    window.addEventListener('native.keyboardhide', onHide);\n    softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });\n\n    return true;\n  }\n\n  return false;\n};\n\nvar noPluginError = function noPluginError() {\n  util.warn('ons-keyboard: Cordova Keyboard plugin is not present.');\n};\n\ndocument.addEventListener('deviceready', function () {\n  if (!bindEvents()) {\n    if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {\n      noPluginError();\n    }\n\n    softwareKeyboard.on = noPluginError;\n  }\n});\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar generateId = function () {\n  var i = 0;\n  return function () {\n    return i++;\n  };\n}();\n\n/**\n * Door locking system.\n *\n * @param {Object} [options]\n * @param {Function} [options.log]\n */\n\nvar DoorLock = function () {\n  function DoorLock() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, DoorLock);\n\n    this._lockList = [];\n    this._waitList = [];\n    this._log = options.log || function () {};\n  }\n\n  /**\n   * Register a lock.\n   *\n   * @return {Function} Callback for unlocking.\n   */\n\n\n  createClass(DoorLock, [{\n    key: 'lock',\n    value: function lock() {\n      var _this = this;\n\n      var unlock = function unlock() {\n        _this._unlock(unlock);\n      };\n      unlock.id = generateId();\n      this._lockList.push(unlock);\n      this._log('lock: ' + unlock.id);\n\n      return unlock;\n    }\n  }, {\n    key: '_unlock',\n    value: function _unlock(fn) {\n      var index = this._lockList.indexOf(fn);\n      if (index === -1) {\n        throw new Error('This function is not registered in the lock list.');\n      }\n\n      this._lockList.splice(index, 1);\n      this._log('unlock: ' + fn.id);\n\n      this._tryToFreeWaitList();\n    }\n  }, {\n    key: '_tryToFreeWaitList',\n    value: function _tryToFreeWaitList() {\n      while (!this.isLocked() && this._waitList.length > 0) {\n        this._waitList.shift()();\n      }\n    }\n\n    /**\n     * Register a callback for waiting unlocked door.\n     *\n     * @params {Function} callback Callback on unlocking the door completely.\n     */\n\n  }, {\n    key: 'waitUnlock',\n    value: function waitUnlock(callback) {\n      if (!(callback instanceof Function)) {\n        throw new Error('The callback param must be a function.');\n      }\n\n      if (this.isLocked()) {\n        this._waitList.push(callback);\n      } else {\n        callback();\n      }\n    }\n\n    /**\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLocked',\n    value: function isLocked() {\n      return this._lockList.length > 0;\n    }\n  }]);\n  return DoorLock;\n}();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n// Default implementation for global PageLoader.\nfunction loadPage(_ref, done) {\n  var page = _ref.page,\n      parent = _ref.parent,\n      _ref$params = _ref.params;\n\n  internal$1.getPageHTMLAsync(page).then(function (html) {\n    var pageElement = util.createElement(html);\n    parent.appendChild(pageElement);\n\n    done(pageElement);\n  });\n}\n\nfunction unloadPage(element) {\n  if (element._destroy instanceof Function) {\n    element._destroy();\n  } else {\n    element.remove();\n  }\n}\n\nvar PageLoader = function () {\n  /**\n   * @param {Function} [fn] Returns an object that has \"element\" property and \"unload\" function.\n   */\n  function PageLoader(loader, unloader) {\n    classCallCheck(this, PageLoader);\n\n    this._loader = loader instanceof Function ? loader : loadPage;\n    this._unloader = unloader instanceof Function ? unloader : unloadPage;\n  }\n\n  /**\n   * Set internal loader implementation.\n   */\n\n\n  createClass(PageLoader, [{\n    key: 'load',\n\n\n    /**\n     * @param {any} options.page\n     * @param {Element} options.parent A location to load page.\n     * @param {Object} [options.params] Extra parameters for ons-page.\n     * @param {Function} done Take an object that has \"element\" property and \"unload\" function.\n     */\n    value: function load(_ref2, done) {\n      var page = _ref2.page,\n          parent = _ref2.parent,\n          _ref2$params = _ref2.params,\n          params = _ref2$params === undefined ? {} : _ref2$params;\n\n      this._loader({ page: page, parent: parent, params: params }, function (pageElement) {\n        if (!(pageElement instanceof Element)) {\n          throw Error('pageElement must be an instance of Element.');\n        }\n\n        done(pageElement);\n      });\n    }\n  }, {\n    key: 'unload',\n    value: function unload(pageElement) {\n      if (!(pageElement instanceof Element)) {\n        throw Error('pageElement must be an instance of Element.');\n      }\n\n      this._unloader(pageElement);\n    }\n  }, {\n    key: 'internalLoader',\n    set: function set$$1(fn) {\n      if (!(fn instanceof Function)) {\n        throw Error('First parameter must be an instance of Function');\n      }\n      this._loader = fn;\n    },\n    get: function get$$1() {\n      return this._loader;\n    }\n  }]);\n  return PageLoader;\n}();\n\nvar defaultPageLoader = new PageLoader();\n\nvar instantPageLoader = new PageLoader(function (_ref3, done) {\n  var page = _ref3.page,\n      parent = _ref3.parent,\n      _ref3$params = _ref3.params;\n\n  var element = util.createElement(page.trim());\n  parent.appendChild(element);\n\n  done(element);\n}, unloadPage);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * @object ons\n * @category util\n * @description\n *   [ja]Onsen UIで利用できるグローバルなオブジェクトです。[/ja]\n *   [en]A global object that's used in Onsen UI. [/en]\n */\nvar ons$1 = {\n  animit: Animit,\n  defaultPageLoader: defaultPageLoader,\n  elements: {},\n  GestureDetector: GestureDetector,\n  modifier: modifier,\n  notification: notification,\n  orientation: orientation,\n  pageAttributeExpression: pageAttributeExpression,\n  PageLoader: PageLoader,\n  platform: platform,\n  softwareKeyboard: softwareKeyboard,\n  _autoStyle: autoStyle,\n  _internal: internal$1,\n  _readyLock: new DoorLock(),\n  _util: util\n};\n\nons$1.platform.select((window.location.search.match(/platform=([\\w-]+)/) || [])[1]);\n\nwaitDeviceReady();\n\n/**\n * @method isReady\n * @signature isReady()\n * @return {Boolean}\n *   [en]Will be true if Onsen UI is initialized.[/en]\n *   [ja]初期化されているかどうかを返します。[/ja]\n * @description\n *   [en]Returns true if Onsen UI is initialized.[/en]\n *   [ja]Onsen UIがすでに初期化されているかどうかを返すメソッドです。[/ja]\n */\nons$1.isReady = function () {\n  return !ons$1._readyLock.isLocked();\n};\n\n/**\n * @method isWebView\n * @signature isWebView()\n * @return {Boolean}\n *   [en]Will be true if the app is running in Cordova.[/en]\n *   [ja]Cordovaで実行されている場合にtrueになります。[/ja]\n * @description\n *   [en]Returns true if running inside Cordova.[/en]\n *   [ja]Cordovaで実行されているかどうかを返すメソッドです。[/ja]\n */\nons$1.isWebView = ons$1.platform.isWebView;\n\n/**\n * @method ready\n * @signature ready(callback)\n * @description\n *   [ja]アプリの初期化に利用するメソッドです。渡された関数は、Onsen UIの初期化が終了している時点で必ず呼ばれます。[/ja]\n *   [en]Method used to wait for app initialization. Waits for `DOMContentLoaded` and `deviceready`, when necessary, before executing the callback.[/en]\n * @param {Function} callback\n *   [en]Function that executes after Onsen UI has been initialized.[/en]\n *   [ja]Onsen UIが初期化が完了した後に呼び出される関数オブジェクトを指定します。[/ja]\n */\nons$1.ready = function (callback) {\n  if (ons$1.isReady()) {\n    callback();\n  } else {\n    ons$1._readyLock.waitUnlock(callback);\n  }\n};\n\n/**\n * @method setDefaultDeviceBackButtonListener\n * @signature setDefaultDeviceBackButtonListener(listener)\n * @param {Function} listener\n *   [en]Function that executes when device back button is pressed. Must be called on `ons.ready`.[/en]\n *   [ja]デバイスのバックボタンが押された時に実行される関数オブジェクトを指定します。[/ja]\n * @description\n *   [en]Set default handler for device back button.[/en]\n *   [ja]デバイスのバックボタンのためのデフォルトのハンドラを設定します。[/ja]\n */\nons$1.setDefaultDeviceBackButtonListener = function (listener) {\n  if (!ons$1.isReady()) {\n    throw new Error('This method must be called after ons.isReady() is true.');\n  }\n  ons$1._defaultDeviceBackButtonHandler.setListener(listener);\n};\n\n/**\n * @method disableDeviceBackButtonHandler\n * @signature disableDeviceBackButtonHandler()\n * @description\n * [en]Disable device back button event handler. Must be called on `ons.ready`.[/en]\n * [ja]デバイスのバックボタンのイベントを受け付けないようにします。[/ja]\n */\nons$1.disableDeviceBackButtonHandler = function () {\n  if (!ons$1.isReady()) {\n    throw new Error('This method must be called after ons.isReady() is true.');\n  }\n  internal$1.dbbDispatcher.disable();\n};\n\n/**\n * @method enableDeviceBackButtonHandler\n * @signature enableDeviceBackButtonHandler()\n * @description\n * [en]Enable device back button event handler. Must be called on `ons.ready`.[/en]\n * [ja]デバイスのバックボタンのイベントを受け付けるようにします。[/ja]\n */\nons$1.enableDeviceBackButtonHandler = function () {\n  if (!ons$1.isReady()) {\n    throw new Error('This method must be called after ons.isReady() is true.');\n  }\n  internal$1.dbbDispatcher.enable();\n};\n\nons$1.fireDeviceBackButtonEvent = function () {\n  internal$1.dbbDispatcher.fireDeviceBackButtonEvent();\n};\n\n/**\n * @method enableAutoStatusBarFill\n * @signature enableAutoStatusBarFill()\n * @description\n *   [en]Enable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]\n *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を有効にします。[/ja]\n */\nons$1.enableAutoStatusBarFill = function () {\n  if (ons$1.isReady()) {\n    throw new Error('This method must be called before ons.isReady() is true.');\n  }\n  internal$1.config.autoStatusBarFill = true;\n};\n\n/**\n * @method disableAutoStatusBarFill\n * @signature disableAutoStatusBarFill()\n * @description\n *   [en]Disable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]\n *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を無効にします。[/ja]\n */\nons$1.disableAutoStatusBarFill = function () {\n  if (ons$1.isReady()) {\n    throw new Error('This method must be called before ons.isReady() is true.');\n  }\n  internal$1.config.autoStatusBarFill = false;\n};\n\n/**\n * @method mockStatusBar\n * @signature mockStatusBar()\n * @description\n *   [en]Creates a static element similar to iOS status bar. Only useful for browser testing. Must be called before `ons.ready`.[/en]\n *   [ja][/ja]\n */\nons$1.mockStatusBar = function () {\n  if (ons$1.isReady()) {\n    throw new Error('This method must be called before ons.isReady() is true.');\n  }\n\n  var mock = function mock() {\n    if (!document.body.children[0] || !document.body.children[0].classList.contains('ons-status-bar-mock')) {\n      var android = platform.isAndroid(),\n          i = function i(_i) {\n        return '<i class=\"' + _i.split('-')[0] + ' ' + _i + '\"></i>';\n      };\n      var left = android ? i('zmdi-twitter') + ' ' + i('zmdi-google-play') : 'No SIM ' + i('fa-wifi'),\n          center = android ? '' : '12:28 PM',\n          right = android ? i('zmdi-network') + ' ' + i('zmdi-wifi') + ' ' + i('zmdi-battery') + ' 12:28 PM' : '80% ' + i('fa-battery-three-quarters');\n\n      document.body.insertBefore(util.createElement('<div class=\"ons-status-bar-mock ' + (android ? 'android' : 'ios') + '\">' + ('<div>' + left + '</div><div>' + center + '</div><div>' + right + '</div>') + '</div>'), document.body.firstChild);\n    }\n  };\n\n  document.body ? mock() : internal$1.waitDOMContentLoaded(mock);\n};\n\n/**\n * @method disableAnimations\n * @signature disableAnimations()\n * @description\n *   [en]Disable all animations. Could be handy for testing and older devices.[/en]\n *   [ja]アニメーションを全て無効にします。テストの際に便利です。[/ja]\n */\nons$1.disableAnimations = function () {\n  internal$1.config.animationsDisabled = true;\n};\n\n/**\n * @method enableAnimations\n * @signature enableAnimations()\n * @description\n *   [en]Enable animations (default).[/en]\n *   [ja]アニメーションを有効にします。[/ja]\n */\nons$1.enableAnimations = function () {\n  internal$1.config.animationsDisabled = false;\n};\n\nons$1._disableWarnings = function () {\n  internal$1.config.warningsDisabled = true;\n};\n\nons$1._enableWarnings = function () {\n  internal$1.config.warningsDisabled = false;\n};\n\n/**\n * @method disableAutoStyling\n * @signature disableAutoStyling()\n * @description\n *   [en]Disable automatic styling.[/en]\n *   [ja][/ja]\n */\nons$1.disableAutoStyling = autoStyle.disable;\n\n/**\n * @method enableAutoStyling\n * @signature enableAutoStyling()\n * @description\n *   [en]Enable automatic styling based on OS (default).[/en]\n *   [ja][/ja]\n */\nons$1.enableAutoStyling = autoStyle.enable;\n\n/**\n * @method disableIconAutoPrefix\n * @signature disableIconAutoPrefix()\n * @description\n *   [en]Disable adding `fa-` prefix automatically to `ons-icon` classes. Useful when including custom icon packs.[/en]\n *   [ja][/ja]\n */\nons$1.disableIconAutoPrefix = function () {\n  if (!ons$1.elements.Icon) {\n    throw new Error('Expected \\'ons-icon\\' Custom Element to be registered before calling this method.');\n  }\n  ons$1.elements.Icon.setAutoPrefix(false);\n};\n\n/**\n * @method forcePlatformStyling\n * @signature forcePlatformStyling(platform)\n * @description\n *   [en]Refresh styling for the given platform. Only useful for demos. Use `ons.platform.select(...)` instead for development and production.[/en]\n *   [ja][/ja]\n * @param {string} platform New platform to style the elements.\n */\nons$1.forcePlatformStyling = function (newPlatform) {\n  ons$1.enableAutoStyling();\n  ons$1.platform.select(newPlatform || 'ios');\n\n  ons$1._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {\n    if (element.tagName.toLowerCase() === 'ons-if') {\n      element._platformUpdate();\n    } else if (element.tagName.match(/^ons-/i)) {\n      autoStyle.prepare(element, true);\n      if (element.tagName.toLowerCase() === 'ons-tabbar') {\n        element._updatePosition();\n      }\n    }\n  });\n};\n\n/**\n * @method preload\n * @signature preload(templatePaths)\n * @param {String|Array} templatePaths\n *   [en]Set of HTML file paths containing 'ons-page' elements.[/en]\n *   [ja][/ja]\n * @return {Promise}\n *   [en]Promise that resolves when all the templates are cached.[/en]\n *   [ja][/ja]\n * @description\n *   [en]Separated files need to be requested on demand and this can slightly delay pushing new pages. This method requests and caches templates for later use.[/en]\n *   [ja][/ja]\n */\nons$1.preload = function () {\n  var templates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  return Promise.all((templates instanceof Array ? templates : [templates]).map(function (template) {\n    if (typeof template !== 'string') {\n      throw new Error('Expected string arguments but got ' + (typeof template === 'undefined' ? 'undefined' : _typeof(template)));\n    }\n    return internal$1.getTemplateHTMLAsync(template);\n  }));\n};\n\n/**\n * @method createElement\n * @signature createElement(template, options)\n * @param {String} template\n *   [en]Either an HTML file path, an `<ons-template>` id or an HTML string such as `'<div id=\"foo\">hoge</div>'`.[/en]\n *   [ja][/ja]\n * @param {Object} [options]\n *   [en]Parameter object.[/en]\n *   [ja]オプションを指定するオブジェクト。[/ja]\n * @param {Boolean|HTMLElement} [options.append]\n *   [en]Whether or not the element should be automatically appended to the DOM.  Defaults to `false`. If `true` value is given, `document.body` will be used as the target.[/en]\n *   [ja][/ja]\n * @param {HTMLElement} [options.insertBefore]\n *   [en]Reference node that becomes the next sibling of the new node (`options.append` element).[/en]\n *   [ja][/ja]\n * @return {HTMLElement|Promise}\n *   [en]If the provided template was an inline HTML string, it returns the new element. Otherwise, it returns a promise that resolves to the new element.[/en]\n *   [ja][/ja]\n * @description\n *   [en]Create a new element from a template. Both inline HTML and external files are supported although the return value differs.[/en]\n *   [ja][/ja]\n */\nons$1.createElement = function (template) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  template = template.trim();\n\n  var create = function create(html) {\n    var element = ons$1._util.createElement(html);\n    element.remove();\n\n    if (options.append) {\n      var target = options.append instanceof HTMLElement ? options.append : document.body;\n      target.insertBefore(element, options.insertBefore || null);\n      options.link instanceof Function && options.link(element);\n    }\n\n    return element;\n  };\n\n  return template.charAt(0) === '<' ? create(template) : internal$1.getPageHTMLAsync(template).then(create);\n};\n\n/**\n * @method createPopover\n * @signature createPopover(page, [options])\n * @param {String} page\n *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]\n *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]\n * @param {Object} [options]\n *   [en]Parameter object.[/en]\n *   [ja]オプションを指定するオブジェクト。[/ja]\n * @param {Object} [options.parentScope]\n *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]\n *   [ja]ダイアログ内で利用する親スコープを指定します。ダイアログからモデルやスコープのメソッドにアクセスするのに使います。このパラメータはAngularJSバインディングでのみ利用できます。[/ja]\n * @return {Promise}\n *   [en]Promise object that resolves to the popover component object.[/en]\n *   [ja]ポップオーバーのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]\n * @description\n *   [en]Create a popover instance from a template.[/en]\n *   [ja]テンプレートからポップオーバーのインスタンスを生成します。[/ja]\n */\n/**\n * @method createDialog\n * @signature createDialog(page, [options])\n * @param {String} page\n *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-dialog> component.[/en]\n *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]\n * @param {Object} [options]\n *   [en]Parameter object.[/en]\n *   [ja]オプションを指定するオブジェクト。[/ja]\n * @return {Promise}\n *   [en]Promise object that resolves to the dialog component object.[/en]\n *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]\n * @description\n *   [en]Create a dialog instance from a template.[/en]\n *   [ja]テンプレートからダイアログのインスタンスを生成します。[/ja]\n */\n/**\n * @method createAlertDialog\n * @signature createAlertDialog(page, [options])\n * @param {String} page\n *   [en]Page name. Can be either an HTML file or an <ons-template> containing a <ons-alert-dialog> component.[/en]\n *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]\n * @param {Object} [options]\n *   [en]Parameter object.[/en]\n *   [ja]オプションを指定するオブジェクト。[/ja]\n * @return {Promise}\n *   [en]Promise object that resolves to the alert dialog component object.[/en]\n *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]\n * @description\n *   [en]Create a alert dialog instance from a template.[/en]\n *   [ja]テンプレートからアラートダイアログのインスタンスを生成します。[/ja]\n */\nons$1.createPopover = ons$1.createDialog = ons$1.createAlertDialog = function (template) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return ons$1.createElement(template, _extends({ append: true }, options));\n};\n\n/**\n * @method openActionSheet\n * @signature openActionSheet(options)\n * @description\n *   [en]Shows an instant Action Sheet and lets the user choose an action.[/en]\n *   [ja][/ja]\n * @param {Object} [options]\n *   [en]Parameter object.[/en]\n *   [ja]オプションを指定するオブジェクト。[/ja]\n * @param {Array} [options.buttons]\n *   [en]Represent each button of the action sheet following the specified order. Every item can be either a string label or an object containing `label`, `icon` and `modifier` properties.[/en]\n *   [ja][/ja]\n * @param {String} [options.title]\n *   [en]Optional title for the action sheet.[/en]\n *   [ja][/ja]\n * @param {Number} [options.destructive]\n *   [en]Optional index of the \"destructive\" button (only for iOS). It can be specified in the button array as well.[/en]\n *   [ja][/ja]\n * @param {Boolean} [options.cancelable]\n *   [en]Whether the action sheet can be canceled by tapping on the background mask or not.[/en]\n *   [ja][/ja]\n * @param {String} [options.modifier]\n *   [en]Modifier attribute of the action sheet. E.g. `'destructive'`.[/en]\n *   [ja][/ja]\n * @param {String} [options.maskColor]\n *   [en]Optionally change the background mask color.[/en]\n *   [ja][/ja]\n * @param {String} [options.id]\n *   [en]The element's id attribute.[/en]\n *   [ja][/ja]\n * @param {String} [options.class]\n *   [en]The element's class attribute.[/en]\n *   [ja][/ja]\n * @return {Promise}\n *   [en]Will resolve when the action sheet is closed. The resolve value is either the index of the tapped button or -1 when canceled.[/en]\n *   [ja][/ja]\n */\nons$1.openActionSheet = actionSheet;\n\n/**\n * @method resolveLoadingPlaceholder\n * @signature resolveLoadingPlaceholder(page)\n * @param {String} page\n *   [en]Page name. Can be either an HTML file or a `<template>` id.[/en]\n *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]\n * @description\n *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]\n *   [ja]ons-loading-placeholderの属性値としてページが指定されていない場合は、ページロード前に呼ばれるons.resolveLoadingPlaceholder処理が行われるまで表示されません。[/ja]\n */\nons$1.resolveLoadingPlaceholder = function (page, link) {\n  var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));\n  if (elements.length === 0) {\n    throw new Error('No ons-loading-placeholder exists.');\n  }\n\n  elements.filter(function (element) {\n    return !element.getAttribute('page');\n  }).forEach(function (element) {\n    element.setAttribute('ons-loading-placeholder', page);\n    ons$1._resolveLoadingPlaceholder(element, page, link);\n  });\n};\n\nons$1._setupLoadingPlaceHolders = function () {\n  ons$1.ready(function () {\n    var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));\n\n    elements.forEach(function (element) {\n      var page = element.getAttribute('ons-loading-placeholder');\n      if (typeof page === 'string') {\n        ons$1._resolveLoadingPlaceholder(element, page);\n      }\n    });\n  });\n};\n\nons$1._resolveLoadingPlaceholder = function (parent, page) {\n  var link = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el, done) {\n    return done();\n  };\n\n  page && ons$1.createElement(page).then(function (element) {\n    element.style.display = 'none';\n    parent.appendChild(element);\n    link(element, function () {\n      while (parent.firstChild && parent.firstChild !== element) {\n        parent.removeChild(parent.firstChild);\n      }\n      element.style.display = '';\n    });\n  }).catch(function (error) {\n    return Promise.reject('Unabled to resolve placeholder: ' + error);\n  });\n};\n\nfunction waitDeviceReady() {\n  var unlockDeviceReady = ons$1._readyLock.lock();\n  window.addEventListener('DOMContentLoaded', function () {\n    if (ons$1.isWebView()) {\n      window.document.addEventListener('deviceready', unlockDeviceReady, false);\n    } else {\n      unlockDeviceReady();\n    }\n  }, false);\n}\n\n/**\n * @method getScriptPage\n * @signature getScriptPage()\n * @description\n *   [en]Access the last created page from the current `script` scope. Only works inside `<script></script>` tags that are direct children of `ons-page` element. Use this to add lifecycle hooks to a page.[/en]\n *   [ja][/ja]\n * @return {HTMLElement}\n *   [en]Returns the corresponding page element.[/en]\n *   [ja][/ja]\n */\nvar getCS = 'currentScript' in document ? function () {\n  return document.currentScript;\n} : function () {\n  return document.scripts[document.scripts.length - 1];\n};\nons$1.getScriptPage = function () {\n  return getCS() && /ons-page/i.test(getCS().parentElement.tagName) && getCS().parentElement || null;\n};\n\n// For @onsenui/custom-elements\nif (window.customElements) {\n    // even if native CE1 impl exists, use polyfill\n    window.customElements.forcePolyfill = true;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar _global = createCommonjsModule(function (module) {\n  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\n  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n});\n\nvar _core = createCommonjsModule(function (module) {\n  var core = module.exports = { version: '2.5.1' };\n  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n});\n\nvar _core_1 = _core.version;\n\nvar _isObject = function _isObject(it) {\n  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';\n};\n\nvar _anObject = function _anObject(it) {\n  if (!_isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\nvar _fails = function _fails(exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n// Thank's IE8 for his funny defineProperty\nvar _descriptors = !_fails(function () {\n  return Object.defineProperty({}, 'a', { get: function get() {\n      return 7;\n    } }).a != 7;\n});\n\nvar document$1 = _global.document;\n// typeof document.createElement is 'object' in old IE\nvar is = _isObject(document$1) && _isObject(document$1.createElement);\nvar _domCreate = function _domCreate(it) {\n  return is ? document$1.createElement(it) : {};\n};\n\nvar _ie8DomDefine = !_descriptors && !_fails(function () {\n  return Object.defineProperty(_domCreate('div'), 'a', { get: function get() {\n      return 7;\n    } }).a != 7;\n});\n\n// 7.1.1 ToPrimitive(input [, PreferredType])\n\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nvar _toPrimitive = function _toPrimitive(it, S) {\n  if (!_isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\nvar dP = Object.defineProperty;\n\nvar f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  _anObject(O);\n  P = _toPrimitive(P, true);\n  _anObject(Attributes);\n  if (_ie8DomDefine) try {\n    return dP(O, P, Attributes);\n  } catch (e) {/* empty */}\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar _objectDp = {\n  f: f\n};\n\nvar _propertyDesc = function _propertyDesc(bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar _hide = _descriptors ? function (object, key, value) {\n  return _objectDp.f(object, key, _propertyDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar hasOwnProperty = {}.hasOwnProperty;\nvar _has = function _has(it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\nvar id = 0;\nvar px = Math.random();\nvar _uid = function _uid(key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\nvar _redefine = createCommonjsModule(function (module) {\n  var SRC = _uid('src');\n  var TO_STRING = 'toString';\n  var $toString = Function[TO_STRING];\n  var TPL = ('' + $toString).split(TO_STRING);\n\n  _core.inspectSource = function (it) {\n    return $toString.call(it);\n  };\n\n  (module.exports = function (O, key, val, safe) {\n    var isFunction = typeof val == 'function';\n    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);\n    if (O[key] === val) return;\n    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n    if (O === _global) {\n      O[key] = val;\n    } else if (!safe) {\n      delete O[key];\n      _hide(O, key, val);\n    } else if (O[key]) {\n      O[key] = val;\n    } else {\n      _hide(O, key, val);\n    }\n    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n  })(Function.prototype, TO_STRING, function toString() {\n    return typeof this == 'function' && this[SRC] || $toString.call(this);\n  });\n});\n\nvar _aFunction = function _aFunction(it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n// optional / simple context binding\n\nvar _ctx = function _ctx(fn, that, length) {\n  _aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1:\n      return function (a) {\n        return fn.call(that, a);\n      };\n    case 2:\n      return function (a, b) {\n        return fn.call(that, a, b);\n      };\n    case 3:\n      return function (a, b, c) {\n        return fn.call(that, a, b, c);\n      };\n  }\n  return function () /* ...args */{\n    return fn.apply(that, arguments);\n  };\n};\n\nvar PROTOTYPE = 'prototype';\n\nvar $export = function $export(type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;\n    // extend global\n    if (target) _redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) _hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\n_global.core = _core;\n// type bitmap\n$export.F = 1; // forced\n$export.G = 2; // global\n$export.S = 4; // static\n$export.P = 8; // proto\n$export.B = 16; // bind\n$export.W = 32; // wrap\n$export.U = 64; // safe\n$export.R = 128; // real proto method for `library`\nvar _export = $export;\n\nvar f$2 = {}.propertyIsEnumerable;\n\nvar _objectPie = {\n\tf: f$2\n};\n\nvar toString = {}.toString;\n\nvar _cof = function _cof(it) {\n  return toString.call(it).slice(8, -1);\n};\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\n// eslint-disable-next-line no-prototype-builtins\nvar _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return _cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n// 7.2.1 RequireObjectCoercible(argument)\nvar _defined = function _defined(it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n// to indexed object, toObject with fallback for non-array-like ES3 strings\n\n\nvar _toIobject = function _toIobject(it) {\n  return _iobject(_defined(it));\n};\n\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar f$1 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = _toIobject(O);\n  P = _toPrimitive(P, true);\n  if (_ie8DomDefine) try {\n    return gOPD(O, P);\n  } catch (e) {/* empty */}\n  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);\n};\n\nvar _objectGopd = {\n  f: f$1\n};\n\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\n\nvar check = function check(O, proto) {\n  _anObject(O);\n  if (!_isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nvar _setProto = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n  function (test, buggy, set) {\n    try {\n      set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);\n      set(test, []);\n      buggy = !(test instanceof Array);\n    } catch (e) {\n      buggy = true;\n    }\n    return function setPrototypeOf(O, proto) {\n      check(O, proto);\n      if (buggy) O.__proto__ = proto;else set(O, proto);\n      return O;\n    };\n  }({}, false) : undefined),\n  check: check\n};\n\n// 19.1.3.19 Object.setPrototypeOf(O, proto)\n\n_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });\n\nvar setPrototypeOf = _core.Object.setPrototypeOf;\n\nvar SHARED = '__core-js_shared__';\nvar store = _global[SHARED] || (_global[SHARED] = {});\nvar _shared = function _shared(key) {\n  return store[key] || (store[key] = {});\n};\n\nvar _wks = createCommonjsModule(function (module) {\n  var store = _shared('wks');\n\n  var _Symbol = _global.Symbol;\n  var USE_SYMBOL = typeof _Symbol == 'function';\n\n  var $exports = module.exports = function (name) {\n    return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : _uid)('Symbol.' + name));\n  };\n\n  $exports.store = store;\n});\n\n// getting tag from 19.1.3.6 Object.prototype.toString()\n\nvar TAG = _wks('toStringTag');\n// ES3 wrong here\nvar ARG = _cof(function () {\n  return arguments;\n}()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function tryGet(it, key) {\n  try {\n    return it[key];\n  } catch (e) {/* empty */}\n};\n\nvar _classof = function _classof(it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n  // @@toStringTag case\n  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n  // builtinTag case\n  : ARG ? _cof(O)\n  // ES3 arguments fallback\n  : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n// 19.1.3.6 Object.prototype.toString()\n\nvar test = {};\ntest[_wks('toStringTag')] = 'z';\nif (test + '' != '[object z]') {\n  _redefine(Object.prototype, 'toString', function toString() {\n    return '[object ' + _classof(this) + ']';\n  }, true);\n}\n\n// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nvar _toInteger = function _toInteger(it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n// true  -> String#at\n// false -> String#codePointAt\nvar _stringAt = function _stringAt(TO_STRING) {\n  return function (that, pos) {\n    var s = String(_defined(that));\n    var i = _toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\nvar _library = false;\n\nvar _iterators = {};\n\n// 7.1.15 ToLength\n\nvar min = Math.min;\nvar _toLength = function _toLength(it) {\n  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\nvar max = Math.max;\nvar min$1 = Math.min;\nvar _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {\n  index = _toInteger(index);\n  return index < 0 ? max(index + length, 0) : min$1(index, length);\n};\n\n// false -> Array#indexOf\n// true  -> Array#includes\n\n\nvar _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = _toIobject($this);\n    var length = _toLength(O.length);\n    var index = _toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n      // Array#indexOf ignores holes, Array#includes - not\n    } else for (; length > index; index++) {\n      if (IS_INCLUDES || index in O) {\n        if (O[index] === el) return IS_INCLUDES || index || 0;\n      }\n    }return !IS_INCLUDES && -1;\n  };\n};\n\nvar shared = _shared('keys');\n\nvar _sharedKey = function _sharedKey(key) {\n  return shared[key] || (shared[key] = _uid(key));\n};\n\nvar arrayIndexOf = _arrayIncludes(false);\nvar IE_PROTO$1 = _sharedKey('IE_PROTO');\n\nvar _objectKeysInternal = function _objectKeysInternal(object, names) {\n  var O = _toIobject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) {\n    if (key != IE_PROTO$1) _has(O, key) && result.push(key);\n  } // Don't enum bug & hidden keys\n  while (names.length > i) {\n    if (_has(O, key = names[i++])) {\n      ~arrayIndexOf(result, key) || result.push(key);\n    }\n  }return result;\n};\n\n// IE 8- don't enum bug keys\nvar _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');\n\n// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\n\nvar _objectKeys = Object.keys || function keys(O) {\n  return _objectKeysInternal(O, _enumBugKeys);\n};\n\nvar _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {\n  _anObject(O);\n  var keys = _objectKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) {\n    _objectDp.f(O, P = keys[i++], Properties[P]);\n  }return O;\n};\n\nvar document$2 = _global.document;\nvar _html = document$2 && document$2.documentElement;\n\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\n\nvar IE_PROTO = _sharedKey('IE_PROTO');\nvar Empty = function Empty() {/* empty */};\nvar PROTOTYPE$1 = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar _createDict = function createDict() {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = _domCreate('iframe');\n  var i = _enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  _html.appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  _createDict = iframeDocument.F;\n  while (i--) {\n    delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];\n  }return _createDict();\n};\n\nvar _objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE$1] = _anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = _createDict();\n  return Properties === undefined ? result : _objectDps(result, Properties);\n};\n\nvar def = _objectDp.f;\n\nvar TAG$1 = _wks('toStringTag');\n\nvar _setToStringTag = function _setToStringTag(it, tag, stat) {\n  if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, { configurable: true, value: tag });\n};\n\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n_hide(IteratorPrototype, _wks('iterator'), function () {\n  return this;\n});\n\nvar _iterCreate = function _iterCreate(Constructor, NAME, next) {\n  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });\n  _setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n// 7.1.13 ToObject(argument)\n\nvar _toObject = function _toObject(it) {\n  return Object(_defined(it));\n};\n\n// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\n\nvar IE_PROTO$2 = _sharedKey('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nvar _objectGpo = Object.getPrototypeOf || function (O) {\n  O = _toObject(O);\n  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  }return O instanceof Object ? ObjectProto : null;\n};\n\nvar ITERATOR = _wks('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function returnThis() {\n  return this;\n};\n\nvar _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  _iterCreate(Constructor, NAME, next);\n  var getMethod = function getMethod(kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS:\n        return function keys() {\n          return new Constructor(this, kind);\n        };\n      case VALUES:\n        return function values() {\n          return new Constructor(this, kind);\n        };\n    }return function entries() {\n      return new Constructor(this, kind);\n    };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = _objectGpo($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      _setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!_library && !_has(IteratorPrototype, ITERATOR)) _hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() {\n      return $native.call(this);\n    };\n  }\n  // Define iterator\n  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    _hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  _iterators[NAME] = $default;\n  _iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) _redefine(proto, key, methods[key]);\n    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\nvar $at = _stringAt(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n_iterDefine(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0; // next index\n  // 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n\n// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = _wks('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});\nvar _addToUnscopables = function _addToUnscopables(key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n\nvar _iterStep = function _iterStep(done, value) {\n  return { value: value, done: !!done };\n};\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nvar es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {\n  this._t = _toIobject(iterated); // target\n  this._i = 0; // next index\n  this._k = kind; // kind\n  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return _iterStep(1);\n  }\n  if (kind == 'keys') return _iterStep(0, index);\n  if (kind == 'values') return _iterStep(0, O[index]);\n  return _iterStep(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n_iterators.Arguments = _iterators.Array;\n\n_addToUnscopables('keys');\n_addToUnscopables('values');\n_addToUnscopables('entries');\n\nvar ITERATOR$1 = _wks('iterator');\nvar TO_STRING_TAG = _wks('toStringTag');\nvar ArrayValues = _iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = _global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR$1]) _hide(proto, ITERATOR$1, ArrayValues);\n    if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);\n    _iterators[NAME] = ArrayValues;\n    if (explicit) for (key in es6_array_iterator) {\n      if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);\n    }\n  }\n}\n\nvar _redefineAll = function _redefineAll(target, src, safe) {\n  for (var key in src) {\n    _redefine(target, key, src[key], safe);\n  }return target;\n};\n\nvar _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {\n    throw TypeError(name + ': incorrect invocation!');\n  }return it;\n};\n\n// call something on iterator step with safe closing on error\n\nvar _iterCall = function _iterCall(iterator, fn, value, entries) {\n  try {\n    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);\n    // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) _anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n// check on default Array iterator\n\nvar ITERATOR$2 = _wks('iterator');\nvar ArrayProto$1 = Array.prototype;\n\nvar _isArrayIter = function _isArrayIter(it) {\n  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$2] === it);\n};\n\nvar ITERATOR$3 = _wks('iterator');\n\nvar core_getIteratorMethod = _core.getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || _iterators[_classof(it)];\n};\n\nvar _forOf = createCommonjsModule(function (module) {\n  var BREAK = {};\n  var RETURN = {};\n  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n    var iterFn = ITERATOR ? function () {\n      return iterable;\n    } : core_getIteratorMethod(iterable);\n    var f = _ctx(fn, that, entries ? 2 : 1);\n    var index = 0;\n    var length, step, iterator, result;\n    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n    // fast case for arrays with default iterator\n    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {\n      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n      if (result === BREAK || result === RETURN) return result;\n    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n      result = _iterCall(iterator, f, step.value, entries);\n      if (result === BREAK || result === RETURN) return result;\n    }\n  };\n  exports.BREAK = BREAK;\n  exports.RETURN = RETURN;\n});\n\nvar SPECIES = _wks('species');\n\nvar _setSpecies = function _setSpecies(KEY) {\n  var C = _global[KEY];\n  if (_descriptors && C && !C[SPECIES]) _objectDp.f(C, SPECIES, {\n    configurable: true,\n    get: function get() {\n      return this;\n    }\n  });\n};\n\nvar _meta = createCommonjsModule(function (module) {\n  var META = _uid('meta');\n\n  var setDesc = _objectDp.f;\n  var id = 0;\n  var isExtensible = Object.isExtensible || function () {\n    return true;\n  };\n  var FREEZE = !_fails(function () {\n    return isExtensible(Object.preventExtensions({}));\n  });\n  var setMeta = function setMeta(it) {\n    setDesc(it, META, { value: {\n        i: 'O' + ++id, // object ID\n        w: {} // weak collections IDs\n      } });\n  };\n  var fastKey = function fastKey(it, create) {\n    // return primitive with prefix\n    if (!_isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n    if (!_has(it, META)) {\n      // can't set metadata to uncaught frozen object\n      if (!isExtensible(it)) return 'F';\n      // not necessary to add metadata\n      if (!create) return 'E';\n      // add missing metadata\n      setMeta(it);\n      // return object ID\n    }return it[META].i;\n  };\n  var getWeak = function getWeak(it, create) {\n    if (!_has(it, META)) {\n      // can't set metadata to uncaught frozen object\n      if (!isExtensible(it)) return true;\n      // not necessary to add metadata\n      if (!create) return false;\n      // add missing metadata\n      setMeta(it);\n      // return hash weak collections IDs\n    }return it[META].w;\n  };\n  // add metadata on freeze-family methods calling\n  var onFreeze = function onFreeze(it) {\n    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);\n    return it;\n  };\n  var meta = module.exports = {\n    KEY: META,\n    NEED: false,\n    fastKey: fastKey,\n    getWeak: getWeak,\n    onFreeze: onFreeze\n  };\n});\n\nvar _meta_1 = _meta.KEY;\nvar _meta_2 = _meta.NEED;\nvar _meta_3 = _meta.fastKey;\nvar _meta_4 = _meta.getWeak;\nvar _meta_5 = _meta.onFreeze;\n\nvar _validateCollection = function _validateCollection(it, TYPE) {\n  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\n  return it;\n};\n\nvar dP$1 = _objectDp.f;\n\nvar fastKey = _meta.fastKey;\n\nvar SIZE = _descriptors ? '_s' : 'size';\n\nvar getEntry = function getEntry(that, key) {\n  // fast case\n  var index = fastKey(key);\n  var entry;\n  if (index !== 'F') return that._i[index];\n  // frozen object case\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nvar _collectionStrong = {\n  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      _anInstance(that, C, NAME, '_i');\n      that._t = NAME; // collection type\n      that._i = _objectCreate(null); // index\n      that._f = undefined; // first entry\n      that._l = undefined; // last entry\n      that[SIZE] = 0; // size\n      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    _redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function _delete(key) {\n        var that = _validateCollection(this, NAME);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.n;\n          var prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        }return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        _validateCollection(this, NAME);\n        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while (entry && entry.r) {\n            entry = entry.p;\n          }\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(_validateCollection(this, NAME), key);\n      }\n    });\n    if (_descriptors) dP$1(C.prototype, 'size', {\n      get: function get() {\n        return _validateCollection(this, NAME)[SIZE];\n      }\n    });\n    return C;\n  },\n  def: function def(that, key, value) {\n    var entry = getEntry(that, key);\n    var prev, index;\n    // change existing entry\n    if (entry) {\n      entry.v = value;\n      // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key, // <- key\n        v: value, // <- value\n        p: prev = that._l, // <- previous entry\n        n: undefined, // <- next entry\n        r: false // <- removed\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if (index !== 'F') that._i[index] = entry;\n    }return that;\n  },\n  getEntry: getEntry,\n  setStrong: function setStrong(C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    _iterDefine(C, NAME, function (iterated, kind) {\n      this._t = _validateCollection(iterated, NAME); // target\n      this._k = kind; // kind\n      this._l = undefined; // previous\n    }, function () {\n      var that = this;\n      var kind = that._k;\n      var entry = that._l;\n      // revert to the last existing entry\n      while (entry && entry.r) {\n        entry = entry.p;\n      } // get next entry\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return _iterStep(1);\n      }\n      // return step by kind\n      if (kind == 'keys') return _iterStep(0, entry.k);\n      if (kind == 'values') return _iterStep(0, entry.v);\n      return _iterStep(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    _setSpecies(NAME);\n  }\n};\n\nvar ITERATOR$4 = _wks('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR$4]();\n  riter['return'] = function () {\n    SAFE_CLOSING = true;\n  };\n  // eslint-disable-next-line no-throw-literal\n  \n} catch (e) {/* empty */}\n\nvar _iterDetect = function _iterDetect(exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR$4]();\n    iter.next = function () {\n      return { done: safe = true };\n    };\n    arr[ITERATOR$4] = function () {\n      return iter;\n    };\n    exec(arr);\n  } catch (e) {/* empty */}\n  return safe;\n};\n\nvar setPrototypeOf$2 = _setProto.set;\nvar _inheritIfRequired = function _inheritIfRequired(that, target, C) {\n  var S = target.constructor;\n  var P;\n  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf$2) {\n    setPrototypeOf$2(that, P);\n  }return that;\n};\n\nvar _collection = function _collection(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\n  var Base = _global[NAME];\n  var C = Base;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var proto = C && C.prototype;\n  var O = {};\n  var fixMethod = function fixMethod(KEY) {\n    var fn = proto[KEY];\n    _redefine(proto, KEY, KEY == 'delete' ? function (a) {\n      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n    } : KEY == 'has' ? function has(a) {\n      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n    } : KEY == 'get' ? function get(a) {\n      return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n    } : KEY == 'add' ? function add(a) {\n      fn.call(this, a === 0 ? 0 : a);return this;\n    } : function set(a, b) {\n      fn.call(this, a === 0 ? 0 : a, b);return this;\n    });\n  };\n  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {\n    new C().entries().next();\n  }))) {\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    _redefineAll(C.prototype, methods);\n    _meta.NEED = true;\n  } else {\n    var instance = new C();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = _fails(function () {\n      instance.has(1);\n    });\n    // most early implementations doesn't supports iterables, most modern - not close it correctly\n    var ACCEPT_ITERABLES = _iterDetect(function (iter) {\n      new C(iter);\n    }); // eslint-disable-line no-new\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && _fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new C();\n      var index = 5;\n      while (index--) {\n        $instance[ADDER](index, index);\n      }return !$instance.has(-0);\n    });\n    if (!ACCEPT_ITERABLES) {\n      C = wrapper(function (target, iterable) {\n        _anInstance(target, C, NAME);\n        var that = _inheritIfRequired(new Base(), target, C);\n        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if (IS_WEAK && proto.clear) delete proto.clear;\n  }\n\n  _setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  _export(_export.G + _export.W + _export.F * (C != Base), O);\n\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n\nvar SET = 'Set';\n\n// 23.2 Set Objects\nvar es6_set = _collection(SET, function (get) {\n  return function Set() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value) {\n    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);\n  }\n}, _collectionStrong);\n\nvar _arrayFromIterable = function _arrayFromIterable(iter, ITERATOR) {\n  var result = [];\n  _forOf(iter, false, result.push, result, ITERATOR);\n  return result;\n};\n\n// https://github.com/DavidBruant/Map-Set.prototype.toJSON\n\n\nvar _collectionToJson = function _collectionToJson(NAME) {\n  return function toJSON() {\n    if (_classof(this) != NAME) throw TypeError(NAME + \"#toJSON isn't generic\");\n    return _arrayFromIterable(this);\n  };\n};\n\n// https://github.com/DavidBruant/Map-Set.prototype.toJSON\n\n\n_export(_export.P + _export.R, 'Set', { toJSON: _collectionToJson('Set') });\n\n// https://tc39.github.io/proposal-setmap-offrom/\n\n\nvar _setCollectionOf = function _setCollectionOf(COLLECTION) {\n  _export(_export.S, COLLECTION, { of: function of() {\n      var length = arguments.length;\n      var A = Array(length);\n      while (length--) {\n        A[length] = arguments[length];\n      }return new this(A);\n    } });\n};\n\n// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of\n_setCollectionOf('Set');\n\n// https://tc39.github.io/proposal-setmap-offrom/\n\n\nvar _setCollectionFrom = function _setCollectionFrom(COLLECTION) {\n  _export(_export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {\n      var mapFn = arguments[1];\n      var mapping, A, n, cb;\n      _aFunction(this);\n      mapping = mapFn !== undefined;\n      if (mapping) _aFunction(mapFn);\n      if (source == undefined) return new this();\n      A = [];\n      if (mapping) {\n        n = 0;\n        cb = _ctx(mapFn, arguments[2], 2);\n        _forOf(source, false, function (nextItem) {\n          A.push(cb(nextItem, n++));\n        });\n      } else {\n        _forOf(source, false, A.push, A);\n      }\n      return new this(A);\n    } });\n};\n\n// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from\n_setCollectionFrom('Set');\n\nvar set$1 = _core.Set;\n\nvar MAP = 'Map';\n\n// 23.1 Map Objects\nvar es6_map = _collection(MAP, function (get) {\n  return function Map() {\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key) {\n    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value) {\n    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);\n  }\n}, _collectionStrong, true);\n\n// https://github.com/DavidBruant/Map-Set.prototype.toJSON\n\n\n_export(_export.P + _export.R, 'Map', { toJSON: _collectionToJson('Map') });\n\n// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of\n_setCollectionOf('Map');\n\n// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from\n_setCollectionFrom('Map');\n\nvar map = _core.Map;\n\nvar reservedTagList = new Set(['annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph']);\n\n/**\n * @param {string} localName\n * @returns {boolean}\n */\nfunction isValidCustomElementName(localName) {\n  var reserved = reservedTagList.has(localName);\n  var validForm = /^[a-z][.0-9_a-z]*-[\\-.0-9_a-z]*$/.test(localName);\n  return !reserved && validForm;\n}\n\n/**\n * @private\n * @param {!Node} node\n * @return {boolean}\n */\nfunction isConnected(node) {\n  // Use `Node#isConnected`, if defined.\n  var nativeValue = node.isConnected;\n  if (nativeValue !== undefined) {\n    return nativeValue;\n  }\n\n  /** @type {?Node|undefined} */\n  var current = node;\n  while (current && !(current.__CE_isImportDocument || current instanceof Document)) {\n    current = current.parentNode || (window.ShadowRoot && current instanceof ShadowRoot ? current.host : undefined);\n  }\n  return !!(current && (current.__CE_isImportDocument || current instanceof Document));\n}\n\n/**\n * @param {!Node} root\n * @param {!Node} start\n * @return {?Node}\n */\nfunction nextSiblingOrAncestorSibling(root, start) {\n  var node = start;\n  while (node && node !== root && !node.nextSibling) {\n    node = node.parentNode;\n  }\n  return !node || node === root ? null : node.nextSibling;\n}\n\n/**\n * @param {!Node} root\n * @param {!Node} start\n * @return {?Node}\n */\nfunction nextNode(root, start) {\n  return start.firstChild ? start.firstChild : nextSiblingOrAncestorSibling(root, start);\n}\n\n/**\n * @param {!Node} root\n * @param {!function(!Element)} callback\n * @param {!Set<Node>=} visitedImports\n */\nfunction walkDeepDescendantElements(root, callback) {\n  var visitedImports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n\n  var node = root;\n  while (node) {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      var element = /** @type {!Element} */node;\n\n      callback(element);\n\n      var localName = element.localName;\n      if (localName === 'link' && element.getAttribute('rel') === 'import') {\n        // If this import (polyfilled or not) has it's root node available,\n        // walk it.\n        var importNode = /** @type {!Node} */element.import;\n        if (importNode instanceof Node && !visitedImports.has(importNode)) {\n          // Prevent multiple walks of the same import root.\n          visitedImports.add(importNode);\n\n          for (var child = importNode.firstChild; child; child = child.nextSibling) {\n            walkDeepDescendantElements(child, callback, visitedImports);\n          }\n        }\n\n        // Ignore descendants of import links to prevent attempting to walk the\n        // elements created by the HTML Imports polyfill that we just walked\n        // above.\n        node = nextSiblingOrAncestorSibling(root, element);\n        continue;\n      } else if (localName === 'template') {\n        // Ignore descendants of templates. There shouldn't be any descendants\n        // because they will be moved into `.content` during construction in\n        // browsers that support template but, in case they exist and are still\n        // waiting to be moved by a polyfill, they will be ignored.\n        node = nextSiblingOrAncestorSibling(root, element);\n        continue;\n      }\n\n      // Walk shadow roots.\n      var shadowRoot = element.__CE_shadowRoot;\n      if (shadowRoot) {\n        for (var _child = shadowRoot.firstChild; _child; _child = _child.nextSibling) {\n          walkDeepDescendantElements(_child, callback, visitedImports);\n        }\n      }\n    }\n\n    node = nextNode(root, node);\n  }\n}\n\n/**\n * Used to suppress Closure's \"Modifying the prototype is only allowed if the\n * constructor is in the same scope\" warning without using\n * `@suppress {newCheckTypes, duplicate}` because `newCheckTypes` is too broad.\n *\n * @param {!Object} destination\n * @param {string} name\n * @param {*} value\n */\nfunction setPropertyUnchecked(destination, name, value) {\n  destination[name] = value;\n}\n\n/**\n * @enum {number}\n */\nvar CustomElementState = {\n  custom: 1,\n  failed: 2\n};\n\nvar CustomElementInternals = function () {\n  function CustomElementInternals() {\n    classCallCheck(this, CustomElementInternals);\n\n    /** @type {!Map<string, !CustomElementDefinition>} */\n    this._localNameToDefinition = new Map();\n\n    /** @type {!Map<!Function, !CustomElementDefinition>} */\n    this._constructorToDefinition = new Map();\n\n    /** @type {!Array<!function(!Node)>} */\n    this._patches = [];\n\n    /** @type {boolean} */\n    this._hasPatches = false;\n  }\n\n  /**\n   * @param {string} localName\n   * @param {!CustomElementDefinition} definition\n   */\n\n\n  createClass(CustomElementInternals, [{\n    key: 'setDefinition',\n    value: function setDefinition(localName, definition) {\n      this._localNameToDefinition.set(localName, definition);\n      this._constructorToDefinition.set(definition.constructor, definition);\n    }\n\n    /**\n     * @param {string} localName\n     * @return {!CustomElementDefinition|undefined}\n     */\n\n  }, {\n    key: 'localNameToDefinition',\n    value: function localNameToDefinition(localName) {\n      return this._localNameToDefinition.get(localName);\n    }\n\n    /**\n     * @param {!Function} constructor\n     * @return {!CustomElementDefinition|undefined}\n     */\n\n  }, {\n    key: 'constructorToDefinition',\n    value: function constructorToDefinition(constructor) {\n      return this._constructorToDefinition.get(constructor);\n    }\n\n    /**\n     * @param {!function(!Node)} listener\n     */\n\n  }, {\n    key: 'addPatch',\n    value: function addPatch(listener) {\n      this._hasPatches = true;\n      this._patches.push(listener);\n    }\n\n    /**\n     * @param {!Node} node\n     */\n\n  }, {\n    key: 'patchTree',\n    value: function patchTree(node) {\n      var _this = this;\n\n      if (!this._hasPatches) return;\n\n      walkDeepDescendantElements(node, function (element) {\n        return _this.patch(element);\n      });\n    }\n\n    /**\n     * @param {!Node} node\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(node) {\n      if (!this._hasPatches) return;\n\n      if (node.__CE_patched) return;\n      node.__CE_patched = true;\n\n      for (var i = 0; i < this._patches.length; i++) {\n        this._patches[i](node);\n      }\n    }\n\n    /**\n     * @param {!Node} root\n     */\n\n  }, {\n    key: 'connectTree',\n    value: function connectTree(root) {\n      var elements = [];\n\n      walkDeepDescendantElements(root, function (element) {\n        return elements.push(element);\n      });\n\n      for (var i = 0; i < elements.length; i++) {\n        var element = elements[i];\n        if (element.__CE_state === CustomElementState.custom) {\n          if (isConnected(element)) {\n            this.connectedCallback(element);\n          }\n        } else {\n          this.upgradeElement(element);\n        }\n      }\n    }\n\n    /**\n     * @param {!Node} root\n     */\n\n  }, {\n    key: 'disconnectTree',\n    value: function disconnectTree(root) {\n      var elements = [];\n\n      walkDeepDescendantElements(root, function (element) {\n        return elements.push(element);\n      });\n\n      for (var i = 0; i < elements.length; i++) {\n        var element = elements[i];\n        if (element.__CE_state === CustomElementState.custom) {\n          this.disconnectedCallback(element);\n        }\n      }\n    }\n\n    /**\n     * Upgrades all uncustomized custom elements at and below a root node for\n     * which there is a definition. When custom element reaction callbacks are\n     * assumed to be called synchronously (which, by the current DOM / HTML spec\n     * definitions, they are *not*), callbacks for both elements customized\n     * synchronously by the parser and elements being upgraded occur in the same\n     * relative order.\n     *\n     * NOTE: This function, when used to simulate the construction of a tree that\n     * is already created but not customized (i.e. by the parser), does *not*\n     * prevent the element from reading the 'final' (true) state of the tree. For\n     * example, the element, during truly synchronous parsing / construction would\n     * see that it contains no children as they have not yet been inserted.\n     * However, this function does not modify the tree, the element will\n     * (incorrectly) have children. Additionally, self-modification restrictions\n     * for custom element constructors imposed by the DOM spec are *not* enforced.\n     *\n     *\n     * The following nested list shows the steps extending down from the HTML\n     * spec's parsing section that cause elements to be synchronously created and\n     * upgraded:\n     *\n     * The \"in body\" insertion mode:\n     * https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n     * - Switch on token:\n     *   .. other cases ..\n     *   -> Any other start tag\n     *      - [Insert an HTML element](below) for the token.\n     *\n     * Insert an HTML element:\n     * https://html.spec.whatwg.org/multipage/syntax.html#insert-an-html-element\n     * - Insert a foreign element for the token in the HTML namespace:\n     *   https://html.spec.whatwg.org/multipage/syntax.html#insert-a-foreign-element\n     *   - Create an element for a token:\n     *     https://html.spec.whatwg.org/multipage/syntax.html#create-an-element-for-the-token\n     *     - Will execute script flag is true?\n     *       - (Element queue pushed to the custom element reactions stack.)\n     *     - Create an element:\n     *       https://dom.spec.whatwg.org/#concept-create-element\n     *       - Sync CE flag is true?\n     *         - Constructor called.\n     *         - Self-modification restrictions enforced.\n     *       - Sync CE flag is false?\n     *         - (Upgrade reaction enqueued.)\n     *     - Attributes appended to element.\n     *       (`attributeChangedCallback` reactions enqueued.)\n     *     - Will execute script flag is true?\n     *       - (Element queue popped from the custom element reactions stack.\n     *         Reactions in the popped stack are invoked.)\n     *   - (Element queue pushed to the custom element reactions stack.)\n     *   - Insert the element:\n     *     https://dom.spec.whatwg.org/#concept-node-insert\n     *     - Shadow-including descendants are connected. During parsing\n     *       construction, there are no shadow-*excluding* descendants.\n     *       However, the constructor may have validly attached a shadow\n     *       tree to itself and added descendants to that shadow tree.\n     *       (`connectedCallback` reactions enqueued.)\n     *   - (Element queue popped from the custom element reactions stack.\n     *     Reactions in the popped stack are invoked.)\n     *\n     * @param {!Node} root\n     * @param {!Set<Node>=} visitedImports\n     */\n\n  }, {\n    key: 'patchAndUpgradeTree',\n    value: function patchAndUpgradeTree(root) {\n      var _this2 = this;\n\n      var visitedImports = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n\n      var elements = [];\n\n      var gatherElements = function gatherElements(element) {\n        if (element.localName === 'link' && element.getAttribute('rel') === 'import') {\n          // The HTML Imports polyfill sets a descendant element of the link to\n          // the `import` property, specifically this is *not* a Document.\n          var importNode = /** @type {?Node} */element.import;\n\n          if (importNode instanceof Node && importNode.readyState === 'complete') {\n            importNode.__CE_isImportDocument = true;\n\n            // Connected links are associated with the registry.\n            importNode.__CE_hasRegistry = true;\n          } else {\n            // If this link's import root is not available, its contents can't be\n            // walked. Wait for 'load' and walk it when it's ready.\n            element.addEventListener('load', function () {\n              var importNode = /** @type {!Node} */element.import;\n\n              if (importNode.__CE_documentLoadHandled) return;\n              importNode.__CE_documentLoadHandled = true;\n\n              importNode.__CE_isImportDocument = true;\n\n              // Connected links are associated with the registry.\n              importNode.__CE_hasRegistry = true;\n\n              // Clone the `visitedImports` set that was populated sync during\n              // the `patchAndUpgradeTree` call that caused this 'load' handler to\n              // be added. Then, remove *this* link's import node so that we can\n              // walk that import again, even if it was partially walked later\n              // during the same `patchAndUpgradeTree` call.\n              visitedImports.delete(importNode);\n\n              _this2.patchAndUpgradeTree(importNode, visitedImports);\n            });\n          }\n        } else {\n          elements.push(element);\n        }\n      };\n\n      // `walkDeepDescendantElements` populates (and internally checks against)\n      // `visitedImports` when traversing a loaded import.\n      walkDeepDescendantElements(root, gatherElements, visitedImports);\n\n      if (this._hasPatches) {\n        for (var i = 0; i < elements.length; i++) {\n          this.patch(elements[i]);\n        }\n      }\n\n      for (var _i = 0; _i < elements.length; _i++) {\n        this.upgradeElement(elements[_i]);\n      }\n    }\n\n    /**\n     * @param {!Element} element\n     */\n\n  }, {\n    key: 'upgradeElement',\n    value: function upgradeElement(element) {\n      var currentState = element.__CE_state;\n      if (currentState !== undefined) return;\n\n      var definition = this.localNameToDefinition(element.localName);\n      if (!definition) return;\n\n      definition.constructionStack.push(element);\n\n      var constructor = definition.constructor;\n      try {\n        try {\n          var result = new constructor();\n          if (result !== element) {\n            throw new Error('The custom element constructor did not produce the element being upgraded.');\n          }\n        } finally {\n          definition.constructionStack.pop();\n        }\n      } catch (e) {\n        element.__CE_state = CustomElementState.failed;\n        throw e;\n      }\n\n      element.__CE_state = CustomElementState.custom;\n      element.__CE_definition = definition;\n\n      if (definition.attributeChangedCallback) {\n        var observedAttributes = definition.observedAttributes;\n        for (var i = 0; i < observedAttributes.length; i++) {\n          var name = observedAttributes[i];\n          var value = element.getAttribute(name);\n          if (value !== null) {\n            this.attributeChangedCallback(element, name, null, value, null);\n          }\n        }\n      }\n\n      if (isConnected(element)) {\n        this.connectedCallback(element);\n      }\n    }\n\n    /**\n     * @param {!Element} element\n     */\n\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback(element) {\n      var definition = element.__CE_definition;\n      if (definition.connectedCallback) {\n        definition.connectedCallback.call(element);\n      }\n\n      element.__CE_isConnectedCallbackCalled = true;\n    }\n\n    /**\n     * @param {!Element} element\n     */\n\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback(element) {\n      if (!element.__CE_isConnectedCallbackCalled) {\n        this.connectedCallback(element);\n      }\n\n      var definition = element.__CE_definition;\n      if (definition.disconnectedCallback) {\n        definition.disconnectedCallback.call(element);\n      }\n\n      element.__CE_isConnectedCallbackCalled = undefined;\n    }\n\n    /**\n     * @param {!Element} element\n     * @param {string} name\n     * @param {?string} oldValue\n     * @param {?string} newValue\n     * @param {?string} namespace\n     */\n\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(element, name, oldValue, newValue, namespace) {\n      var definition = element.__CE_definition;\n      if (definition.attributeChangedCallback && definition.observedAttributes.indexOf(name) > -1) {\n        definition.attributeChangedCallback.call(element, name, oldValue, newValue, namespace);\n      }\n    }\n  }]);\n  return CustomElementInternals;\n}();\n\nvar DocumentConstructionObserver = function () {\n  function DocumentConstructionObserver(internals, doc) {\n    classCallCheck(this, DocumentConstructionObserver);\n\n    /**\n     * @type {!CustomElementInternals}\n     */\n    this._internals = internals;\n\n    /**\n     * @type {!Document}\n     */\n    this._document = doc;\n\n    /**\n     * @type {MutationObserver|undefined}\n     */\n    this._observer = undefined;\n\n    // Simulate tree construction for all currently accessible nodes in the\n    // document.\n    this._internals.patchAndUpgradeTree(this._document);\n\n    if (this._document.readyState === 'loading') {\n      this._observer = new MutationObserver(this._handleMutations.bind(this));\n\n      // Nodes created by the parser are given to the observer *before* the next\n      // task runs. Inline scripts are run in a new task. This means that the\n      // observer will be able to handle the newly parsed nodes before the inline\n      // script is run.\n      this._observer.observe(this._document, {\n        childList: true,\n        subtree: true\n      });\n    }\n  }\n\n  createClass(DocumentConstructionObserver, [{\n    key: 'disconnect',\n    value: function disconnect() {\n      if (this._observer) {\n        this._observer.disconnect();\n      }\n    }\n\n    /**\n     * @param {!Array<!MutationRecord>} mutations\n     */\n\n  }, {\n    key: '_handleMutations',\n    value: function _handleMutations(mutations) {\n      // Once the document's `readyState` is 'interactive' or 'complete', all new\n      // nodes created within that document will be the result of script and\n      // should be handled by patching.\n      var readyState = this._document.readyState;\n      if (readyState === 'interactive' || readyState === 'complete') {\n        this.disconnect();\n      }\n\n      for (var i = 0; i < mutations.length; i++) {\n        var addedNodes = mutations[i].addedNodes;\n        for (var j = 0; j < addedNodes.length; j++) {\n          var node = addedNodes[j];\n          this._internals.patchAndUpgradeTree(node);\n        }\n      }\n    }\n  }]);\n  return DocumentConstructionObserver;\n}();\n\n/**\n * @template T\n */\nvar Deferred = function () {\n  function Deferred() {\n    var _this = this;\n\n    classCallCheck(this, Deferred);\n\n    /**\n     * @private\n     * @type {T|undefined}\n     */\n    this._value = undefined;\n\n    /**\n     * @private\n     * @type {Function|undefined}\n     */\n    this._resolve = undefined;\n\n    /**\n     * @private\n     * @type {!Promise<T>}\n     */\n    this._promise = new Promise(function (resolve) {\n      _this._resolve = resolve;\n\n      if (_this._value) {\n        resolve(_this._value);\n      }\n    });\n  }\n\n  /**\n   * @param {T} value\n   */\n\n\n  createClass(Deferred, [{\n    key: 'resolve',\n    value: function resolve(value) {\n      if (this._value) {\n        throw new Error('Already resolved.');\n      }\n\n      this._value = value;\n\n      if (this._resolve) {\n        this._resolve(value);\n      }\n    }\n\n    /**\n     * @return {!Promise<T>}\n     */\n\n  }, {\n    key: 'toPromise',\n    value: function toPromise() {\n      return this._promise;\n    }\n  }]);\n  return Deferred;\n}();\n\n/**\n * @unrestricted\n */\n\nvar CustomElementRegistry = function () {\n\n  /**\n   * @param {!CustomElementInternals} internals\n   */\n  function CustomElementRegistry(internals) {\n    classCallCheck(this, CustomElementRegistry);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this._elementDefinitionIsRunning = false;\n\n    /**\n     * @private\n     * @type {!CustomElementInternals}\n     */\n    this._internals = internals;\n\n    /**\n     * @private\n     * @type {!Map<string, !Deferred<undefined>>}\n     */\n    this._whenDefinedDeferred = new Map();\n\n    /**\n     * The default flush callback triggers the document walk synchronously.\n     * @private\n     * @type {!Function}\n     */\n    this._flushCallback = function (fn) {\n      return fn();\n    };\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this._flushPending = false;\n\n    /**\n     * @private\n     * @type {!Array<string>}\n     */\n    this._unflushedLocalNames = [];\n\n    /**\n     * @private\n     * @type {!DocumentConstructionObserver}\n     */\n    this._documentConstructionObserver = new DocumentConstructionObserver(internals, document);\n  }\n\n  /**\n   * @param {string} localName\n   * @param {!Function} constructor\n   */\n\n\n  createClass(CustomElementRegistry, [{\n    key: 'define',\n    value: function define(localName, constructor) {\n      var _this = this;\n\n      if (!(constructor instanceof Function)) {\n        throw new TypeError('Custom element constructors must be functions.');\n      }\n\n      if (!isValidCustomElementName(localName)) {\n        throw new SyntaxError('The element name \\'' + localName + '\\' is not valid.');\n      }\n\n      if (this._internals.localNameToDefinition(localName)) {\n        throw new Error('A custom element with name \\'' + localName + '\\' has already been defined.');\n      }\n\n      if (this._elementDefinitionIsRunning) {\n        throw new Error('A custom element is already being defined.');\n      }\n      this._elementDefinitionIsRunning = true;\n\n      var connectedCallback = void 0;\n      var disconnectedCallback = void 0;\n      var adoptedCallback = void 0;\n      var attributeChangedCallback = void 0;\n      var observedAttributes = void 0;\n      try {\n        var getCallback = function getCallback(name) {\n          var callbackValue = prototype[name];\n          if (callbackValue !== undefined && !(callbackValue instanceof Function)) {\n            throw new Error('The \\'' + name + '\\' callback must be a function.');\n          }\n          return callbackValue;\n        };\n\n        /** @type {!Object} */\n        var prototype = constructor.prototype;\n        if (!(prototype instanceof Object)) {\n          throw new TypeError('The custom element constructor\\'s prototype is not an object.');\n        }\n\n        connectedCallback = getCallback('connectedCallback');\n        disconnectedCallback = getCallback('disconnectedCallback');\n        adoptedCallback = getCallback('adoptedCallback');\n        attributeChangedCallback = getCallback('attributeChangedCallback');\n        observedAttributes = constructor['observedAttributes'] || [];\n      } catch (e) {\n        return;\n      } finally {\n        this._elementDefinitionIsRunning = false;\n      }\n\n      var definition = {\n        localName: localName,\n        constructor: constructor,\n        connectedCallback: connectedCallback,\n        disconnectedCallback: disconnectedCallback,\n        adoptedCallback: adoptedCallback,\n        attributeChangedCallback: attributeChangedCallback,\n        observedAttributes: observedAttributes,\n        constructionStack: []\n      };\n\n      this._internals.setDefinition(localName, definition);\n\n      this._unflushedLocalNames.push(localName);\n\n      // If we've already called the flush callback and it hasn't called back yet,\n      // don't call it again.\n      if (!this._flushPending) {\n        this._flushPending = true;\n        this._flushCallback(function () {\n          return _this._flush();\n        });\n      }\n    }\n  }, {\n    key: '_flush',\n    value: function _flush() {\n      // If no new definitions were defined, don't attempt to flush. This could\n      // happen if a flush callback keeps the function it is given and calls it\n      // multiple times.\n      if (this._flushPending === false) return;\n\n      this._flushPending = false;\n      this._internals.patchAndUpgradeTree(document);\n\n      while (this._unflushedLocalNames.length > 0) {\n        var localName = this._unflushedLocalNames.shift();\n        var deferred = this._whenDefinedDeferred.get(localName);\n        if (deferred) {\n          deferred.resolve(undefined);\n        }\n      }\n    }\n\n    /**\n     * @param {string} localName\n     * @return {Function|undefined}\n     */\n\n  }, {\n    key: 'get',\n    value: function get$$1(localName) {\n      var definition = this._internals.localNameToDefinition(localName);\n      if (definition) {\n        return definition.constructor;\n      }\n\n      return undefined;\n    }\n\n    /**\n     * @param {string} localName\n     * @return {!Promise<undefined>}\n     */\n\n  }, {\n    key: 'whenDefined',\n    value: function whenDefined(localName) {\n      if (!isValidCustomElementName(localName)) {\n        return Promise.reject(new SyntaxError('\\'' + localName + '\\' is not a valid custom element name.'));\n      }\n\n      var prior = this._whenDefinedDeferred.get(localName);\n      if (prior) {\n        return prior.toPromise();\n      }\n\n      var deferred = new Deferred();\n      this._whenDefinedDeferred.set(localName, deferred);\n\n      var definition = this._internals.localNameToDefinition(localName);\n      // Resolve immediately only if the given local name has a definition *and*\n      // the full document walk to upgrade elements with that local name has\n      // already happened.\n      if (definition && this._unflushedLocalNames.indexOf(localName) === -1) {\n        deferred.resolve(undefined);\n      }\n\n      return deferred.toPromise();\n    }\n  }, {\n    key: 'polyfillWrapFlushCallback',\n    value: function polyfillWrapFlushCallback(outer) {\n      this._documentConstructionObserver.disconnect();\n      var inner = this._flushCallback;\n      this._flushCallback = function (flush) {\n        return outer(function () {\n          return inner(flush);\n        });\n      };\n    }\n  }]);\n  return CustomElementRegistry;\n}();\n\nwindow['CustomElementRegistry'] = CustomElementRegistry;\nCustomElementRegistry.prototype['define'] = CustomElementRegistry.prototype.define;\nCustomElementRegistry.prototype['get'] = CustomElementRegistry.prototype.get;\nCustomElementRegistry.prototype['whenDefined'] = CustomElementRegistry.prototype.whenDefined;\nCustomElementRegistry.prototype['polyfillWrapFlushCallback'] = CustomElementRegistry.prototype.polyfillWrapFlushCallback;\n\nvar Native = {\n  Document_createElement: window.Document.prototype.createElement,\n  Document_createElementNS: window.Document.prototype.createElementNS,\n  Document_importNode: window.Document.prototype.importNode,\n  Document_prepend: window.Document.prototype['prepend'],\n  Document_append: window.Document.prototype['append'],\n  Node_cloneNode: window.Node.prototype.cloneNode,\n  Node_appendChild: window.Node.prototype.appendChild,\n  Node_insertBefore: window.Node.prototype.insertBefore,\n  Node_removeChild: window.Node.prototype.removeChild,\n  Node_replaceChild: window.Node.prototype.replaceChild,\n  Node_textContent: Object.getOwnPropertyDescriptor(window.Node.prototype, 'textContent'),\n  Element_attachShadow: window.Element.prototype['attachShadow'],\n  Element_innerHTML: Object.getOwnPropertyDescriptor(window.Element.prototype, 'innerHTML'),\n  Element_getAttribute: window.Element.prototype.getAttribute,\n  Element_setAttribute: window.Element.prototype.setAttribute,\n  Element_removeAttribute: window.Element.prototype.removeAttribute,\n  Element_getAttributeNS: window.Element.prototype.getAttributeNS,\n  Element_setAttributeNS: window.Element.prototype.setAttributeNS,\n  Element_removeAttributeNS: window.Element.prototype.removeAttributeNS,\n  Element_insertAdjacentElement: window.Element.prototype['insertAdjacentElement'],\n  Element_prepend: window.Element.prototype['prepend'],\n  Element_append: window.Element.prototype['append'],\n  Element_before: window.Element.prototype['before'],\n  Element_after: window.Element.prototype['after'],\n  Element_replaceWith: window.Element.prototype['replaceWith'],\n  Element_remove: window.Element.prototype['remove'],\n  HTMLElement: window.HTMLElement,\n  HTMLElement_innerHTML: Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML'),\n  HTMLElement_insertAdjacentElement: window.HTMLElement.prototype['insertAdjacentElement']\n};\n\n/**\n * This class exists only to work around Closure's lack of a way to describe\n * singletons. It represents the 'already constructed marker' used in custom\n * element construction stacks.\n *\n * https://html.spec.whatwg.org/#concept-already-constructed-marker\n */\nvar AlreadyConstructedMarker = function AlreadyConstructedMarker() {\n  classCallCheck(this, AlreadyConstructedMarker);\n};\n\nvar AlreadyConstructedMarker$1 = new AlreadyConstructedMarker();\n\n/**\n * @param {!CustomElementInternals} internals\n */\nvar PatchHTMLElement = function (internals) {\n  window['HTMLElement'] = function () {\n    /**\n     * @type {function(new: HTMLElement): !HTMLElement}\n     */\n    function HTMLElement() {\n      // This should really be `new.target` but `new.target` can't be emulated\n      // in ES5. Assuming the user keeps the default value of the constructor's\n      // prototype's `constructor` property, this is equivalent.\n      /** @type {!Function} */\n      var constructor = this.constructor;\n\n      var definition = internals.constructorToDefinition(constructor);\n      if (!definition) {\n        throw new Error('The custom element being constructed was not registered with `customElements`.');\n      }\n\n      var constructionStack = definition.constructionStack;\n\n      if (constructionStack.length === 0) {\n        var _element = Native.Document_createElement.call(document, definition.localName);\n        Object.setPrototypeOf(_element, constructor.prototype);\n        _element.__CE_state = CustomElementState.custom;\n        _element.__CE_definition = definition;\n        internals.patch(_element);\n        return _element;\n      }\n\n      var lastIndex = constructionStack.length - 1;\n      var element = constructionStack[lastIndex];\n      if (element === AlreadyConstructedMarker$1) {\n        throw new Error('The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.');\n      }\n      constructionStack[lastIndex] = AlreadyConstructedMarker$1;\n\n      Object.setPrototypeOf(element, constructor.prototype);\n      internals.patch( /** @type {!HTMLElement} */element);\n\n      return element;\n    }\n\n    HTMLElement.prototype = Native.HTMLElement.prototype;\n\n    return HTMLElement;\n  }();\n};\n\n/**\n * @param {!CustomElementInternals} internals\n * @param {!Object} destination\n * @param {!ParentNodeNativeMethods} builtIn\n */\nvar PatchParentNode = function (internals, destination, builtIn) {\n  /**\n   * @param {...(!Node|string)} nodes\n   */\n  destination['prepend'] = function () {\n    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {\n      nodes[_key] = arguments[_key];\n    }\n\n    // TODO: Fix this for when one of `nodes` is a DocumentFragment!\n    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {\n      // DocumentFragments are not connected and will not be added to the list.\n      return node instanceof Node && isConnected(node);\n    });\n\n    builtIn.prepend.apply(this, nodes);\n\n    for (var i = 0; i < connectedBefore.length; i++) {\n      internals.disconnectTree(connectedBefore[i]);\n    }\n\n    if (isConnected(this)) {\n      for (var _i = 0; _i < nodes.length; _i++) {\n        var node = nodes[_i];\n        if (node instanceof Element) {\n          internals.connectTree(node);\n        }\n      }\n    }\n  };\n\n  /**\n   * @param {...(!Node|string)} nodes\n   */\n  destination['append'] = function () {\n    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      nodes[_key2] = arguments[_key2];\n    }\n\n    // TODO: Fix this for when one of `nodes` is a DocumentFragment!\n    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {\n      // DocumentFragments are not connected and will not be added to the list.\n      return node instanceof Node && isConnected(node);\n    });\n\n    builtIn.append.apply(this, nodes);\n\n    for (var i = 0; i < connectedBefore.length; i++) {\n      internals.disconnectTree(connectedBefore[i]);\n    }\n\n    if (isConnected(this)) {\n      for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n        var node = nodes[_i2];\n        if (node instanceof Element) {\n          internals.connectTree(node);\n        }\n      }\n    }\n  };\n};\n\n/**\n * @param {!CustomElementInternals} internals\n */\nvar PatchDocument = function (internals) {\n  setPropertyUnchecked(Document.prototype, 'createElement',\n  /**\n   * @this {Document}\n   * @param {string} localName\n   * @return {!Element}\n   */\n  function (localName) {\n    // Only create custom elements if this document is associated with the registry.\n    if (this.__CE_hasRegistry) {\n      var definition = internals.localNameToDefinition(localName);\n      if (definition) {\n        return new definition.constructor();\n      }\n    }\n\n    var result = /** @type {!Element} */\n    Native.Document_createElement.call(this, localName);\n    internals.patch(result);\n    return result;\n  });\n\n  setPropertyUnchecked(Document.prototype, 'importNode',\n  /**\n   * @this {Document}\n   * @param {!Node} node\n   * @param {boolean=} deep\n   * @return {!Node}\n   */\n  function (node, deep) {\n    var clone = Native.Document_importNode.call(this, node, deep);\n    // Only create custom elements if this document is associated with the registry.\n    if (!this.__CE_hasRegistry) {\n      internals.patchTree(clone);\n    } else {\n      internals.patchAndUpgradeTree(clone);\n    }\n    return clone;\n  });\n\n  var NS_HTML = \"http://www.w3.org/1999/xhtml\";\n\n  setPropertyUnchecked(Document.prototype, 'createElementNS',\n  /**\n   * @this {Document}\n   * @param {?string} namespace\n   * @param {string} localName\n   * @return {!Element}\n   */\n  function (namespace, localName) {\n    // Only create custom elements if this document is associated with the registry.\n    if (this.__CE_hasRegistry && (namespace === null || namespace === NS_HTML)) {\n      var definition = internals.localNameToDefinition(localName);\n      if (definition) {\n        return new definition.constructor();\n      }\n    }\n\n    var result = /** @type {!Element} */\n    Native.Document_createElementNS.call(this, namespace, localName);\n    internals.patch(result);\n    return result;\n  });\n\n  PatchParentNode(internals, Document.prototype, {\n    prepend: Native.Document_prepend,\n    append: Native.Document_append\n  });\n};\n\n/**\n * @param {!CustomElementInternals} internals\n */\nvar PatchNode = function (internals) {\n  // `Node#nodeValue` is implemented on `Attr`.\n  // `Node#textContent` is implemented on `Attr`, `Element`.\n\n  setPropertyUnchecked(Node.prototype, 'insertBefore',\n  /**\n   * @this {Node}\n   * @param {!Node} node\n   * @param {?Node} refNode\n   * @return {!Node}\n   */\n  function (node, refNode) {\n    if (node instanceof DocumentFragment) {\n      var insertedNodes = Array.prototype.slice.apply(node.childNodes);\n      var _nativeResult = Native.Node_insertBefore.call(this, node, refNode);\n\n      // DocumentFragments can't be connected, so `disconnectTree` will never\n      // need to be called on a DocumentFragment's children after inserting it.\n\n      if (isConnected(this)) {\n        for (var i = 0; i < insertedNodes.length; i++) {\n          internals.connectTree(insertedNodes[i]);\n        }\n      }\n\n      return _nativeResult;\n    }\n\n    var nodeWasConnected = isConnected(node);\n    var nativeResult = Native.Node_insertBefore.call(this, node, refNode);\n\n    if (nodeWasConnected) {\n      internals.disconnectTree(node);\n    }\n\n    if (isConnected(this)) {\n      internals.connectTree(node);\n    }\n\n    return nativeResult;\n  });\n\n  setPropertyUnchecked(Node.prototype, 'appendChild',\n  /**\n   * @this {Node}\n   * @param {!Node} node\n   * @return {!Node}\n   */\n  function (node) {\n    if (node instanceof DocumentFragment) {\n      var insertedNodes = Array.prototype.slice.apply(node.childNodes);\n      var _nativeResult2 = Native.Node_appendChild.call(this, node);\n\n      // DocumentFragments can't be connected, so `disconnectTree` will never\n      // need to be called on a DocumentFragment's children after inserting it.\n\n      if (isConnected(this)) {\n        for (var i = 0; i < insertedNodes.length; i++) {\n          internals.connectTree(insertedNodes[i]);\n        }\n      }\n\n      return _nativeResult2;\n    }\n\n    var nodeWasConnected = isConnected(node);\n    var nativeResult = Native.Node_appendChild.call(this, node);\n\n    if (nodeWasConnected) {\n      internals.disconnectTree(node);\n    }\n\n    if (isConnected(this)) {\n      internals.connectTree(node);\n    }\n\n    return nativeResult;\n  });\n\n  setPropertyUnchecked(Node.prototype, 'cloneNode',\n  /**\n   * @this {Node}\n   * @param {boolean=} deep\n   * @return {!Node}\n   */\n  function (deep) {\n    var clone = Native.Node_cloneNode.call(this, deep);\n    // Only create custom elements if this element's owner document is\n    // associated with the registry.\n    if (!this.ownerDocument.__CE_hasRegistry) {\n      internals.patchTree(clone);\n    } else {\n      internals.patchAndUpgradeTree(clone);\n    }\n    return clone;\n  });\n\n  setPropertyUnchecked(Node.prototype, 'removeChild',\n  /**\n   * @this {Node}\n   * @param {!Node} node\n   * @return {!Node}\n   */\n  function (node) {\n    var nodeWasConnected = isConnected(node);\n    var nativeResult = Native.Node_removeChild.call(this, node);\n\n    if (nodeWasConnected) {\n      internals.disconnectTree(node);\n    }\n\n    return nativeResult;\n  });\n\n  setPropertyUnchecked(Node.prototype, 'replaceChild',\n  /**\n   * @this {Node}\n   * @param {!Node} nodeToInsert\n   * @param {!Node} nodeToRemove\n   * @return {!Node}\n   */\n  function (nodeToInsert, nodeToRemove) {\n    if (nodeToInsert instanceof DocumentFragment) {\n      var insertedNodes = Array.prototype.slice.apply(nodeToInsert.childNodes);\n      var _nativeResult3 = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);\n\n      // DocumentFragments can't be connected, so `disconnectTree` will never\n      // need to be called on a DocumentFragment's children after inserting it.\n\n      if (isConnected(this)) {\n        internals.disconnectTree(nodeToRemove);\n        for (var i = 0; i < insertedNodes.length; i++) {\n          internals.connectTree(insertedNodes[i]);\n        }\n      }\n\n      return _nativeResult3;\n    }\n\n    var nodeToInsertWasConnected = isConnected(nodeToInsert);\n    var nativeResult = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);\n    var thisIsConnected = isConnected(this);\n\n    if (thisIsConnected) {\n      internals.disconnectTree(nodeToRemove);\n    }\n\n    if (nodeToInsertWasConnected) {\n      internals.disconnectTree(nodeToInsert);\n    }\n\n    if (thisIsConnected) {\n      internals.connectTree(nodeToInsert);\n    }\n\n    return nativeResult;\n  });\n\n  function patch_textContent(destination, baseDescriptor) {\n    Object.defineProperty(destination, 'textContent', {\n      enumerable: baseDescriptor.enumerable,\n      configurable: true,\n      get: baseDescriptor.get,\n      set: /** @this {Node} */function set(assignedValue) {\n        // If this is a text node then there are no nodes to disconnect.\n        if (this.nodeType === Node.TEXT_NODE) {\n          baseDescriptor.set.call(this, assignedValue);\n          return;\n        }\n\n        var removedNodes = undefined;\n        // Checking for `firstChild` is faster than reading `childNodes.length`\n        // to compare with 0.\n        if (this.firstChild) {\n          // Using `childNodes` is faster than `children`, even though we only\n          // care about elements.\n          var childNodes = this.childNodes;\n          var childNodesLength = childNodes.length;\n          if (childNodesLength > 0 && isConnected(this)) {\n            // Copying an array by iterating is faster than using slice.\n            removedNodes = new Array(childNodesLength);\n            for (var i = 0; i < childNodesLength; i++) {\n              removedNodes[i] = childNodes[i];\n            }\n          }\n        }\n\n        baseDescriptor.set.call(this, assignedValue);\n\n        if (removedNodes) {\n          for (var _i = 0; _i < removedNodes.length; _i++) {\n            internals.disconnectTree(removedNodes[_i]);\n          }\n        }\n      }\n    });\n  }\n\n  if (Native.Node_textContent && Native.Node_textContent.get) {\n    patch_textContent(Node.prototype, Native.Node_textContent);\n  } else {\n    internals.addPatch(function (element) {\n      patch_textContent(element, {\n        enumerable: true,\n        configurable: true,\n        // NOTE: This implementation of the `textContent` getter assumes that\n        // text nodes' `textContent` getter will not be patched.\n        get: /** @this {Node} */function get() {\n          /** @type {!Array<string>} */\n          var parts = [];\n\n          for (var i = 0; i < this.childNodes.length; i++) {\n            parts.push(this.childNodes[i].textContent);\n          }\n\n          return parts.join('');\n        },\n        set: /** @this {Node} */function set(assignedValue) {\n          while (this.firstChild) {\n            Native.Node_removeChild.call(this, this.firstChild);\n          }\n          Native.Node_appendChild.call(this, document.createTextNode(assignedValue));\n        }\n      });\n    });\n  }\n};\n\n/**\n * @param {!CustomElementInternals} internals\n * @param {!Object} destination\n * @param {!ChildNodeNativeMethods} builtIn\n */\nvar PatchChildNode = function (internals, destination, builtIn) {\n  /**\n   * @param {...(!Node|string)} nodes\n   */\n  destination['before'] = function () {\n    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {\n      nodes[_key] = arguments[_key];\n    }\n\n    // TODO: Fix this for when one of `nodes` is a DocumentFragment!\n    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {\n      // DocumentFragments are not connected and will not be added to the list.\n      return node instanceof Node && isConnected(node);\n    });\n\n    builtIn.before.apply(this, nodes);\n\n    for (var i = 0; i < connectedBefore.length; i++) {\n      internals.disconnectTree(connectedBefore[i]);\n    }\n\n    if (isConnected(this)) {\n      for (var _i = 0; _i < nodes.length; _i++) {\n        var node = nodes[_i];\n        if (node instanceof Element) {\n          internals.connectTree(node);\n        }\n      }\n    }\n  };\n\n  /**\n   * @param {...(!Node|string)} nodes\n   */\n  destination['after'] = function () {\n    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      nodes[_key2] = arguments[_key2];\n    }\n\n    // TODO: Fix this for when one of `nodes` is a DocumentFragment!\n    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {\n      // DocumentFragments are not connected and will not be added to the list.\n      return node instanceof Node && isConnected(node);\n    });\n\n    builtIn.after.apply(this, nodes);\n\n    for (var i = 0; i < connectedBefore.length; i++) {\n      internals.disconnectTree(connectedBefore[i]);\n    }\n\n    if (isConnected(this)) {\n      for (var _i2 = 0; _i2 < nodes.length; _i2++) {\n        var node = nodes[_i2];\n        if (node instanceof Element) {\n          internals.connectTree(node);\n        }\n      }\n    }\n  };\n\n  /**\n   * @param {...(!Node|string)} nodes\n   */\n  destination['replaceWith'] = function () {\n    for (var _len3 = arguments.length, nodes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      nodes[_key3] = arguments[_key3];\n    }\n\n    // TODO: Fix this for when one of `nodes` is a DocumentFragment!\n    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {\n      // DocumentFragments are not connected and will not be added to the list.\n      return node instanceof Node && isConnected(node);\n    });\n\n    var wasConnected = isConnected(this);\n\n    builtIn.replaceWith.apply(this, nodes);\n\n    for (var i = 0; i < connectedBefore.length; i++) {\n      internals.disconnectTree(connectedBefore[i]);\n    }\n\n    if (wasConnected) {\n      internals.disconnectTree(this);\n      for (var _i3 = 0; _i3 < nodes.length; _i3++) {\n        var node = nodes[_i3];\n        if (node instanceof Element) {\n          internals.connectTree(node);\n        }\n      }\n    }\n  };\n\n  destination['remove'] = function () {\n    var wasConnected = isConnected(this);\n\n    builtIn.remove.call(this);\n\n    if (wasConnected) {\n      internals.disconnectTree(this);\n    }\n  };\n};\n\n/**\n * @param {!CustomElementInternals} internals\n */\nvar PatchElement = function (internals) {\n  if (Native.Element_attachShadow) {\n    setPropertyUnchecked(Element.prototype, 'attachShadow',\n    /**\n     * @this {Element}\n     * @param {!{mode: string}} init\n     * @return {ShadowRoot}\n     */\n    function (init) {\n      var shadowRoot = Native.Element_attachShadow.call(this, init);\n      this.__CE_shadowRoot = shadowRoot;\n      return shadowRoot;\n    });\n  } else {\n    console.warn('Custom Elements: `Element#attachShadow` was not patched.');\n  }\n\n  function patch_innerHTML(destination, baseDescriptor) {\n    Object.defineProperty(destination, 'innerHTML', {\n      enumerable: baseDescriptor.enumerable,\n      configurable: true,\n      get: baseDescriptor.get,\n      set: /** @this {Element} */function set(htmlString) {\n        var _this = this;\n\n        var isConnected$$1 = isConnected(this);\n\n        // NOTE: In IE11, when using the native `innerHTML` setter, all nodes\n        // that were previously descendants of the context element have all of\n        // their children removed as part of the set - the entire subtree is\n        // 'disassembled'. This work around walks the subtree *before* using the\n        // native setter.\n        /** @type {!Array<!Element>|undefined} */\n        var removedElements = undefined;\n        if (isConnected$$1) {\n          removedElements = [];\n          walkDeepDescendantElements(this, function (element) {\n            if (element !== _this) {\n              removedElements.push(element);\n            }\n          });\n        }\n\n        baseDescriptor.set.call(this, htmlString);\n\n        if (removedElements) {\n          for (var i = 0; i < removedElements.length; i++) {\n            var element = removedElements[i];\n            if (element.__CE_state === CustomElementState.custom) {\n              internals.disconnectedCallback(element);\n            }\n          }\n        }\n\n        // Only create custom elements if this element's owner document is\n        // associated with the registry.\n        if (!this.ownerDocument.__CE_hasRegistry) {\n          internals.patchTree(this);\n        } else {\n          internals.patchAndUpgradeTree(this);\n        }\n        return htmlString;\n      }\n    });\n  }\n\n  if (Native.Element_innerHTML && Native.Element_innerHTML.get) {\n    patch_innerHTML(Element.prototype, Native.Element_innerHTML);\n  } else if (Native.HTMLElement_innerHTML && Native.HTMLElement_innerHTML.get) {\n    patch_innerHTML(HTMLElement.prototype, Native.HTMLElement_innerHTML);\n  } else {\n\n    /** @type {HTMLDivElement} */\n    var rawDiv = Native.Document_createElement.call(document, 'div');\n\n    internals.addPatch(function (element) {\n      patch_innerHTML(element, {\n        enumerable: true,\n        configurable: true,\n        // Implements getting `innerHTML` by performing an unpatched `cloneNode`\n        // of the element and returning the resulting element's `innerHTML`.\n        // TODO: Is this too expensive?\n        get: /** @this {Element} */function get() {\n          return Native.Node_cloneNode.call(this, true).innerHTML;\n        },\n        // Implements setting `innerHTML` by creating an unpatched element,\n        // setting `innerHTML` of that element and replacing the target\n        // element's children with those of the unpatched element.\n        set: /** @this {Element} */function set(assignedValue) {\n          // NOTE: re-route to `content` for `template` elements.\n          // We need to do this because `template.appendChild` does not\n          // route into `template.content`.\n          /** @type {!Node} */\n          var content = this.localName === 'template' ? /** @type {!HTMLTemplateElement} */this.content : this;\n          rawDiv.innerHTML = assignedValue;\n\n          while (content.childNodes.length > 0) {\n            Native.Node_removeChild.call(content, content.childNodes[0]);\n          }\n          while (rawDiv.childNodes.length > 0) {\n            Native.Node_appendChild.call(content, rawDiv.childNodes[0]);\n          }\n        }\n      });\n    });\n  }\n\n  setPropertyUnchecked(Element.prototype, 'setAttribute',\n  /**\n   * @this {Element}\n   * @param {string} name\n   * @param {string} newValue\n   */\n  function (name, newValue) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CustomElementState.custom) {\n      return Native.Element_setAttribute.call(this, name, newValue);\n    }\n\n    var oldValue = Native.Element_getAttribute.call(this, name);\n    Native.Element_setAttribute.call(this, name, newValue);\n    newValue = Native.Element_getAttribute.call(this, name);\n    internals.attributeChangedCallback(this, name, oldValue, newValue, null);\n  });\n\n  setPropertyUnchecked(Element.prototype, 'setAttributeNS',\n  /**\n   * @this {Element}\n   * @param {?string} namespace\n   * @param {string} name\n   * @param {string} newValue\n   */\n  function (namespace, name, newValue) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CustomElementState.custom) {\n      return Native.Element_setAttributeNS.call(this, namespace, name, newValue);\n    }\n\n    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    Native.Element_setAttributeNS.call(this, namespace, name, newValue);\n    newValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);\n  });\n\n  setPropertyUnchecked(Element.prototype, 'removeAttribute',\n  /**\n   * @this {Element}\n   * @param {string} name\n   */\n  function (name) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CustomElementState.custom) {\n      return Native.Element_removeAttribute.call(this, name);\n    }\n\n    var oldValue = Native.Element_getAttribute.call(this, name);\n    Native.Element_removeAttribute.call(this, name);\n    if (oldValue !== null) {\n      internals.attributeChangedCallback(this, name, oldValue, null, null);\n    }\n  });\n\n  setPropertyUnchecked(Element.prototype, 'removeAttributeNS',\n  /**\n   * @this {Element}\n   * @param {?string} namespace\n   * @param {string} name\n   */\n  function (namespace, name) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CustomElementState.custom) {\n      return Native.Element_removeAttributeNS.call(this, namespace, name);\n    }\n\n    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    Native.Element_removeAttributeNS.call(this, namespace, name);\n    // In older browsers, `Element#getAttributeNS` may return the empty string\n    // instead of null if the attribute does not exist. For details, see;\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS#Notes\n    var newValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    if (oldValue !== newValue) {\n      internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);\n    }\n  });\n\n  function patch_insertAdjacentElement(destination, baseMethod) {\n    setPropertyUnchecked(destination, 'insertAdjacentElement',\n    /**\n     * @this {Element}\n     * @param {string} where\n     * @param {!Element} element\n     * @return {?Element}\n     */\n    function (where, element) {\n      var wasConnected = isConnected(element);\n      var insertedElement = /** @type {!Element} */\n      baseMethod.call(this, where, element);\n\n      if (wasConnected) {\n        internals.disconnectTree(element);\n      }\n\n      if (isConnected(insertedElement)) {\n        internals.connectTree(element);\n      }\n      return insertedElement;\n    });\n  }\n\n  if (Native.HTMLElement_insertAdjacentElement) {\n    patch_insertAdjacentElement(HTMLElement.prototype, Native.HTMLElement_insertAdjacentElement);\n  } else if (Native.Element_insertAdjacentElement) {\n    patch_insertAdjacentElement(Element.prototype, Native.Element_insertAdjacentElement);\n  } else {\n    console.warn('Custom Elements: `Element#insertAdjacentElement` was not patched.');\n  }\n\n  PatchParentNode(internals, Element.prototype, {\n    prepend: Native.Element_prepend,\n    append: Native.Element_append\n  });\n\n  PatchChildNode(internals, Element.prototype, {\n    before: Native.Element_before,\n    after: Native.Element_after,\n    replaceWith: Native.Element_replaceWith,\n    remove: Native.Element_remove\n  });\n};\n\n/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nvar priorCustomElements = window['customElements'];\n\nif (!priorCustomElements || priorCustomElements['forcePolyfill'] || typeof priorCustomElements['define'] != 'function' || typeof priorCustomElements['get'] != 'function') {\n  /** @type {!CustomElementInternals} */\n  var internals = new CustomElementInternals();\n\n  PatchHTMLElement(internals);\n  PatchDocument(internals);\n  PatchNode(internals);\n  PatchElement(internals);\n\n  // The main document is always associated with the registry.\n  document.__CE_hasRegistry = true;\n\n  /** @type {!CustomElementRegistry} */\n  var customElements$1 = new CustomElementRegistry(internals);\n\n  Object.defineProperty(window, 'customElements', {\n    configurable: true,\n    enumerable: true,\n    value: customElements$1\n  });\n}\n\n/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n// @version 0.7.22\nif (typeof WeakMap === \"undefined\") {\n  (function () {\n    var defineProperty = Object.defineProperty;\n    var counter = Date.now() % 1e9;\n    var WeakMap = function WeakMap() {\n      this.name = \"__st\" + (Math.random() * 1e9 >>> 0) + (counter++ + \"__\");\n    };\n    WeakMap.prototype = {\n      set: function set(key, value) {\n        var entry = key[this.name];\n        if (entry && entry[0] === key) entry[1] = value;else defineProperty(key, this.name, {\n          value: [key, value],\n          writable: true\n        });\n        return this;\n      },\n      get: function get(key) {\n        var entry;\n        return (entry = key[this.name]) && entry[0] === key ? entry[1] : undefined;\n      },\n      \"delete\": function _delete(key) {\n        var entry = key[this.name];\n        if (!entry || entry[0] !== key) return false;\n        entry[0] = entry[1] = undefined;\n        return true;\n      },\n      has: function has(key) {\n        var entry = key[this.name];\n        if (!entry) return false;\n        return entry[0] === key;\n      }\n    };\n    window.WeakMap = WeakMap;\n  })();\n}\n\n(function (global) {\n  if (global.JsMutationObserver) {\n    return;\n  }\n  var registrationsTable = new WeakMap();\n  var setImmediate;\n  if (/Trident|Edge/.test(navigator.userAgent)) {\n    setImmediate = setTimeout;\n  } else if (window.setImmediate) {\n    setImmediate = window.setImmediate;\n  } else {\n    var setImmediateQueue = [];\n    var sentinel = String(Math.random());\n    window.addEventListener(\"message\", function (e) {\n      if (e.data === sentinel) {\n        var queue = setImmediateQueue;\n        setImmediateQueue = [];\n        queue.forEach(function (func) {\n          func();\n        });\n      }\n    });\n    setImmediate = function setImmediate(func) {\n      setImmediateQueue.push(func);\n      window.postMessage(sentinel, \"*\");\n    };\n  }\n  var isScheduled = false;\n  var scheduledObservers = [];\n  function scheduleCallback(observer) {\n    scheduledObservers.push(observer);\n    if (!isScheduled) {\n      isScheduled = true;\n      setImmediate(dispatchCallbacks);\n    }\n  }\n  function wrapIfNeeded(node) {\n    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;\n  }\n  function dispatchCallbacks() {\n    isScheduled = false;\n    var observers = scheduledObservers;\n    scheduledObservers = [];\n    observers.sort(function (o1, o2) {\n      return o1.uid_ - o2.uid_;\n    });\n    var anyNonEmpty = false;\n    observers.forEach(function (observer) {\n      var queue = observer.takeRecords();\n      removeTransientObserversFor(observer);\n      if (queue.length) {\n        observer.callback_(queue, observer);\n        anyNonEmpty = true;\n      }\n    });\n    if (anyNonEmpty) dispatchCallbacks();\n  }\n  function removeTransientObserversFor(observer) {\n    observer.nodes_.forEach(function (node) {\n      var registrations = registrationsTable.get(node);\n      if (!registrations) return;\n      registrations.forEach(function (registration) {\n        if (registration.observer === observer) registration.removeTransientObservers();\n      });\n    });\n  }\n  function forEachAncestorAndObserverEnqueueRecord(target, callback) {\n    for (var node = target; node; node = node.parentNode) {\n      var registrations = registrationsTable.get(node);\n      if (registrations) {\n        for (var j = 0; j < registrations.length; j++) {\n          var registration = registrations[j];\n          var options = registration.options;\n          if (node !== target && !options.subtree) continue;\n          var record = callback(options);\n          if (record) registration.enqueue(record);\n        }\n      }\n    }\n  }\n  var uidCounter = 0;\n  function JsMutationObserver(callback) {\n    this.callback_ = callback;\n    this.nodes_ = [];\n    this.records_ = [];\n    this.uid_ = ++uidCounter;\n  }\n  JsMutationObserver.prototype = {\n    observe: function observe(target, options) {\n      target = wrapIfNeeded(target);\n      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {\n        throw new SyntaxError();\n      }\n      var registrations = registrationsTable.get(target);\n      if (!registrations) registrationsTable.set(target, registrations = []);\n      var registration;\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i].observer === this) {\n          registration = registrations[i];\n          registration.removeListeners();\n          registration.options = options;\n          break;\n        }\n      }\n      if (!registration) {\n        registration = new Registration(this, target, options);\n        registrations.push(registration);\n        this.nodes_.push(target);\n      }\n      registration.addListeners();\n    },\n    disconnect: function disconnect() {\n      this.nodes_.forEach(function (node) {\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          var registration = registrations[i];\n          if (registration.observer === this) {\n            registration.removeListeners();\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n      this.records_ = [];\n    },\n    takeRecords: function takeRecords() {\n      var copyOfRecords = this.records_;\n      this.records_ = [];\n      return copyOfRecords;\n    }\n  };\n  function MutationRecord(type, target) {\n    this.type = type;\n    this.target = target;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.previousSibling = null;\n    this.nextSibling = null;\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.oldValue = null;\n  }\n  function copyMutationRecord(original) {\n    var record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  }\n  var currentRecord, recordWithOldValue;\n  function getRecord(type, target) {\n    return currentRecord = new MutationRecord(type, target);\n  }\n  function getRecordWithOldValue(oldValue) {\n    if (recordWithOldValue) return recordWithOldValue;\n    recordWithOldValue = copyMutationRecord(currentRecord);\n    recordWithOldValue.oldValue = oldValue;\n    return recordWithOldValue;\n  }\n  function clearRecords() {\n    currentRecord = recordWithOldValue = undefined;\n  }\n  function recordRepresentsCurrentMutation(record) {\n    return record === recordWithOldValue || record === currentRecord;\n  }\n  function selectRecord(lastRecord, newRecord) {\n    if (lastRecord === newRecord) return lastRecord;\n    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n    return null;\n  }\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n  Registration.prototype = {\n    enqueue: function enqueue(record) {\n      var records = this.observer.records_;\n      var length = records.length;\n      if (records.length > 0) {\n        var lastRecord = records[length - 1];\n        var recordToReplaceLast = selectRecord(lastRecord, record);\n        if (recordToReplaceLast) {\n          records[length - 1] = recordToReplaceLast;\n          return;\n        }\n      } else {\n        scheduleCallback(this.observer);\n      }\n      records[length] = record;\n    },\n    addListeners: function addListeners() {\n      this.addListeners_(this.target);\n    },\n    addListeners_: function addListeners_(node) {\n      var options = this.options;\n      if (options.attributes) node.addEventListener(\"DOMAttrModified\", this, true);\n      if (options.characterData) node.addEventListener(\"DOMCharacterDataModified\", this, true);\n      if (options.childList) node.addEventListener(\"DOMNodeInserted\", this, true);\n      if (options.childList || options.subtree) node.addEventListener(\"DOMNodeRemoved\", this, true);\n    },\n    removeListeners: function removeListeners() {\n      this.removeListeners_(this.target);\n    },\n    removeListeners_: function removeListeners_(node) {\n      var options = this.options;\n      if (options.attributes) node.removeEventListener(\"DOMAttrModified\", this, true);\n      if (options.characterData) node.removeEventListener(\"DOMCharacterDataModified\", this, true);\n      if (options.childList) node.removeEventListener(\"DOMNodeInserted\", this, true);\n      if (options.childList || options.subtree) node.removeEventListener(\"DOMNodeRemoved\", this, true);\n    },\n    addTransientObserver: function addTransientObserver(node) {\n      if (node === this.target) return;\n      this.addListeners_(node);\n      this.transientObservedNodes.push(node);\n      var registrations = registrationsTable.get(node);\n      if (!registrations) registrationsTable.set(node, registrations = []);\n      registrations.push(this);\n    },\n    removeTransientObservers: function removeTransientObservers() {\n      var transientObservedNodes = this.transientObservedNodes;\n      this.transientObservedNodes = [];\n      transientObservedNodes.forEach(function (node) {\n        this.removeListeners_(node);\n        var registrations = registrationsTable.get(node);\n        for (var i = 0; i < registrations.length; i++) {\n          if (registrations[i] === this) {\n            registrations.splice(i, 1);\n            break;\n          }\n        }\n      }, this);\n    },\n    handleEvent: function handleEvent(e) {\n      e.stopImmediatePropagation();\n      switch (e.type) {\n        case \"DOMAttrModified\":\n          var name = e.attrName;\n          var namespace = e.relatedNode.namespaceURI;\n          var target = e.target;\n          var record = new getRecord(\"attributes\", target);\n          record.attributeName = name;\n          record.attributeNamespace = namespace;\n          var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n          forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n            if (!options.attributes) return;\n            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {\n              return;\n            }\n            if (options.attributeOldValue) return getRecordWithOldValue(oldValue);\n            return record;\n          });\n          break;\n\n        case \"DOMCharacterDataModified\":\n          var target = e.target;\n          var record = getRecord(\"characterData\", target);\n          var oldValue = e.prevValue;\n          forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n            if (!options.characterData) return;\n            if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);\n            return record;\n          });\n          break;\n\n        case \"DOMNodeRemoved\":\n          this.addTransientObserver(e.target);\n\n        case \"DOMNodeInserted\":\n          var changedNode = e.target;\n          var addedNodes, removedNodes;\n          if (e.type === \"DOMNodeInserted\") {\n            addedNodes = [changedNode];\n            removedNodes = [];\n          } else {\n            addedNodes = [];\n            removedNodes = [changedNode];\n          }\n          var previousSibling = changedNode.previousSibling;\n          var nextSibling = changedNode.nextSibling;\n          var record = getRecord(\"childList\", e.target.parentNode);\n          record.addedNodes = addedNodes;\n          record.removedNodes = removedNodes;\n          record.previousSibling = previousSibling;\n          record.nextSibling = nextSibling;\n          forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function (options) {\n            if (!options.childList) return;\n            return record;\n          });\n      }\n      clearRecords();\n    }\n  };\n  global.JsMutationObserver = JsMutationObserver;\n  if (!global.MutationObserver) {\n    global.MutationObserver = JsMutationObserver;\n    JsMutationObserver._isPolyfilled = true;\n  }\n})(self);\n\n/*\nCopyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n(function (global, undefined) {\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var setImmediate;\n\n    function addFromSetImmediateArguments(args) {\n        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);\n        return nextHandle++;\n    }\n\n    // This function accepts the same arguments as setImmediate, but\n    // returns a function that requires no arguments.\n    function partiallyApplied(handler) {\n        var args = [].slice.call(arguments, 1);\n        return function () {\n            if (typeof handler === \"function\") {\n                handler.apply(undefined, args);\n            } else {\n                new Function(\"\" + handler)();\n            }\n        };\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(partiallyApplied(runIfPresent, handle), 0);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    task();\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function installNextTickImplementation() {\n        setImmediate = function setImmediate() {\n            var handle = addFromSetImmediateArguments(arguments);\n            process.nextTick(partiallyApplied(runIfPresent, handle));\n            return handle;\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function onGlobalMessage(event) {\n            if (event.source === global && typeof event.data === \"string\" && event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        setImmediate = function setImmediate() {\n            var handle = addFromSetImmediateArguments(arguments);\n            global.postMessage(messagePrefix + handle, \"*\");\n            return handle;\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function (event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        setImmediate = function setImmediate() {\n            var handle = addFromSetImmediateArguments(arguments);\n            channel.port2.postMessage(handle);\n            return handle;\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        setImmediate = function setImmediate() {\n            var handle = addFromSetImmediateArguments(arguments);\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n            return handle;\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        setImmediate = function setImmediate() {\n            var handle = addFromSetImmediateArguments(arguments);\n            setTimeout(partiallyApplied(runIfPresent, handle), 0);\n            return handle;\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n})(self);\n\n// Caution:\n// Do not replace this import statement with codes.\n//\n// If you replace this import statement with codes,\n// the codes will be executed after the following polyfills are imported\n// because import statements are hoisted during compilation.\n// Polyfill ECMAScript standard features with global namespace pollution\n// Polyfill Custom Elements v1 with global namespace pollution\n// Polyfill MutationObserver with global namespace pollution\n// Polyfill setImmediate with global namespace pollution\n\n(function () {\n\tfunction FastClick(layer, options) {\n\t\tvar oldOnClick;\n\n\t\toptions = options || {};\n\n\t\t/**\n   * Whether a click is currently being tracked.\n   *\n   * @type boolean\n   */\n\t\tthis.trackingClick = false;\n\n\t\t/**\n   * Timestamp for when click tracking started.\n   *\n   * @type number\n   */\n\t\tthis.trackingClickStart = 0;\n\n\t\t/**\n   * The element being tracked for a click.\n   *\n   * @type EventTarget\n   */\n\t\tthis.targetElement = null;\n\n\t\t/**\n   * X-coordinate of touch start event.\n   *\n   * @type number\n   */\n\t\tthis.touchStartX = 0;\n\n\t\t/**\n   * Y-coordinate of touch start event.\n   *\n   * @type number\n   */\n\t\tthis.touchStartY = 0;\n\n\t\t/**\n   * ID of the last touch, retrieved from Touch.identifier.\n   *\n   * @type number\n   */\n\t\tthis.lastTouchIdentifier = 0;\n\n\t\t/**\n   * Touchmove boundary, beyond which a click will be cancelled.\n   *\n   * @type number\n   */\n\t\tthis.touchBoundary = options.touchBoundary || 10;\n\n\t\t/**\n   * The FastClick layer.\n   *\n   * @type Element\n   */\n\t\tthis.layer = layer;\n\n\t\t/**\n   * The minimum time between tap(touchstart and touchend) events\n   *\n   * @type number\n   */\n\t\tthis.tapDelay = options.tapDelay || 200;\n\n\t\t/**\n   * The maximum time for a tap\n   *\n   * @type number\n   */\n\t\tthis.tapTimeout = options.tapTimeout || 700;\n\n\t\tif (FastClick.notNeeded(layer)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Some old versions of Android don't have Function.prototype.bind\n\t\tfunction bind(method, context) {\n\t\t\treturn function () {\n\t\t\t\treturn method.apply(context, arguments);\n\t\t\t};\n\t\t}\n\n\t\tvar methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];\n\t\tvar context = this;\n\t\tfor (var i = 0, l = methods.length; i < l; i++) {\n\t\t\tcontext[methods[i]] = bind(context[methods[i]], context);\n\t\t}\n\n\t\t// Set up event handlers as required\n\t\tif (deviceIsAndroid) {\n\t\t\tlayer.addEventListener('mouseover', this.onMouse, true);\n\t\t\tlayer.addEventListener('mousedown', this.onMouse, true);\n\t\t\tlayer.addEventListener('mouseup', this.onMouse, true);\n\t\t}\n\n\t\tlayer.addEventListener('click', this.onClick, true);\n\t\tlayer.addEventListener('touchstart', this.onTouchStart, false);\n\t\tlayer.addEventListener('touchmove', this.onTouchMove, false);\n\t\tlayer.addEventListener('touchend', this.onTouchEnd, false);\n\t\tlayer.addEventListener('touchcancel', this.onTouchCancel, false);\n\n\t\t// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t\t// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick\n\t\t// layer when they are cancelled.\n\t\tif (!Event.prototype.stopImmediatePropagation) {\n\t\t\tlayer.removeEventListener = function (type, callback, capture) {\n\t\t\t\tvar rmv = Node.prototype.removeEventListener;\n\t\t\t\tif (type === 'click') {\n\t\t\t\t\trmv.call(layer, type, callback.hijacked || callback, capture);\n\t\t\t\t} else {\n\t\t\t\t\trmv.call(layer, type, callback, capture);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tlayer.addEventListener = function (type, callback, capture) {\n\t\t\t\tvar adv = Node.prototype.addEventListener;\n\t\t\t\tif (type === 'click') {\n\t\t\t\t\tadv.call(layer, type, callback.hijacked || (callback.hijacked = function (event) {\n\t\t\t\t\t\tif (!event.propagationStopped) {\n\t\t\t\t\t\t\tcallback(event);\n\t\t\t\t\t\t}\n\t\t\t\t\t}), capture);\n\t\t\t\t} else {\n\t\t\t\t\tadv.call(layer, type, callback, capture);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// If a handler is already declared in the element's onclick attribute, it will be fired before\n\t\t// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and\n\t\t// adding it as listener.\n\t\tif (typeof layer.onclick === 'function') {\n\n\t\t\t// Android browser on at least 3.2 requires a new reference to the function in layer.onclick\n\t\t\t// - the old one won't work if passed to addEventListener directly.\n\t\t\toldOnClick = layer.onclick;\n\t\t\tlayer.addEventListener('click', function (event) {\n\t\t\t\toldOnClick(event);\n\t\t\t}, false);\n\t\t\tlayer.onclick = null;\n\t\t}\n\t}\n\n\t/**\n * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.\n *\n * @type boolean\n */\n\tvar deviceIsWindowsPhone = navigator.userAgent.indexOf(\"Windows Phone\") >= 0;\n\n\t/**\n  * Android requires exceptions.\n  *\n  * @type boolean\n  */\n\tvar deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;\n\n\t/**\n  * iOS requires exceptions.\n  *\n  * @type boolean\n  */\n\tvar deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;\n\n\t/**\n  * iOS 4 requires an exception for select elements.\n  *\n  * @type boolean\n  */\n\tvar deviceIsIOS4 = deviceIsIOS && /OS 4_\\d(_\\d)?/.test(navigator.userAgent);\n\n\t/**\n  * iOS 6.0-7.* requires the target element to be manually derived\n  *\n  * @type boolean\n  */\n\tvar deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\\d/.test(navigator.userAgent);\n\n\t/**\n  * BlackBerry requires exceptions.\n  *\n  * @type boolean\n  */\n\tvar deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;\n\n\t/**\n  * Determine whether a given element requires a native click.\n  *\n  * @param {EventTarget|Element} target Target DOM element\n  * @returns {boolean} Returns true if the element needs a native click\n  */\n\tFastClick.prototype.needsClick = function (target) {\n\t\tswitch (target.nodeName.toLowerCase()) {\n\n\t\t\t// Don't send a synthetic click to disabled inputs (issue #62)\n\t\t\tcase 'button':\n\t\t\tcase 'select':\n\t\t\tcase 'textarea':\n\t\t\t\tif (target.disabled) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'input':\n\n\t\t\t\t// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)\n\t\t\t\tif (deviceIsIOS && target.type === 'file' || target.disabled) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 'label':\n\t\t\tcase 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames\n\t\t\tcase 'video':\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn (/\\bneedsclick\\b/.test(target.className)\n\t\t);\n\t};\n\n\t/**\n  * Determine whether a given element requires a call to focus to simulate click into element.\n  *\n  * @param {EventTarget|Element} target Target DOM element\n  * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.\n  */\n\tFastClick.prototype.needsFocus = function (target) {\n\t\tswitch (target.nodeName.toLowerCase()) {\n\t\t\tcase 'textarea':\n\t\t\t\treturn true;\n\t\t\tcase 'select':\n\t\t\t\treturn !deviceIsAndroid;\n\t\t\tcase 'input':\n\t\t\t\tswitch (target.type) {\n\t\t\t\t\tcase 'button':\n\t\t\t\t\tcase 'checkbox':\n\t\t\t\t\tcase 'file':\n\t\t\t\t\tcase 'image':\n\t\t\t\t\tcase 'radio':\n\t\t\t\t\tcase 'submit':\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// No point in attempting to focus disabled inputs\n\t\t\t\treturn !target.disabled && !target.readOnly;\n\t\t\tdefault:\n\t\t\t\treturn (/\\bneedsfocus\\b/.test(target.className)\n\t\t\t\t);\n\t\t}\n\t};\n\n\t/**\n  * Send a click event to the specified element.\n  *\n  * @param {EventTarget|Element} targetElement\n  * @param {Event} event\n  */\n\tFastClick.prototype.sendClick = function (targetElement, event) {\n\t\tvar clickEvent, touch;\n\n\t\t// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)\n\t\tif (document.activeElement && document.activeElement !== targetElement) {\n\t\t\tdocument.activeElement.blur();\n\t\t}\n\n\t\ttouch = event.changedTouches[0];\n\n\t\t// Synthesize a click event, with an extra attribute so it can be tracked\n\t\tclickEvent = document.createEvent('MouseEvents');\n\t\tclickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\n\t\tclickEvent.forwardedTouchEvent = true;\n\t\ttargetElement.dispatchEvent(clickEvent);\n\t};\n\n\tFastClick.prototype.determineEventType = function (targetElement) {\n\n\t\t//Issue #159: Android Chrome Select Box does not open with a synthetic click event\n\t\tif (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {\n\t\t\treturn 'mousedown';\n\t\t}\n\n\t\treturn 'click';\n\t};\n\n\t/**\n  * @param {EventTarget|Element} targetElement\n  */\n\tFastClick.prototype.focus = function (targetElement) {\n\t\tvar length;\n\n\t\t// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.\n\t\tif (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {\n\t\t\tlength = targetElement.value.length;\n\t\t\ttargetElement.setSelectionRange(length, length);\n\t\t} else {\n\t\t\ttargetElement.focus();\n\t\t}\n\t};\n\n\t/**\n  * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.\n  *\n  * @param {EventTarget|Element} targetElement\n  */\n\tFastClick.prototype.updateScrollParent = function (targetElement) {\n\t\tvar scrollParent, parentElement;\n\n\t\tscrollParent = targetElement.fastClickScrollParent;\n\n\t\t// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the\n\t\t// target element was moved to another parent.\n\t\tif (!scrollParent || !scrollParent.contains(targetElement)) {\n\t\t\tparentElement = targetElement;\n\t\t\tdo {\n\t\t\t\tif (parentElement.scrollHeight > parentElement.offsetHeight) {\n\t\t\t\t\tscrollParent = parentElement;\n\t\t\t\t\ttargetElement.fastClickScrollParent = parentElement;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tparentElement = parentElement.parentElement;\n\t\t\t} while (parentElement);\n\t\t}\n\n\t\t// Always update the scroll top tracker if possible.\n\t\tif (scrollParent) {\n\t\t\tscrollParent.fastClickLastScrollTop = scrollParent.scrollTop;\n\t\t}\n\t};\n\n\t/**\n  * @param {EventTarget} targetElement\n  * @returns {Element|EventTarget}\n  */\n\tFastClick.prototype.getTargetElementFromEventTarget = function (eventTarget) {\n\n\t\t// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.\n\t\tif (eventTarget.nodeType === Node.TEXT_NODE) {\n\t\t\treturn eventTarget.parentNode;\n\t\t}\n\n\t\treturn eventTarget;\n\t};\n\n\t/**\n  * On touch start, record the position and scroll offset.\n  *\n  * @param {Event} event\n  * @returns {boolean}\n  */\n\tFastClick.prototype.onTouchStart = function (event) {\n\t\tvar targetElement, touch, selection;\n\n\t\t// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).\n\t\tif (event.targetTouches.length > 1) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttargetElement = this.getTargetElementFromEventTarget(event.target);\n\t\ttouch = event.targetTouches[0];\n\n\t\t// Ignore touches on contenteditable elements to prevent conflict with text selection.\n\t\t// (For details: https://github.com/ftlabs/fastclick/pull/211 )\n\t\tif (targetElement.isContentEditable) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (deviceIsIOS) {\n\n\t\t\t// Only trusted events will deselect text on iOS (issue #49)\n\t\t\tselection = window.getSelection();\n\t\t\tif (selection.rangeCount && !selection.isCollapsed) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!deviceIsIOS4) {\n\n\t\t\t\t// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):\n\t\t\t\t// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched\n\t\t\t\t// with the same identifier as the touch event that previously triggered the click that triggered the alert.\n\t\t\t\t// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an\n\t\t\t\t// immediately preceding touch event (issue #52), so this fix is unavailable on that platform.\n\t\t\t\t// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,\n\t\t\t\t// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,\n\t\t\t\t// random integers, it's safe to to continue if the identifier is 0 here.\n\t\t\t\tif (touch.identifier && touch.identifier === this.lastTouchIdentifier) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthis.lastTouchIdentifier = touch.identifier;\n\n\t\t\t\t// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:\n\t\t\t\t// 1) the user does a fling scroll on the scrollable layer\n\t\t\t\t// 2) the user stops the fling scroll with another tap\n\t\t\t\t// then the event.target of the last 'touchend' event will be the element that was under the user's finger\n\t\t\t\t// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check\n\t\t\t\t// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).\n\t\t\t\tthis.updateScrollParent(targetElement);\n\t\t\t}\n\t\t}\n\n\t\tthis.trackingClick = true;\n\t\tthis.trackingClickStart = event.timeStamp;\n\t\tthis.targetElement = targetElement;\n\n\t\tthis.touchStartX = touch.pageX;\n\t\tthis.touchStartY = touch.pageY;\n\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\n\t\tif (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\treturn true;\n\t};\n\n\t/**\n  * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.\n  *\n  * @param {Event} event\n  * @returns {boolean}\n  */\n\tFastClick.prototype.touchHasMoved = function (event) {\n\t\tvar touch = event.changedTouches[0],\n\t\t    boundary = this.touchBoundary;\n\n\t\tif (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n  * Update the last position.\n  *\n  * @param {Event} event\n  * @returns {boolean}\n  */\n\tFastClick.prototype.onTouchMove = function (event) {\n\t\tif (!this.trackingClick) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If the touch has moved, cancel the click tracking\n\t\tif (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {\n\t\t\tthis.trackingClick = false;\n\t\t\tthis.targetElement = null;\n\t\t}\n\n\t\treturn true;\n\t};\n\n\t/**\n  * Attempt to find the labelled control for the given label element.\n  *\n  * @param {EventTarget|HTMLLabelElement} labelElement\n  * @returns {Element|null}\n  */\n\tFastClick.prototype.findControl = function (labelElement) {\n\n\t\t// Fast path for newer browsers supporting the HTML5 control attribute\n\t\tif (labelElement.control !== undefined) {\n\t\t\treturn labelElement.control;\n\t\t}\n\n\t\t// All browsers under test that support touch events also support the HTML5 htmlFor attribute\n\t\tif (labelElement.htmlFor) {\n\t\t\treturn document.getElementById(labelElement.htmlFor);\n\t\t}\n\n\t\t// If no for attribute exists, attempt to retrieve the first labellable descendant element\n\t\t// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label\n\t\treturn labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');\n\t};\n\n\t/**\n  * On touch end, determine whether to send a click event at once.\n  *\n  * @param {Event} event\n  * @returns {boolean}\n  */\n\tFastClick.prototype.onTouchEnd = function (event) {\n\t\tvar forElement,\n\t\t    trackingClickStart,\n\t\t    targetTagName,\n\t\t    scrollParent,\n\t\t    touch,\n\t\t    targetElement = this.targetElement;\n\n\t\tif (!this.trackingClick) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Prevent phantom clicks on fast double-tap (issue #36)\n\t\tif (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {\n\t\t\tthis.cancelNextClick = true;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (event.timeStamp - this.trackingClickStart > this.tapTimeout) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Reset to prevent wrong click cancel on input (issue #156).\n\t\tthis.cancelNextClick = false;\n\n\t\tthis.lastClickTime = event.timeStamp;\n\n\t\ttrackingClickStart = this.trackingClickStart;\n\t\tthis.trackingClick = false;\n\t\tthis.trackingClickStart = 0;\n\n\t\t// On some iOS devices, the targetElement supplied with the event is invalid if the layer\n\t\t// is performing a transition or scroll, and has to be re-detected manually. Note that\n\t\t// for this to function correctly, it must be called *after* the event target is checked!\n\t\t// See issue #57; also filed as rdar://13048589 .\n\t\tif (deviceIsIOSWithBadTarget) {\n\t\t\ttouch = event.changedTouches[0];\n\n\t\t\t// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null\n\t\t\ttargetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;\n\t\t\ttargetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;\n\t\t}\n\n\t\ttargetTagName = targetElement.tagName.toLowerCase();\n\t\tif (targetTagName === 'label') {\n\t\t\tforElement = this.findControl(targetElement);\n\t\t\tif (forElement) {\n\t\t\t\tthis.focus(targetElement);\n\t\t\t\tif (deviceIsAndroid) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\ttargetElement = forElement;\n\t\t\t}\n\t\t} else if (this.needsFocus(targetElement)) {\n\n\t\t\t// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.\n\t\t\t// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).\n\t\t\tif (event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && targetTagName === 'input') {\n\t\t\t\tthis.targetElement = null;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tthis.focus(targetElement);\n\t\t\tthis.sendClick(targetElement, event);\n\n\t\t\t// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.\n\t\t\t// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)\n\t\t\tif (!deviceIsIOS || targetTagName !== 'select') {\n\t\t\t\tthis.targetElement = null;\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (deviceIsIOS && !deviceIsIOS4) {\n\n\t\t\t// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled\n\t\t\t// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).\n\t\t\tscrollParent = targetElement.fastClickScrollParent;\n\t\t\tif (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// Prevent the actual click from going though - unless the target node is marked as requiring\n\t\t// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.\n\t\tif (!this.needsClick(targetElement)) {\n\t\t\tevent.preventDefault();\n\t\t\tthis.sendClick(targetElement, event);\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n  * On touch cancel, stop tracking the click.\n  *\n  * @returns {void}\n  */\n\tFastClick.prototype.onTouchCancel = function () {\n\t\tthis.trackingClick = false;\n\t\tthis.targetElement = null;\n\t};\n\n\t/**\n  * Determine mouse events which should be permitted.\n  *\n  * @param {Event} event\n  * @returns {boolean}\n  */\n\tFastClick.prototype.onMouse = function (event) {\n\n\t\t// If a target element was never set (because a touch event was never fired) allow the event\n\t\tif (!this.targetElement) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (event.forwardedTouchEvent) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Programmatically generated events targeting a specific element should be permitted\n\t\tif (!event.cancelable) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Derive and check the target element to see whether the mouse event needs to be permitted;\n\t\t// unless explicitly enabled, prevent non-touch click events from triggering actions,\n\t\t// to prevent ghost/doubleclicks.\n\t\tif (!this.needsClick(this.targetElement) || this.cancelNextClick) {\n\n\t\t\t// Prevent any user-added listeners declared on FastClick element from being fired.\n\t\t\tif (event.stopImmediatePropagation) {\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t} else {\n\n\t\t\t\t// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)\n\t\t\t\tevent.propagationStopped = true;\n\t\t\t}\n\n\t\t\t// Cancel the event\n\t\t\tevent.stopPropagation();\n\t\t\tevent.preventDefault();\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// If the mouse event is permitted, return true for the action to go through.\n\t\treturn true;\n\t};\n\n\t/**\n  * On actual clicks, determine whether this is a touch-generated click, a click action occurring\n  * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or\n  * an actual click which should be permitted.\n  *\n  * @param {Event} event\n  * @returns {boolean}\n  */\n\tFastClick.prototype.onClick = function (event) {\n\t\tvar permitted;\n\n\t\t// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.\n\t\tif (this.trackingClick) {\n\t\t\tthis.targetElement = null;\n\t\t\tthis.trackingClick = false;\n\t\t\treturn true;\n\t\t}\n\n\t\t// Very odd behavior on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.\n\t\tif (event.target.type === 'submit' && event.detail === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tpermitted = this.onMouse(event);\n\n\t\t// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.\n\t\tif (!permitted) {\n\t\t\tthis.targetElement = null;\n\t\t}\n\n\t\t// If clicks are permitted, return true for the action to go through.\n\t\treturn permitted;\n\t};\n\n\t/**\n  * Remove all FastClick's event listeners.\n  *\n  * @returns {void}\n  */\n\tFastClick.prototype.destroy = function () {\n\t\tvar layer = this.layer;\n\n\t\tif (deviceIsAndroid) {\n\t\t\tlayer.removeEventListener('mouseover', this.onMouse, true);\n\t\t\tlayer.removeEventListener('mousedown', this.onMouse, true);\n\t\t\tlayer.removeEventListener('mouseup', this.onMouse, true);\n\t\t}\n\n\t\tlayer.removeEventListener('click', this.onClick, true);\n\t\tlayer.removeEventListener('touchstart', this.onTouchStart, false);\n\t\tlayer.removeEventListener('touchmove', this.onTouchMove, false);\n\t\tlayer.removeEventListener('touchend', this.onTouchEnd, false);\n\t\tlayer.removeEventListener('touchcancel', this.onTouchCancel, false);\n\t};\n\n\t/**\n  * Check whether FastClick is needed.\n  *\n  * @param {Element} layer The layer to listen on\n  */\n\tFastClick.notNeeded = function (layer) {\n\t\tvar metaViewport;\n\t\tvar chromeVersion;\n\t\tvar blackberryVersion;\n\t\tvar firefoxVersion;\n\n\t\t// Devices that don't support touch don't need FastClick\n\t\tif (typeof window.ontouchstart === 'undefined') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Chrome version - zero for other browsers\n\t\tchromeVersion = +(/Chrome\\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];\n\n\t\tif (chromeVersion) {\n\n\t\t\tif (deviceIsAndroid) {\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\n\n\t\t\t\tif (metaViewport) {\n\t\t\t\t\t// Chrome on Android with user-scalable=\"no\" doesn't need FastClick (issue #89)\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// Chrome 32 and above with width=device-width or less don't need FastClick\n\t\t\t\t\tif (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Chrome desktop doesn't need FastClick (issue #15)\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tif (deviceIsBlackBerry10) {\n\t\t\tblackberryVersion = navigator.userAgent.match(/Version\\/([0-9]*)\\.([0-9]*)/);\n\n\t\t\t// BlackBerry 10.3+ does not require Fastclick library.\n\t\t\t// https://github.com/ftlabs/fastclick/issues/251\n\t\t\tif (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {\n\t\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\n\n\t\t\t\tif (metaViewport) {\n\t\t\t\t\t// user-scalable=no eliminates click delay.\n\t\t\t\t\tif (metaViewport.content.indexOf('user-scalable=no') !== -1) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\t// width=device-width (or less than device-width) eliminates click delay.\n\t\t\t\t\tif (document.documentElement.scrollWidth <= window.outerWidth) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)\n\t\tif (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Firefox version - zero for other browsers\n\t\tfirefoxVersion = +(/Firefox\\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];\n\n\t\tif (firefoxVersion >= 27) {\n\t\t\t// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896\n\n\t\t\tmetaViewport = document.querySelector('meta[name=viewport]');\n\t\t\tif (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// IE11: prefixed -ms-touch-action is no longer supported and it's recommended to use non-prefixed version\n\t\t// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx\n\t\tif (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n  * Factory method for creating a FastClick object\n  *\n  * @param {Element} layer The layer to listen on\n  * @param {Object} [options={}] The options to override the defaults\n  */\n\tFastClick.attach = function (layer, options) {\n\t\treturn new FastClick(layer, options);\n\t};\n\n\twindow.FastClick = FastClick;\n})();\n\n(function () {\n  var DEFAULT_VIEWPORT = 'width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no';\n\n  var Viewport = {\n    ensureViewportElement: function ensureViewportElement() {\n      var viewportElement = document.querySelector('meta[name=viewport]');\n\n      if (!viewportElement) {\n        viewportElement = document.createElement('meta');\n        viewportElement.name = 'viewport';\n        document.head.appendChild(viewportElement);\n      }\n\n      return viewportElement;\n    },\n\n    setup: function setup() {\n      var viewportElement = Viewport.ensureViewportElement();\n\n      if (!viewportElement) {\n        return;\n      }\n\n      if (!viewportElement.hasAttribute('content')) {\n        viewportElement.setAttribute('content', DEFAULT_VIEWPORT);\n      }\n    }\n  };\n\n  window.Viewport = Viewport;\n})();\n\n// Load non-polyfill libraries\n// import './microevent.js@47cbc14+mod/microevent.js';\n\nfunction setup$1(ons) {\n  if (window.ons) {\n    ons._util.warn('Onsen UI is loaded more than once.');\n  }\n\n  // fastclick\n  window.addEventListener('load', function () {\n    ons.fastClick = FastClick.attach(document.body);\n\n    var supportTouchAction = 'touch-action' in document.body.style;\n\n    ons.platform._runOnActualPlatform(function () {\n      if (ons.platform.isAndroid()) {\n        // In Android4.4+, correct viewport settings can remove click delay.\n        // So disable FastClick on Android.\n        ons.fastClick.destroy();\n      } else if (ons.platform.isIOS()) {\n        if (supportTouchAction && (ons.platform.isIOSSafari() || ons.platform.isWKWebView())) {\n          // If 'touch-action' supported in iOS Safari or WKWebView, disable FastClick.\n          ons.fastClick.destroy();\n        } else {\n          // Do nothing. 'touch-action: manipulation' has no effect on UIWebView.\n        }\n      }\n    });\n  }, false);\n\n  ons.ready(function () {\n    ons.enableDeviceBackButtonHandler();\n    ons._defaultDeviceBackButtonHandler = ons._internal.dbbDispatcher.createHandler(window.document.body, function () {\n      if (Object.hasOwnProperty.call(navigator, 'app')) {\n        navigator.app.exitApp();\n      } else {\n        console.warn('Could not close the app. Is \\'cordova.js\\' included?\\nError: \\'window.navigator.app\\' is undefined.');\n      }\n    });\n    document.body._gestureDetector = new ons.GestureDetector(document.body);\n\n    // Simulate Device Back Button on ESC press\n    if (!ons.platform.isWebView()) {\n      document.body.addEventListener('keydown', function (event) {\n        if (event.keyCode === 27) {\n          ons.fireDeviceBackButtonEvent();\n        }\n      });\n    }\n\n    // setup loading placeholder\n    ons._setupLoadingPlaceHolders();\n  });\n\n  // viewport.js\n  Viewport.setup();\n}\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nfunction getElementClass() {\n  if (typeof HTMLElement !== 'function') {\n    // case of Safari\n    var _BaseElement = function _BaseElement() {};\n    _BaseElement.prototype = document.createElement('div');\n    return _BaseElement;\n  } else {\n    return HTMLElement;\n  }\n}\n\nvar BaseElement = function (_getElementClass) {\n  inherits(BaseElement, _getElementClass);\n\n  function BaseElement() {\n    classCallCheck(this, BaseElement);\n    return possibleConstructorReturn(this, (BaseElement.__proto__ || Object.getPrototypeOf(BaseElement)).call(this));\n  }\n\n  return BaseElement;\n}(getElementClass());\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * @element ons-template\n * @category util\n * @description\n *   [en]\n *     Define a separate HTML fragment and use as a template. These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs. Since Onsen UI 2.4.0, the native `<template>` element can be used instead of `<ons-template>` for better performance and features. `<ons-template>` is still supported for backward compatibility.\n *   [/en]\n *   [ja]テンプレートとして使用するためのHTMLフラグメントを定義します。この要素でHTMLを宣言すると、id属性に指定した名前をpageのURLとしてons-navigatorなどのコンポーネントから参照できます。[/ja]\n * @seealso ons-navigator\n *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]\n *   [ja][/ja]\n * @seealso ons-tabbar\n *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]\n *   [ja][/ja]\n * @seealso ons-splitter\n *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]\n *   [ja][/ja]\n * @example\n * <ons-template id=\"foobar.html\">\n *   <ons-page>\n *     Page content\n *   </ons-page>\n * </ons-template>\n *\n * <ons-navigator page=\"foobar.html\"></ons-navigator>\n */\n\nvar TemplateElement = function (_BaseElement) {\n  inherits(TemplateElement, _BaseElement);\n\n  /**\n   * @property template\n   * @type {String}\n   * @description\n   *  [en]Template content. This property can not be used with AngularJS bindings.[/en]\n   *  [ja][/ja]\n   */\n\n  function TemplateElement() {\n    classCallCheck(this, TemplateElement);\n\n    var _this = possibleConstructorReturn(this, (TemplateElement.__proto__ || Object.getPrototypeOf(TemplateElement)).call(this));\n\n    _this.template = _this.innerHTML;\n\n    while (_this.firstChild) {\n      _this.removeChild(_this.firstChild);\n    }\n    return _this;\n  }\n\n  createClass(TemplateElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      if (this.parentNode) {\n        // Note: this.parentNode is not set in some CE0/CE1 polyfills.\n        // Show warning when the ons-template is not located just under document.body\n        if (this.parentNode !== document.body) {\n          // if the parent is not document.body\n          util.warn('ons-template (id = ' + this.getAttribute('id') + ') must be located just under document.body' + (this.parentNode.outerHTML ? ':\\n\\n' + this.parentNode.outerHTML : '.'));\n        }\n      }\n\n      var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });\n      event.template = this.template;\n      event.templateId = this.getAttribute('id');\n\n      this.dispatchEvent(event);\n    }\n  }]);\n  return TemplateElement;\n}(BaseElement);\n\nons$1.elements.Template = TemplateElement;\ncustomElements.define('ons-template', TemplateElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * @element ons-if\n * @category conditional\n * @tutorial vanilla/Reference/if\n * @description\n *   [en]\n *     Conditionally display content depending on the platform, device orientation or both.\n *\n *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.\n *   [/en]\n *   [ja][/ja]\n * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]\n * @example\n * <ons-page>\n *   <ons-if orientation=\"landscape\">\n *     Landscape view!\n *   </ons-if>\n *   <ons-if platform=\"android\">\n *     This is Android.\n *   </ons-if>\n *   <ons-if platform=\"ios other\">\n *     This is not Android.\n *   </ons-if>\n * </ons-page>\n */\n\nvar IfElement = function (_BaseElement) {\n  inherits(IfElement, _BaseElement);\n\n  /**\n   * @attribute platform\n   * @initonly\n   * @type {string}\n   * @description\n   *  [en]Space-separated platform names. Possible values are `\"ios\"`, `\"android\"`, `\"windows\"` and `\"other\"`.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute orientation\n   * @type {string}\n   * @description\n   *  [en]Either `\"portrait\"` or `\"landscape\"`.[/en]\n   *  [ja]portraitもしくはlandscapeを指定します[/ja]\n   */\n\n  function IfElement() {\n    classCallCheck(this, IfElement);\n\n    var _this = possibleConstructorReturn(this, (IfElement.__proto__ || Object.getPrototypeOf(IfElement)).call(this));\n\n    contentReady(_this, function () {\n      if (platform._getSelectedPlatform() !== null) {\n        _this._platformUpdate();\n      } else if (!_this._isAllowedPlatform()) {\n        while (_this.childNodes[0]) {\n          _this.childNodes[0].remove();\n        }\n        _this._platformUpdate();\n      }\n    });\n\n    _this._onOrientationChange();\n    return _this;\n  }\n\n  createClass(IfElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      orientation.on('change', this._onOrientationChange.bind(this));\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name) {\n      if (name === 'orientation') {\n        this._onOrientationChange();\n      }\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      orientation.off('change', this._onOrientationChange);\n    }\n  }, {\n    key: '_platformUpdate',\n    value: function _platformUpdate() {\n      this.style.display = this._isAllowedPlatform() ? '' : 'none';\n    }\n  }, {\n    key: '_isAllowedPlatform',\n    value: function _isAllowedPlatform() {\n      return !this.getAttribute('platform') || this.getAttribute('platform').split(/\\s+/).indexOf(platform.getMobileOS()) >= 0;\n    }\n  }, {\n    key: '_onOrientationChange',\n    value: function _onOrientationChange() {\n      if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {\n        var conditionalOrientation = this.getAttribute('orientation').toLowerCase();\n        var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';\n\n        this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';\n      }\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['orientation'];\n    }\n  }]);\n  return IfElement;\n}(BaseElement);\n\nons$1.elements.If = IfElement;\ncustomElements.define('ons-if', IfElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar BaseAnimator = function () {\n\n  /**\n   * @param {Object} options\n   * @param {String} options.timing\n   * @param {Number} options.duration\n   * @param {Number} options.delay\n   */\n  function BaseAnimator() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    classCallCheck(this, BaseAnimator);\n\n    this.timing = options.timing || 'linear';\n    this.duration = options.duration || 0;\n    this.delay = options.delay || 0;\n  }\n\n  createClass(BaseAnimator, null, [{\n    key: 'extend',\n    value: function extend() {\n      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var extendedAnimator = this;\n      var newAnimator = function newAnimator() {\n        extendedAnimator.apply(this, arguments);\n        util.extend(this, properties);\n      };\n\n      newAnimator.prototype = this.prototype;\n      return newAnimator;\n    }\n  }]);\n  return BaseAnimator;\n}();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n// This object should not be exposed to users. Please keep this private.\nvar iPhoneXPatch = {};\n\niPhoneXPatch.isIPhoneXPortraitPatchActive = function () {\n  return document.documentElement.getAttribute('onsflag-iphonex-portrait') != null && window.innerWidth < window.innerHeight;\n};\n\niPhoneXPatch.isIPhoneXLandscapePatchActive = function () {\n  // If width === height, treat it as landscape\n  return document.documentElement.getAttribute('onsflag-iphonex-landscape') != null && window.innerWidth >= window.innerHeight;\n};\n\n/**\n * Returns the safe area lengths based on the current state of the safe areas.\n */\niPhoneXPatch.getSafeAreaLengths = function () {\n  var safeAreaLengths = void 0;\n  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {\n    safeAreaLengths = {\n      top: 44,\n      right: 0,\n      bottom: 34,\n      left: 0\n    };\n  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {\n    safeAreaLengths = {\n      top: 0,\n      right: 44,\n      bottom: 21,\n      left: 44\n    };\n  } else {\n    safeAreaLengths = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n\n  return safeAreaLengths;\n};\n\n/**\n * Returns the safe area rect based on the current state of the safe areas.\n */\niPhoneXPatch.getSafeAreaDOMRect = function () {\n  var safeAreaRect = void 0;\n  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {\n    safeAreaRect = {\n      x: 0,\n      y: 44, /* 0 + 44 (top safe area) */\n      width: window.innerWidth,\n      height: window.innerHeight - 78 /* height - 44 (top safe area) - 34 (bottom safe area) */\n    };\n  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {\n    safeAreaRect = {\n      x: 44, /* 0 + 44 (left safe area) */\n      y: 0,\n      width: window.innerWidth - 88, /* width - 44 (left safe area) - 34 (right safe area) */\n      height: window.innerHeight - 21 /* height - 21 (bottom safe area) */\n    };\n  } else {\n    safeAreaRect = {\n      x: 0,\n      y: 0,\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n  }\n\n  return _extends({}, safeAreaRect, {\n    left: safeAreaRect.x,\n    top: safeAreaRect.y,\n    right: safeAreaRect.x + safeAreaRect.width,\n    bottom: safeAreaRect.y + safeAreaRect.height\n  });\n};\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar ActionSheetAnimator = function (_BaseAnimator) {\n  inherits(ActionSheetAnimator, _BaseAnimator);\n\n  function ActionSheetAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'linear' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.2 : _ref$duration;\n\n    classCallCheck(this, ActionSheetAnimator);\n    return possibleConstructorReturn(this, (ActionSheetAnimator.__proto__ || Object.getPrototypeOf(ActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {HTMLElement} dialog\n   * @param {Function} done\n   */\n\n\n  createClass(ActionSheetAnimator, [{\n    key: 'show',\n    value: function show(dialog, done) {\n      done();\n    }\n\n    /**\n     * @param {HTMLElement} dialog\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, done) {\n      done();\n    }\n  }]);\n  return ActionSheetAnimator;\n}(BaseAnimator);\n\n/**\n * Android style animator for Action Sheet.\n */\nvar MDActionSheetAnimator = function (_ActionSheetAnimator) {\n  inherits(MDActionSheetAnimator, _ActionSheetAnimator);\n\n  function MDActionSheetAnimator() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$timing = _ref2.timing,\n        timing = _ref2$timing === undefined ? 'ease' : _ref2$timing,\n        _ref2$delay = _ref2.delay,\n        delay = _ref2$delay === undefined ? 0 : _ref2$delay,\n        _ref2$duration = _ref2.duration,\n        duration = _ref2$duration === undefined ? 0.4 : _ref2$duration;\n\n    classCallCheck(this, MDActionSheetAnimator);\n\n    var _this2 = possibleConstructorReturn(this, (MDActionSheetAnimator.__proto__ || Object.getPrototypeOf(MDActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this2.maskTiming = 'linear';\n    _this2.maskDuration = 0.2;\n    return _this2;\n  }\n\n  /**\n   * @param {Object} dialog\n   * @param {Function} callback\n   */\n\n\n  createClass(MDActionSheetAnimator, [{\n    key: 'show',\n    value: function show(dialog, callback) {\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 0\n      }).wait(this.delay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.maskDuration,\n        timing: this.maskTiming\n      }), Animit(dialog._sheet).saveStyle().queue({\n        css: {\n          transform: 'translate3d(0, 80%, 0)',\n          opacity: 0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(0, 0, 0)',\n          opacity: 1.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback && callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {Object} dialog\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, callback) {\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.maskDuration,\n        timing: this.maskTiming\n      }), Animit(dialog._sheet).saveStyle().queue({\n        css: {\n          transform: 'translate3d(0, 0, 0)',\n          opacity: 1.0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(0, 80%, 0)',\n          opacity: 0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback && callback();\n        done();\n      }));\n    }\n  }]);\n  return MDActionSheetAnimator;\n}(ActionSheetAnimator);\n\n/**\n * iOS style animator for dialog.\n */\nvar IOSActionSheetAnimator = function (_ActionSheetAnimator2) {\n  inherits(IOSActionSheetAnimator, _ActionSheetAnimator2);\n\n  function IOSActionSheetAnimator() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$timing = _ref3.timing,\n        timing = _ref3$timing === undefined ? 'ease' : _ref3$timing,\n        _ref3$delay = _ref3.delay,\n        delay = _ref3$delay === undefined ? 0 : _ref3$delay,\n        _ref3$duration = _ref3.duration,\n        duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;\n\n    classCallCheck(this, IOSActionSheetAnimator);\n\n    var _this3 = possibleConstructorReturn(this, (IOSActionSheetAnimator.__proto__ || Object.getPrototypeOf(IOSActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this3.maskTiming = 'linear';\n    _this3.maskDuration = 0.2;\n    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {\n      _this3.liftAmount = 'calc(100% + 48px)';\n    } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {\n      _this3.liftAmount = 'calc(100% + 33px)';\n    } else {\n      _this3.liftAmount = document.body.clientHeight / 2.0 - 1 + 'px'; // avoid Forced Synchronous Layout\n    }\n    return _this3;\n  }\n\n  /**\n   * @param {Object} dialog\n   * @param {Function} callback\n   */\n\n\n  createClass(IOSActionSheetAnimator, [{\n    key: 'show',\n    value: function show(dialog, callback) {\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 0\n      }).wait(this.delay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.maskDuration,\n        timing: this.maskTiming\n      }), Animit(dialog._sheet).saveStyle().queue({\n        css: {\n          transform: 'translate3d(0, ' + this.liftAmount + ', 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(0, 0, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback && callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {Object} dialog\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, callback) {\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.maskDuration,\n        timing: this.maskTiming\n      }), Animit(dialog._sheet).saveStyle().queue({\n        css: {\n          transform: 'translate3d(0, 0, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(0, ' + this.liftAmount + ', 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback && callback();\n        done();\n      }));\n    }\n  }]);\n  return IOSActionSheetAnimator;\n}(ActionSheetAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar BaseDialogElement = function (_BaseElement) {\n  inherits(BaseDialogElement, _BaseElement);\n  createClass(BaseDialogElement, [{\n    key: '_updateAnimatorFactory',\n    value: function _updateAnimatorFactory() {\n      throw new Error('_updateAnimatorFactory method must be implemented.');\n    }\n  }, {\n    key: '_toggleStyle',\n    value: function _toggleStyle(shouldShow) {\n      this.style.display = shouldShow ? 'block' : 'none';\n    }\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      throw new Error('_scheme getter must be implemented.');\n    }\n  }]);\n\n  function BaseDialogElement() {\n    classCallCheck(this, BaseDialogElement);\n\n    var _this = possibleConstructorReturn(this, (BaseDialogElement.__proto__ || Object.getPrototypeOf(BaseDialogElement)).call(this));\n\n    _this._visible = false;\n    _this._doorLock = new DoorLock();\n    _this._cancel = _this._cancel.bind(_this);\n    _this._selfCamelName = util.camelize(_this.tagName.slice(4));\n    _this._defaultDBB = function (e) {\n      return _this.cancelable ? _this._cancel() : e.callParentHandler();\n    };\n    _this._animatorFactory = _this._updateAnimatorFactory();\n    return _this;\n  }\n\n  createClass(BaseDialogElement, [{\n    key: '_cancel',\n    value: function _cancel() {\n      var _this2 = this;\n\n      if (this.cancelable && !this._running) {\n        this._running = true;\n        this.hide().then(function () {\n          _this2._running = false;\n          util.triggerElementEvent(_this2, 'dialog-cancel');\n        }, function () {\n          return _this2._running = false;\n        });\n      }\n    }\n  }, {\n    key: '_preventScroll',\n    value: function _preventScroll(event) {\n      event.cancelable && event.preventDefault();\n    }\n  }, {\n    key: 'show',\n    value: function show() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this._setVisible.apply(this, [true].concat(args));\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this._setVisible.apply(this, [false].concat(args));\n    }\n  }, {\n    key: 'toggle',\n    value: function toggle() {\n      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this._setVisible.apply(this, [!this.visible].concat(args));\n    }\n  }, {\n    key: '_setVisible',\n    value: function _setVisible(shouldShow) {\n      var _util$triggerElementE,\n          _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var action = shouldShow ? 'show' : 'hide';\n\n      options = _extends({}, options);\n      options.animationOptions = util.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));\n\n      var canceled = false;\n      util.triggerElementEvent(this, 'pre' + action, (_util$triggerElementE = {}, defineProperty(_util$triggerElementE, this._selfCamelName, this), defineProperty(_util$triggerElementE, 'cancel', function cancel() {\n        return canceled = true;\n      }), _util$triggerElementE));\n\n      if (canceled) {\n        return Promise.reject('Canceled in pre' + action + ' event.');\n      }\n\n      return new Promise(function (resolve) {\n        _this3._doorLock.waitUnlock(function () {\n          var unlock = _this3._doorLock.lock();\n          var animator = _this3._animatorFactory.newAnimator(options);\n\n          shouldShow && _this3._toggleStyle(true, options);\n          _this3._visible = shouldShow;\n\n          contentReady(_this3, function () {\n            animator[action](_this3, function () {\n              !shouldShow && _this3._toggleStyle(false, options);\n\n              unlock();\n\n              util.propagateAction(_this3, '_' + action);\n              util.triggerElementEvent(_this3, 'post' + action, defineProperty({}, _this3._selfCamelName, _this3)); // postshow posthide\n\n              if (options.callback instanceof Function) {\n                options.callback(_this3);\n              }\n\n              resolve(_this3);\n            });\n          });\n        });\n      });\n    }\n  }, {\n    key: '_updateMask',\n    value: function _updateMask() {\n      var _this4 = this;\n\n      contentReady(this, function () {\n        if (_this4._mask && _this4.getAttribute('mask-color')) {\n          _this4._mask.style.backgroundColor = _this4.getAttribute('mask-color');\n        }\n      });\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this5 = this;\n\n      this.onDeviceBackButton = this._defaultDBB.bind(this);\n\n      contentReady(this, function () {\n        if (_this5._mask) {\n          _this5._mask.addEventListener('click', _this5._cancel, false);\n          _this5._mask.addEventListener('touchmove', _this5._preventScroll, false); // iOS fix\n        }\n      });\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this._backButtonHandler.destroy();\n      this._backButtonHandler = null;\n\n      if (this._mask) {\n        this._mask.removeEventListener('click', this._cancel, false);\n        this._mask.removeEventListener('touchmove', this._preventScroll, false);\n      }\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, this._scheme);\n          break;\n        case 'animation':\n          this._animatorFactory = this._updateAnimatorFactory();\n          break;\n        case 'mask-color':\n          this._updateMask();\n          break;\n      }\n    }\n  }, {\n    key: 'onDeviceBackButton',\n    get: function get$$1() {\n      return this._backButtonHandler;\n    },\n    set: function set$$1(callback) {\n      if (this._backButtonHandler) {\n        this._backButtonHandler.destroy();\n      }\n\n      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);\n    }\n  }, {\n    key: 'visible',\n    get: function get$$1() {\n      return this._visible;\n    }\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n  }, {\n    key: 'cancelable',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'cancelable', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('cancelable');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'animation', 'mask-color'];\n    }\n  }, {\n    key: 'events',\n    get: function get$$1() {\n      return ['preshow', 'postshow', 'prehide', 'posthide', 'dialog-cancel'];\n    }\n  }]);\n  return BaseDialogElement;\n}(BaseElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme = {\n  '.action-sheet': 'action-sheet--*',\n  '.action-sheet-mask': 'action-sheet-mask--*',\n  '.action-sheet-title': 'action-sheet-title--*'\n};\n\nvar _animatorDict = {\n  'default': function _default() {\n    return platform.isAndroid() ? MDActionSheetAnimator : IOSActionSheetAnimator;\n  },\n  'none': ActionSheetAnimator\n};\n\n/**\n * @element ons-action-sheet\n * @category dialog\n * @description\n *   [en]\n *     Action/bottom sheet that is displayed on top of current screen.\n *\n *     This element can either be attached directly to the `<body>` or dynamically created from a template using the `ons.createElement(template, { append: true })` utility function and the `<ons-template>` tag.\n *\n *     The action sheet is useful for displaying a list of options and asking the user to make a decision. A `ons-action-sheet-button` is provided for this purpose, although it can contain any type of content.\n *\n *     It will automatically be displayed as Material Design (bottom sheet) when running on an Android device.\n *   [/en]\n *   [ja]\n *     アクションシート、もしくはボトムシートを現在のスクリーン上に表示します。\n *\n *     この要素は、`<body>`要素に直接アタッチされるか、もしくは`ons.createElement(template, { append: true })`と`<ons-template>`タグを使ってテンプレートから動的に生成されます。\n *\n *     アクションシートは、選択肢のリストを表示してユーザーに尋ねるのに便利です。`ons-action-sheet-button`は、この要素の中に置くために提供されていますが、それ以外にも他のどのような要素を含むことができます。\n *\n *     Androidデバイスで実行されるときには、自動的にマテリアルデザイン(ボトムシート)として表示されます。\n *   [/ja]\n * @modifier material\n *   [en]Display a Material Design bottom sheet.[/en]\n *   [ja]マテリアルデザインのボトムシートを表示します。[/ja]\n * @tutorial vanilla/reference/action-sheet\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @seealso ons-popover\n *   [en]`<ons-popover>` component[/en]\n *   [ja]ons-popoverコンポーネント[/ja]\n * @seealso ons-modal\n *   [en]`<ons-modal>` component[/en]\n *   [ja]ons-modalコンポーネント[/ja]\n * @example\n * <ons-action-sheet id=\"sheet\">\n *   <ons-action-sheet-button>Label</ons-action-sheet-button>\n *   <ons-action-sheet-button>Label</ons-action-sheet-button>\n * </ons-action-sheet>\n *\n * <script>\n *   document.getElementById('sheet').show();\n * </script>\n */\n\nvar ActionSheetElement = function (_BaseDialogElement) {\n  inherits(ActionSheetElement, _BaseDialogElement);\n\n  /**\n   * @event preshow\n   * @description\n   * [en]Fired just before the action sheet is displayed.[/en]\n   * [ja]ダイアログが表示される直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.actionSheet\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Execute this function to stop the action sheet from being shown.[/en]\n   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]\n   */\n\n  /**\n   * @event postshow\n   * @description\n   * [en]Fired just after the action sheet is displayed.[/en]\n   * [ja]ダイアログが表示された直後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.actionSheet\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @event prehide\n   * @description\n   * [en]Fired just before the action sheet is hidden.[/en]\n   * [ja]ダイアログが隠れる直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.actionSheet\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Execute this function to stop the action sheet from being hidden.[/en]\n   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]\n   */\n\n  /**\n   * @event posthide\n   * @description\n   * [en]Fired just after the action sheet is hidden.[/en]\n   * [ja]ダイアログが隠れた後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.actionSheet\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @attribute title\n   * @type {String}\n   * @description\n   *  [en]Optional title of the action sheet. A new element will be created containing this string.[/en]\n   *  [ja]アクションシートのタイトルを指定します。ここで指定した文字列を含む新しい要素が作成されます。[/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *  [en]The appearance of the action sheet.[/en]\n   *  [ja]ダイアログの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute cancelable\n   * @description\n   *  [en]If this attribute is set the action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]\n   *  [ja]この属性が設定されると、アクションシートの背景やAndroidデバイスのバックボタンを推すことでアクションシートが閉じるようになります。[/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *  [en]If this attribute is set the action sheet is disabled.[/en]\n   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]\n   */\n\n  /**\n   * @attribute animation\n   * @type {String}\n   * @default default\n   * @description\n   *  [en]The animation used when showing and hiding the action sheet. Can be either `\"none\"` or `\"default\"`.[/en]\n   *  [ja]ダイアログを表示する際のアニメーション名を指定します。\"none\"もしくは\"default\"を指定できます。[/ja]\n   */\n\n  /**\n   * @attribute animation-options\n   * @type {Expression}\n   * @description\n   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]\n   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]\n   */\n\n  /**\n   * @attribute mask-color\n   * @type {String}\n   * @default rgba(0, 0, 0, 0.2)\n   * @description\n   *  [en]Color of the background mask. Default is `\"rgba(0, 0, 0, 0.2)\"`.[/en]\n   *  [ja]背景のマスクの色を指定します。\"rgba(0, 0, 0, 0.2)\"がデフォルト値です。[/ja]\n   */\n\n  function ActionSheetElement() {\n    classCallCheck(this, ActionSheetElement);\n\n    var _this = possibleConstructorReturn(this, (ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(ActionSheetElement, [{\n    key: '_updateAnimatorFactory',\n    value: function _updateAnimatorFactory() {\n      return new AnimatorFactory({\n        animators: _animatorDict,\n        baseClass: ActionSheetAnimator,\n        baseClassName: 'ActionSheetAnimator',\n        defaultAnimation: this.getAttribute('animation')\n      });\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.style.display = 'none';\n      this.style.zIndex = 10001;\n\n      /* Expected result:\n       *   <ons-action-sheet>\n       *     <div class=\"action-sheet-mask\"></div>\n       *     <div class=\"action-sheet\">\n       *       <div class=\"action-sheet-title></div>\n       *       ...\n       *     </div>\n       *   </ons-action-sheet>\n       */\n\n      if (!this._sheet) {\n        var sheet = document.createElement('div');\n        sheet.classList.add('action-sheet');\n\n        while (this.firstChild) {\n          sheet.appendChild(this.firstChild);\n        }\n\n        this.appendChild(sheet);\n      }\n\n      if (!this._title && this.hasAttribute('title')) {\n        var title = document.createElement('div');\n        title.innerHTML = this.getAttribute('title');\n        title.classList.add('action-sheet-title');\n        this._sheet.insertBefore(title, this._sheet.firstChild);\n      }\n\n      if (!this._mask) {\n        var mask = document.createElement('div');\n        mask.classList.add('action-sheet-mask');\n        this.insertBefore(mask, this.firstChild);\n      }\n\n      this._sheet.style.zIndex = 20001;\n      this._mask.style.zIndex = 20000;\n\n      ModifierUtil.initModifier(this, this._scheme);\n    }\n  }, {\n    key: '_updateTitle',\n    value: function _updateTitle() {\n      if (this._title) {\n        this._title.innerHTML = this.getAttribute('title');\n      }\n    }\n\n    /**\n     * @property onDeviceBackButton\n     * @type {Object}\n     * @description\n     *   [en]Back-button handler.[/en]\n     *   [ja]バックボタンハンドラ。[/ja]\n     */\n\n    /**\n     * @method show\n     * @signature show([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"none\"` and `\"slide\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"none\", \"slide\"のいずれかを指定します。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]\n     * @param {Function} [options.callback]\n     *   [en]This function is called after the action sheet has been revealed.[/en]\n     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *  [en]Show the action sheet.[/en]\n     *  [ja]ダイアログを開きます。[/ja]\n     * @return {Promise} Resolves to the displayed element.\n     */\n\n    /**\n     * @method hide\n     * @signature hide([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"none\"` and `\"slide\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"none\", \"slide\"のいずれかを指定できます。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]\n     * @param {Function} [options.callback]\n     *   [en]This functions is called after the action sheet has been hidden.[/en]\n     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *   [en]Hide the action sheet.[/en]\n     *   [ja]ダイアログを閉じます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the hidden element[/en]\n     *   [ja]隠れた要素を解決します。[/ja]\n     */\n\n    /**\n     * @property visible\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the action sheet is visible or not.[/en]\n     *   [ja]要素が見える場合に`true`。[/ja]\n     */\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the action sheet is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n    /**\n     * @property cancelable\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the action sheet is cancelable or not. A cancelable action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]\n     *   [ja]アクションシートがキャンセル可能かどうかを設定します。キャンセル可能なアクションシートは、背景をタップしたりAndroidデバイスのバックボタンを推すことで閉じるようになります。[/ja]\n     */\n\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'title') {\n        this._updateTitle();\n      } else {\n        get(ActionSheetElement.prototype.__proto__ || Object.getPrototypeOf(ActionSheetElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);\n      }\n    }\n\n    /**\n     * @param {String} name\n     * @param {ActionSheetAnimator} Animator\n     */\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme;\n    }\n  }, {\n    key: '_mask',\n    get: function get$$1() {\n      return util.findChild(this, '.action-sheet-mask');\n    }\n  }, {\n    key: '_sheet',\n    get: function get$$1() {\n      return util.findChild(this, '.action-sheet');\n    }\n  }, {\n    key: '_title',\n    get: function get$$1() {\n      return this.querySelector('.action-sheet-title');\n    }\n  }], [{\n    key: 'registerAnimator',\n    value: function registerAnimator(name, Animator) {\n      if (!(Animator.prototype instanceof ActionSheetAnimator)) {\n        throw new Error('\"Animator\" param must inherit OnsActionSheetElement.ActionSheetAnimator');\n      }\n      _animatorDict[name] = Animator;\n    }\n  }, {\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return [].concat(toConsumableArray(get(ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement), 'observedAttributes', this)), ['title']);\n    }\n  }, {\n    key: 'animators',\n    get: function get$$1() {\n      return _animatorDict;\n    }\n  }, {\n    key: 'ActionSheetAnimator',\n    get: function get$$1() {\n      return ActionSheetAnimator;\n    }\n  }]);\n  return ActionSheetElement;\n}(BaseDialogElement);\n\nons$1.elements.ActionSheet = ActionSheetElement;\ncustomElements.define('ons-action-sheet', ActionSheetElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName = 'action-sheet-button';\nvar scheme$1 = {\n  '': 'action-sheet-button--*',\n  '.action-sheet-icon': 'action-sheet-icon--*'\n};\n\n/**\n * @element ons-action-sheet-button\n * @category dialog\n * @modifier destructive\n *   [en]Shows a \"destructive\" button (only for iOS).[/en]\n *   [ja]\"destructive\"なボタンを表示します(iOSでのみ有効)。[/ja]\n * @description\n *   [en]Component that represent each button of the action sheet.[/en]\n *   [ja]アクションシートに表示される各ボタンを表現するコンポーネントです。[/ja]\n * @seealso ons-action-sheet\n *   [en]The `<ons-action-sheet>` component[/en]\n *   [ja]ons-action-sheetコンポーネント[/ja]\n * @seealso ons-list-item\n *   [en]The `<ons-list-item>` component[/en]\n *   [ja]ons-list-itemコンポーネント[/ja]\n * @seealso ons-icon\n *   [en]The `<ons-icon>` component[/en]\n *   [ja]ons-iconコンポーネント[/ja]\n * @tutorial vanilla/Reference/action-sheet\n * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]\n * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]\n * @modifier material\n *   [en]Display a Material Design action sheet button.[/en]\n *   [ja]マテリアルデザインのアクションシート用のボタンを表示します。[/ja]\n * @example\n * <ons-action-sheet id=\"sheet\">\n *   <ons-action-sheet-button>Label</ons-action-sheet-button>\n *   <ons-action-sheet-button>Label</ons-action-sheet-button>\n * </ons-action-sheet>\n *\n * <script>\n *   document.getElementById('sheet').show();\n * </script>\n */\n\nvar ActionSheetButtonElement = function (_BaseElement) {\n  inherits(ActionSheetButtonElement, _BaseElement);\n\n  /**\n   * @attribute icon\n   * @type {String}\n   * @description\n   *  [en]Creates an `ons-icon` component with this string. Only visible on Android. Check [See also](#seealso) section for more information.[/en]\n   *  [ja]`ons-icon`コンポーネントを悪性します。Androidでのみ表示されます。[/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the action sheet button.[/en]\n   *   [ja]アクションシートボタンの見た目を設定します。[/ja]\n   */\n\n  function ActionSheetButtonElement() {\n    classCallCheck(this, ActionSheetButtonElement);\n\n    var _this = possibleConstructorReturn(this, (ActionSheetButtonElement.__proto__ || Object.getPrototypeOf(ActionSheetButtonElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(ActionSheetButtonElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n      this.classList.add(defaultClassName);\n\n      if (!this._icon && this.hasAttribute('icon')) {\n        var icon = util.createElement('<ons-icon icon=\"' + this.getAttribute('icon') + '\"></ons-icon>');\n        icon.classList.add('action-sheet-icon');\n        this.insertBefore(icon, this.firstChild);\n      }\n\n      ModifierUtil.initModifier(this, scheme$1);\n    }\n  }, {\n    key: '_updateIcon',\n    value: function _updateIcon() {\n      if (this._icon) {\n        this._icon.setAttribute('icon', this.getAttribute('icon'));\n      }\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName, scheme$1);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$1);\n          break;\n        case 'icon':\n          this._updateIcon();\n          break;\n      }\n    }\n  }, {\n    key: '_icon',\n    get: function get$$1() {\n      return util.findChild(this, '.action-sheet-icon');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class', 'icon'];\n    }\n  }]);\n  return ActionSheetButtonElement;\n}(BaseElement);\n\nons$1.elements.ActionSheetButton = ActionSheetButtonElement;\ncustomElements.define('ons-action-sheet-button', ActionSheetButtonElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar AlertDialogAnimator = function (_BaseAnimator) {\n  inherits(AlertDialogAnimator, _BaseAnimator);\n\n  function AlertDialogAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'linear' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.2 : _ref$duration;\n\n    classCallCheck(this, AlertDialogAnimator);\n    return possibleConstructorReturn(this, (AlertDialogAnimator.__proto__ || Object.getPrototypeOf(AlertDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {HTMLElement} dialog\n   * @param {Function} done\n   */\n\n\n  createClass(AlertDialogAnimator, [{\n    key: 'show',\n    value: function show(dialog, done) {\n      done();\n    }\n\n    /**\n     * @param {HTMLElement} dialog\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, done) {\n      done();\n    }\n  }]);\n  return AlertDialogAnimator;\n}(BaseAnimator);\n\n/**\n * Android style animator for alert dialog.\n */\nvar AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {\n  inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);\n\n  function AndroidAlertDialogAnimator() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$timing = _ref2.timing,\n        timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing,\n        _ref2$duration = _ref2.duration,\n        duration = _ref2$duration === undefined ? 0.2 : _ref2$duration,\n        _ref2$delay = _ref2.delay,\n        delay = _ref2$delay === undefined ? 0 : _ref2$delay;\n\n    classCallCheck(this, AndroidAlertDialogAnimator);\n    return possibleConstructorReturn(this, (AndroidAlertDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));\n  }\n\n  /**\n   * @param {Object} dialog\n   * @param {Function} callback\n   */\n\n\n  createClass(AndroidAlertDialogAnimator, [{\n    key: 'show',\n    value: function show(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 0\n      }).wait(this.delay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',\n          opacity: 0.0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',\n          opacity: 1.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {Object} dialog\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',\n          opacity: 1.0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0) scale3d(0.9, 0.9, 1.0)',\n          opacity: 0.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n  }]);\n  return AndroidAlertDialogAnimator;\n}(AlertDialogAnimator);\n\n/**\n * iOS style animator for alert dialog.\n */\nvar IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {\n  inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);\n\n  function IOSAlertDialogAnimator() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$timing = _ref3.timing,\n        timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing,\n        _ref3$duration = _ref3.duration,\n        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration,\n        _ref3$delay = _ref3.delay,\n        delay = _ref3$delay === undefined ? 0 : _ref3$delay;\n\n    classCallCheck(this, IOSAlertDialogAnimator);\n    return possibleConstructorReturn(this, (IOSAlertDialogAnimator.__proto__ || Object.getPrototypeOf(IOSAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));\n  }\n\n  /*\n   * @param {Object} dialog\n   * @param {Function} callback\n   */\n\n\n  createClass(IOSAlertDialogAnimator, [{\n    key: 'show',\n    value: function show(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 0\n      }).wait(this.delay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1.0)',\n          opacity: 0.0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0) scale3d(1.0, 1.0, 1.0)',\n          opacity: 1.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {Object} dialog\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          opacity: 1.0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          opacity: 0.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n  }]);\n  return IOSAlertDialogAnimator;\n}(AlertDialogAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$2 = {\n  '.alert-dialog': 'alert-dialog--*',\n  '.alert-dialog-container': 'alert-dialog-container--*',\n  '.alert-dialog-title': 'alert-dialog-title--*',\n  '.alert-dialog-content': 'alert-dialog-content--*',\n  '.alert-dialog-footer': 'alert-dialog-footer--*',\n  '.alert-dialog-footer--rowfooter': 'alert-dialog-footer--rowfooter--*',\n  '.alert-dialog-button--rowfooter': 'alert-dialog-button--rowfooter--*',\n  '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',\n  '.alert-dialog-button': 'alert-dialog-button--*',\n  'ons-alert-dialog-button': 'alert-dialog-button--*',\n  '.alert-dialog-mask': 'alert-dialog-mask--*',\n  '.text-input': 'text-input--*'\n};\n\nvar _animatorDict$1 = {\n  'none': AlertDialogAnimator,\n  'default': function _default() {\n    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;\n  },\n  'fade': function fade() {\n    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;\n  }\n};\n\n/**\n * @element ons-alert-dialog\n * @category dialog\n * @description\n *   [en]\n *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.\n *\n *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<ons-template>` tag.\n *   [/en]\n *   [ja]\n *     現在のスクリーンの上に表示するアラートダイアログです。ユーザに対する問いかけ、警告、エラーメッセージを表示するのに利用できます。タイトルやコンテンツやボタンは簡単にカスタマイズでき、実行しているプラットフォームに併せてスタイルが自動的に切り替わります。\n *   [/ja]\n * @codepen Qwwxyp\n * @tutorial vanilla/Reference/dialog\n * @modifier material\n *   [en]Material Design style[/en]\n *   [ja]マテリアルデザインのスタイル[/ja]\n * @modifier rowfooter\n *   [en]Horizontally aligns the footer buttons.[/en]\n *   [ja]フッターの複数のボタンを水平に配置[/ja]\n * @seealso ons-dialog\n *   [en]ons-dialog component[/en]\n *   [ja]ons-dialogコンポーネント[/ja]\n * @seealso ons-popover\n *   [en]ons-popover component[/en]\n *   [ja]ons-dialogコンポーネント[/ja]\n * @seealso ons.notification\n *   [en]Using ons.notification utility functions.[/en]\n *   [ja]アラートダイアログを表示するには、ons.notificationオブジェクトのメソッドを使うこともできます。[/ja]\n * @example\n * <ons-alert-dialog id=\"alert-dialog\">\n *   <div class=\"alert-dialog-title\">Warning!</div>\n *   <div class=\"alert-dialog-content\">\n *     An error has occurred!\n *   </div>\n *   <div class=\"alert-dialog-footer\">\n *     <button id=\"alert-dialog-button\" class=\"alert-dialog-button\">OK</button>\n *   </div>\n * </ons-alert-dialog>\n * <script>\n *   document.getElementById('alert-dialog').show();\n * </script>\n */\n\nvar AlertDialogElement = function (_BaseDialogElement) {\n  inherits(AlertDialogElement, _BaseDialogElement);\n\n  /**\n   * @event preshow\n   * @description\n   *   [en]Fired just before the alert dialog is displayed.[/en]\n   *   [ja]アラートダイアログが表示される直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.alertDialog\n   *   [en]Alert dialog object.[/en]\n   *   [ja]アラートダイアログのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Execute to stop the dialog from showing.[/en]\n   *   [ja]この関数を実行すると、アラートダイアログの表示を止めます。[/ja]\n   */\n\n  /**\n   * @event postshow\n   * @description\n   *   [en]Fired just after the alert dialog is displayed.[/en]\n   *   [ja]アラートダイアログが表示された直後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.alertDialog\n   *   [en]Alert dialog object.[/en]\n   *   [ja]アラートダイアログのオブジェクト。[/ja]\n   */\n\n  /**\n   * @event prehide\n   * @description\n   *   [en]Fired just before the alert dialog is hidden.[/en]\n   *   [ja]アラートダイアログが隠れる直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.alertDialog\n   *   [en]Alert dialog object.[/en]\n   *   [ja]アラートダイアログのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Execute to stop the dialog from hiding.[/en]\n   *   [ja]この関数を実行すると、アラートダイアログが閉じようとするのを止めます。[/ja]\n   */\n\n  /**\n   * @event posthide\n   * @description\n   * [en]Fired just after the alert dialog is hidden.[/en]\n   * [ja]アラートダイアログが隠れた後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.alertDialog\n   *   [en]Alert dialog object.[/en]\n   *   [ja]アラートダイアログのオブジェクト。[/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *  [en]The appearance of the dialog.[/en]\n   *  [ja]ダイアログの見た目を指定します。[/ja]\n   */\n\n  /**\n   * @attribute cancelable\n   * @description\n   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]\n   *  [ja]この属性を設定すると、ダイアログの背景をタップしたりAndroidデバイスのバックボタンを押すとダイアログが閉じるようになります。[/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *  [en]If this attribute is set the dialog is disabled.[/en]\n   *  [ja]この属性がある時、アラートダイアログはdisabled状態になります。[/ja]\n   */\n\n  /**\n   * @attribute animation\n   * @type {String}\n   * @default default\n   * @description\n   *  [en]The animation used when showing and hiding the dialog. Can be either `\"none\"` or `\"default\"`.[/en]\n   *  [ja]ダイアログを表示する際のアニメーション名を指定します。デフォルトでは\"none\"か\"default\"が指定できます。[/ja]\n   */\n\n  /**\n   * @attribute animation-options\n   * @type {Expression}\n   * @description\n   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]\n   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]\n   */\n\n  /**\n   * @attribute mask-color\n   * @type {String}\n   * @default rgba(0, 0, 0, 0.2)\n   * @description\n   *  [en]Color of the background mask. Default is \"rgba(0, 0, 0, 0.2)\".[/en]\n   *  [ja]背景のマスクの色を指定します。\"rgba(0, 0, 0, 0.2)\"がデフォルト値です。[/ja]\n   */\n\n  function AlertDialogElement() {\n    classCallCheck(this, AlertDialogElement);\n\n    var _this = possibleConstructorReturn(this, (AlertDialogElement.__proto__ || Object.getPrototypeOf(AlertDialogElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(AlertDialogElement, [{\n    key: '_updateAnimatorFactory',\n    value: function _updateAnimatorFactory() {\n      return new AnimatorFactory({\n        animators: _animatorDict$1,\n        baseClass: AlertDialogAnimator,\n        baseClassName: 'AlertDialogAnimator',\n        defaultAnimation: this.getAttribute('animation')\n      });\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.style.display = 'none';\n      this.style.zIndex = 10001;\n\n      /**\n       * Expected result after compile:\n       *\n       * <ons-alert-dialog style=\"none\">\n       *   <div class=\"alert-dialog-mask\"></div>\n       *   <div class=\"alert-dialog\">\n       *     <div class=\"alert-dialog-container\">...</div>\n       *   </div>\n       * </ons-alert-dialog>\n       */\n\n      var content = document.createDocumentFragment();\n\n      if (!this._mask && !this._dialog) {\n        while (this.firstChild) {\n          content.appendChild(this.firstChild);\n        }\n      }\n\n      if (!this._mask) {\n        var mask = document.createElement('div');\n        mask.classList.add('alert-dialog-mask');\n        this.insertBefore(mask, this.children[0]);\n      }\n\n      if (!this._dialog) {\n        var dialog = document.createElement('div');\n        dialog.classList.add('alert-dialog');\n        this.insertBefore(dialog, null);\n      }\n\n      if (!util.findChild(this._dialog, '.alert-dialog-container')) {\n        var container = document.createElement('div');\n        container.classList.add('alert-dialog-container');\n        this._dialog.appendChild(container);\n      }\n\n      this._dialog.children[0].appendChild(content);\n\n      this._dialog.style.zIndex = 20001;\n      this._mask.style.zIndex = 20000;\n\n      ModifierUtil.initModifier(this, this._scheme);\n    }\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n    /**\n     * @property cancelable\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]\n     *   [ja]そのダイアログがキャンセル可能かどうかを表します。キャンセル可能なダイアログは、背景をタップするかAndroidデバイスのバックボタンを押すことで閉じることが出来るようになります。[/ja]\n     */\n\n    /**\n     * @method show\n     * @signature show([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクトです。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"fade\"` and `\"none\"`.[/en]\n     *   [ja]アニメーション名を指定します。指定できるのは、\"fade\", \"none\"のいずれかです。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]\n     * @param {Function} [options.callback]\n     *   [en]Function to execute after the dialog has been revealed.[/en]\n     *   [ja]ダイアログが表示され終わった時に呼び出されるコールバックを指定します。[/ja]\n     * @description\n     *   [en]Show the alert dialog.[/en]\n     *   [ja]ダイアログを表示します。[/ja]\n     * @return {Promise}\n     *   [en]A `Promise` object that resolves to the displayed element.[/en]\n     *   [ja]表示される要素を解決する`Promise`オブジェクトを返します。[/ja]\n     */\n\n    /**\n     * @method hide\n     * @signature hide([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"fade\"` and `\"none\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"fade\", \"none\"のいずれかを指定します。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]\n     * @param {Function} [options.callback]\n     *   [en]Function to execute after the dialog has been hidden.[/en]\n     *   [ja]このダイアログが閉じた時に呼び出されるコールバックを指定します。[/ja]\n     * @description\n     *   [en]Hide the alert dialog.[/en]\n     *   [ja]ダイアログを閉じます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the hidden element[/en]\n     *   [ja]隠れた要素を解決する`Promise`オブジェクトを返します。[/ja]\n     */\n\n    /**\n     * @property visible\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the dialog is visible or not.[/en]\n     *   [ja]要素が見える場合に`true`。[/ja]\n     */\n\n    /**\n     * @property onDeviceBackButton\n     * @type {Object}\n     * @description\n     *   [en]Back-button handler.[/en]\n     *   [ja]バックボタンハンドラ。[/ja]\n     */\n\n    /**\n     * @param {String} name\n     * @param {DialogAnimator} Animator\n     */\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$2;\n    }\n\n    /**\n     * @return {Element}\n     */\n\n  }, {\n    key: '_mask',\n    get: function get$$1() {\n      return util.findChild(this, '.alert-dialog-mask');\n    }\n\n    /**\n     * @return {Element}\n     */\n\n  }, {\n    key: '_dialog',\n    get: function get$$1() {\n      return util.findChild(this, '.alert-dialog');\n    }\n\n    /**\n     * @return {Element}\n     */\n\n  }, {\n    key: '_titleElement',\n    get: function get$$1() {\n      return util.findChild(this._dialog.children[0], '.alert-dialog-title');\n    }\n\n    /**\n     * @return {Element}\n     */\n\n  }, {\n    key: '_contentElement',\n    get: function get$$1() {\n      return util.findChild(this._dialog.children[0], '.alert-dialog-content');\n    }\n  }], [{\n    key: 'registerAnimator',\n    value: function registerAnimator(name, Animator) {\n      if (!(Animator.prototype instanceof AlertDialogAnimator)) {\n        throw new Error('\"Animator\" param must inherit OnsAlertDialogElement.AlertDialogAnimator');\n      }\n      _animatorDict$1[name] = Animator;\n    }\n  }, {\n    key: 'animators',\n    get: function get$$1() {\n      return _animatorDict$1;\n    }\n  }, {\n    key: 'AlertDialogAnimator',\n    get: function get$$1() {\n      return AlertDialogAnimator;\n    }\n  }]);\n  return AlertDialogElement;\n}(BaseDialogElement);\n\nons$1.elements.AlertDialog = AlertDialogElement;\ncustomElements.define('ons-alert-dialog', AlertDialogElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$1 = 'alert-dialog-button';\n\nvar scheme$3 = { '': 'alert-dialog-button--*' };\n\n/**\n * @element ons-alert-dialog-button\n * @modifier material\n *   [en]Material Design alert-dialog button.[/en]\n *   [ja]マテリアルデザインのボタンを表示します。[/ja]\n * @description\n *   [en][/en]\n *   [ja][/ja]\n * @seealso ons-alert-dialog\n *   [en]The `<ons-alert-dialog>` component displays a alert dialog.[/en]\n *   [ja]ons-alert-dialogコンポーネント[/ja]\n * @example\n *  <ons-alert-dialog>\n *    <div class=\"alert-dialog-title\">Warning!</div>\n *    <div class=\"alert-dialog-content\">\n *      An error has occurred!\n *    </div>\n *    <div class=\"alert-dialog-footer\">\n *      <alert-dialog-button onclick=\"app.close()\">Cancel</alert-dialog-button>\n *      <alert-dialog-button class=\"alert-dialog-button\" onclick=\"app.close()\">OK</alert-dialog-button>\n *    </div>\n *  </ons-alert-dialog>\n */\n\nvar AlertDialogButtonElement = function (_BaseElement) {\n  inherits(AlertDialogButtonElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the button.[/en]\n   *   [ja]ボタンの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *   [en]Specify if button should be disabled.[/en]\n   *   [ja]ボタンを無効化する場合は指定してください。[/ja]\n   */\n\n  function AlertDialogButtonElement() {\n    classCallCheck(this, AlertDialogButtonElement);\n\n    var _this = possibleConstructorReturn(this, (AlertDialogButtonElement.__proto__ || Object.getPrototypeOf(AlertDialogButtonElement)).call(this));\n\n    _this._compile();\n    return _this;\n  }\n\n  /**\n   * @property disabled\n   * @type {Boolean}\n   * @description\n   *   [en]Whether the element is disabled or not.[/en]\n   *   [ja]無効化されている場合に`true`。[/ja]\n   */\n\n\n  createClass(AlertDialogButtonElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.classList.add(defaultClassName$1);\n\n      util.updateRipple(this, undefined, { 'modifier': 'light-gray' });\n\n      ModifierUtil.initModifier(this, scheme$3);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$1, scheme$3);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$3);\n          break;\n      }\n    }\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'];\n    }\n  }]);\n  return AlertDialogButtonElement;\n}(BaseElement);\n\nons$1.elements.AlertDialogButton = AlertDialogButtonElement;\ncustomElements.define('ons-alert-dialog-button', AlertDialogButtonElement);\n\nvar iosBackButtonIcon = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<svg width=\\\"13px\\\" height=\\\"21px\\\" viewBox=\\\"0 0 13 21\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">\\n    <title>ios-back-button-icon</title>\\n    <desc>Created with Sketch.</desc>\\n    <defs></defs>\\n    <g id=\\\"toolbar-back-button\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill-rule=\\\"evenodd\\\">\\n        <g id=\\\"ios\\\" transform=\\\"translate(-34.000000, -30.000000)\\\">\\n            <polygon id=\\\"ios-back-button-icon\\\" points=\\\"34 40.5 44.5 30 46.5 32 38 40.5 46.5 49 44.5 51\\\"></polygon>\\n        </g>\\n    </g>\\n</svg>\\n\";\n\nvar mdBackButtonIcon = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<svg width=\\\"16px\\\" height=\\\"16px\\\" viewBox=\\\"0 0 16 16\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">\\n    <title>md-back-button-icon</title>\\n    <desc>Created with Sketch.</desc>\\n    <defs></defs>\\n    <g id=\\\"toolbar-back-button\\\" stroke=\\\"none\\\" stroke-width=\\\"1\\\" fill-rule=\\\"evenodd\\\">\\n        <g id=\\\"android\\\" transform=\\\"translate(-32.000000, -32.000000)\\\" fill-rule=\\\"nonzero\\\">\\n            <polygon id=\\\"md-back-button-icon\\\" points=\\\"48 39 35.83 39 41.42 33.41 40 32 32 40 40 48 41.41 46.59 35.83 41 48 41\\\"></polygon>\\n        </g>\\n    </g>\\n</svg>\\n\";\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$2 = 'back-button';\n\nvar scheme$4 = {\n  '': 'back-button--*',\n  '.back-button__icon': 'back-button--*__icon',\n  '.back-button__label': 'back-button--*__label'\n};\n\n/**\n * @element ons-back-button\n * @category navigation\n * @description\n *   [en]\n *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.\n *\n *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.\n *   [/en]\n *   [ja][/ja]\n * @codepen aHmGL\n * @tutorial vanilla/Reference/navigator\n * @modifier material\n *   [en]Material Design style[/en]\n *   [ja][/ja]\n * @seealso ons-toolbar\n *   [en]ons-toolbar component[/en]\n *   [ja]ons-toolbarコンポーネント[/ja]\n * @seealso ons-navigator\n *   [en]ons-navigator component[/en]\n *   [ja]ons-navigatorコンポーネント[/ja]\n * @example\n * <ons-toolbar>\n *   <div class=\"left\">\n *     <ons-back-button>Back</ons-back-button>\n *   </div>\n *   <div class=\"center\">\n *     Title\n *   <div>\n * </ons-toolbar>\n */\n\nvar BackButtonElement = function (_BaseElement) {\n  inherits(BackButtonElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *  [en]The appearance of the back button.[/en]\n   *  [ja]バックボタンの見た目を指定します。[/ja]\n   */\n\n  function BackButtonElement() {\n    classCallCheck(this, BackButtonElement);\n\n    var _this = possibleConstructorReturn(this, (BackButtonElement.__proto__ || Object.getPrototypeOf(BackButtonElement)).call(this));\n\n    contentReady(_this, function () {\n      _this._compile();\n    });\n\n    _this._options = {};\n    _this._boundOnClick = _this._onClick.bind(_this);\n    return _this;\n  }\n\n  createClass(BackButtonElement, [{\n    key: '_updateIcon',\n    value: function _updateIcon() {\n      var icon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : util.findChild(this, '.back-button__icon');\n\n      icon.innerHTML = autoStyle.getPlatform(this) === 'android' || util.hasModifier(this, 'material') ? mdBackButtonIcon : iosBackButtonIcon;\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.classList.add(defaultClassName$2);\n\n      if (!util.findChild(this, '.back-button__label')) {\n        var label = util.create('span.back-button__label');\n\n        while (this.childNodes[0]) {\n          label.appendChild(this.childNodes[0]);\n        }\n        this.appendChild(label);\n      }\n\n      if (!util.findChild(this, '.back-button__icon')) {\n        var icon = util.create('span.back-button__icon');\n        this._updateIcon(icon);\n\n        this.insertBefore(icon, this.children[0]);\n      }\n\n      util.updateRipple(this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' });\n\n      ModifierUtil.initModifier(this, scheme$4);\n    }\n\n    /**\n     * @property options\n     * @type {Object}\n     * @description\n     *   [en]Options object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     */\n\n    /**\n     * @property options.animation\n     * @type {String}\n     * @description\n     *   [en]Animation name. Available animations are \"slide\", \"lift\", \"fade\" and \"none\".\n     *     These are platform based animations. For fixed animations, add \"-ios\" or \"-md\"\n     *     suffix to the animation name. E.g. \"lift-ios\", \"lift-md\". Defaults values are \"slide-ios\" and \"fade-md\".\n     *   [/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property options.animationOptions\n     * @type {String}\n     * @description\n     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]\n     */\n\n    /**\n     * @property options.callback\n     * @type {String}\n     * @description\n     *   [en]Function that is called when the transition has ended.[/en]\n     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]\n     */\n\n  }, {\n    key: '_onClick',\n\n\n    /**\n     * @property onClick\n     * @type {Function}\n     * @description\n     *   [en]Used to override the default back button behavior.[/en]\n     *   [ja][/ja]\n     */\n    value: function _onClick() {\n      if (this.onClick) {\n        this.onClick.apply(this);\n      } else {\n        var navigator = util.findParent(this, 'ons-navigator');\n        if (navigator) {\n          navigator.popPage(this.options);\n        }\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      this.addEventListener('click', this._boundOnClick, false);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$2, scheme$4);\n          break;\n\n        case 'modifier':\n          {\n            ModifierUtil.onModifierChanged(last, current, this, scheme$4) && this._updateIcon();\n            break;\n          }\n      }\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this.removeEventListener('click', this._boundOnClick, false);\n    }\n  }, {\n    key: 'show',\n    value: function show() {\n      this.style.display = 'inline-block';\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      this.style.display = 'none';\n    }\n  }, {\n    key: 'options',\n    get: function get$$1() {\n      return this._options;\n    },\n    set: function set$$1(object) {\n      this._options = object;\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'];\n    }\n  }]);\n  return BackButtonElement;\n}(BaseElement);\n\nons$1.elements.BackButton = BackButtonElement;\ncustomElements.define('ons-back-button', BackButtonElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$3 = 'bottom-bar';\nvar scheme$5 = { '': 'bottom-bar--*' };\n\n/**\n * @element ons-bottom-toolbar\n * @category page\n * @description\n *   [en]Toolbar component that is positioned at the bottom of the page. Since bottom toolbars are very versatile elements, `ons-bottom-toolbar` does not provide any specific layout syntax for its children. Modifiers or custom CSS must be used.[/en]\n *   [ja]ページ下部に配置されるツールバー用コンポーネントです。[/ja]\n * @modifier transparent\n *   [en]Make the toolbar transparent.[/en]\n *   [ja]ツールバーの背景を透明にして表示します。[/ja]\n * @modifier aligned\n *   [en]Vertically aligns its children and applies flexbox for block elements. `justify-content` CSS rule can be used to change horizontal align.[/en]\n *   [ja]ツールバーの背景を透明にして表示します。[/ja]\n * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbarコンポーネント[/ja]\n * @example\n * <ons-bottom-toolbar>\n *   Content\n * </ons-bottom-toolbar>\n */\n\nvar BottomToolbarElement = function (_BaseElement) {\n  inherits(BottomToolbarElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the toolbar.[/en]\n   *   [ja]ツールバーの見た目の表現を指定します。[/ja]\n   */\n\n  function BottomToolbarElement() {\n    classCallCheck(this, BottomToolbarElement);\n\n    var _this = possibleConstructorReturn(this, (BottomToolbarElement.__proto__ || Object.getPrototypeOf(BottomToolbarElement)).call(this));\n\n    _this.classList.add(defaultClassName$3);\n    ModifierUtil.initModifier(_this, scheme$5);\n    return _this;\n  }\n\n  createClass(BottomToolbarElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      if (util.match(this.parentNode, 'ons-page')) {\n        this.parentNode.classList.add('page-with-bottom-toolbar');\n      }\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$3, scheme$5);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$5);\n          break;\n      }\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'];\n    }\n  }]);\n  return BottomToolbarElement;\n}(BaseElement);\n\nons$1.elements.BottomToolbar = BottomToolbarElement;\ncustomElements.define('ons-bottom-toolbar', BottomToolbarElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$6 = { '': 'button--*' };\n\nvar defaultClassName$4 = 'button';\n\n/**\n * @element ons-button\n * @category form\n * @modifier outline\n *   [en]Button with outline and transparent background[/en]\n *   [ja]アウトラインを持ったボタンを表示します。[/ja]\n * @modifier light\n *   [en]Button that doesn't stand out.[/en]\n *   [ja]目立たないボタンを表示します。[/ja]\n * @modifier quiet\n *   [en]Button with no outline and or background..[/en]\n *   [ja]枠線や背景が無い文字だけのボタンを表示します。[/ja]\n * @modifier cta\n *   [en]Button that really stands out.[/en]\n *   [ja]目立つボタンを表示します。[/ja]\n * @modifier large\n *   [en]Large button that covers the width of the screen.[/en]\n *   [ja]横いっぱいに広がる大きなボタンを表示します。[/ja]\n * @modifier large--quiet\n *   [en]Large quiet button.[/en]\n *   [ja]横いっぱいに広がるquietボタンを表示します。[/ja]\n * @modifier large--cta\n *   [en]Large call to action button.[/en]\n *   [ja]横いっぱいに広がるctaボタンを表示します。[/ja]\n * @modifier material\n *   [en]Material Design button[/en]\n *   [ja]マテリアルデザインのボタン[/ja]\n * @modifier material--flat\n *   [en]Material Design flat button[/en]\n *   [ja]マテリアルデザインのフラットボタン[/ja]\n * @description\n *   [en]\n *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.\n *\n *     Will automatically display as a Material Design button with a ripple effect on Android.\n *   [/en]\n *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、ons-toolbar-buttonもしくはons-back-buttonコンポーネントを使用します。[/ja]\n * @codepen hLayx\n * @tutorial vanilla/Reference/button\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]\n * @example\n * <ons-button modifier=\"large--cta\">\n *   Tap Me\n * </ons-button>\n */\n\nvar ButtonElement = function (_BaseElement) {\n  inherits(ButtonElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *  [en]The appearance of the button.[/en]\n   *  [ja]ボタンの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute ripple\n   * @description\n   *  [en]If this attribute is defined, the button will have a ripple effect.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *   [en]Specify if button should be disabled.[/en]\n   *   [ja]ボタンを無効化する場合は指定します。[/ja]\n   */\n\n  function ButtonElement() {\n    classCallCheck(this, ButtonElement);\n\n    var _this = possibleConstructorReturn(this, (ButtonElement.__proto__ || Object.getPrototypeOf(ButtonElement)).call(this));\n\n    _this._compile();\n    return _this;\n  }\n\n  createClass(ButtonElement, [{\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$4, scheme$6);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$6);\n          break;\n        case 'ripple':\n          this._updateRipple();\n      }\n    }\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the button is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.classList.add(defaultClassName$4);\n\n      this._updateRipple();\n\n      ModifierUtil.initModifier(this, scheme$6);\n    }\n  }, {\n    key: '_updateRipple',\n    value: function _updateRipple() {\n      util.updateRipple(this);\n    }\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'ripple', 'class'];\n    }\n  }]);\n  return ButtonElement;\n}(BaseElement);\n\nons$1.elements.Button = ButtonElement;\ncustomElements.define('ons-button', ButtonElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$5 = 'card';\nvar scheme$7 = {\n  '': 'card--*',\n  '.card__title': 'card--*__title',\n  '.card__content': 'card--*__content'\n};\n\n/**\n * @element ons-card\n * @category visual\n * @modifier material\n *   [en]A card with material design.[/en]\n *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]\n * @description\n *   [en]\n *    Component to create a card that displays some information.\n *\n *    The card may be composed by divs with specially prepared classes `title` and/or `content`. You can also add your own content as you please.[/en]\n *   [ja][/ja]\n * @tutorial vanilla/Reference/card\n * @example\n * <ons-card>\n *   <p>Some content</p>\n * </ons-card>\n */\n\nvar CardElement = function (_BaseElement) {\n  inherits(CardElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the card.[/en]\n   *   [ja]リストの表現を指定します。[/ja]\n   */\n\n  function CardElement() {\n    classCallCheck(this, CardElement);\n\n    var _this = possibleConstructorReturn(this, (CardElement.__proto__ || Object.getPrototypeOf(CardElement)).call(this));\n\n    contentReady(_this, function () {\n      _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(CardElement, [{\n    key: '_compile',\n    value: function _compile() {\n      for (var i = 0; i < this.children.length; i++) {\n        var el = this.children[i];\n\n        if (el.classList.contains('title')) {\n          el.classList.add('card__title');\n          \n        } else if (el.classList.contains('content')) {\n          el.classList.add('card__content');\n          \n        }\n      }\n\n      autoStyle.prepare(this);\n      this.classList.add(defaultClassName$5);\n      ModifierUtil.initModifier(this, scheme$7);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$5, scheme$7);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$7);\n          break;\n      }\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'];\n    }\n  }]);\n  return CardElement;\n}(BaseElement);\n\nons$1.elements.Card = CardElement;\ncustomElements.define('ons-card', CardElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$8 = { '': 'carousel-item--*' };\n\n/**\n * @element ons-carousel-item\n * @category carousel\n * @description\n *   [en]\n *     Carousel item component. Used as a child of the `<ons-carousel>` element.\n *   [/en]\n *   [ja][/ja]\n * @codepen xbbzOQ\n * @tutorial vanilla/Reference/carousel\n * @seealso ons-carousel\n *   [en]`<ons-carousel>` components[/en]\n *   [ja]<ons-carousel>コンポーネント[/ja]\n * @example\n * <ons-carousel style=\"width: 100%; height: 200px\">\n *   <ons-carousel-item>\n *    ...\n *   </ons-carousel-item>\n *   <ons-carousel-item>\n *    ...\n *   </ons-carousel-item>\n * </ons-carousel>\n */\n\nvar CarouselItemElement = function (_BaseElement) {\n  inherits(CarouselItemElement, _BaseElement);\n\n  function CarouselItemElement() {\n    classCallCheck(this, CarouselItemElement);\n\n    var _this = possibleConstructorReturn(this, (CarouselItemElement.__proto__ || Object.getPrototypeOf(CarouselItemElement)).call(this));\n\n    _this.style.width = '100%';\n    ModifierUtil.initModifier(_this, scheme$8);\n    return _this;\n  }\n\n  createClass(CarouselItemElement, [{\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'modifier') {\n        return ModifierUtil.onModifierChanged(last, current, this, scheme$8);\n      }\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier'];\n    }\n  }]);\n  return CarouselItemElement;\n}(BaseElement);\n\nons$1.elements.CarouselItem = CarouselItemElement;\ncustomElements.define('ons-carousel-item', CarouselItemElement);\n\nvar directionMap = {\n  vertical: {\n    axis: 'Y',\n    size: 'Height',\n    dir: ['up', 'down'],\n    t3d: ['0px, ', 'px, 0px']\n  },\n  horizontal: {\n    axis: 'X',\n    size: 'Width',\n    dir: ['left', 'right'],\n    t3d: ['', 'px, 0px, 0px']\n  }\n};\n\nvar Swiper = function () {\n  function Swiper(params) {\n    var _this = this;\n\n    classCallCheck(this, Swiper);\n\n    // Parameters\n    var FALSE = function FALSE() {\n      return false;\n    };\n    'getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook'.split(/\\s+/).forEach(function (key) {\n      return _this[key] = params[key] || FALSE;\n    });\n\n    this.getElement = params.getElement; // Required\n    this.scrollHook = params.scrollHook; // Optional\n    this.itemSize = params.itemSize || '100%';\n\n    this.getAutoScrollRatio = function () {\n      var ratio = params.getAutoScrollRatio && params.getAutoScrollRatio.apply(params, arguments);\n      ratio = typeof ratio === 'number' && ratio === ratio ? ratio : .5;\n      if (ratio < 0.0 || ratio > 1.0) {\n        throw new Error('Invalid auto-scroll-ratio ' + ratio + '. Must be between 0 and 1');\n      }\n      return ratio;\n    };\n\n    // Prevent clicks only on desktop\n    this.shouldBlock = platform._runOnActualPlatform(function () {\n      return platform.getMobileOS();\n    }) === 'other';\n\n    // Bind handlers\n    this.onDragStart = this.onDragStart.bind(this);\n    this.onDrag = this.onDrag.bind(this);\n    this.onDragEnd = this.onDragEnd.bind(this);\n    this.onResize = this.onResize.bind(this);\n  }\n\n  createClass(Swiper, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          swipeable = _ref.swipeable,\n          autoRefresh = _ref.autoRefresh;\n\n      this.initialized = true;\n      this.target = this.getElement().children[0];\n      this.blocker = this.getElement().children[1];\n      if (!this.target || !this.blocker) {\n        throw new Error('Expected \"target\" and \"blocker\" elements to exist before initializing Swiper.');\n      }\n\n      if (!this.shouldBlock) {\n        this.blocker.style.display = 'none';\n      }\n\n      // Add classes\n      this.getElement().classList.add('ons-swiper');\n      this.target.classList.add('ons-swiper-target');\n      this.blocker.classList.add('ons-swiper-blocker');\n\n      // Setup listeners\n      this._gestureDetector = new GestureDetector(this.getElement(), { dragMinDistance: 1, dragLockToAxis: true });\n      this._mutationObserver = new MutationObserver(function () {\n        return _this2.refresh();\n      });\n      this.updateSwipeable(swipeable);\n      this.updateAutoRefresh(autoRefresh);\n\n      // Setup initial layout\n      this._scroll = this._offset = this._lastActiveIndex = 0;\n      this._updateLayout();\n      this._setupInitialIndex();\n      setImmediate(function () {\n        return _this2.initialized && _this2._setupInitialIndex();\n      });\n\n      // Fix rendering glitch on Android 4.1\n      if (this.offsetHeight === 0) {\n        setImmediate(function () {\n          return _this2.refresh();\n        });\n      }\n    }\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.initialized = false;\n      this.updateSwipeable(false);\n      this.updateAutoRefresh(false);\n\n      this._gestureDetector && this._gestureDetector.dispose();\n      this.target = this.blocker = this._gestureDetector = this._mutationObserver = null;\n\n      this.setupResize(false);\n    }\n  }, {\n    key: 'onResize',\n    value: function onResize() {\n      var i = this._scroll / this.targetSize;\n      this._reset();\n      this.setActiveIndex(i);\n      this.refresh();\n    }\n  }, {\n    key: '_calculateItemSize',\n    value: function _calculateItemSize() {\n      var matches = this.itemSize.match(/^(\\d+)(px|%)/);\n\n      if (!matches) {\n        throw new Error('Invalid state: swiper\\'s size unit must be \\'%\\' or \\'px\\'');\n      }\n\n      var value = parseInt(matches[1], 10);\n      return matches[2] === '%' ? Math.round(value / 100 * this.targetSize) : value;\n    }\n  }, {\n    key: '_setupInitialIndex',\n    value: function _setupInitialIndex() {\n      this._reset();\n      this._lastActiveIndex = Math.max(Math.min(Number(this.getInitialIndex()), this.itemCount), 0);\n      this._scroll = this._offset + this.itemNumSize * this._lastActiveIndex;\n      this._scrollTo(this._scroll);\n    }\n  }, {\n    key: 'setActiveIndex',\n    value: function setActiveIndex(index) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      index = Math.max(0, Math.min(index, this.itemCount - 1));\n      var scroll = Math.max(0, Math.min(this.maxScroll, this._offset + this.itemNumSize * index));\n\n      if (platform.isUIWebView()) {\n        /* Dirty fix for #2231(https://github.com/OnsenUI/OnsenUI/issues/2231). begin */\n        var concat = function concat(arrayOfArray) {\n          return Array.prototype.concat.apply([], arrayOfArray);\n        };\n        var contents = concat(util.arrayFrom(this.target.children).map(function (page) {\n          return util.arrayFrom(page.children).filter(function (child) {\n            return child.classList.contains('page__content');\n          });\n        }));\n\n        var map = new Map();\n        return new Promise(function (resolve) {\n          contents.forEach(function (content) {\n            map.set(content, content.getAttribute('class'));\n            content.classList.add('page__content--suppress-layer-creation');\n          });\n          requestAnimationFrame(resolve);\n        }).then(function () {\n          return _this3._changeTo(scroll, options);\n        }).then(function () {\n          return new Promise(function (resolve) {\n            contents.forEach(function (content) {\n              content.setAttribute('class', map.get(content));\n            });\n            requestAnimationFrame(resolve);\n          });\n        });\n        /* end */\n      } else {\n        return this._changeTo(scroll, options);\n      }\n    }\n  }, {\n    key: 'getActiveIndex',\n    value: function getActiveIndex() {\n      var scroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._scroll;\n\n      scroll -= this._offset;\n      var count = this.itemCount,\n          size = this.itemNumSize;\n\n      if (scroll <= 0) {\n        return 0;\n      }\n\n      for (var i = 0; i < count; i++) {\n        if (size * i <= scroll && size * (i + 1) > scroll) {\n          return i;\n        }\n      }\n\n      return count - 1;\n    }\n  }, {\n    key: 'setupResize',\n    value: function setupResize(add) {\n      window[(add ? 'add' : 'remove') + 'EventListener']('resize', this.onResize, true);\n    }\n  }, {\n    key: 'show',\n    value: function show() {\n      this.setupResize(true);\n      this.onResize();\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      this.setupResize(false);\n    }\n  }, {\n    key: 'updateSwipeable',\n    value: function updateSwipeable(shouldUpdate) {\n      if (this._gestureDetector) {\n        var action = shouldUpdate ? 'on' : 'off';\n        this._gestureDetector[action]('drag', this.onDrag);\n        this._gestureDetector[action]('dragstart', this.onDragStart);\n        this._gestureDetector[action]('dragend', this.onDragEnd);\n      }\n    }\n  }, {\n    key: 'updateAutoRefresh',\n    value: function updateAutoRefresh(shouldWatch) {\n      if (this._mutationObserver) {\n        shouldWatch ? this._mutationObserver.observe(this.target, { childList: true }) : this._mutationObserver.disconnect();\n      }\n    }\n  }, {\n    key: 'updateItemSize',\n    value: function updateItemSize(newSize) {\n      this.itemSize = newSize || '100%';\n      this.refresh();\n    }\n  }, {\n    key: 'toggleBlocker',\n    value: function toggleBlocker(block) {\n      this.blocker.style.pointerEvents = block ? 'auto' : 'none';\n    }\n  }, {\n    key: '_canConsumeGesture',\n    value: function _canConsumeGesture(gesture) {\n      var d = gesture.direction;\n      var isFirst = this._scroll === 0 && !this.isOverScrollable();\n      var isLast = this._scroll === this.maxScroll && !this.isOverScrollable();\n\n      return this.isVertical() ? d === 'down' && !isFirst || d === 'up' && !isLast : d === 'right' && !isFirst || d === 'left' && !isLast;\n    }\n  }, {\n    key: 'onDragStart',\n    value: function onDragStart(event) {\n      var _this4 = this;\n\n      this._ignoreDrag = event.consumed || !util.isValidGesture(event);\n\n      if (!this._ignoreDrag) {\n        var consume = event.consume;\n        event.consume = function () {\n          consume && consume();_this4._ignoreDrag = true;\n        };\n\n        if (this._canConsumeGesture(event.gesture)) {\n          var startX = event.gesture.center && event.gesture.center.clientX || 0,\n              distFromEdge = this.getBubbleWidth() || 0,\n              start = function start() {\n            consume && consume();\n            event.consumed = true;\n            _this4._started = true; // Avoid starting drag from outside\n            _this4.shouldBlock && _this4.toggleBlocker(true);\n            util.preventScroll(_this4._gestureDetector);\n          };\n\n          // Let parent elements consume the gesture or consume it right away\n          startX < distFromEdge || startX > this.targetSize - distFromEdge ? setImmediate(function () {\n            return !_this4._ignoreDrag && start();\n          }) : start();\n        }\n      }\n    }\n  }, {\n    key: 'onDrag',\n    value: function onDrag(event) {\n      if (!event.gesture || this._ignoreDrag || !this._started) {\n        return;\n      }\n\n      this._continued = true; // Fix for random 'dragend' without 'drag'\n      event.stopPropagation();\n\n      this._scrollTo(this._scroll - this._getDelta(event), { throttle: true });\n    }\n  }, {\n    key: 'onDragEnd',\n    value: function onDragEnd(event) {\n      this._started = false;\n      if (!event.gesture || this._ignoreDrag || !this._continued) {\n        this._ignoreDrag = true; // onDragEnd might fire before onDragStart's setImmediate\n        return;\n      }\n\n      this._continued = false;\n      event.stopPropagation();\n\n      var scroll = this._scroll - this._getDelta(event);\n      var normalizedScroll = this._normalizeScroll(scroll);\n      scroll === normalizedScroll ? this._startMomentumScroll(scroll, event) : this._killOverScroll(normalizedScroll);\n      this.shouldBlock && this.toggleBlocker(false);\n    }\n  }, {\n    key: '_startMomentumScroll',\n    value: function _startMomentumScroll(scroll, event) {\n      var velocity = this._getVelocity(event),\n          matchesDirection = event.gesture.interimDirection === this.dM.dir[this._getDelta(event) < 0 ? 0 : 1];\n\n      var nextScroll = this._getAutoScroll(scroll, velocity, matchesDirection);\n      var duration = Math.abs(nextScroll - scroll) / (velocity + 0.01) / 1000;\n      duration = Math.min(.25, Math.max(.1, duration));\n\n      this._changeTo(nextScroll, { swipe: true, animationOptions: { duration: duration, timing: 'cubic-bezier(.4, .7, .5, 1)' } });\n    }\n  }, {\n    key: '_killOverScroll',\n    value: function _killOverScroll(scroll) {\n      var _this5 = this;\n\n      this._scroll = scroll;\n      var direction = this.dM.dir[Number(scroll > 0)];\n      var killOverScroll = function killOverScroll() {\n        return _this5._changeTo(scroll, { animationOptions: { duration: .4, timing: 'cubic-bezier(.1, .4, .1, 1)' } });\n      };\n      this.overScrollHook({ direction: direction, killOverScroll: killOverScroll }) || killOverScroll();\n    }\n  }, {\n    key: '_changeTo',\n    value: function _changeTo(scroll) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var e = { activeIndex: this.getActiveIndex(scroll), lastActiveIndex: this._lastActiveIndex, swipe: options.swipe || false };\n      var change = e.activeIndex !== e.lastActiveIndex;\n      var canceled = change ? this.preChangeHook(e) : false;\n\n      this._scroll = canceled ? this._offset + e.lastActiveIndex * this.itemNumSize : scroll;\n      this._lastActiveIndex = canceled ? e.lastActiveIndex : e.activeIndex;\n\n      return this._scrollTo(this._scroll, options).then(function () {\n        if (scroll === _this6._scroll && !canceled) {\n          change && _this6.postChangeHook(e);\n        } else if (options.reject) {\n          return Promise.reject('Canceled');\n        }\n      });\n    }\n  }, {\n    key: '_scrollTo',\n    value: function _scrollTo(scroll) {\n      var _this7 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (options.throttle) {\n        var ratio = 0.35;\n        if (scroll < 0) {\n          scroll = this.isOverScrollable() ? Math.round(scroll * ratio) : 0;\n        } else {\n          var maxScroll = this.maxScroll;\n          if (maxScroll < scroll) {\n            scroll = this.isOverScrollable() ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;\n          }\n        }\n      }\n\n      var opt = options.animation === 'none' ? {} : options.animationOptions;\n      this.scrollHook && this.itemNumSize > 0 && this.scrollHook((scroll / this.itemNumSize).toFixed(2), options.animationOptions || {});\n\n      return new Promise(function (resolve) {\n        return Animit(_this7.target).queue({ transform: _this7._getTransform(scroll) }, opt).play(resolve);\n      });\n    }\n  }, {\n    key: '_getAutoScroll',\n    value: function _getAutoScroll(scroll, velocity, matchesDirection) {\n      var max = this.maxScroll,\n          offset = this._offset,\n          size = this.itemNumSize;\n\n      if (!this.isAutoScrollable()) {\n        return Math.max(0, Math.min(max, scroll));\n      }\n\n      var arr = [];\n      for (var s = offset; s < max; s += size) {\n        arr.push(s);\n      }\n      arr.push(max);\n\n      arr = arr.sort(function (left, right) {\n        return Math.abs(left - scroll) - Math.abs(right - scroll);\n      }).filter(function (item, pos) {\n        return !pos || item !== arr[pos - 1];\n      });\n\n      var result = arr[0];\n      var lastScroll = this._lastActiveIndex * size + offset;\n      var scrollRatio = Math.abs(scroll - lastScroll) / size;\n\n      if (scrollRatio <= this.getAutoScrollRatio(matchesDirection, velocity, size)) {\n        result = lastScroll;\n      } else {\n        if (scrollRatio < 1.0 && arr[0] === lastScroll && arr.length > 1) {\n          result = arr[1];\n        }\n      }\n      return Math.max(0, Math.min(max, result));\n    }\n  }, {\n    key: '_reset',\n    value: function _reset() {\n      this._targetSize = this._itemNumSize = undefined;\n    }\n  }, {\n    key: '_normalizeScroll',\n    value: function _normalizeScroll(scroll) {\n      return Math.max(Math.min(scroll, this.maxScroll), 0);\n    }\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      this._reset();\n      this._updateLayout();\n\n      var scroll = this._normalizeScroll(this._scroll);\n      scroll !== this._scroll ? this._killOverScroll(scroll) : this._changeTo(scroll);\n\n      this.refreshHook();\n    }\n  }, {\n    key: '_getDelta',\n    value: function _getDelta(event) {\n      return event.gesture['delta' + this.dM.axis];\n    }\n  }, {\n    key: '_getVelocity',\n    value: function _getVelocity(event) {\n      return event.gesture['velocity' + this.dM.axis];\n    }\n  }, {\n    key: '_getTransform',\n    value: function _getTransform(scroll) {\n      return 'translate3d(' + this.dM.t3d[0] + -scroll + this.dM.t3d[1] + ')';\n    }\n  }, {\n    key: '_updateLayout',\n    value: function _updateLayout() {\n      this.dM = directionMap[this.isVertical() ? 'vertical' : 'horizontal'];\n      this.target.classList.toggle('ons-swiper-target--vertical', this.isVertical());\n\n      for (var c = this.target.children[0]; c; c = c.nextElementSibling) {\n        c.style[this.dM.size.toLowerCase()] = this.itemSize;\n      }\n\n      if (this.isCentered()) {\n        this._offset = (this.targetSize - this.itemNumSize) / -2 || 0;\n      }\n    }\n  }, {\n    key: 'itemCount',\n    get: function get$$1() {\n      return this.target.children.length;\n    }\n  }, {\n    key: 'itemNumSize',\n    get: function get$$1() {\n      if (typeof this._itemNumSize !== 'number' || this._itemNumSize !== this._itemNumSize) {\n        this._itemNumSize = this._calculateItemSize();\n      }\n      return this._itemNumSize;\n    }\n  }, {\n    key: 'maxScroll',\n    get: function get$$1() {\n      var max = this.itemCount * this.itemNumSize - this.targetSize;\n      return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.\n    }\n  }, {\n    key: 'targetSize',\n    get: function get$$1() {\n      if (!this._targetSize) {\n        this._targetSize = this.target['offset' + this.dM.size];\n      }\n      return this._targetSize;\n    }\n  }]);\n  return Swiper;\n}();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * @element ons-carousel\n * @category carousel\n * @description\n *   [en]\n *     Carousel component. A carousel can be used to display several items in the same space.\n *\n *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.\n *   [/en]\n *   [ja][/ja]\n * @codepen xbbzOQ\n * @tutorial vanilla/Reference/carousel\n * @seealso ons-carousel-item\n *   [en]`<ons-carousel-item>` component[/en]\n *   [ja]ons-carousel-itemコンポーネント[/ja]\n * @example\n * <ons-carousel style=\"width: 100%; height: 200px\">\n *   <ons-carousel-item>\n *    ...\n *   </ons-carousel-item>\n *   <ons-carousel-item>\n *    ...\n *   </ons-carousel-item>\n * </ons-carousel>\n */\n\nvar CarouselElement = function (_BaseElement) {\n  inherits(CarouselElement, _BaseElement);\n\n  /**\n   * @event postchange\n   * @description\n   *   [en]Fired just after the current carousel item has changed.[/en]\n   *   [ja]現在表示しているカルーセルの要素が変わった時に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクトです。[/ja]\n   * @param {Object} event.carousel\n   *   [en]Carousel object.[/en]\n   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]\n   * @param {Number} event.activeIndex\n   *   [en]Current active index.[/en]\n   *   [ja]現在アクティブになっている要素のインデックス。[/ja]\n   * @param {Number} event.lastActiveIndex\n   *   [en]Previous active index.[/en]\n   *   [ja]以前アクティブだった要素のインデックス。[/ja]\n   */\n\n  /**\n   * @event refresh\n   * @description\n   *   [en]Fired when the carousel has been refreshed.[/en]\n   *   [ja]カルーセルが更新された時に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクトです。[/ja]\n   * @param {Object} event.carousel\n   *   [en]Carousel object.[/en]\n   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]\n   */\n\n  /**\n   * @event overscroll\n   * @description\n   *   [en]Fired when the carousel has been overscrolled.[/en]\n   *   [ja]カルーセルがオーバースクロールした時に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクトです。[/ja]\n   * @param {Object} event.carousel\n   *   [en]Fired when the carousel has been refreshed.[/en]\n   *   [ja]カルーセルが更新された時に発火します。[/ja]\n   * @param {Number} event.activeIndex\n   *   [en]Current active index.[/en]\n   *   [ja]現在アクティブになっている要素のインデックス。[/ja]\n   * @param {String} event.direction\n   *   [en]Can be one of either \"up\", \"down\", \"left\" or \"right\".[/en]\n   *   [ja]オーバースクロールされた方向が得られます。\"up\", \"down\", \"left\", \"right\"のいずれかの方向が渡されます。[/ja]\n   * @param {Function} event.waitToReturn\n   *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]\n   *   [ja]この関数はPromiseオブジェクトを引数として受け取ります。渡したPromiseオブジェクトがresolveされるかrejectされるまで、カルーセルはスクロールバックしません。[/ja]\n   */\n\n  /**\n   * @attribute direction\n   * @type {String}\n   * @description\n   *   [en]The direction of the carousel. Can be either \"horizontal\" or \"vertical\". Default is \"horizontal\".[/en]\n   *   [ja]カルーセルの方向を指定します。\"horizontal\"か\"vertical\"を指定できます。\"horizontal\"がデフォルト値です。[/ja]\n   */\n\n  /**\n   * @attribute fullscreen\n   * @description\n   *   [en]If this attribute is set the carousel will cover the whole screen.[/en]\n   *   [ja]この属性があると、absoluteポジションを使ってカルーセルが自動的に画面いっぱいに広がります。[/ja]\n   */\n\n  /**\n   * @attribute overscrollable\n   * @description\n   *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]\n   *   [ja]この属性がある時、タッチやドラッグで端までスクロールした時に、バウンドするような効果が当たります。[/ja]\n   */\n\n  /**\n   * @attribute centered\n   * @description\n   *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]\n   *   [ja]この属性がある時、選んでいるons-carousel-itemはカルーセルの真ん中へ行きます。項目がカルーセルよりも小さい場合にのみ、これは便利です。[/ja]\n   */\n\n  /**\n   * @attribute item-width\n   * @type {String}\n   * @description\n   *    [en]ons-carousel-item's width. Only works when the direction is set to \"horizontal\".[/en]\n   *    [ja]ons-carousel-itemの幅を指定します。この属性は、direction属性に\"horizontal\"を指定した時のみ有効になります。[/ja]\n   */\n\n  /**\n   * @attribute item-height\n   * @type {String}\n   * @description\n   *   [en]ons-carousel-item's height. Only works when the direction is set to \"vertical\".[/en]\n   *   [ja]ons-carousel-itemの高さを指定します。この属性は、direction属性に\"vertical\"を指定した時のみ有効になります。[/ja]\n   */\n\n  /**\n   * @attribute auto-scroll\n   * @description\n   *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]\n   *   [ja]この属性がある時、一番近いcarousel-itemの境界まで自動的にスクロールするようになります。[/ja]\n   */\n\n  /**\n   * @attribute auto-scroll-ratio\n   * @type {Number}\n   * @description\n   *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]\n   *    [ja]0.0から1.0までの値を指定します。カルーセルの要素をどれぐらいの割合までドラッグすると次の要素に自動的にスクロールするかを指定します。[/ja]\n   */\n\n  /**\n   * @attribute swipeable\n   * @description\n   *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]\n   *   [ja]この属性がある時、カルーセルをスワイプやドラッグで移動できるようになります。[/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *   [en]If this attribute is set the carousel is disabled.[/en]\n   *   [ja]この属性がある時、dragやtouchやswipeを受け付けなくなります。[/ja]\n   */\n\n  /**\n   * @attribute initial-index\n   * @initonly\n   * @default 0\n   * @type {Number}\n   * @description\n   *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]\n   *   [ja]最初に表示するons-carousel-itemを0始まりのインデックスで指定します。デフォルト値は 0 です。[/ja]\n   */\n\n  /**\n   * @attribute auto-refresh\n   * @description\n   *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]\n   *   [ja]この属性がある時、子要素の数が変わるとカルーセルは自動的に更新されるようになります。[/ja]\n   */\n\n  /**\n   * @attribute animation\n   * @type {String}\n   * @description\n   *   [en]If this attribute is set to `\"none\"` the transitions will not be animated.[/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute animation-options\n   * @type {Expression}\n   * @description\n   *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]\n   *   [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]\n   */\n\n  function CarouselElement() {\n    classCallCheck(this, CarouselElement);\n\n    var _this = possibleConstructorReturn(this, (CarouselElement.__proto__ || Object.getPrototypeOf(CarouselElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(CarouselElement, [{\n    key: '_compile',\n    value: function _compile() {\n      var target = this.children[0] && this.children[0].tagName !== 'ONS-CAROUSEL-ITEM' && this.children[0] || document.createElement('div');\n      if (!target.parentNode) {\n        while (this.firstChild) {\n          target.appendChild(this.firstChild);\n        }\n        this.appendChild(target);\n      }\n\n      !this.children[1] && this.appendChild(document.createElement('div'));\n\n      this.appendChild = this.appendChild.bind(target);\n      this.insertBefore = this.insertBefore.bind(target);\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      if (!this._swiper) {\n        this._swiper = new Swiper({\n          getElement: function getElement() {\n            return _this2;\n          },\n          getInitialIndex: function getInitialIndex() {\n            return _this2.getAttribute('initial-index');\n          },\n          getAutoScrollRatio: function getAutoScrollRatio() {\n            return _this2.autoScrollRatio;\n          },\n          isVertical: function isVertical() {\n            return _this2.vertical;\n          },\n          isOverScrollable: function isOverScrollable() {\n            return _this2.overscrollable;\n          },\n          isCentered: function isCentered() {\n            return _this2.centered;\n          },\n          isAutoScrollable: function isAutoScrollable() {\n            return _this2.autoScroll;\n          },\n          itemSize: this.itemSize,\n          overScrollHook: this._onOverScroll.bind(this),\n          preChangeHook: this._onChange.bind(this, 'prechange'),\n          postChangeHook: this._onChange.bind(this, 'postchange'),\n          refreshHook: this._onRefresh.bind(this),\n          scrollHook: this._onSwipe\n        });\n\n        contentReady(this, function () {\n          return _this2._swiper.init({\n            swipeable: _this2.hasAttribute('swipeable'),\n            autoRefresh: _this2.hasAttribute('auto-refresh')\n          });\n        });\n      }\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      if (this._swiper && this._swiper.initialized) {\n        this._swiper.dispose();\n        this._swiper = null;\n      }\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (!this._swiper) {\n        return;\n      }\n\n      switch (name) {\n        case 'swipeable':\n          this._swiper.updateSwipeable(this.hasAttribute('swipeable'));\n          break;\n        case 'auto-refresh':\n          this._swiper.updateAutoRefresh(this.hasAttribute('auto-refresh'));\n          break;\n        case 'item-height':\n          this.vertical && this._swiper.updateItemSize(this.itemSize);\n          break;\n        case 'item-width':\n          this.vertical || this._swiper.updateItemSize(this.itemSize);\n          break;\n        case 'direction':\n          this._swiper.refresh();\n      }\n    }\n  }, {\n    key: '_show',\n    value: function _show() {\n      this._swiper.show();\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      this._swiper.hide();\n    }\n  }, {\n    key: '_onOverScroll',\n    value: function _onOverScroll(_ref) {\n      var direction = _ref.direction,\n          killOverScroll = _ref.killOverScroll;\n\n      var waitForAction = false;\n      util.triggerElementEvent(this, 'overscroll', {\n        carousel: this,\n        activeIndex: this.getActiveIndex(),\n        direction: direction,\n        waitToReturn: function waitToReturn(promise) {\n          waitForAction = true;\n          promise.then(killOverScroll);\n        }\n      });\n\n      return waitForAction;\n    }\n  }, {\n    key: '_onChange',\n    value: function _onChange(eventName, _ref2) {\n      var activeIndex = _ref2.activeIndex,\n          lastActiveIndex = _ref2.lastActiveIndex;\n\n      util.triggerElementEvent(this, eventName, { carousel: this, activeIndex: activeIndex, lastActiveIndex: lastActiveIndex });\n    }\n  }, {\n    key: '_onRefresh',\n    value: function _onRefresh() {\n      util.triggerElementEvent(this, 'refresh', { carousel: this });\n    }\n\n    /**\n     * @method setActiveIndex\n     * @signature setActiveIndex(index, [options])\n     * @param {Number} index\n     *   [en]The index that the carousel should be set to.[/en]\n     *   [ja]carousel要素のインデックスを指定します。[/ja]\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja][/ja]\n     * @param {Function} [options.callback]\n     *   [en]A function that will be called after the animation is finished.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animation]\n     *   [en]If this attribute is set to `\"none\"` the transitions will not be animated.[/en]\n     *   [ja][/ja]\n     * @param {Object} [options.animationOptions]\n     *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]\n     *   [ja][/ja]\n     * @description\n     *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]\n     *   [ja]表示するons-carousel-itemをindexで指定します。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the carousel element.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'setActiveIndex',\n    value: function setActiveIndex(index) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {\n        throw new Error('options must be an object. You supplied ' + options);\n      }\n\n      options.animation = options.animation || this.getAttribute('animation');\n      options.animationOptions = util.extend({ duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }, options.animationOptions || {}, this.hasAttribute('animation-options') ? util.animationOptionsParse(this.getAttribute('animation-options')) : {});\n\n      return this._swiper.setActiveIndex(index, options).then(function () {\n        options.callback instanceof Function && options.callback(_this3);\n        return Promise.resolve(_this3);\n      });\n    }\n\n    /**\n     * @method getActiveIndex\n     * @signature getActiveIndex()\n     * @return {Number}\n     *   [en]The current carousel item index.[/en]\n     *   [ja]現在表示しているカルーセル要素のインデックスが返されます。[/ja]\n     * @description\n     *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]\n     *   [ja]現在表示されているons-carousel-item要素のインデックスを返します。[/ja]\n     */\n\n  }, {\n    key: 'getActiveIndex',\n    value: function getActiveIndex() {\n      return this._swiper.getActiveIndex();\n    }\n\n    /**\n     * @method next\n     * @signature next([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja][/ja]\n     * @param {Function} [options.callback]\n     *   [en]A function that will be executed after the animation has finished.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animation]\n     *   [en]If this attribute is set to `\"none\"` the transitions will not be animated.[/en]\n     *   [ja][/ja]\n     * @param {Object} [options.animationOptions]\n     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]\n     *   [ja][/ja]\n     * @return {Promise}\n     *   [en]Resolves to the carousel element[/en]\n     *   [ja][/ja]\n     * @description\n     *   [en]Show next `<ons-carousel-item>`.[/en]\n     *   [ja]次のons-carousel-itemを表示します。[/ja]\n     */\n\n  }, {\n    key: 'next',\n    value: function next(options) {\n      return this.setActiveIndex(this.getActiveIndex() + 1, options);\n    }\n\n    /**\n     * @method prev\n     * @signature prev([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja][/ja]\n     * @param {Function} [options.callback]\n     *   [en]A function that will be executed after the animation has finished.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animation]\n     *   [en]If this attribute is set to `\"none\"` the transitions will not be animated.[/en]\n     *   [ja][/ja]\n     * @param {Object} [options.animationOptions]\n     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]\n     *   [ja][/ja]\n     * @return {Promise}\n     *   [en]Resolves to the carousel element[/en]\n     *   [ja][/ja]\n     * @description\n     *   [en]Show previous `<ons-carousel-item>`.[/en]\n     *   [ja]前のons-carousel-itemを表示します。[/ja]\n     */\n\n  }, {\n    key: 'prev',\n    value: function prev(options) {\n      return this.setActiveIndex(this.getActiveIndex() - 1, options);\n    }\n\n    /**\n     * @method first\n     * @signature first()\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja][/ja]\n     * @param {Function} [options.callback]\n     *   [en]A function that will be executed after the animation has finished.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animation]\n     *   [en]If this is set to `\"none\"`, the transitions will not be animated.[/en]\n     *   [ja][/ja]\n     * @param {Object} [options.animationOptions]\n     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]\n     *   [ja][/ja]\n     * @return {Promise}\n     *   [en]Resolves to the carousel element[/en]\n     *   [ja][/ja]\n     * @description\n     *   [en]Show first `<ons-carousel-item>`.[/en]\n     *   [ja]最初のons-carousel-itemを表示します。[/ja]\n     */\n\n  }, {\n    key: 'first',\n    value: function first(options) {\n      return this.setActiveIndex(0, options);\n    }\n\n    /**\n     * @method last\n     * @signature last()\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja][/ja]\n     * @param {Function} [options.callback]\n     *   [en]A function that will be executed after the animation has finished.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animation]\n     *   [en]If this attribute is set to `\"none\"` the transitions will not be animated.[/en]\n     *   [ja][/ja]\n     * @param {Object} [options.animationOptions]\n     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]\n     *   [ja][/ja]\n     * @return {Promise}\n     *   [en]Resolves to the carousel element[/en]\n     *   [ja]Resolves to the carousel element[/ja]\n     * @description\n     *   [en]Show last ons-carousel item.[/en]\n     *   [ja]最後のons-carousel-itemを表示します。[/ja]\n     */\n\n  }, {\n    key: 'last',\n    value: function last(options) {\n      this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);\n    }\n\n    /**\n     * @method refresh\n     * @signature refresh()\n     * @description\n     *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]\n     *   [ja]レイアウトや内部の状態を最新のものに更新します。ons-carousel-itemを動的に増やしたり、ons-carouselの大きさを動的に変える際に利用します。[/ja]\n     */\n\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      this._swiper.refresh();\n    }\n\n    /**\n     * @property itemCount\n     * @readonly\n     * @type {Number}\n     * @description\n     *   [en]The number of carousel items.[/en]\n     *   [ja]カルーセル要素の数です。[/ja]\n     */\n\n  }, {\n    key: 'itemCount',\n    get: function get$$1() {\n      return this._swiper.itemCount;\n    }\n\n    /**\n     * @property swipeable\n     * @type {Boolean}\n     * @description\n     *   [en]true if the carousel is swipeable.[/en]\n     *   [ja]swipeableであればtrueを返します。[/ja]\n     */\n\n  }, {\n    key: 'swipeable',\n    get: function get$$1() {\n      return this.hasAttribute('swipeable');\n    },\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'swipeable', value);\n    }\n\n    /**\n     * @property onSwipe\n     * @type {Function}\n     * @description\n     *   [en]Hook called whenever the user slides the carousel. It gets a decimal index and an animationOptions object as arguments.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'onSwipe',\n    get: function get$$1() {\n      return this._onSwipe;\n    },\n    set: function set$$1(value) {\n      if (value && !(value instanceof Function)) {\n        throw new Error('\\'onSwipe\\' must be a function.');\n      }\n      this._onSwipe = value;\n    }\n\n    /**\n     * @property autoScroll\n     * @type {Boolean}\n     * @description\n     *   [en]true if auto scroll is enabled.[/en]\n     *   [ja]オートスクロールが有効であればtrueを返します。[/ja]\n     */\n\n  }, {\n    key: 'autoScroll',\n    get: function get$$1() {\n      return this.hasAttribute('auto-scroll');\n    },\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'auto-scroll', value);\n    }\n  }, {\n    key: 'vertical',\n    get: function get$$1() {\n      return this.getAttribute('direction') === 'vertical';\n    }\n  }, {\n    key: 'itemSize',\n    get: function get$$1() {\n      var itemSizeAttr = (this.getAttribute('item-' + (this.vertical ? 'height' : 'width')) || '').trim();\n      return itemSizeAttr.match(/^\\d+(px|%)$/) ? itemSizeAttr : '100%';\n    }\n\n    /**\n     * @property autoScrollRatio\n     * @type {Number}\n     * @description\n     *   [en]The current auto scroll ratio. [/en]\n     *   [ja]現在のオートスクロールのratio値。[/ja]\n     */\n\n  }, {\n    key: 'autoScrollRatio',\n    get: function get$$1() {\n      return parseFloat(this.getAttribute('auto-scroll-ratio'));\n    },\n    set: function set$$1(ratio) {\n      this.setAttribute('auto-scroll-ratio', ratio);\n    }\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the carousel is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'disabled',\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    },\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    }\n\n    /**\n     * @property overscrollable\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the carousel is overscrollable or not.[/en]\n     *   [ja]overscrollできればtrueを返します。[/ja]\n     */\n\n  }, {\n    key: 'overscrollable',\n    get: function get$$1() {\n      return this.hasAttribute('overscrollable');\n    },\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'overscrollable', value);\n    }\n\n    /**\n     * @property centered\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the carousel is centered or not.[/en]\n     *   [ja]centered状態になっていればtrueを返します。[/ja]\n     */\n\n  }, {\n    key: 'centered',\n    get: function get$$1() {\n      return this.hasAttribute('centered');\n    },\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'centered', value);\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['swipeable', 'auto-refresh', 'direction', 'item-height', 'item-width'];\n    }\n  }, {\n    key: 'events',\n    get: function get$$1() {\n      return ['postchange', 'refresh', 'overscroll'];\n    }\n  }]);\n  return CarouselElement;\n}(BaseElement);\n\nons$1.elements.Carousel = CarouselElement;\ncustomElements.define('ons-carousel', CarouselElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * @element ons-col\n * @category grid\n * @description\n *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]\n *   [ja]グリッドシステムにて列を定義します。ons-rowとともに使用し、コンポーネントのレイアウトに利用します。[/ja]\n * @note\n *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]\n *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-columnを組み合わせた場合に描画が崩れる場合があります。[/ja]\n * @codepen GgujC {wide}\n * @guide theming.html [en]Layouting guide[/en][ja]レイアウト機能[/ja]\n * @seealso ons-row\n *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]\n *   [ja]ons-rowコンポーネント[/ja]\n * @example\n * <ons-row>\n *   <ons-col width=\"50px\"><ons-icon icon=\"fa-twitter\"></ons-icon></ons-col>\n *   <ons-col>Text</ons-col>\n * </ons-row>\n */\n\n/**\n * @attribute vertical-align\n * @type {String}\n * @description\n *   [en]Vertical alignment of the column. Valid values are \"top\", \"center\", and \"bottom\".[/en]\n *   [ja]縦の配置を指定する。\"top\", \"center\", \"bottom\"のいずれかを指定します。[/ja]\n */\n\n/**\n * @attribute width\n * @type {String}\n * @description\n *   [en]The width of the column. Valid values are css width values (\"10%\", \"50px\").[/en]\n *   [ja]カラムの横幅を指定する。パーセントもしくはピクセルで指定します（10%や50px）。[/ja]\n */\n\nvar ColElement = function (_BaseElement) {\n  inherits(ColElement, _BaseElement);\n\n  function ColElement() {\n    classCallCheck(this, ColElement);\n\n    var _this = possibleConstructorReturn(this, (ColElement.__proto__ || Object.getPrototypeOf(ColElement)).call(this));\n\n    if (_this.getAttribute('width')) {\n      _this._updateWidth();\n    }\n    return _this;\n  }\n\n  createClass(ColElement, [{\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'width') {\n        this._updateWidth();\n      }\n    }\n  }, {\n    key: '_updateWidth',\n    value: function _updateWidth() {\n      var width = this.getAttribute('width');\n      if (!width) {\n        styler.clear(this, 'flex maxWidth');\n      } else {\n        width = width.trim().match(/^\\d+$/) ? width + '%' : width;\n\n        styler(this, {\n          flex: '0 0 ' + width,\n          maxWidth: width\n        });\n      }\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['width'];\n    }\n  }]);\n  return ColElement;\n}(BaseElement);\n\nons$1.elements.Col = ColElement;\ncustomElements.define('ons-col', ColElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar DialogAnimator = function (_BaseAnimator) {\n  inherits(DialogAnimator, _BaseAnimator);\n\n  function DialogAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'linear' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.2 : _ref$duration;\n\n    classCallCheck(this, DialogAnimator);\n    return possibleConstructorReturn(this, (DialogAnimator.__proto__ || Object.getPrototypeOf(DialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {HTMLElement} dialog\n   * @param {Function} done\n   */\n\n\n  createClass(DialogAnimator, [{\n    key: 'show',\n    value: function show(dialog, done) {\n      done();\n    }\n\n    /**\n     * @param {HTMLElement} dialog\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, done) {\n      done();\n    }\n  }]);\n  return DialogAnimator;\n}(BaseAnimator);\n\n/**\n * Android style animator for dialog.\n */\nvar AndroidDialogAnimator = function (_DialogAnimator) {\n  inherits(AndroidDialogAnimator, _DialogAnimator);\n\n  function AndroidDialogAnimator() {\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$timing = _ref2.timing,\n        timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing,\n        _ref2$delay = _ref2.delay,\n        delay = _ref2$delay === undefined ? 0 : _ref2$delay,\n        _ref2$duration = _ref2.duration,\n        duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;\n\n    classCallCheck(this, AndroidDialogAnimator);\n    return possibleConstructorReturn(this, (AndroidDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {Object} dialog\n   * @param {Function} callback\n   */\n\n\n  createClass(AndroidDialogAnimator, [{\n    key: 'show',\n    value: function show(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 0\n      }).wait(this.delay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          transform: 'translate3d(-50%, -60%, 0)',\n          opacity: 0.0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0)',\n          opacity: 1.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {Object} dialog\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0)',\n          opacity: 1.0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(-50%, -60%, 0)',\n          opacity: 0.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n  }]);\n  return AndroidDialogAnimator;\n}(DialogAnimator);\n\n/**\n * iOS style animator for dialog.\n */\nvar IOSDialogAnimator = function (_DialogAnimator2) {\n  inherits(IOSDialogAnimator, _DialogAnimator2);\n\n  function IOSDialogAnimator() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref3$timing = _ref3.timing,\n        timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing,\n        _ref3$delay = _ref3.delay,\n        delay = _ref3$delay === undefined ? 0 : _ref3$delay,\n        _ref3$duration = _ref3.duration,\n        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;\n\n    classCallCheck(this, IOSDialogAnimator);\n\n    var _this3 = possibleConstructorReturn(this, (IOSDialogAnimator.__proto__ || Object.getPrototypeOf(IOSDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this3.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout\n    return _this3;\n  }\n\n  /**\n   * @param {Object} dialog\n   * @param {Function} callback\n   */\n\n\n  createClass(IOSDialogAnimator, [{\n    key: 'show',\n    value: function show(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 0\n      }).wait(this.delay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {Object} dialog\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          transform: 'translate3d(-50%, -50%, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n  }]);\n  return IOSDialogAnimator;\n}(DialogAnimator);\n\n/**\n * Slide animator for dialog.\n */\nvar SlideDialogAnimator = function (_DialogAnimator3) {\n  inherits(SlideDialogAnimator, _DialogAnimator3);\n\n  function SlideDialogAnimator() {\n    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref4$timing = _ref4.timing,\n        timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing,\n        _ref4$delay = _ref4.delay,\n        delay = _ref4$delay === undefined ? 0 : _ref4$delay,\n        _ref4$duration = _ref4.duration,\n        duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;\n\n    classCallCheck(this, SlideDialogAnimator);\n\n    var _this4 = possibleConstructorReturn(this, (SlideDialogAnimator.__proto__ || Object.getPrototypeOf(SlideDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this4.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout\n    return _this4;\n  }\n\n  /**\n   * @param {Object} dialog\n   * @param {Function} callback\n   */\n\n\n  createClass(SlideDialogAnimator, [{\n    key: 'show',\n    value: function show(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 0\n      }).wait(this.delay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.\n          transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(-50%, -50%, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {Object} dialog\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(dialog, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit.runAll(Animit(dialog._mask).queue({\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(dialog._dialog).saveStyle().queue({\n        css: {\n          transform: 'translate3D(-50%, -50%, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.\n          transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }));\n    }\n  }]);\n  return SlideDialogAnimator;\n}(DialogAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$9 = {\n  '.dialog': 'dialog--*',\n  '.dialog-container': 'dialog-container--*',\n  '.dialog-mask': 'dialog-mask--*'\n};\n\nvar _animatorDict$2 = {\n  'default': function _default() {\n    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;\n  },\n  'slide': SlideDialogAnimator,\n  'none': DialogAnimator\n};\n\n/**\n * @element ons-dialog\n * @category dialog\n * @description\n *   [en]\n *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.\n *\n *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createDialog(template)` utility function and the `<ons-template>` tag.\n *\n *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.\n *\n *     It will automatically be displayed as Material Design when running on an Android device.\n *   [/en]\n *   [ja][/ja]\n * @modifier material\n *   [en]Display a Material Design dialog.[/en]\n *   [ja]マテリアルデザインのダイアログを表示します。[/ja]\n * @codepen zxxaGa\n * @tutorial vanilla/Reference/dialog\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @seealso ons-alert-dialog\n *   [en]`<ons-alert-dialog>` component[/en]\n *   [ja]ons-alert-dialogコンポーネント[/ja]\n * @seealso ons-popover\n *   [en]`<ons-popover>` component[/en]\n *   [ja]ons-popoverコンポーネント[/ja]\n * @seealso ons-modal\n *   [en]`<ons-modal>` component[/en]\n *   [ja]ons-modalコンポーネント[/ja]\n * @example\n * <ons-dialog id=\"dialog\">\n *   <p>This is a dialog!</p>\n * </ons-dialog>\n *\n * <script>\n *   document.getElementById('dialog').show();\n * </script>\n */\n\nvar DialogElement = function (_BaseDialogElement) {\n  inherits(DialogElement, _BaseDialogElement);\n\n  /**\n   * @event preshow\n   * @description\n   * [en]Fired just before the dialog is displayed.[/en]\n   * [ja]ダイアログが表示される直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.dialog\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Execute this function to stop the dialog from being shown.[/en]\n   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]\n   */\n\n  /**\n   * @event postshow\n   * @description\n   * [en]Fired just after the dialog is displayed.[/en]\n   * [ja]ダイアログが表示された直後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.dialog\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @event prehide\n   * @description\n   * [en]Fired just before the dialog is hidden.[/en]\n   * [ja]ダイアログが隠れる直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.dialog\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Execute this function to stop the dialog from being hidden.[/en]\n   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]\n   */\n\n  /**\n   * @event posthide\n   * @description\n   * [en]Fired just after the dialog is hidden.[/en]\n   * [ja]ダイアログが隠れた後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.dialog\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *  [en]The appearance of the dialog.[/en]\n   *  [ja]ダイアログの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute cancelable\n   * @description\n   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *  [en]If this attribute is set the dialog is disabled.[/en]\n   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]\n   */\n\n  /**\n   * @attribute animation\n   * @type {String}\n   * @default default\n   * @description\n   *  [en]The animation used when showing and hiding the dialog. Can be either `\"none\"` or `\"default\"`.[/en]\n   *  [ja]ダイアログを表示する際のアニメーション名を指定します。\"none\"もしくは\"default\"を指定できます。[/ja]\n   */\n\n  /**\n   * @attribute animation-options\n   * @type {Expression}\n   * @description\n   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]\n   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]\n   */\n\n  /**\n   * @attribute mask-color\n   * @type {String}\n   * @default rgba(0, 0, 0, 0.2)\n   * @description\n   *  [en]Color of the background mask. Default is `\"rgba(0, 0, 0, 0.2)\"`.[/en]\n   *  [ja]背景のマスクの色を指定します。\"rgba(0, 0, 0, 0.2)\"がデフォルト値です。[/ja]\n   */\n\n  function DialogElement() {\n    classCallCheck(this, DialogElement);\n\n    var _this = possibleConstructorReturn(this, (DialogElement.__proto__ || Object.getPrototypeOf(DialogElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(DialogElement, [{\n    key: '_updateAnimatorFactory',\n    value: function _updateAnimatorFactory() {\n      return new AnimatorFactory({\n        animators: _animatorDict$2,\n        baseClass: DialogAnimator,\n        baseClassName: 'DialogAnimator',\n        defaultAnimation: this.getAttribute('animation')\n      });\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.style.display = 'none';\n      this.style.zIndex = 10001;\n\n      /* Expected result:\n       *   <ons-dialog>\n       *     <div class=\"dialog-mask\"></div>\n       *     <div class=\"dialog\">\n       *       <div class=\"dialog-container\">...</div>\n       *     </div>\n       *   </ons-dialog>\n       */\n\n      if (!this._dialog) {\n        var dialog = document.createElement('div');\n        dialog.classList.add('dialog');\n\n        var container = document.createElement('div');\n        container.classList.add('dialog-container');\n        while (this.firstChild) {\n          container.appendChild(this.firstChild);\n        }\n        dialog.appendChild(container);\n\n        this.appendChild(dialog);\n      }\n\n      if (!this._mask) {\n        var mask = document.createElement('div');\n        mask.classList.add('dialog-mask');\n        this.insertBefore(mask, this.firstChild);\n      }\n\n      this._dialog.style.zIndex = 20001;\n      this._mask.style.zIndex = 20000;\n\n      this.setAttribute('status-bar-fill', '');\n\n      ModifierUtil.initModifier(this, this._scheme);\n    }\n\n    /**\n     * @property onDeviceBackButton\n     * @type {Object}\n     * @description\n     *   [en]Back-button handler.[/en]\n     *   [ja]バックボタンハンドラ。[/ja]\n     */\n\n    /**\n     * @method show\n     * @signature show([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"none\"` and `\"slide\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"none\", \"slide\"のいずれかを指定します。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]\n     * @param {Function} [options.callback]\n     *   [en]This function is called after the dialog has been revealed.[/en]\n     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *  [en]Show the dialog.[/en]\n     *  [ja]ダイアログを開きます。[/ja]\n     * @return {Promise} Resolves to the displayed element.\n     */\n\n    /**\n     * @method hide\n     * @signature hide([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"none\"` and `\"slide\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"none\", \"slide\"のいずれかを指定できます。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]\n     * @param {Function} [options.callback]\n     *   [en]This functions is called after the dialog has been hidden.[/en]\n     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *   [en]Hide the dialog.[/en]\n     *   [ja]ダイアログを閉じます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the hidden element[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property visible\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the dialog is visible or not.[/en]\n     *   [ja]要素が見える場合に`true`。[/ja]\n     */\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the dialog is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n    /**\n     * @property cancelable\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @param {String} name\n     * @param {DialogAnimator} Animator\n     */\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$9;\n    }\n  }, {\n    key: '_mask',\n    get: function get$$1() {\n      return util.findChild(this, '.dialog-mask');\n    }\n  }, {\n    key: '_dialog',\n    get: function get$$1() {\n      return util.findChild(this, '.dialog');\n    }\n  }], [{\n    key: 'registerAnimator',\n    value: function registerAnimator(name, Animator) {\n      if (!(Animator.prototype instanceof DialogAnimator)) {\n        throw new Error('\"Animator\" param must inherit OnsDialogElement.DialogAnimator');\n      }\n      _animatorDict$2[name] = Animator;\n    }\n  }, {\n    key: 'animators',\n    get: function get$$1() {\n      return _animatorDict$2;\n    }\n  }, {\n    key: 'DialogAnimator',\n    get: function get$$1() {\n      return DialogAnimator;\n    }\n  }]);\n  return DialogElement;\n}(BaseDialogElement);\n\nons$1.elements.Dialog = DialogElement;\ncustomElements.define('ons-dialog', DialogElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar defaultClassName$6 = 'fab';\n\nvar scheme$10 = {\n  '': 'fab--*',\n  '.fab__icon': 'fab--*__icon'\n};\n\n/**\n * @element ons-fab\n * @category form\n * @description\n *   [en]\n *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.\n *\n *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.\n *   [/en]\n *   [ja][/ja]\n * @tutorial vanilla/Reference/fab\n * @modifier mini\n *   [en]Makes the `ons-fab` smaller.[/en]\n *   [ja][/ja]\n * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]\n * @seealso ons-speed-dial\n *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]\n *   [ja][/ja]\n */\n\nvar FabElement = function (_BaseElement) {\n  inherits(FabElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *  [en]The appearance of the button.[/en]\n   *  [ja]ボタンの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute ripple\n   * @description\n   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute position\n   * @type {String}\n   * @description\n   *  [en]The position of the button. Should be a string like `\"bottom right\"` or `\"top left\"`. If this attribute is not defined it will be displayed as an inline element.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *   [en]Specify if button should be disabled.[/en]\n   *   [ja]ボタンを無効化する場合は指定します。[/ja]\n   */\n\n  function FabElement() {\n    classCallCheck(this, FabElement);\n\n    // The following statements can be executed before contentReady\n    // since these do not access the children\n    var _this = possibleConstructorReturn(this, (FabElement.__proto__ || Object.getPrototypeOf(FabElement)).call(this));\n\n    _this.hide();\n    _this.classList.add(defaultClassName$6);\n\n    contentReady(_this, function () {\n      _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(FabElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      if (!util.findChild(this, '.fab__icon')) {\n        var content = document.createElement('span');\n        content.classList.add('fab__icon');\n\n        util.arrayFrom(this.childNodes).forEach(function (element) {\n          if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {\n            content.appendChild(element);\n          }\n        });\n        this.appendChild(content);\n      }\n\n      this._updateRipple();\n\n      ModifierUtil.initModifier(this, scheme$10);\n\n      this._updatePosition();\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      setImmediate(function () {\n        return _this2.show();\n      });\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$6, scheme$10);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$10);\n          break;\n        case 'ripple':\n          this._updateRipple();\n          break;\n        case 'position':\n          this._updatePosition();\n          break;\n      }\n    }\n  }, {\n    key: '_show',\n    value: function _show() {\n      this.show();\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      var _this3 = this;\n\n      setImmediate(function () {\n        return _this3.hide();\n      });\n    }\n  }, {\n    key: '_updateRipple',\n    value: function _updateRipple() {\n      util.updateRipple(this);\n    }\n  }, {\n    key: '_updatePosition',\n    value: function _updatePosition() {\n      var position = this.getAttribute('position');\n      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');\n      switch (position) {\n        case 'top right':\n        case 'right top':\n          this.classList.add('fab--top__right');\n          break;\n        case 'top left':\n        case 'left top':\n          this.classList.add('fab--top__left');\n          break;\n        case 'bottom right':\n        case 'right bottom':\n          this.classList.add('fab--bottom__right');\n          break;\n        case 'bottom left':\n        case 'left bottom':\n          this.classList.add('fab--bottom__left');\n          break;\n        case 'center top':\n        case 'top center':\n          this.classList.add('fab--top__center');\n          break;\n        case 'center bottom':\n        case 'bottom center':\n          this.classList.add('fab--bottom__center');\n          break;\n        default:\n          break;\n      }\n    }\n\n    /**\n     * @method show\n     * @signature show()\n     * @description\n     *  [en]Show the floating action button.[/en]\n     *  [ja][/ja]\n     */\n\n  }, {\n    key: 'show',\n    value: function show() {\n      this.toggle(true);\n    }\n\n    /**\n     * @method hide\n     * @signature hide()\n     * @description\n     *  [en]Hide the floating action button.[/en]\n     *  [ja][/ja]\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide() {\n      this.toggle(false);\n    }\n\n    /**\n     * @method toggle\n     * @signature toggle()\n     * @description\n     *   [en]Toggle the visibility of the button.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'toggle',\n    value: function toggle() {\n      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.visible;\n\n      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;\n      var translate = isBottom ? 'translate3d(0px, -' + (util.globals.fabOffset || 0) + 'px, 0px)' : '';\n\n      styler(this, { transform: translate + ' scale(' + Number(action) + ')' });\n    }\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n\n    /**\n     * @property visible\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is visible or not.[/en]\n     *   [ja]要素が見える場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'visible',\n    get: function get$$1() {\n      return this.style.transform.indexOf('scale(0)') === -1 && this.style.display !== 'none';\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'ripple', 'position', 'class'];\n    }\n  }]);\n  return FabElement;\n}(BaseElement);\n\nons$1.elements.Fab = FabElement;\ncustomElements.define('ons-fab', FabElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * @element ons-gesture-detector\n * @category gesture\n * @description\n *   [en]\n *     Component to detect finger gestures within the wrapped element. Following gestures are supported:\n *     - Drag gestures: `drag`, `dragleft`, `dragright`, `dragup`, `dragdown`\n *     - Hold gestures: `hold`, `release`\n *     - Swipe gestures: `swipe`, `swipeleft`, `swiperight`, `swipeup`, `swipedown`\n *     - Tap gestures: `tap`, `doubletap`\n *     - Pinch gestures: `pinch`, `pinchin`, `pinchout`\n *     - Other gestures: `touch`, `transform`, `rotate`\n *   [/en]\n *   [ja]要素内のジェスチャー操作を検知します。詳しくはガイドを参照してください。[/ja]\n * @guide features.html#gesture-detection\n *   [en]Detecting finger gestures[/en]\n *   [ja]ジェスチャー操作の検知[/ja]\n * @example\n * <ons-gesture-detector>\n *   <div id=\"detect-area\" style=\"width: 100px; height: 100px;\">\n *     Swipe Here\n *   </div>\n * </ons-gesture-detector>\n *\n * <script>\n *   document.addEventListener('swipeleft', function(event) {\n *     if (event.target.matches('#detect-area')) {\n *       console.log('Swipe left is detected.');\n *     }\n *   });\n * </script>\n */\n\nvar GestureDetectorElement = function (_BaseElement) {\n  inherits(GestureDetectorElement, _BaseElement);\n\n  function GestureDetectorElement() {\n    classCallCheck(this, GestureDetectorElement);\n\n    var _this = possibleConstructorReturn(this, (GestureDetectorElement.__proto__ || Object.getPrototypeOf(GestureDetectorElement)).call(this));\n\n    _this._gestureDetector = new GestureDetector(_this);\n    return _this;\n  }\n\n  return GestureDetectorElement;\n}(BaseElement);\n\nons$1.elements.GestureDetector = GestureDetectorElement;\ncustomElements.define('ons-gesture-detector', GestureDetectorElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar autoPrefix = 'fa'; // FIXME: To be removed in v3\n\n/**\n * @element ons-icon\n * @category visual\n * @description\n *   [en]\n *     Displays an icon. The following icon suites are available:\n *\n *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)\n *     * [Ionicons](http://ionicons.com/)\n *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)\n *   [/en]\n *   [ja][/ja]\n * @codepen xAhvg\n * @tutorial vanilla/Reference/icon\n * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja][/ja]\n * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]\n * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]\n * @example\n * <ons-icon\n *   icon=\"md-car\"\n *   size=\"20px\"\n *   style=\"color: red\">\n * </ons-icon>\n *\n * <ons-button>\n *   <ons-icon icon=\"md-car\"></ons-icon>\n *   Car\n * </ons-button>\n */\n\nvar IconElement = function (_BaseElement) {\n  inherits(IconElement, _BaseElement);\n\n  /**\n   * @attribute icon\n   * @type {String}\n   * @description\n   *   [en]\n   *     The icon name. `\"md-\"` prefix for Material Icons, `\"fa-\"` for Font Awesome and `\"ion-\"` prefix for Ionicons.\n   *\n   *     See all available icons on the element description (at the top).\n   *\n   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `\"modifierName:\"` prefix.\n   *\n   *     The code `<ons-icon icon=\"ion-edit, material:md-edit\"></ons-icon>` will display `\"md-edit\"` for Material Design and `\"ion-edit\"` as the default icon.\n   *\n   *     `fa-` prefix is added automatically if none is provided. Check [See also](#seealso) section for more information.\n   *   [/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute size\n   * @type {String}\n   * @description\n   *   [en]\n   *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.\n   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `\"modifierName:\"` prefix.\n   *\n   *     The code:\n   *\n   *     ```\n   *     <ons-icon\n   *       icon=\"ion-edit\"\n   *       size=\"32px, material:24px\">\n   *     </ons-icon>\n   *     ```\n   *\n   *     will render as a `24px` icon if the `\"material\"` modifier is present and `32px` otherwise.\n   *   [/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute rotate\n   * @type {Number}\n   * @description\n   *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]\n   *   [ja]アイコンを回転して表示します。90, 180, 270から指定できます。[/ja]\n   */\n\n  /**\n   * @attribute fixed-width\n   * @type {Boolean}\n   * @default false\n   * @description\n   *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute spin\n   * @description\n   *   [en]Specify whether the icon should be spinning.[/en]\n   *   [ja]アイコンを回転するかどうかを指定します。[/ja]\n   */\n\n  function IconElement() {\n    classCallCheck(this, IconElement);\n\n    var _this = possibleConstructorReturn(this, (IconElement.__proto__ || Object.getPrototypeOf(IconElement)).call(this));\n\n    _this._compile();\n    return _this;\n  }\n\n  createClass(IconElement, [{\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      this._cleanClassAttribute(name === 'icon' ? last : this.getAttribute('icon'), name === 'modifier' ? last : undefined);\n      this._update();\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n      this._update();\n    }\n  }, {\n    key: '_update',\n    value: function _update() {\n      var _this2 = this;\n\n      var _buildClassAndStyle2 = this._buildClassAndStyle(this._parseAttr('icon'), this._parseAttr('size')),\n          classList = _buildClassAndStyle2.classList,\n          style = _buildClassAndStyle2.style;\n\n      util.extend(this.style, style);\n\n      classList.forEach(function (className) {\n        return _this2.classList.add(className);\n      });\n    }\n  }, {\n    key: '_parseAttr',\n    value: function _parseAttr(attrName) {\n      var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getAttribute('modifier') || '';\n\n      var attr = this.getAttribute(attrName) || attrName || '';\n      var parts = attr.split(/\\s*,\\s*/);\n      var def = parts[0];\n      var md = parts[1];\n      md = (md || '').split(/\\s*:\\s*/);\n\n      return (modifier && RegExp('(^|\\\\s+)' + md[0] + '($|\\\\s+)', 'i').test(modifier) ? md[1] : def) || '';\n    }\n\n    /**\n     * Remove unneeded class value.\n     */\n\n  }, {\n    key: '_cleanClassAttribute',\n    value: function _cleanClassAttribute(lastIcon, lastModifier) {\n      var _this3 = this;\n\n      var _prefixIcon2 = this._prefixIcon(this._parseAttr(lastIcon, lastModifier)),\n          className = _prefixIcon2.className,\n          prefix = _prefixIcon2.prefix;\n\n      var customPrefixRE = className !== prefix ? '|' + prefix + '$|' + prefix + '-' : '|' + className + '$' || '';\n      var re = new RegExp('^(fa$|fa-|ion-|zmdi$|zmdi-|ons-icon--' + customPrefixRE + ')');\n\n      util.arrayFrom(this.classList).filter(function (className) {\n        return re.test(className);\n      }).forEach(function (className) {\n        return _this3.classList.remove(className);\n      });\n    }\n  }, {\n    key: '_prefixIcon',\n    value: function _prefixIcon(iconName) {\n      var className = autoPrefix + (autoPrefix ? '-' : '') + iconName;\n      return { className: className, prefix: className.split('-')[0] };\n    }\n  }, {\n    key: '_buildClassAndStyle',\n    value: function _buildClassAndStyle(iconName, size) {\n      var classList = ['ons-icon'];\n      var style = {};\n\n      // Icon\n      if (iconName.indexOf('ion-') === 0) {\n        classList.push(iconName);\n        classList.push('ons-icon--ion');\n      } else if (iconName.indexOf('fa-') === 0) {\n        classList.push(iconName);\n        classList.push('fa');\n      } else if (iconName.indexOf('md-') === 0) {\n        classList.push('zmdi');\n        classList.push('zmdi-' + iconName.split(/-(.+)?/)[1]);\n      } else {\n        var _prefixIcon3 = this._prefixIcon(iconName),\n            className = _prefixIcon3.className,\n            prefix = _prefixIcon3.prefix;\n\n        prefix && classList.push(prefix);\n        className && classList.push(className);\n      }\n\n      // Size\n      if (size.match(/^[1-5]x|lg$/)) {\n        classList.push('ons-icon--' + size);\n        this.style.removeProperty('font-size');\n      } else {\n        style.fontSize = size;\n      }\n\n      return {\n        classList: classList,\n        style: style\n      };\n    }\n  }], [{\n    key: 'setAutoPrefix',\n    value: function setAutoPrefix(prefix) {\n      autoPrefix = prefix ? typeof prefix === 'string' && prefix || 'fa' : '';\n    }\n  }, {\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['icon', 'size', 'modifier', 'class'];\n    }\n  }]);\n  return IconElement;\n}(BaseElement);\n\nons$1.elements.Icon = IconElement;\ncustomElements.define('ons-icon', IconElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar LazyRepeatDelegate = function () {\n  function LazyRepeatDelegate(userDelegate) {\n    var templateElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    classCallCheck(this, LazyRepeatDelegate);\n\n    if ((typeof userDelegate === 'undefined' ? 'undefined' : _typeof(userDelegate)) !== 'object' || userDelegate === null) {\n      throw Error('\"delegate\" parameter must be an object.');\n    }\n    this._userDelegate = userDelegate;\n\n    if (!(templateElement instanceof Element) && templateElement !== null) {\n      throw Error('\"templateElement\" parameter must be an instance of Element or null.');\n    }\n    this._templateElement = templateElement;\n  }\n\n  createClass(LazyRepeatDelegate, [{\n    key: 'hasRenderFunction',\n\n\n    /**\n     * @return {Boolean}\n     */\n    value: function hasRenderFunction() {\n      return this._userDelegate._render instanceof Function;\n    }\n\n    /**\n     * @return {void}\n     */\n\n  }, {\n    key: '_render',\n    value: function _render() {\n      this._userDelegate._render.apply(this._userDelegate, arguments);\n    }\n\n    /**\n     * @param {Number} index\n     * @param {Function} done A function that take item object as parameter.\n     */\n\n  }, {\n    key: 'loadItemElement',\n    value: function loadItemElement(index, done) {\n      if (this._userDelegate.loadItemElement instanceof Function) {\n        this._userDelegate.loadItemElement(index, done);\n      } else {\n        var element = this._userDelegate.createItemContent(index, this._templateElement);\n        if (!(element instanceof Element)) {\n          throw Error('createItemContent() must return an instance of Element.');\n        }\n\n        done({ element: element });\n      }\n    }\n\n    /**\n     * @return {Number}\n     */\n\n  }, {\n    key: 'countItems',\n    value: function countItems() {\n      var count = this._userDelegate.countItems();\n      if (typeof count !== 'number') {\n        throw Error('countItems() must return a number.');\n      }\n      return count;\n    }\n\n    /**\n     * @param {Number} index\n     * @param {Object} item\n     * @param {Element} item.element\n     */\n\n  }, {\n    key: 'updateItem',\n    value: function updateItem(index, item) {\n      if (this._userDelegate.updateItemContent instanceof Function) {\n        this._userDelegate.updateItemContent(index, item);\n      }\n    }\n\n    /**\n     * @return {Number}\n     */\n\n  }, {\n    key: 'calculateItemHeight',\n    value: function calculateItemHeight(index) {\n      if (this._userDelegate.calculateItemHeight instanceof Function) {\n        var height = this._userDelegate.calculateItemHeight(index);\n\n        if (typeof height !== 'number') {\n          throw Error('calculateItemHeight() must return a number.');\n        }\n\n        return height;\n      }\n\n      return 0;\n    }\n\n    /**\n     * @param {Number} index\n     * @param {Object} item\n     */\n\n  }, {\n    key: 'destroyItem',\n    value: function destroyItem(index, item) {\n      if (this._userDelegate.destroyItem instanceof Function) {\n        this._userDelegate.destroyItem(index, item);\n      }\n    }\n\n    /**\n     * @return {void}\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      if (this._userDelegate.destroy instanceof Function) {\n        this._userDelegate.destroy();\n      }\n\n      this._userDelegate = this._templateElement = null;\n    }\n  }, {\n    key: 'itemHeight',\n    get: function get$$1() {\n      return this._userDelegate.itemHeight;\n    }\n  }]);\n  return LazyRepeatDelegate;\n}();\n\n/**\n * This class provide core functions for ons-lazy-repeat.\n */\nvar LazyRepeatProvider = function () {\n\n  /**\n   * @param {Element} wrapperElement\n   * @param {LazyRepeatDelegate} delegate\n   */\n  function LazyRepeatProvider(wrapperElement, delegate) {\n    classCallCheck(this, LazyRepeatProvider);\n\n    if (!(delegate instanceof LazyRepeatDelegate)) {\n      throw Error('\"delegate\" parameter must be an instance of LazyRepeatDelegate.');\n    }\n\n    this._wrapperElement = wrapperElement;\n    this._delegate = delegate;\n    this._insertIndex = this._wrapperElement.children[0] && this._wrapperElement.children[0].tagName === 'ONS-LAZY-REPEAT' ? 1 : 0;\n\n    if (wrapperElement.tagName.toLowerCase() === 'ons-list') {\n      wrapperElement.classList.add('lazy-list');\n    }\n\n    this._pageContent = this._findPageContentElement(wrapperElement);\n\n    if (!this._pageContent) {\n      throw new Error('ons-lazy-repeat must be a descendant of an <ons-page> or an element.');\n    }\n\n    this.lastScrollTop = this._pageContent.scrollTop;\n    this.padding = 0;\n    this._topPositions = [0];\n    this._renderedItems = {};\n\n    if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {\n      this._unknownItemHeight = true;\n    }\n\n    this._addEventListeners();\n    this._onChange();\n  }\n\n  createClass(LazyRepeatProvider, [{\n    key: '_findPageContentElement',\n    value: function _findPageContentElement(wrapperElement) {\n      var pageContent = util.findParent(wrapperElement, '.page__content');\n\n      if (pageContent) {\n        return pageContent;\n      }\n\n      var page = util.findParent(wrapperElement, 'ons-page');\n      if (page) {\n        var content = util.findChild(page, '.content');\n        if (content) {\n          return content;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: '_checkItemHeight',\n    value: function _checkItemHeight(callback) {\n      var _this = this;\n\n      this._delegate.loadItemElement(0, function (item) {\n        if (!_this._unknownItemHeight) {\n          throw Error('Invalid state');\n        }\n\n        _this._wrapperElement.appendChild(item.element);\n\n        var done = function done() {\n          _this._delegate.destroyItem(0, item);\n          item.element && item.element.remove();\n          delete _this._unknownItemHeight;\n          callback();\n        };\n\n        _this._itemHeight = item.element.offsetHeight;\n\n        if (_this._itemHeight > 0) {\n          done();\n          return;\n        }\n\n        // retry to measure offset height\n        // dirty fix for angular2 directive\n        _this._wrapperElement.style.visibility = 'hidden';\n        item.element.style.visibility = 'hidden';\n\n        setImmediate(function () {\n          _this._itemHeight = item.element.offsetHeight;\n          if (_this._itemHeight == 0) {\n            throw Error('Invalid state: this._itemHeight must be greater than zero.');\n          }\n          _this._wrapperElement.style.visibility = '';\n          done();\n        });\n      });\n    }\n  }, {\n    key: '_countItems',\n    value: function _countItems() {\n      return this._delegate.countItems();\n    }\n  }, {\n    key: '_getItemHeight',\n    value: function _getItemHeight(i) {\n      // Item is rendered\n      if (this._renderedItems.hasOwnProperty(i)) {\n        if (!this._renderedItems[i].hasOwnProperty('height')) {\n          this._renderedItems[i].height = this._renderedItems[i].element.offsetHeight;\n        }\n        return this._renderedItems[i].height;\n      }\n\n      // Item is not rendered, scroll up\n      if (this._topPositions[i + 1] && this._topPositions[i]) {\n        return this._topPositions[i + 1] - this._topPositions[i];\n      }\n      // Item is not rendered, scroll down\n      return this.staticItemHeight || this._delegate.calculateItemHeight(i);\n    }\n  }, {\n    key: '_calculateRenderedHeight',\n    value: function _calculateRenderedHeight() {\n      var _this2 = this;\n\n      return Object.keys(this._renderedItems).reduce(function (a, b) {\n        return a + _this2._getItemHeight(+b);\n      }, 0);\n    }\n  }, {\n    key: '_onChange',\n    value: function _onChange() {\n      this._render();\n    }\n  }, {\n    key: '_lastItemRendered',\n    value: function _lastItemRendered() {\n      return Math.max.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));\n    }\n  }, {\n    key: '_firstItemRendered',\n    value: function _firstItemRendered() {\n      return Math.min.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));\n    }\n  }, {\n    key: 'refresh',\n    value: function refresh() {\n      var forceRender = { forceScrollDown: true };\n      var lastItemIndex = Math.min(this._lastItemRendered(), this._countItems() - 1);\n      var firstItemIndex = this._firstItemRendered();\n\n      if (util.isInteger(lastItemIndex)) {\n        forceRender.forceLastIndex = lastItemIndex;\n      }\n\n      if (util.isInteger(firstItemIndex)) {\n        this._wrapperElement.style.height = this._topPositions[firstItemIndex] + this._calculateRenderedHeight() + 'px';\n        this.padding = this._topPositions[firstItemIndex];\n        forceRender.forceFirstIndex = firstItemIndex;\n      }\n\n      this._removeAllElements();\n      this._render(forceRender);\n      this._wrapperElement.style.height = 'inherit';\n    }\n  }, {\n    key: '_render',\n    value: function _render() {\n      var _this3 = this;\n\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$forceScrollDown = _ref.forceScrollDown,\n          forceScrollDown = _ref$forceScrollDown === undefined ? false : _ref$forceScrollDown,\n          forceFirstIndex = _ref.forceFirstIndex,\n          forceLastIndex = _ref.forceLastIndex;\n\n      if (this._unknownItemHeight) {\n        return this._checkItemHeight(this._render.bind(this, arguments[0]));\n      }\n\n      var isScrollUp = !forceScrollDown && this.lastScrollTop > this._pageContent.scrollTop;\n      this.lastScrollTop = this._pageContent.scrollTop;\n      var keep = {};\n\n      var offset = this._wrapperElement.getBoundingClientRect().top;\n      var limit = 4 * window.innerHeight - offset;\n      var count = this._countItems();\n\n      var start = forceFirstIndex || Math.max(0, this._calculateStartIndex(offset) - 30); // Recalculate for 0 or undefined\n      var i = start;\n\n      for (var top = this._topPositions[i]; i < count && top < limit; i++) {\n        if (i >= this._topPositions.length) {\n          // perf optimization\n          this._topPositions.length += 100;\n        }\n\n        this._topPositions[i] = top;\n        top += this._getItemHeight(i);\n      }\n\n      if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {\n        return this._delegate._render(start, i, function () {\n          _this3.padding = _this3._topPositions[start];\n        });\n      }\n\n      if (isScrollUp) {\n        for (var j = i - 1; j >= start; j--) {\n          keep[j] = true;\n          this._renderElement(j, isScrollUp);\n        }\n      } else {\n        var lastIndex = forceLastIndex || Math.max.apply(Math, [i - 1].concat(toConsumableArray(Object.keys(this._renderedItems)))); // Recalculate for 0 or undefined\n        for (var _j = start; _j <= lastIndex; _j++) {\n          keep[_j] = true;\n          this._renderElement(_j, isScrollUp);\n        }\n      }\n\n      Object.keys(this._renderedItems).forEach(function (key) {\n        return keep[key] || _this3._removeElement(key, isScrollUp);\n      });\n    }\n\n    /**\n     * @param {Number} index\n     * @param {Boolean} isScrollUp\n     */\n\n  }, {\n    key: '_renderElement',\n    value: function _renderElement(index, isScrollUp) {\n      var _this4 = this;\n\n      var item = this._renderedItems[index];\n      if (item) {\n        this._delegate.updateItem(index, item); // update if it exists\n        return;\n      }\n\n      this._delegate.loadItemElement(index, function (item) {\n        if (isScrollUp) {\n          _this4._wrapperElement.insertBefore(item.element, _this4._wrapperElement.children[_this4._insertIndex]);\n          _this4.padding = _this4._topPositions[index];\n          item.height = _this4._topPositions[index + 1] - _this4._topPositions[index];\n        } else {\n          _this4._wrapperElement.appendChild(item.element);\n        }\n\n        _this4._renderedItems[index] = item;\n      });\n    }\n\n    /**\n     * @param {Number} index\n     * @param {Boolean} isScrollUp\n     */\n\n  }, {\n    key: '_removeElement',\n    value: function _removeElement(index) {\n      var isScrollUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      index = +index;\n      var item = this._renderedItems[index];\n      this._delegate.destroyItem(index, item);\n\n      if (isScrollUp) {\n        this._topPositions[index + 1] = undefined;\n      } else {\n        this.padding = this.padding + this._getItemHeight(index);\n      }\n\n      if (item.element.parentElement) {\n        item.element.parentElement.removeChild(item.element);\n      }\n\n      delete this._renderedItems[index];\n    }\n  }, {\n    key: '_removeAllElements',\n    value: function _removeAllElements() {\n      var _this5 = this;\n\n      Object.keys(this._renderedItems).forEach(function (key) {\n        return _this5._removeElement(key);\n      });\n    }\n  }, {\n    key: '_recalculateTopPositions',\n    value: function _recalculateTopPositions(start, end) {\n      for (var i = start; i <= end; i++) {\n        this._topPositions[i + 1] = this._topPositions[i] + this._getItemHeight(i);\n      }\n    }\n  }, {\n    key: '_calculateStartIndex',\n    value: function _calculateStartIndex(current) {\n      var firstItemIndex = this._firstItemRendered();\n      var lastItemIndex = this._lastItemRendered();\n\n      // Fix for Safari scroll and Angular 2\n      this._recalculateTopPositions(firstItemIndex, lastItemIndex);\n\n      var start = 0;\n      var end = this._countItems() - 1;\n\n      // Binary search for index at top of screen so we can speed up rendering.\n      for (;;) {\n        var middle = Math.floor((start + end) / 2);\n        var value = current + this._topPositions[middle];\n\n        if (end < start) {\n          return 0;\n        } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {\n          return middle;\n        } else if (isNaN(value) || value >= 0) {\n          end = middle - 1;\n        } else {\n          start = middle + 1;\n        }\n      }\n    }\n  }, {\n    key: '_debounce',\n    value: function _debounce(func, wait, immediate) {\n      var timeout = void 0;\n      return function () {\n        var _this6 = this,\n            _arguments = arguments;\n\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        if (callNow) {\n          func.apply(this, arguments);\n        } else {\n          timeout = setTimeout(function () {\n            timeout = null;\n            func.apply(_this6, _arguments);\n          }, wait);\n        }\n      };\n    }\n  }, {\n    key: '_doubleFireOnTouchend',\n    value: function _doubleFireOnTouchend() {\n      this._render();\n      this._debounce(this._render.bind(this), 100);\n    }\n  }, {\n    key: '_addEventListeners',\n    value: function _addEventListeners() {\n      util.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);\n\n      if (platform.isIOS()) {\n        this._boundOnChange = this._debounce(this._boundOnChange, 30);\n      }\n\n      this._pageContent.addEventListener('scroll', this._boundOnChange, true);\n\n      if (platform.isIOS()) {\n        this._pageContent.addEventListener('touchmove', this._boundOnChange, true);\n        this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);\n      }\n\n      window.document.addEventListener('resize', this._boundOnChange, true);\n    }\n  }, {\n    key: '_removeEventListeners',\n    value: function _removeEventListeners() {\n      this._pageContent.removeEventListener('scroll', this._boundOnChange, true);\n\n      if (platform.isIOS()) {\n        this._pageContent.removeEventListener('touchmove', this._boundOnChange, true);\n        this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);\n      }\n\n      window.document.removeEventListener('resize', this._boundOnChange, true);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this._removeAllElements();\n      this._delegate.destroy();\n      this._parentElement = this._delegate = this._renderedItems = null;\n      this._removeEventListeners();\n    }\n  }, {\n    key: 'padding',\n    get: function get$$1() {\n      return parseInt(this._wrapperElement.style.paddingTop, 10);\n    },\n    set: function set$$1(newValue) {\n      this._wrapperElement.style.paddingTop = newValue + 'px';\n    }\n  }, {\n    key: 'staticItemHeight',\n    get: function get$$1() {\n      return this._delegate.itemHeight || this._itemHeight;\n    }\n  }]);\n  return LazyRepeatProvider;\n}();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * @element ons-lazy-repeat\n * @category list\n * @description\n *   [en]\n *     Using this component a list with millions of items can be rendered without a drop in performance.\n *     It does that by \"lazily\" loading elements into the DOM when they come into view and\n *     removing items from the DOM when they are not visible.\n *   [/en]\n *   [ja]\n *     このコンポーネント内で描画されるアイテムのDOM要素の読み込みは、画面に見えそうになった時まで自動的に遅延され、\n *     画面から見えなくなった場合にはその要素は動的にアンロードされます。\n *     このコンポーネントを使うことで、パフォーマンスを劣化させること無しに巨大な数の要素を描画できます。\n *   [/ja]\n * @codepen QwrGBm\n * @tutorial vanilla/Reference/lazy-repeat\n * @seealso ons-list\n *   [en]The `<ons-list>` element is used to render a list.[/en]\n *   [ja]`<ons-list>`要素はリストを描画するのに使われます。[/ja]\n * @example\n * <script>\n *   window.addEventListener('load', function() {\n *     var lazyRepeat = document.querySelector('#list');\n *     lazyRepeat.delegate = {\n *      createItemContent: function(i, template) {\n *        var dom = template.cloneNode(true);\n *        dom.innerText = i;\n *\n *        return dom;\n *      },\n *      countItems: function() {\n *        return 10000000;\n *      },\n *      destroyItem: function(index, item) {\n *        console.log('Destroyed item with index: ' + index);\n *      }\n *     };\n *   });\n * </script>\n *\n * <ons-list id=\"list\">\n *   <ons-lazy-repeat>\n *     <ons-list-item></ons-list-item>\n *   </ons-lazy-repeat>\n * </ons-list>\n */\n\nvar LazyRepeatElement = function (_BaseElement) {\n  inherits(LazyRepeatElement, _BaseElement);\n\n  function LazyRepeatElement() {\n    classCallCheck(this, LazyRepeatElement);\n    return possibleConstructorReturn(this, (LazyRepeatElement.__proto__ || Object.getPrototypeOf(LazyRepeatElement)).apply(this, arguments));\n  }\n\n  createClass(LazyRepeatElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      // not very good idea and also not documented\n      if (this.hasAttribute('delegate')) {\n        this.delegate = window[this.getAttribute('delegate')];\n      }\n    }\n\n    /**\n     * @property delegate\n     * @type {Object}\n     * @description\n     *  [en]Specify a delegate object to load and unload item elements.[/en]\n     *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]\n     */\n\n    /**\n     * @property delegate.createItemContent\n     * @type {Function}\n     * @description\n     *   [en]\n     *     This function should return a `HTMLElement`.\n     *\n     *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.\n     *   [/en]\n     *   [ja]\n     *     この関数は`HTMLElement`を返してください。\n     *     要素を生成しやすくするために、現在のアイテムのインデックスとテンプレートが引数に渡されます。\n     *     このテンプレートは、`<ons-lazy-repeat>`要素のコンテンツが渡されます。\n     *   [/ja]\n     */\n\n    /**\n     * @property delegate.countItems\n     * @type {Function}\n     * @description\n     *   [en]Should return the number of items in the list.[/en]\n     *   [ja]リスト内のアイテム数を返してください。[/ja]\n     */\n\n    /**\n     * @property delegate.calculateItemHeight\n     * @type {Function}\n     * @description\n     *   [en]\n     *     Should return the height of an item. The index is provided as an argument.\n     *\n     *     This is important when rendering lists where the items have different height.\n     *\n     *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.\n     *   [/en]\n     *   [ja]\n     *     アイテムの高さ(ピクセル)を返してください。アイテムのインデックス値は引数で渡されます。\n     *     この関数は、それぞれのアイムが違った高さを持つリストをレンダリングする際に重要です。\n     *     この関数はオプショナルです。もしこの関数が無い場合には、\n     *     最初のアイテムの高さが他のすべてのアイテムの高さとして利用されます。\n     *   [/ja]\n     */\n\n    /**\n     * @property delegate.destroyItem\n     * @type {Function}\n     * @description\n     *   [en]\n     *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.\n     *\n     *     The function is optional but may be important in order to avoid memory leaks.\n     *   [/en]\n     *   [ja]\n     *     この関数は、あるアイテムがDOMツリーから除かれた時に呼び出されます。\n     *     アイテムのインデックス値とDOM要素が引数として渡されます。\n     *     この関数はオプショナルですが、各アイテムの後処理が必要な場合にはメモリーリークを避けるために重要です。\n     *   [/ja]\n     */\n\n  }, {\n    key: 'refresh',\n\n\n    /**\n     * @method refresh\n     * @signature refresh()\n     * @description\n     *   [en]Refresh the list. Use this method when the data has changed.[/en]\n     *   [ja]リストを更新します。もしデータが変わった場合にはこのメソッドを使ってください。[/ja]\n     */\n    value: function refresh() {\n      this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {}\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      if (this._lazyRepeatProvider) {\n        this._lazyRepeatProvider.destroy();\n        this._lazyRepeatProvider = null;\n      }\n    }\n  }, {\n    key: 'delegate',\n    set: function set$$1(userDelegate) {\n      this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();\n\n      if (!this._templateElement && this.children[0]) {\n        this._templateElement = this.removeChild(this.children[0]);\n      }\n\n      var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);\n      this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);\n    },\n    get: function get$$1() {\n      throw new Error('This property can only be used to set the delegate object.');\n    }\n  }]);\n  return LazyRepeatElement;\n}(BaseElement);\n\ninternal$1.LazyRepeatDelegate = LazyRepeatDelegate;\ninternal$1.LazyRepeatProvider = LazyRepeatProvider;\n\nons$1.elements.LazyRepeat = LazyRepeatElement;\ncustomElements.define('ons-lazy-repeat', LazyRepeatElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$7 = 'list-header';\nvar scheme$11 = { '': 'list-header--*' };\n\n/**\n * @element ons-list-header\n * @category list\n * @description\n *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]\n *   [ja]リスト要素に使用するヘッダー用コンポーネント。ons-listと共に使用します。[/ja]\n * @seealso ons-list\n *   [en]The `<ons-list>` component[/en]\n *   [ja]ons-listコンポーネント[/ja]\n * @seealso ons-list-item\n *   [en]The `<ons-list-item>` component[/en]\n *   [ja]ons-list-itemコンポーネント[/ja]\n * @codepen yxcCt\n * @tutorial vanilla/Reference/list\n * @modifier material\n *   [en]Display a Material Design list header.[/en]\n *   [ja][/ja]\n * @example\n * <ons-list>\n *   <ons-list-header>Header Text</ons-list-header>\n *   <ons-list-item>Item</ons-list-item>\n *   <ons-list-item>Item</ons-list-item>\n * </ons-list>\n */\n\nvar ListHeaderElement = function (_BaseElement) {\n  inherits(ListHeaderElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the list header.[/en]\n   *   [ja]ヘッダーの表現を指定します。[/ja]\n   */\n\n  function ListHeaderElement() {\n    classCallCheck(this, ListHeaderElement);\n\n    var _this = possibleConstructorReturn(this, (ListHeaderElement.__proto__ || Object.getPrototypeOf(ListHeaderElement)).call(this));\n\n    _this._compile();\n    return _this;\n  }\n\n  createClass(ListHeaderElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n      this.classList.add(defaultClassName$7);\n      ModifierUtil.initModifier(this, scheme$11);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$7, scheme$11);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$11);\n          break;\n      }\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'];\n    }\n  }]);\n  return ListHeaderElement;\n}(BaseElement);\n\nons$1.elements.ListHeader = ListHeaderElement;\ncustomElements.define('ons-list-header', ListHeaderElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$8 = 'list-title';\nvar scheme$12 = { '': 'list-title--*' };\n\n/**\n * @element ons-list-title\n * @category list\n * @description\n *   [en]Represents a list title.[/en]\n *   [ja]リストのタイトルを表現します。[/ja]\n * @example\n * <ons-list-title>List Title</ons-list-title>\n * <ons-list>\n *   <ons-list-item>Item</ons-list-item>\n * </ons-list>\n * @modifier material\n *   [en]Display a Material Design list title.[/en]\n *   [ja][/ja]\n */\n\nvar ListTitleElement = function (_BaseElement) {\n  inherits(ListTitleElement, _BaseElement);\n\n  function ListTitleElement() {\n    classCallCheck(this, ListTitleElement);\n\n    var _this = possibleConstructorReturn(this, (ListTitleElement.__proto__ || Object.getPrototypeOf(ListTitleElement)).call(this));\n\n    _this._compile();\n    return _this;\n  }\n\n  createClass(ListTitleElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n      this.classList.add(defaultClassName$8);\n      ModifierUtil.initModifier(this, scheme$12);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$8, scheme$12);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$12);\n          break;\n      }\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'];\n    }\n  }]);\n  return ListTitleElement;\n}(BaseElement);\n\nons$1.elements.ListTitle = ListTitleElement;\ncustomElements.define('ons-list-title', ListTitleElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$9 = 'list-item';\nvar scheme$13 = {\n  '.list-item': 'list-item--*',\n  '.list-item__left': 'list-item--*__left',\n  '.list-item__center': 'list-item--*__center',\n  '.list-item__right': 'list-item--*__right',\n  '.list-item__label': 'list-item--*__label',\n  '.list-item__title': 'list-item--*__title',\n  '.list-item__subtitle': 'list-item--*__subtitle',\n  '.list-item__thumbnail': 'list-item--*__thumbnail',\n  '.list-item__icon': 'list-item--*__icon'\n};\n\n/**\n * @element ons-list-item\n * @category list\n * @modifier tappable\n *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the \"tappable\" and \"tap-background-color\" attribute for better behavior when scrolling.[/en]\n *   [ja]タップやクリックした時に効果が表示されるようになります。[/ja]\n * @modifier chevron\n *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped.[/en]\n *   [ja][/ja]\n * @modifier longdivider\n *   [en]Displays a long horizontal divider between items.[/en]\n *   [ja][/ja]\n * @modifier nodivider\n *   [en]Removes the divider between list items.[/en]\n *   [ja][/ja]\n * @modifier material\n *   [en]Display a Material Design list item.[/en]\n *   [ja][/ja]\n * @description\n *   [en]\n *     Component that represents each item in a list. The list item is composed of three parts that are represented with the `left`, `center` and `right` classes. These classes can be used to ensure that the content of the list items is properly aligned.\n *\n *     ```\n *     <ons-list-item>\n *       <div class=\"left\">Left</div>\n *       <div class=\"center\">Center</div>\n *       <div class=\"right\">Right</div>\n *     </ons-list-item>\n *     ```\n *\n *     There is also a number of classes (prefixed with `list-item__*`) that help when putting things like icons and thumbnails into the list items.\n *   [/en]\n *   [ja][/ja]\n * @seealso ons-list\n *   [en]ons-list component[/en]\n *   [ja]ons-listコンポーネント[/ja]\n * @seealso ons-list-header\n *   [en]ons-list-header component[/en]\n *   [ja]ons-list-headerコンポーネント[/ja]\n * @codepen yxcCt\n * @tutorial vanilla/Reference/list\n * @example\n * <ons-list-item>\n *   <div class=\"left\">\n *     <ons-icon icon=\"md-face\" class=\"list-item__icon\"></ons-icon>\n *   </div>\n *   <div class=\"center\">\n *     <div class=\"list-item__title\">Title</div>\n *     <div class=\"list-item__subtitle\">Subtitle</div>\n *   </div>\n *   <div class=\"right\">\n *     <ons-switch></ons-switch>\n *   </div>\n * </ons-list-item>\n */\n\nvar ListItemElement = function (_BaseElement) {\n  inherits(ListItemElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the list item.[/en]\n   *   [ja]各要素の表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute lock-on-drag\n   * @type {String}\n   * @description\n   *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]\n   *   [ja]この属性があると、ユーザーがこの要素を横方向にドラッグしている時に、縦方向のスクロールが起きないようになります。[/ja]\n   */\n\n  /**\n   * @attribute tappable\n   * @type {Boolean}\n   * @description\n   *   [en]Makes the element react to taps.[/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute tap-background-color\n   * @type {Color}\n   * @description\n   *   [en] Changes the background color when tapped. For this to work, the attribute \"tappable\" needs to be set. The default color is \"#d9d9d9\". It will display as a ripple effect on Android.[/en]\n   *   [ja][/ja]\n   */\n\n  function ListItemElement() {\n    classCallCheck(this, ListItemElement);\n\n    var _this = possibleConstructorReturn(this, (ListItemElement.__proto__ || Object.getPrototypeOf(ListItemElement)).call(this));\n\n    contentReady(_this, function () {\n      _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(ListItemElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.classList.add(defaultClassName$9);\n\n      var left = void 0,\n          center = void 0,\n          right = void 0;\n\n      for (var i = 0; i < this.children.length; i++) {\n        var el = this.children[i];\n\n        if (el.classList.contains('left')) {\n          el.classList.add('list-item__left');\n          left = el;\n        } else if (el.classList.contains('center')) {\n          center = el;\n        } else if (el.classList.contains('right')) {\n          el.classList.add('list-item__right');\n          right = el;\n        }\n      }\n\n      if (!center) {\n        center = document.createElement('div');\n\n        if (!left && !right) {\n          while (this.childNodes[0]) {\n            center.appendChild(this.childNodes[0]);\n          }\n        } else {\n          for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {\n            var _el = this.childNodes[_i];\n            if (_el !== left && _el !== right) {\n              center.insertBefore(_el, center.firstChild);\n            }\n          }\n        }\n\n        this.insertBefore(center, right || null);\n      }\n\n      center.classList.add('center');\n      center.classList.add('list-item__center');\n\n      util.updateRipple(this);\n\n      ModifierUtil.initModifier(this, scheme$13);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$9, scheme$13);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$13);\n          break;\n        case 'ripple':\n          util.updateRipple(this);\n          break;\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      this._setupListeners(true);\n      this._originalBackgroundColor = this.style.backgroundColor;\n      this.tapped = false;\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this._setupListeners(false);\n    }\n  }, {\n    key: '_setupListeners',\n    value: function _setupListeners(add) {\n      var action = (add ? 'add' : 'remove') + 'EventListener';\n      this[action]('drag', this._onDrag);\n      this[action]('touchstart', this._onTouch);\n      this[action]('mousedown', this._onTouch);\n      this[action]('touchend', this._onRelease);\n      this[action]('touchmove', this._onRelease);\n      this[action]('touchcancel', this._onRelease);\n      this[action]('mouseup', this._onRelease);\n      this[action]('mouseout', this._onRelease);\n      this[action]('touchleave', this._onRelease);\n    }\n  }, {\n    key: '_onDrag',\n    value: function _onDrag(event) {\n      var gesture = event.gesture;\n      // Prevent vertical scrolling if the users pans left or right.\n      if (this.hasAttribute('lock-on-drag') && ['left', 'right'].indexOf(gesture.direction) > -1) {\n        gesture.preventDefault();\n      }\n    }\n  }, {\n    key: '_onTouch',\n    value: function _onTouch() {\n      if (this.tapped) {\n        return;\n      }\n\n      this.tapped = true;\n      var touchStyle = { transition: 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s' };\n\n      if (this.hasAttribute('tappable')) {\n        if (this.style.backgroundColor) {\n          this._originalBackgroundColor = this.style.backgroundColor;\n        }\n\n        touchStyle.backgroundColor = this.getAttribute('tap-background-color') || '#d9d9d9';\n        touchStyle.boxShadow = '0px -1px 0px 0px ' + touchStyle.backgroundColor;\n      }\n\n      styler(this, touchStyle);\n    }\n  }, {\n    key: '_onRelease',\n    value: function _onRelease() {\n      this.tapped = false;\n      this.style.backgroundColor = this._originalBackgroundColor || '';\n      styler.clear(this, 'transition boxShadow');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class', 'ripple'];\n    }\n  }]);\n  return ListItemElement;\n}(BaseElement);\n\nons$1.elements.ListItem = ListItemElement;\ncustomElements.define('ons-list-item', ListItemElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$10 = 'list';\nvar scheme$14 = { '': 'list--*' };\n\n/**\n * @element ons-list\n * @category list\n * @modifier inset\n *   [en]Inset list that doesn't cover the whole width of the parent.[/en]\n *   [ja]親要素の画面いっぱいに広がらないリストを表示します。[/ja]\n * @modifier noborder\n *   [en]A list with no borders at the top and bottom.[/en]\n *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]\n * @description\n *   [en]Component to define a list, and the container for ons-list-item(s).[/en]\n *   [ja]リストを表現するためのコンポーネント。ons-list-itemのコンテナとして使用します。[/ja]\n * @seealso ons-list-item\n *   [en]ons-list-item component[/en]\n *   [ja]ons-list-itemコンポーネント[/ja]\n * @seealso ons-list-header\n *   [en]ons-list-header component[/en]\n *   [ja]ons-list-headerコンポーネント[/ja]\n * @seealso ons-lazy-repeat\n *   [en]ons-lazy-repeat component[/en]\n *   [ja]ons-lazy-repeatコンポーネント[/ja]\n * @codepen yxcCt\n * @tutorial vanilla/Reference/list\n * @example\n * <ons-list>\n *   <ons-list-header>Header Text</ons-list-header>\n *   <ons-list-item>Item</ons-list-item>\n *   <ons-list-item>Item</ons-list-item>\n * </ons-list>\n */\n\nvar ListElement = function (_BaseElement) {\n  inherits(ListElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the list.[/en]\n   *   [ja]リストの表現を指定します。[/ja]\n   */\n\n  function ListElement() {\n    classCallCheck(this, ListElement);\n\n    var _this = possibleConstructorReturn(this, (ListElement.__proto__ || Object.getPrototypeOf(ListElement)).call(this));\n\n    _this._compile();\n    return _this;\n  }\n\n  createClass(ListElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n      this.classList.add(defaultClassName$10);\n      ModifierUtil.initModifier(this, scheme$14);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$10, scheme$14);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$14);\n          break;\n      }\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'];\n    }\n  }]);\n  return ListElement;\n}(BaseElement);\n\nons$1.elements.List = ListElement;\ncustomElements.define('ons-list', ListElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'step', 'validator', 'value'];\n\nvar BaseInputElement = function (_BaseElement) {\n  inherits(BaseInputElement, _BaseElement);\n  createClass(BaseInputElement, [{\n    key: '_update',\n    value: function _update() {} // Optionally implemented\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      throw new Error('_scheme getter must be implemented.');\n    }\n  }, {\n    key: '_template',\n    get: function get$$1() {\n      throw new Error('_template getter must be implemented.');\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      throw new Error('type getter must be implemented.');\n    }\n  }]);\n\n  function BaseInputElement() {\n    classCallCheck(this, BaseInputElement);\n\n    var _this = possibleConstructorReturn(this, (BaseInputElement.__proto__ || Object.getPrototypeOf(BaseInputElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    _this._boundDelegateEvent = _this._delegateEvent.bind(_this);\n    return _this;\n  }\n\n  createClass(BaseInputElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n      this._defaultClassName && this.classList.add(this._defaultClassName);\n\n      if (this.children.length !== 0) {\n        return;\n      }\n\n      this.appendChild(util.createFragment(this._template));\n\n      this._setInputId();\n      this._updateBoundAttributes();\n\n      ModifierUtil.initModifier(this, this._scheme);\n    }\n  }, {\n    key: '_updateBoundAttributes',\n    value: function _updateBoundAttributes() {\n      var _this2 = this;\n\n      INPUT_ATTRIBUTES.forEach(function (attr) {\n        if (_this2.hasAttribute(attr)) {\n          _this2._input.setAttribute(attr, _this2.getAttribute(attr));\n        } else {\n          _this2._input.removeAttribute(attr);\n        }\n      });\n\n      this._update();\n    }\n  }, {\n    key: '_delegateEvent',\n    value: function _delegateEvent(event) {\n      var e = new CustomEvent(event.type, {\n        bubbles: false,\n        cancelable: true\n      });\n\n      return this.dispatchEvent(e);\n    }\n  }, {\n    key: '_setInputId',\n    value: function _setInputId() {\n      if (this.hasAttribute('input-id')) {\n        this._input.id = this.getAttribute('input-id');\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this3 = this;\n\n      contentReady(this, function () {\n        _this3._input.addEventListener('focus', _this3._boundDelegateEvent);\n        _this3._input.addEventListener('blur', _this3._boundDelegateEvent);\n      });\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      var _this4 = this;\n\n      contentReady(this, function () {\n        _this4._input.removeEventListener('focus', _this4._boundDelegateEvent);\n        _this4._input.removeEventListener('blur', _this4._boundDelegateEvent);\n      });\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      var _this5 = this;\n\n      switch (name) {\n        case 'modifier':\n          contentReady(this, function () {\n            return ModifierUtil.onModifierChanged(last, current, _this5, _this5._scheme);\n          });\n          break;\n        case 'input-id':\n          contentReady(this, function () {\n            return _this5._setInputId();\n          });\n          break;\n        case 'class':\n          util.restoreClass(this, this._defaultClassName, this._scheme);\n          break;\n      }\n\n      if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {\n        contentReady(this, function () {\n          return _this5._updateBoundAttributes();\n        });\n      }\n    }\n  }, {\n    key: '_defaultClassName',\n    get: function get$$1() {\n      return '';\n    }\n  }, {\n    key: '_input',\n    get: function get$$1() {\n      return this.querySelector('input');\n    }\n  }, {\n    key: 'value',\n    get: function get$$1() {\n      return this._input === null ? this.getAttribute('value') : this._input.value;\n    },\n    set: function set$$1(val) {\n      var _this6 = this;\n\n      contentReady(this, function () {\n        if (val instanceof Date) {\n          val = val.toISOString().substring(0, 10);\n        }\n        _this6._input.value = val;\n        _this6._update();\n      });\n    }\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'input-id', 'class'].concat(INPUT_ATTRIBUTES);\n    }\n  }]);\n  return BaseInputElement;\n}(BaseElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar scheme$15 = {\n  '.text-input': 'text-input--*',\n  '.text-input__label': 'text-input--*__label'\n};\n\n/**\n * @element ons-input\n * @category form\n * @modifier material\n *  [en]Displays a Material Design input.[/en]\n *  [ja][/ja]\n * @modifier underbar\n *  [en]Displays a horizontal line underneath a text input.[/en]\n *  [ja][/ja]\n * @modifier transparent\n *  [en]Displays a transparent input. Works for Material Design.[/en]\n *  [ja][/ja]\n * @description\n *  [en]\n *    An input element. The `type` attribute can be used to change the input type. All text input types are supported.\n *\n *    The component will automatically render as a Material Design input on Android devices.\n *\n *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.\n *  [/en]\n *  [ja][/ja]\n * @tutorial vanilla/Reference/input\n * @seealso ons-checkbox\n *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]\n *   [ja][/ja]\n * @seealso ons-radio\n *   [en]The `<ons-radio>` element is used to display a radio button.[/en]\n *   [ja][/ja]\n * @seealso ons-range\n *   [en]The `<ons-range>` element is used to display a range slider.[/en]\n *   [ja][/ja]\n * @seealso ons-switch\n *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]\n *   [ja][/ja]\n * @seealso ons-select\n *   [en]The `<ons-select>` element is used to display a select box.[/en]\n *   [ja][/ja]\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @example\n * <ons-input placeholder=\"Username\" float></ons-input>\n */\n\nvar InputElement = function (_BaseInputElement) {\n  inherits(InputElement, _BaseInputElement);\n\n  function InputElement() {\n    classCallCheck(this, InputElement);\n\n    var _this = possibleConstructorReturn(this, (InputElement.__proto__ || Object.getPrototypeOf(InputElement)).call(this));\n\n    _this._boundOnInput = _this._update.bind(_this);\n    _this._boundOnFocusin = _this._update.bind(_this);\n    return _this;\n  }\n\n  /* Inherited props */\n\n  createClass(InputElement, [{\n    key: '_update',\n    value: function _update() {\n      this._updateLabel();\n      this._updateLabelClass();\n    }\n  }, {\n    key: '_updateLabel',\n\n\n    /* Own props */\n\n    value: function _updateLabel() {\n      var label = this.getAttribute('placeholder') || '';\n\n      if (typeof this._helper.textContent !== 'undefined') {\n        this._helper.textContent = label;\n      } else {\n        this._helper.innerText = label;\n      }\n    }\n  }, {\n    key: '_updateLabelClass',\n    value: function _updateLabelClass() {\n      if (this.value === '') {\n        this._helper.classList.remove('text-input--material__label--active');\n      } else {\n        this._helper.classList.add('text-input--material__label--active');\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'connectedCallback', this).call(this);\n\n      contentReady(this, function () {\n        _this2._input.addEventListener('input', _this2._boundOnInput);\n        _this2._input.addEventListener('focusin', _this2._boundOnFocusin);\n      });\n\n      var type = this.getAttribute('type');\n      if (['checkbox', 'radio'].indexOf(type) >= 0) {\n        util.warn('Warn: <ons-input type=\"' + type + '\"> is deprecated since v2.4.0. Use <ons-' + type + '> instead.');\n      }\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      var _this3 = this;\n\n      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'disconnectedCallback', this).call(this);\n\n      contentReady(this, function () {\n        _this3._input.removeEventListener('input', _this3._boundOnInput);\n        _this3._input.removeEventListener('focusin', _this3._boundOnFocusin);\n      });\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      var _this4 = this;\n\n      switch (name) {\n        case 'type':\n          contentReady(this, function () {\n            return _this4._input.setAttribute('type', _this4.type);\n          });\n          break;\n        default:\n          get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);\n      }\n    }\n\n    /**\n     * @attribute placeholder\n     * @type {String}\n     * @description\n     *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @attribute float\n     * @description\n     *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]\n     *  [ja]この属性が設定された時、ラベルはアニメーションするようになります。[/ja]\n     */\n\n    /**\n     * @attribute type\n     * @type {String}\n     * @description\n     *  [en]\n     *    Specify the input type. This is the same as the \"type\" attribute for normal inputs. It expects strict text types such as `text`, `password`, etc. For checkbox, radio button, select or range, please have a look at the corresponding elements.\n     *\n     *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.\n     *  [/en]\n     *  [ja][/ja]\n     */\n\n    /**\n     * @attribute input-id\n     * @type {String}\n     * @description\n     *  [en]Specify the \"id\" attribute of the inner `<input>` element. This is useful when using `<label for=\"...\">` elements.[/en]\n     *  [ja][/ja]\n     */\n\n    /**\n     * @property value\n     * @type {String}\n     * @description\n     *   [en]The current value of the input.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the input is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$15;\n    }\n  }, {\n    key: '_template',\n    get: function get$$1() {\n      return '\\n      <input type=\"' + this.type + '\" class=\"text-input\">\\n      <span class=\"text-input__label\"></span>\\n    ';\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      var type = this.getAttribute('type');\n      return ['checkbox', 'radio'].indexOf(type) < 0 && type || 'text';\n    }\n  }, {\n    key: '_helper',\n    get: function get$$1() {\n      return this.querySelector('span');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return [].concat(toConsumableArray(get(InputElement.__proto__ || Object.getPrototypeOf(InputElement), 'observedAttributes', this)), ['type']);\n    }\n  }]);\n  return InputElement;\n}(BaseInputElement);\n\nons$1.elements.Input = InputElement;\ncustomElements.define('ons-input', InputElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar BaseCheckboxElement = function (_BaseInputElement) {\n  inherits(BaseCheckboxElement, _BaseInputElement);\n\n  function BaseCheckboxElement() {\n    classCallCheck(this, BaseCheckboxElement);\n\n    var _this = possibleConstructorReturn(this, (BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement)).call(this));\n\n    contentReady(_this, function () {\n      _this.attributeChangedCallback('checked', null, _this.getAttribute('checked'));\n    });\n    return _this;\n  }\n\n  /* Inherited props */\n\n  createClass(BaseCheckboxElement, [{\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'checked':\n          this.checked = current !== null;\n          break;\n        default:\n          get(BaseCheckboxElement.prototype.__proto__ || Object.getPrototypeOf(BaseCheckboxElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);\n      }\n    }\n  }, {\n    key: '_template',\n    get: function get$$1() {\n      return '\\n      <input type=\"' + this.type + '\" class=\"' + this._defaultClassName + '__input\">\\n      <span class=\"' + this._defaultClassName + '__checkmark\"></span>\\n    ';\n    }\n\n    /* Own props */\n\n  }, {\n    key: '_helper',\n    get: function get$$1() {\n      return this.querySelector('span');\n    }\n  }, {\n    key: 'checked',\n    get: function get$$1() {\n      return this._input.checked;\n    },\n    set: function set$$1(val) {\n      var _this2 = this;\n\n      contentReady(this, function () {\n        _this2._input.checked = val;\n      });\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return [].concat(toConsumableArray(get(BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement), 'observedAttributes', this)), ['checked']);\n    }\n  }]);\n  return BaseCheckboxElement;\n}(BaseInputElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar scheme$16 = {\n  '.checkbox': 'checkbox--*',\n  '.checkbox__input': 'checkbox--*__input',\n  '.checkbox__checkmark': 'checkbox--*__checkmark'\n};\n\n/**\n * @element ons-checkbox\n * @category form\n * @modifier material\n *  [en]Displays a Material Design checkbox.[/en]\n *  [ja][/ja]\n * @modifier noborder\n *  [en]iOS borderless checkbox.[/en]\n *  [ja][/ja]\n * @description\n *  [en]\n *    A checkbox element. The component will automatically render as a Material Design checkbox on Android devices.\n *\n *    Most attributes that can be used for a normal `<input type=\"checkbox\">` element can also be used on the `<ons-checkbox>` element.\n *  [/en]\n *  [ja][/ja]\n * @tutorial vanilla/Reference/input\n * @seealso ons-switch\n *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]\n *   [ja][/ja]\n * @seealso ons-radio\n *   [en]The `<ons-radio>` element is used to display a radio button.[/en]\n *   [ja][/ja]\n * @seealso ons-input\n *   [en]The `<ons-input>` element is used to display a text input.[/en]\n *   [ja][/ja]\n * @seealso ons-search-input\n *   [en]The `<ons-search-input>` element is used to display a search input.[/en]\n *   [ja][/ja]\n * @seealso ons-range\n *   [en]The `<ons-range>` element is used to display a range slider.[/en]\n *   [ja][/ja]\n * @seealso ons-select\n *   [en]The `<ons-select>` element is used to display a select box.[/en]\n *   [ja][/ja]\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @example\n * <ons-checkbox checked></ons-checkbox>\n */\n\nvar CheckboxElement = function (_BaseCheckboxElement) {\n  inherits(CheckboxElement, _BaseCheckboxElement);\n\n  function CheckboxElement() {\n    classCallCheck(this, CheckboxElement);\n    return possibleConstructorReturn(this, (CheckboxElement.__proto__ || Object.getPrototypeOf(CheckboxElement)).apply(this, arguments));\n  }\n\n  createClass(CheckboxElement, [{\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$16;\n    }\n  }, {\n    key: '_defaultClassName',\n    get: function get$$1() {\n      return 'checkbox';\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return 'checkbox';\n    }\n\n    /**\n     * @attribute input-id\n     * @type {String}\n     * @description\n     *  [en]Specify the \"id\" attribute of the inner `<input>` element. This is useful when using `<label for=\"...\">` elements.[/en]\n     *  [ja][/ja]\n     */\n\n    /**\n     * @property value\n     * @type {String}\n     * @description\n     *   [en]The current value of the checkbox.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property checked\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the checkbox is checked or not.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the checkbox is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }]);\n  return CheckboxElement;\n}(BaseCheckboxElement);\n\nons$1.elements.Checkbox = CheckboxElement;\ncustomElements.define('ons-checkbox', CheckboxElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar scheme$17 = {\n  '.radio-button': 'radio-button--*',\n  '.radio-button__input': 'radio-button--*__input',\n  '.radio-button__checkmark': 'radio-button--*__checkmark'\n};\n\n/**\n * @element ons-radio\n * @category form\n * @modifier material\n *  [en]Displays a Material Design radio button.[/en]\n *  [ja][/ja]\n * @description\n *  [en]\n *    A radio button element. The component will automatically render as a Material Design radio button on Android devices.\n *\n *    Most attributes that can be used for a normal `<input type=\"radio\">` element can also be used on the `<ons-radio>` element.\n *  [/en]\n *  [ja][/ja]\n * @tutorial vanilla/Reference/input\n * @seealso ons-select\n *   [en]The `<ons-select>` element is used to display a select box.[/en]\n *   [ja][/ja]\n * @seealso ons-checkbox\n *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]\n *   [ja][/ja]\n * @seealso ons-switch\n *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]\n *   [ja][/ja]\n * @seealso ons-input\n *   [en]The `<ons-input>` element is used to display a text input.[/en]\n *   [ja][/ja]\n * @seealso ons-search-input\n *   [en]The `<ons-search-input>` element is used to display a search input.[/en]\n *   [ja][/ja]\n * @seealso ons-range\n *   [en]The `<ons-range>` element is used to display a range slider.[/en]\n *   [ja][/ja]\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @example\n * <ons-radio checked></ons-radio>\n */\n\nvar RadioElement = function (_BaseCheckboxElement) {\n  inherits(RadioElement, _BaseCheckboxElement);\n\n  function RadioElement() {\n    classCallCheck(this, RadioElement);\n    return possibleConstructorReturn(this, (RadioElement.__proto__ || Object.getPrototypeOf(RadioElement)).apply(this, arguments));\n  }\n\n  createClass(RadioElement, [{\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$17;\n    }\n  }, {\n    key: '_defaultClassName',\n    get: function get$$1() {\n      return 'radio-button';\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return 'radio';\n    }\n\n    /**\n     * @attribute input-id\n     * @type {String}\n     * @description\n     *  [en]Specify the \"id\" attribute of the inner `<input>` element. This is useful when using `<label for=\"...\">` elements.[/en]\n     *  [ja][/ja]\n     */\n\n    /**\n     * @property value\n     * @type {String}\n     * @description\n     *   [en]The current value of the radio button.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property checked\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the radio button is checked or not.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the radio button is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }]);\n  return RadioElement;\n}(BaseCheckboxElement);\n\nons$1.elements.Radio = RadioElement;\ncustomElements.define('ons-radio', RadioElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar scheme$18 = {\n  '.search-input': 'search-input--*'\n};\n\n/**\n * @element ons-search-input\n * @category form\n * @modifier material\n *  [en]Displays a Material Design search input.[/en]\n *  [ja][/ja]\n * @description\n *  [en]\n *    A search input element. The component will automatically render as a Material Design search input on Android devices.\n *\n *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-search-input>` element.\n *  [/en]\n *  [ja][/ja]\n * @tutorial vanilla/Reference/input\n * @seealso ons-input\n *   [en]The `<ons-input>` element is used to display a text input.[/en]\n *   [ja][/ja]\n * @seealso ons-range\n *   [en]The `<ons-range>` element is used to display a range slider.[/en]\n *   [ja][/ja]\n * @seealso ons-switch\n *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]\n *   [ja][/ja]\n * @seealso ons-select\n *   [en]The `<ons-select>` element is used to display a select box.[/en]\n *   [ja][/ja]\n * @seealso ons-checkbox\n *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]\n *   [ja][/ja]\n * @seealso ons-radio\n *   [en]The `<ons-radio>` element is used to display a radio button.[/en]\n *   [ja][/ja]\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @example\n * <ons-search-input placeholder=\"Search\"></ons-search-input>\n */\n\nvar SearchInputElement = function (_BaseInputElement) {\n  inherits(SearchInputElement, _BaseInputElement);\n\n  function SearchInputElement() {\n    classCallCheck(this, SearchInputElement);\n    return possibleConstructorReturn(this, (SearchInputElement.__proto__ || Object.getPrototypeOf(SearchInputElement)).apply(this, arguments));\n  }\n\n  createClass(SearchInputElement, [{\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$18;\n    }\n  }, {\n    key: '_template',\n    get: function get$$1() {\n      return '\\n      <input type=\"' + this.type + '\" class=\"search-input\">\\n    ';\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return 'search';\n    }\n\n    /**\n     * @attribute input-id\n     * @type {String}\n     * @description\n     *  [en]Specify the \"id\" attribute of the inner `<input>` element. This is useful when using `<label for=\"...\">` elements.[/en]\n     *  [ja][/ja]\n     */\n\n    /**\n     * @property value\n     * @type {String}\n     * @description\n     *   [en]The current value of the input.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the input is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }]);\n  return SearchInputElement;\n}(BaseInputElement);\n\nons$1.elements.SearchInput = SearchInputElement;\ncustomElements.define('ons-search-input', SearchInputElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar ModalAnimator = function (_BaseAnimator) {\n  inherits(ModalAnimator, _BaseAnimator);\n\n  /**\n   * @param {Object} options\n   * @param {String} options.timing\n   * @param {Number} options.duration\n   * @param {Number} options.delay\n   */\n  function ModalAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'linear' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.2 : _ref$duration;\n\n    classCallCheck(this, ModalAnimator);\n    return possibleConstructorReturn(this, (ModalAnimator.__proto__ || Object.getPrototypeOf(ModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {HTMLElement} modal\n   * @param {Function} callback\n   */\n\n\n  createClass(ModalAnimator, [{\n    key: 'show',\n    value: function show(modal, callback) {\n      callback();\n    }\n\n    /**\n     * @param {HTMLElement} modal\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(modal, callback) {\n      callback();\n    }\n  }]);\n  return ModalAnimator;\n}(BaseAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * iOS style animator for dialog.\n */\n\nvar FadeModalAnimator = function (_ModalAnimator) {\n  inherits(FadeModalAnimator, _ModalAnimator);\n\n  function FadeModalAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'linear' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.3 : _ref$duration;\n\n    classCallCheck(this, FadeModalAnimator);\n    return possibleConstructorReturn(this, (FadeModalAnimator.__proto__ || Object.getPrototypeOf(FadeModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {HTMLElement} modal\n   * @param {Function} callback\n   */\n\n\n  createClass(FadeModalAnimator, [{\n    key: 'show',\n    value: function show(modal, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit(modal).queue({\n        opacity: 0\n      }).wait(this.delay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).queue(function (done) {\n        callback();\n        done();\n      }).play();\n    }\n\n    /**\n     * @param {HTMLElement} modal\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(modal, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit(modal).queue({\n        opacity: 1\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).queue(function (done) {\n        callback();\n        done();\n      }).play();\n    }\n  }]);\n  return FadeModalAnimator;\n}(ModalAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * iOS style animator for modal.\n */\n\nvar LiftModalAnimator = function (_ModalAnimator) {\n  inherits(LiftModalAnimator, _ModalAnimator);\n\n  function LiftModalAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'cubic-bezier( .1, .7, .1, 1)' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.4 : _ref$duration;\n\n    classCallCheck(this, LiftModalAnimator);\n    return possibleConstructorReturn(this, (LiftModalAnimator.__proto__ || Object.getPrototypeOf(LiftModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {HTMLElement} modal\n   * @param {Function} callback\n   */\n\n\n  createClass(LiftModalAnimator, [{\n    key: 'show',\n    value: function show(modal, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit(modal).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 100%, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }).play();\n    }\n\n    /**\n     * @param {HTMLElement} modal\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(modal, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit(modal).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 100%, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }).play();\n    }\n  }]);\n  return LiftModalAnimator;\n}(ModalAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$19 = {\n  '': 'modal--*',\n  'modal__content': 'modal--*__content'\n};\n\nvar defaultClassName$11 = 'modal';\n\nvar _animatorDict$3 = {\n  'default': ModalAnimator,\n  'fade': FadeModalAnimator,\n  'lift': LiftModalAnimator,\n  'none': ModalAnimator\n};\n\n/**\n * @element ons-modal\n * @category dialog\n * @description\n *   [en]\n *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.\n *\n *     This component can be used to block user input while some operation is running or to show some information to the user.\n *   [/en]\n *   [ja]\n *     画面全体をマスクするモーダル用コンポーネントです。下側にあるコンポーネントは、\n *     モーダルが表示されている間はイベント通知が行われません。\n *   [/ja]\n * @seealso ons-dialog\n *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]\n *   [ja][/ja]\n * @codepen devIg\n * @tutorial vanilla/reference/modal\n * @example\n * <ons-modal id=\"modal\">\n *   Modal content\n * </ons-modal>\n * <script>\n *   var modal = document.getElementById('modal');\n *   modal.show();\n * </script>\n */\n\nvar ModalElement = function (_BaseDialogElement) {\n  inherits(ModalElement, _BaseDialogElement);\n\n  /**\n   * @event preshow\n   * @description\n   * [en]Fired just before the modal is displayed.[/en]\n   * [ja]モーダルが表示される直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.modal\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Execute this function to stop the modal from being shown.[/en]\n   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]\n   */\n\n  /**\n   * @event postshow\n   * @description\n   * [en]Fired just after the modal is displayed.[/en]\n   * [ja]モーダルが表示された直後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.modal\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @event prehide\n   * @description\n   * [en]Fired just before the modal is hidden.[/en]\n   * [ja]モーダルが隠れる直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.modal\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Execute this function to stop the modal from being hidden.[/en]\n   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]\n   */\n\n  /**\n   * @event posthide\n   * @description\n   * [en]Fired just after the modal is hidden.[/en]\n   * [ja]モーダルが隠れた後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.modal\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @attribute animation\n   * @type {String}\n   * @default default\n   * @description\n   *  [en]The animation used when showing and hiding the modal. Can be either `\"none\"`, `\"fade\"` or `\"lift\"`.[/en]\n   *  [ja]モーダルを表示する際のアニメーション名を指定します。\"none\"もしくは\"fade\",\"lift\"を指定できます。[/ja]\n   */\n\n  /**\n   * @attribute animation-options\n   * @type {Expression}\n   * @description\n   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]\n   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]\n   */\n\n  function ModalElement() {\n    classCallCheck(this, ModalElement);\n\n    var _this = possibleConstructorReturn(this, (ModalElement.__proto__ || Object.getPrototypeOf(ModalElement)).call(this));\n\n    _this._defaultDBB = function () {\n      return undefined;\n    };\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(ModalElement, [{\n    key: '_updateAnimatorFactory',\n    value: function _updateAnimatorFactory() {\n      return new AnimatorFactory({\n        animators: _animatorDict$3,\n        baseClass: ModalAnimator,\n        baseClassName: 'ModalAnimator',\n        defaultAnimation: this.getAttribute('animation')\n      });\n    }\n\n    /**\n     * @property onDeviceBackButton\n     * @type {Object}\n     * @description\n     *   [en]Back-button handler.[/en]\n     *   [ja]バックボタンハンドラ。[/ja]\n     */\n\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      this.style.display = 'none';\n      this.style.zIndex = 10001;\n      this.classList.add(defaultClassName$11);\n\n      if (!util.findChild(this, '.modal__content')) {\n        var content = document.createElement('div');\n        content.classList.add('modal__content');\n\n        while (this.childNodes[0]) {\n          var node = this.childNodes[0];\n          this.removeChild(node);\n          content.insertBefore(node, null);\n        }\n\n        this.appendChild(content);\n      }\n\n      ModifierUtil.initModifier(this, this._scheme);\n    }\n  }, {\n    key: '_toggleStyle',\n    value: function _toggleStyle(shouldShow) {\n      this.style.display = shouldShow ? 'table' : 'none';\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'connectedCallback', this).call(this);\n      this.addEventListener('touchmove', get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), '_preventScroll', this), false); // iOS fix\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'disconnectedCallback', this).call(this);\n      this.removeEventListener('touchmove', get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), '_preventScroll', this), false);\n    }\n\n    /**\n     * @property visible\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is visible or not.[/en]\n     *   [ja]要素が見える場合に`true`。[/ja]\n     */\n\n    /**\n     * @method show\n     * @signature show([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"none\"` and `\"fade\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"none\", \"fade\"のいずれかを指定します。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @param {Function} [options.callback]\n     *   [en]This function is called after the modal has been revealed.[/en]\n     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *   [en]Show modal.[/en]\n     *   [ja]モーダルを表示します。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the displayed element[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @method toggle\n     * @signature toggle([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"none\"` and `\"fade\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"none\", \"fade\"のいずれかを指定します。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @param {Function} [options.callback]\n     *   [en]This function is called after the modal has been revealed.[/en]\n     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *   [en]Toggle modal visibility.[/en]\n     *   [ja]モーダルの表示を切り替えます。[/ja]\n     */\n\n    /**\n     * @method hide\n     * @signature hide([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"none\"` and `\"fade\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"none\", \"fade\"のいずれかを指定します。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @param {Function} [options.callback]\n     *   [en]This function is called after the modal has been revealed.[/en]\n     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *   [en]Hide modal.[/en]\n     *   [ja]モーダルを非表示にします。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the hidden element[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'class') {\n        util.restoreClass(this, defaultClassName$11, scheme$19);\n      } else {\n        get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);\n      }\n    }\n\n    /**\n     * @param {String} name\n     * @param {Function} Animator\n     */\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$19;\n    }\n  }], [{\n    key: 'registerAnimator',\n    value: function registerAnimator(name, Animator) {\n      if (!(Animator.prototype instanceof ModalAnimator)) {\n        throw new Error('\"Animator\" param must inherit OnsModalElement.ModalAnimator');\n      }\n      _animatorDict$3[name] = Animator;\n    }\n  }, {\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return [].concat(toConsumableArray(get(ModalElement.__proto__ || Object.getPrototypeOf(ModalElement), 'observedAttributes', this)), ['class']);\n    }\n  }, {\n    key: 'animators',\n    get: function get$$1() {\n      return _animatorDict$3;\n    }\n  }, {\n    key: 'ModalAnimator',\n    get: function get$$1() {\n      return ModalAnimator;\n    }\n  }]);\n  return ModalElement;\n}(BaseDialogElement);\n\nons$1.elements.Modal = ModalElement;\ncustomElements.define('ons-modal', ModalElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar widthToPx = function widthToPx(width) {\n  var _ref = [parseInt(width, 10), /px/.test(width)],\n      value = _ref[0],\n      px = _ref[1];\n\n  return px ? value : Math.round(document.body.offsetWidth * value / 100);\n};\n\nvar SwipeReveal = function () {\n  function SwipeReveal(params) {\n    var _this = this;\n\n    classCallCheck(this, SwipeReveal);\n\n    'element ignoreSwipe isInitialState onDragCallback swipeMax swipeMin swipeMid'.split(/\\s+/).forEach(function (key) {\n      return _this[key] = params[key];\n    });\n\n    this.elementHandler = params.elementHandler || params.element;\n    this.getThreshold = params.getThreshold || function () {\n      return .5;\n    };\n    this.getSide = params.getSide || function () {\n      return 'left';\n    };\n\n    this.handleGesture = this.handleGesture.bind(this);\n  }\n\n  createClass(SwipeReveal, [{\n    key: 'update',\n    value: function update() {\n      var swipeable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element.hasAttribute('swipeable');\n\n      if (!this.gestureDetector) {\n        this.gestureDetector = new GestureDetector(this.elementHandler, { dragMinDistance: 1 });\n      }\n\n      var action = swipeable ? 'on' : 'off';\n      this.gestureDetector[action]('drag dragstart dragend', this.handleGesture);\n    }\n  }, {\n    key: 'handleGesture',\n    value: function handleGesture(e) {\n      if (e.gesture) {\n        if (e.type === 'dragstart') {\n          this.onDragStart(e);\n        } else if (!this._ignoreDrag) {\n          e.type === 'dragend' ? this.onDragEnd(e) : this.onDrag(e);\n        }\n      }\n    }\n  }, {\n    key: 'onDragStart',\n    value: function onDragStart(event) {\n      var _this2 = this;\n\n      var getDistance = function getDistance() {\n        return _this2.getSide() === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;\n      };\n      this._ignoreDrag = event.consumed || !util.isValidGesture(event) || this.ignoreSwipe(event, getDistance());\n\n      if (!this._ignoreDrag) {\n        event.consume && event.consume();\n        event.consumed = true;\n\n        this._width = widthToPx(this.element.style.width || '100%');\n        this._startDistance = this._distance = !(this.isInitialState instanceof Function) || this.isInitialState() ? 0 : this._width;\n\n        util.preventScroll(this.gestureDetector);\n      }\n    }\n  }, {\n    key: 'onDrag',\n    value: function onDrag(event) {\n      event.stopPropagation();\n      event.gesture.preventDefault();\n\n      var delta = this.getSide() === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;\n      var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));\n      if (distance !== this._distance) {\n        this._distance = distance;\n        this.swipeMid(this._distance, this._width);\n      }\n    }\n  }, {\n    key: 'onDragEnd',\n    value: function onDragEnd(event) {\n      event.stopPropagation();\n\n      var direction = event.gesture.interimDirection;\n      var isSwipeMax = this.getSide() !== direction && this._distance > this._width * this.getThreshold();\n      isSwipeMax ? this.swipeMax() : this.swipeMin();\n    }\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      this.gestureDetector && this.gestureDetector.dispose();\n      this.gestureDetector = this.element = this.elementHandler = null;\n    }\n  }]);\n  return SwipeReveal;\n}();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar NavigatorAnimator = function (_BaseAnimator) {\n  inherits(NavigatorAnimator, _BaseAnimator);\n\n  /**\n   * @param {Object} options\n   * @param {String} options.timing\n   * @param {Number} options.duration\n   * @param {Number} options.delay\n   */\n  function NavigatorAnimator(options) {\n    classCallCheck(this, NavigatorAnimator);\n\n    options = util.extend({\n      timing: 'linear',\n      duration: '0.4',\n      delay: '0'\n    }, options || {});\n\n    return possibleConstructorReturn(this, (NavigatorAnimator.__proto__ || Object.getPrototypeOf(NavigatorAnimator)).call(this, options));\n  }\n\n  createClass(NavigatorAnimator, [{\n    key: 'push',\n    value: function push(enterPage, leavePage, callback) {\n      callback();\n    }\n  }, {\n    key: 'pop',\n    value: function pop(enterPage, leavePage, callback) {\n      callback();\n    }\n  }, {\n    key: 'block',\n    value: function block(page) {\n      var blocker = util.createElement('\\n      <div style=\"position: absolute; background-color: transparent; width: 100%; height: 100%; z-index: 100000\"></div>\\n    ');\n      page.parentNode.appendChild(blocker);\n      return function () {\n        return blocker.remove();\n      };\n    }\n  }]);\n  return NavigatorAnimator;\n}(BaseAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Slide animator for navigator transition like iOS's screen slide transition.\n */\n\nvar IOSSlideNavigatorAnimator = function (_NavigatorAnimator) {\n  inherits(IOSSlideNavigatorAnimator, _NavigatorAnimator);\n\n  function IOSSlideNavigatorAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'cubic-bezier(0.3, .4, 0, .9)' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.4 : _ref$duration;\n\n    classCallCheck(this, IOSSlideNavigatorAnimator);\n\n    var _this = possibleConstructorReturn(this, (IOSSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this.backgroundMask = util.createElement('\\n      <div style=\"position: absolute; width: 100%; height: 100%;\\n        background-color: black; z-index: 2\"></div>\\n    ');\n\n    return _this;\n  }\n\n  createClass(IOSSlideNavigatorAnimator, [{\n    key: '_decompose',\n    value: function _decompose(page) {\n      var toolbar = page._getToolbarElement();\n      var left = toolbar._getToolbarLeftItemsElement();\n      var right = toolbar._getToolbarRightItemsElement();\n\n      var excludeBackButton = function excludeBackButton(elements) {\n        var result = [];\n\n        for (var i = 0; i < elements.length; i++) {\n          if (elements[i].nodeName.toLowerCase() !== 'ons-back-button') {\n            result.push(elements[i]);\n          }\n        }\n\n        return result;\n      };\n\n      var other = [].concat(left.children.length === 0 ? left : excludeBackButton(left.children)).concat(right.children.length === 0 ? right : excludeBackButton(right.children));\n\n      return {\n        toolbarCenter: toolbar._getToolbarCenterItemsElement(),\n        backButtonIcon: toolbar._getToolbarBackButtonIconElement(),\n        backButtonLabel: toolbar._getToolbarBackButtonLabelElement(),\n        other: other,\n        content: page._getContentElement(),\n        background: page._getBackgroundElement(),\n        toolbar: toolbar,\n        bottomToolbar: page._getBottomToolbarElement()\n      };\n    }\n  }, {\n    key: '_shouldAnimateToolbar',\n    value: function _shouldAnimateToolbar(enterPage, leavePage) {\n      var enterToolbar = enterPage._getToolbarElement();\n      var leaveToolbar = leavePage._getToolbarElement();\n\n      var toolbars = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();\n      var material = util.hasModifier(enterToolbar, 'material') || util.hasModifier(leaveToolbar, 'material');\n      var transparent = util.hasModifier(enterToolbar, 'transparent') || util.hasModifier(leaveToolbar, 'transparent');\n\n      return toolbars && !material && !transparent;\n    }\n  }, {\n    key: '_calculateDelta',\n    value: function _calculateDelta(element, decomposition) {\n      var title = void 0,\n          label = void 0;\n\n      var pageRect = element.getBoundingClientRect();\n      if (decomposition.backButtonLabel.classList.contains('back-button__label')) {\n        var labelRect = decomposition.backButtonLabel.getBoundingClientRect();\n        title = Math.round(pageRect.width / 2 - labelRect.width / 2 - labelRect.left);\n      } else {\n        title = Math.round(pageRect.width / 2 * 0.6);\n      }\n\n      if (decomposition.backButtonIcon.classList.contains('back-button__icon')) {\n        label = decomposition.backButtonIcon.getBoundingClientRect().right - 2;\n      }\n\n      return { title: title, label: label };\n    }\n\n    /**\n     * @param {Object} enterPage\n     * @param {Object} leavePage\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'push',\n    value: function push(enterPage, leavePage, callback) {\n      var _this2 = this;\n\n      this.backgroundMask.remove();\n      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);\n\n      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      contentReady(enterPage, function () {\n        var enterPageTarget = util.findToolbarPage(enterPage) || enterPage;\n        var leavePageTarget = util.findToolbarPage(leavePage) || leavePage;\n        var enterPageDecomposition = _this2._decompose(enterPageTarget);\n        var leavePageDecomposition = _this2._decompose(leavePageTarget);\n\n        var delta = _this2._calculateDelta(leavePage, enterPageDecomposition);\n\n        var shouldAnimateToolbar = _this2._shouldAnimateToolbar(enterPageTarget, leavePageTarget);\n\n        if (shouldAnimateToolbar) {\n\n          Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({\n            css: {\n              transform: 'translate3D(100%, 0px, 0px)'\n            },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: {\n              transform: 'translate3D(0px, 0px, 0px)'\n            },\n            duration: _this2.duration,\n            timing: _this2.timing\n          }).restoreStyle(), Animit(enterPageDecomposition.toolbar).saveStyle().queue({\n            css: {\n              opacity: 0\n            },\n            duration: 0\n          }).queue({\n            css: {\n              opacity: 1\n            },\n            duration: _this2.duration,\n            timing: _this2.timing\n          }).restoreStyle(), Animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({\n            css: {\n              transform: 'translate3d(125%, 0, 0)',\n              opacity: 1\n            },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: {\n              transform: 'translate3d(0, 0, 0)',\n              opacity: 1\n            },\n            duration: _this2.duration,\n            timing: _this2.timing\n          }).restoreStyle(), Animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({\n            css: {\n              transform: 'translate3d(' + delta.title + 'px, 0, 0)',\n              opacity: 0\n            },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: {\n              transform: 'translate3d(0, 0, 0)',\n              opacity: 1.0,\n              transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing\n            },\n            duration: _this2.duration\n          }).restoreStyle(), Animit(enterPageDecomposition.other).saveStyle().queue({\n            css: { opacity: 0 },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: { opacity: 1 },\n            duration: _this2.duration,\n            timing: 'linear'\n          }).restoreStyle(), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).saveStyle().queue({\n            css: {\n              transform: 'translate3D(0, 0, 0)',\n              opacity: 1\n            },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: {\n              transform: 'translate3D(-25%, 0px, 0px)',\n              opacity: 0.9\n            },\n            duration: _this2.duration,\n            timing: _this2.timing\n          }).restoreStyle().queue(function (done) {\n            _this2.backgroundMask.remove();\n            unblock();\n            callback();\n            done();\n          }), Animit(leavePageDecomposition.toolbarCenter).saveStyle().queue({\n            css: {\n              transform: 'translate3d(0, 0, 0)',\n              opacity: 1.0\n            },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: {\n              transform: 'translate3d(-' + delta.title + 'px, 0, 0)',\n              opacity: 0,\n              transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing\n            },\n            duration: _this2.duration\n          }).restoreStyle(), Animit(leavePageDecomposition.backButtonLabel).saveStyle().queue({\n            css: {\n              transform: 'translate3d(0, 0, 0)',\n              opacity: 1.0\n            },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: {\n              transform: 'translate3d(-' + delta.label + 'px, 0, 0)',\n              opacity: 0\n            },\n            duration: _this2.duration,\n            timing: _this2.timing\n          }).restoreStyle(), Animit(leavePageDecomposition.other).saveStyle().queue({\n            css: { opacity: 1 },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: { opacity: 0 },\n            duration: _this2.duration,\n            timing: 'linear'\n          }).restoreStyle());\n        } else {\n\n          Animit.runAll(Animit(enterPage).saveStyle().queue({\n            css: {\n              transform: 'translate3D(100%, 0px, 0px)'\n            },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: {\n              transform: 'translate3D(0px, 0px, 0px)'\n            },\n            duration: _this2.duration,\n            timing: _this2.timing\n          }).restoreStyle(), Animit(leavePage).saveStyle().queue({\n            css: {\n              transform: 'translate3D(0, 0, 0)',\n              opacity: 1\n            },\n            duration: 0\n          }).wait(_this2.delay).queue({\n            css: {\n              transform: 'translate3D(-25%, 0px, 0px)',\n              opacity: 0.9\n            },\n            duration: _this2.duration,\n            timing: _this2.timing\n          }).restoreStyle().queue(function (done) {\n            _this2.backgroundMask.remove();\n            unblock();\n            callback();\n            done();\n          }));\n        }\n      });\n    }\n\n    /**\n     * @param {Object} enterPage\n     * @param {Object} leavePage\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop(enterPage, leavePage, callback) {\n      var _this3 = this;\n\n      this.backgroundMask.remove();\n      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);\n\n      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      var enterPageTarget = util.findToolbarPage(enterPage) || enterPage;\n      var leavePageTarget = util.findToolbarPage(leavePage) || leavePage;\n      var enterPageDecomposition = this._decompose(enterPageTarget);\n      var leavePageDecomposition = this._decompose(leavePageTarget);\n\n      var delta = this._calculateDelta(leavePage, leavePageDecomposition);\n\n      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPageTarget, leavePageTarget);\n\n      if (shouldAnimateToolbar) {\n        Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background]).saveStyle().queue({\n          css: {\n            transform: 'translate3D(-25%, 0px, 0px)',\n            opacity: 0.9\n          },\n          duration: 0\n        }).wait(this.delay).queue({\n          css: {\n            transform: 'translate3D(0px, 0px, 0px)',\n            opacity: 1\n          },\n          duration: this.duration,\n          timing: this.timing\n        }).restoreStyle(), Animit(enterPageDecomposition.toolbarCenter).saveStyle().queue({\n          css: {\n            transform: 'translate3d(-' + delta.title + 'px, 0, 0)',\n            opacity: 0\n          },\n          duration: 0\n        }).wait(this.delay).queue({\n          css: {\n            transform: 'translate3d(0, 0, 0)',\n            opacity: 1.0,\n            transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing\n          },\n          duration: this.duration\n        }).restoreStyle(), Animit(enterPageDecomposition.backButtonLabel).saveStyle().queue({\n          css: {\n            transform: 'translate3d(-' + delta.label + 'px, 0, 0)'\n          },\n          duration: 0\n        }).wait(this.delay).queue({\n          css: {\n            transform: 'translate3d(0, 0, 0)'\n          },\n          duration: this.duration,\n          timing: this.timing\n        }).restoreStyle(), Animit(enterPageDecomposition.other).saveStyle().queue({\n          css: { opacity: 0 },\n          duration: 0\n        }).wait(this.delay).queue({\n          css: { opacity: 1 },\n          duration: this.duration,\n          timing: 'linear'\n        }).restoreStyle(), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background]).queue({\n          css: {\n            transform: 'translate3D(0px, 0px, 0px)'\n          },\n          duration: 0\n        }).wait(this.delay).queue({\n          css: {\n            transform: 'translate3D(100%, 0px, 0px)'\n          },\n          duration: this.duration,\n          timing: this.timing\n        }).wait(0).queue(function (done) {\n          _this3.backgroundMask.remove();\n          unblock();\n          callback();\n          done();\n        }), Animit(leavePageDecomposition.toolbar).queue({\n          css: {\n            opacity: 1\n          },\n          duration: 0\n        }).queue({\n          css: {\n            opacity: 0\n          },\n          duration: this.duration,\n          timing: this.timing\n        }), Animit(leavePageDecomposition.toolbarCenter).queue({\n          css: {\n            transform: 'translate3d(0, 0, 0)'\n          },\n          duration: 0\n        }).wait(this.delay).queue({\n          css: {\n            transform: 'translate3d(125%, 0, 0)'\n          },\n          duration: this.duration,\n          timing: this.timing\n        }), Animit(leavePageDecomposition.backButtonLabel).queue({\n          css: {\n            transform: 'translate3d(0, 0, 0)',\n            opacity: 1\n          },\n          duration: 0\n        }).wait(this.delay).queue({\n          css: {\n            transform: 'translate3d(' + delta.title + 'px, 0, 0)',\n            opacity: 0,\n            transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing\n          },\n          duration: this.duration\n        }));\n      } else {\n        Animit.runAll(Animit(enterPage).saveStyle().queue({\n          css: {\n            transform: 'translate3D(-25%, 0px, 0px)',\n            opacity: 0.9\n          },\n          duration: 0\n        }).wait(this.delay).queue({\n          css: {\n            transform: 'translate3D(0px, 0px, 0px)',\n            opacity: 1.0\n          },\n          duration: this.duration,\n          timing: this.timing\n        }).restoreStyle(), Animit(leavePage).queue({\n          css: {\n            transform: 'translate3D(0px, 0px, 0px)'\n          },\n          duration: 0\n        }).wait(this.delay).queue({\n          css: {\n            transform: 'translate3D(100%, 0px, 0px)'\n          },\n          duration: this.duration,\n          timing: this.timing\n        }).queue(function (done) {\n          _this3.backgroundMask.remove();\n          unblock();\n          callback();\n          done();\n        }));\n      }\n    }\n  }]);\n  return IOSSlideNavigatorAnimator;\n}(NavigatorAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Swipe animator for iOS navigator transition.\n */\n\nvar IOSSwipeNavigatorAnimator = function (_IOSSlideNavigatorAni) {\n  inherits(IOSSwipeNavigatorAnimator, _IOSSlideNavigatorAni);\n\n  function IOSSwipeNavigatorAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.15 : _ref$duration,\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'linear' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay;\n\n    classCallCheck(this, IOSSwipeNavigatorAnimator);\n\n    var _this = possibleConstructorReturn(this, (IOSSwipeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));\n\n    _this.durationRestore = 0.1;\n\n    _this.swipeShadow = util.createElement('\\n      <div style=\"position: absolute; height: 100%; width: 12px; right: 100%; top: 0; bottom: 0; z-index: -1;\\n        background: linear-gradient(to right, transparent 0, rgba(0,0,0,.04) 40%, rgba(0,0,0,.12) 80%, rgba(0,0,0,.16) 100%);\"></div>\\n    ');\n\n    _this.isDragStart = true;\n    return _this;\n  }\n\n  createClass(IOSSwipeNavigatorAnimator, [{\n    key: '_dragStartSetup',\n    value: function _dragStartSetup(enterPage, leavePage) {\n      this.isDragStart = false;\n\n      // Avoid content clicks\n      this.unblock = get(IOSSwipeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator.prototype), 'block', this).call(this, leavePage);\n\n      // Mask\n      enterPage.parentElement.insertBefore(this.backgroundMask, enterPage);\n\n      // Decomposition\n      this.target = {\n        enter: util.findToolbarPage(enterPage) || enterPage,\n        leave: util.findToolbarPage(leavePage) || leavePage\n      };\n      this.decomp = {\n        enter: this._decompose(this.target.enter),\n        leave: this._decompose(this.target.leave)\n      };\n\n      // Animation values\n      this.delta = this._calculateDelta(leavePage, this.decomp.leave);\n      this.shouldAnimateToolbar = this._shouldAnimateToolbar(this.target.enter, this.target.leave);\n\n      // Shadow && styles\n      if (this.shouldAnimateToolbar) {\n        this.swipeShadow.style.top = this.decomp.leave.toolbar.offsetHeight + 'px';\n        this.target.leave.appendChild(this.swipeShadow);\n        this._saveStyle(this.target.enter, this.target.leave);\n      } else {\n        leavePage.appendChild(this.swipeShadow);\n        this._saveStyle(enterPage, leavePage);\n      }\n      leavePage.classList.add('overflow-visible');\n      this.overflowElement = leavePage;\n      this.decomp.leave.content.classList.add('content-swiping');\n    }\n  }, {\n    key: 'translate',\n    value: function translate(distance, maxWidth, enterPage, leavePage) {\n      if (this.isDragStart) {\n        this.maxWidth = maxWidth;\n        this._dragStartSetup(enterPage, leavePage);\n      }\n\n      var swipeRatio = (distance - maxWidth) / maxWidth;\n\n      if (this.shouldAnimateToolbar) {\n\n        Animit.runAll(\n\n        /* Enter page */\n\n        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({\n          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',\n          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1\n        }), Animit(this.decomp.enter.toolbarCenter).queue({\n          transform: 'translate3d(' + this.delta.title * swipeRatio + 'px, 0, 0)',\n          opacity: 1 + swipeRatio // 0 -> 1\n        }), Animit(this.decomp.enter.backButtonLabel).queue({\n          opacity: 1 + swipeRatio * 10 / 100, // 0.9 -> 1\n          transform: 'translate3d(' + this.delta.label * swipeRatio + 'px, 0, 0)'\n        }), Animit(this.decomp.enter.other).queue({\n          opacity: 1 + swipeRatio // 0 -> 1\n        }),\n\n        /* Leave page */\n\n        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({\n          transform: 'translate3d(' + distance + 'px, 0px, 0px)'\n        }), Animit(this.decomp.leave.toolbar).queue({\n          opacity: -1 * swipeRatio // 1 -> 0\n        }), Animit(this.decomp.leave.toolbarCenter).queue({\n          transform: 'translate3d(' + (1 + swipeRatio) * 125 + '%, 0, 0)'\n        }), Animit(this.decomp.leave.backButtonLabel).queue({\n          opacity: -1 * swipeRatio, // 1 -> 0\n          transform: 'translate3d(' + this.delta.title * (1 + swipeRatio) + 'px, 0, 0)'\n        }),\n\n        /* Other */\n\n        Animit(this.swipeShadow).queue({\n          opacity: -1 * swipeRatio // 1 -> 0\n        }));\n      } else {\n        Animit.runAll(Animit(leavePage).queue({\n          transform: 'translate3d(' + distance + 'px, 0px, 0px)'\n        }), Animit(enterPage).queue({\n          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',\n          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1\n        }), Animit(this.swipeShadow).queue({\n          opacity: -1 * swipeRatio // 1 -> 0\n        }));\n      }\n    }\n  }, {\n    key: 'restore',\n    value: function restore(enterPage, leavePage, callback) {\n      var _this2 = this;\n\n      if (this.isDragStart) {\n        return;\n      }\n\n      if (this.shouldAnimateToolbar) {\n\n        Animit.runAll(\n\n        /* Enter page */\n\n        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({\n          transform: 'translate3d(-25%, 0, 0)',\n          opacity: 0.9\n        }, {\n          timing: this.timing,\n          duration: this.durationRestore\n        }), Animit(this.decomp.enter.toolbarCenter).queue({\n          transform: 'translate3d(-' + this.delta.title + 'px, 0, 0)',\n          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timing,\n          opacity: 0\n        }), Animit(this.decomp.enter.backButtonLabel).queue({\n          transform: 'translate3d(-' + this.delta.label + 'px, 0, 0)'\n        }, {\n          timing: this.timing,\n          duration: this.durationRestore\n        }), Animit(this.decomp.enter.other).queue({\n          opacity: 0\n        }, {\n          timing: this.timing,\n          duration: this.durationRestore\n        }),\n\n        /* Leave page */\n\n        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({\n          transform: 'translate3d(0, 0px, 0px)'\n        }, {\n          timing: this.timing,\n          duration: this.durationRestore\n        }), Animit(this.decomp.leave.toolbar).queue({\n          opacity: 1\n        }, {\n          timing: this.timing,\n          duration: this.durationRestore\n        }), Animit(this.decomp.leave.toolbarCenter).queue({\n          transform: 'translate3d(0, 0, 0)'\n        }, {\n          timing: this.timing,\n          duration: this.durationRestore\n        }), Animit(this.decomp.leave.backButtonLabel).queue({\n          opacity: 1,\n          transform: 'translate3d(0, 0, 0)',\n          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timing\n        }),\n\n        /* Other */\n\n        Animit(this.swipeShadow).queue({\n          opacity: 0\n        }, {\n          timing: this.timing,\n          duration: this.durationRestore\n        }).queue(function (done) {\n          _this2._reset(_this2.target.enter, _this2.target.leave);\n          callback && callback();\n          done();\n        }));\n      } else {\n        Animit.runAll(Animit(enterPage).queue({\n          css: {\n            transform: 'translate3D(-25%, 0px, 0px)',\n            opacity: 0.9\n          },\n          timing: this.timing,\n          duration: this.durationRestore\n        }), Animit(leavePage).queue({\n          css: {\n            transform: 'translate3D(0px, 0px, 0px)'\n          },\n          timing: this.timing,\n          duration: this.durationRestore\n        }).queue(function (done) {\n          _this2._reset(enterPage, leavePage);\n          callback && callback();\n          done();\n        }));\n      }\n    }\n  }, {\n    key: 'pop',\n    value: function pop(enterPage, leavePage, callback) {\n      var _this3 = this;\n\n      if (this.isDragStart) {\n        return;\n      }\n\n      if (this.shouldAnimateToolbar) {\n\n        Animit.runAll(\n\n        /* Enter page */\n\n        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({\n          transform: 'translate3d(0, 0, 0)',\n          opacity: 1\n        }, {\n          timing: this.timing,\n          duration: this.duration\n        }), Animit(this.decomp.enter.toolbarCenter).queue({\n          transform: 'translate3d(0, 0, 0)',\n          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing,\n          opacity: 1\n        }), Animit(this.decomp.enter.backButtonLabel).queue({\n          transform: 'translate3d(0, 0, 0)'\n        }, {\n          timing: this.timing,\n          duration: this.duration\n        }), Animit(this.decomp.enter.other).queue({\n          opacity: 1\n        }, {\n          timing: this.timing,\n          duration: this.duration\n        }),\n\n        /* Leave page */\n\n        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background]).queue({\n          transform: 'translate3d(100%, 0px, 0px)'\n        }, {\n          timing: this.timing,\n          duration: this.duration\n        }), Animit(this.decomp.leave.toolbar).queue({\n          opacity: 0\n        }, {\n          timing: this.timing,\n          duration: this.duration\n        }), Animit(this.decomp.leave.toolbarCenter).queue({\n          transform: 'translate3d(125%, 0, 0)'\n        }, {\n          timing: this.timing,\n          duration: this.duration\n        }), Animit(this.decomp.leave.backButtonLabel).queue({\n          opacity: 0,\n          transform: 'translate3d(' + this.delta.title + 'px, 0, 0)',\n          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing\n        }),\n\n        /* Other */\n\n        Animit(this.swipeShadow).queue({\n          opacity: 0,\n          transform: 'translate3d(' + this.maxWidth + 'px, 0px, 0px)'\n        }, {\n          timing: this.timing,\n          duration: this.duration\n        }).queue(function (done) {\n          _this3._reset(_this3.target.enter, _this3.target.leave);\n          callback && callback();\n          done();\n        }));\n      } else {\n        Animit.runAll(Animit(enterPage).queue({\n          css: {\n            transform: 'translate3D(0px, 0px, 0px)',\n            opacity: 1.0\n          },\n          duration: this.duration,\n          timing: this.timing\n        }), Animit(leavePage).queue({\n          css: {\n            transform: 'translate3D(100%, 0px, 0px)'\n          },\n          duration: this.duration,\n          timing: this.timing\n        }).queue(function (done) {\n          _this3._reset(enterPage, leavePage);\n          callback && callback();\n          done();\n        }));\n      }\n    }\n  }, {\n    key: '_saveStyle',\n    value: function _saveStyle() {\n      var _this4 = this;\n\n      this._savedStyle = new WeakMap();\n      var save = function save(el) {\n        return _this4._savedStyle.set(el, el.getAttribute('style'));\n      };\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      args.forEach(save);\n\n      Object.keys(this.decomp).forEach(function (p) {\n        Object.keys(_this4.decomp[p]).forEach(function (k) {\n          (_this4.decomp[p][k] instanceof Array ? _this4.decomp[p][k] : [_this4.decomp[p][k]]).forEach(save);\n        });\n      });\n    }\n  }, {\n    key: '_restoreStyle',\n    value: function _restoreStyle() {\n      var _this5 = this;\n\n      var restore = function restore(el) {\n        _this5._savedStyle.get(el) === null ? el.removeAttribute('style') : el.setAttribute('style', _this5._savedStyle.get(el));\n        _this5._savedStyle.delete(el);\n      };\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      args.forEach(restore);\n\n      Object.keys(this.decomp).forEach(function (p) {\n        Object.keys(_this5.decomp[p]).forEach(function (k) {\n          (_this5.decomp[p][k] instanceof Array ? _this5.decomp[p][k] : [_this5.decomp[p][k]]).forEach(restore);\n        });\n      });\n    }\n  }, {\n    key: '_reset',\n    value: function _reset() {\n      this._savedStyle && this._restoreStyle.apply(this, arguments);\n      this.unblock && this.unblock();\n      this.swipeShadow.remove();\n      this.backgroundMask.remove();\n      this.overflowElement.classList.remove('overflow-visible');\n      this.decomp.leave.content.classList.remove('content-swiping');\n      this.decomp = this.target = this.overflowElement = this._savedStyle = null;\n      this.isDragStart = true;\n    }\n  }]);\n  return IOSSwipeNavigatorAnimator;\n}(IOSSlideNavigatorAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Lift screen transition.\n */\n\nvar IOSLiftNavigatorAnimator = function (_NavigatorAnimator) {\n  inherits(IOSLiftNavigatorAnimator, _NavigatorAnimator);\n\n  function IOSLiftNavigatorAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.4 : _ref$duration;\n\n    classCallCheck(this, IOSLiftNavigatorAnimator);\n\n    var _this = possibleConstructorReturn(this, (IOSLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this.backgroundMask = util.createElement('\\n      <div style=\"position: absolute; width: 100%; height: 100%;\\n        background: linear-gradient(black, white);\"></div>\\n    ');\n    return _this;\n  }\n\n  /**\n   * @param {Object} enterPage\n   * @param {Object} leavePage\n   * @param {Function} callback\n   */\n\n\n  createClass(IOSLiftNavigatorAnimator, [{\n    key: 'push',\n    value: function push(enterPage, leavePage, callback) {\n      var _this2 = this;\n\n      this.backgroundMask.remove();\n      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);\n\n      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      Animit.runAll(Animit(enterPage).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 100%, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        _this2.backgroundMask.remove();\n        unblock();\n        callback();\n        done();\n      }), Animit(leavePage).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 1.0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, -10%, 0)',\n          opacity: 0.9\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle());\n    }\n\n    /**\n     * @param {Object} enterPage\n     * @param {Object} leavePage\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop(enterPage, leavePage, callback) {\n      var _this3 = this;\n\n      this.backgroundMask.remove();\n      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);\n\n      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      Animit.runAll(Animit(enterPage).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, -43px, 0)', // Smaller than iOS toolbar - fixes glitch\n          opacity: 0.9\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 1.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        _this3.backgroundMask.remove();\n        unblock();\n        callback();\n        done();\n      }), Animit(leavePage).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 100%, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle());\n    }\n  }]);\n  return IOSLiftNavigatorAnimator;\n}(NavigatorAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Fade-in screen transition.\n */\n\nvar IOSFadeNavigatorAnimator = function (_NavigatorAnimator) {\n  inherits(IOSFadeNavigatorAnimator, _NavigatorAnimator);\n\n  function IOSFadeNavigatorAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'linear' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.4 : _ref$duration;\n\n    classCallCheck(this, IOSFadeNavigatorAnimator);\n    return possibleConstructorReturn(this, (IOSFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {Object} enterPage\n   * @param {Object} leavePage\n   * @param {Function} callback\n   */\n\n\n  createClass(IOSFadeNavigatorAnimator, [{\n    key: 'push',\n    value: function push(enterPage, leavePage, callback) {\n      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      Animit.runAll(Animit([enterPage._getContentElement(), enterPage._getBackgroundElement()]).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 1\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        unblock();\n        callback();\n        done();\n      }), Animit(enterPage._getToolbarElement()).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 1\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle());\n    }\n\n    /**\n     * @param {Object} enterPage\n     * @param {Object} leavePage\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop(enterPage, leavePage, callback) {\n      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      Animit.runAll(Animit([leavePage._getContentElement(), leavePage._getBackgroundElement()]).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 1\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).queue(function (done) {\n        unblock();\n        callback();\n        done();\n      }), Animit(leavePage._getToolbarElement()).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 1\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }));\n    }\n  }]);\n  return IOSFadeNavigatorAnimator;\n}(NavigatorAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Slide animator for navigator transition.\n */\n\nvar MDSlideNavigatorAnimator = function (_NavigatorAnimator) {\n  inherits(MDSlideNavigatorAnimator, _NavigatorAnimator);\n\n  function MDSlideNavigatorAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.3 : _ref$duration;\n\n    classCallCheck(this, MDSlideNavigatorAnimator);\n\n    var _this = possibleConstructorReturn(this, (MDSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this.backgroundMask = util.createElement('\\n      <div style=\"position: absolute; width: 100%; height: 100%; z-index: 2;\\n        background-color: black; opacity: 0;\"></div>\\n    ');\n    _this.blackMaskOpacity = 0.4;\n    return _this;\n  }\n\n  /**\n   * @param {Object} enterPage\n   * @param {Object} leavePage\n   * @param {Function} callback\n   */\n\n\n  createClass(MDSlideNavigatorAnimator, [{\n    key: 'push',\n    value: function push(enterPage, leavePage, callback) {\n      var _this2 = this;\n\n      this.backgroundMask.remove();\n      leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);\n\n      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      Animit.runAll(Animit(this.backgroundMask).saveStyle().queue({\n        opacity: 0,\n        transform: 'translate3d(0, 0, 0)'\n      }).wait(this.delay).queue({\n        opacity: this.blackMaskOpacity\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        _this2.backgroundMask.remove();\n        done();\n      }), Animit(enterPage).saveStyle().queue({\n        css: {\n          transform: 'translate3D(100%, 0, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle(), Animit(leavePage).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(-45%, 0px, 0px)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().wait(0.2).queue(function (done) {\n        unblock();\n        callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {Object} enterPage\n     * @param {Object} leavePage\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop(enterPage, leavePage, callback) {\n      var _this3 = this;\n\n      this.backgroundMask.remove();\n      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);\n\n      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      Animit.runAll(Animit(this.backgroundMask).saveStyle().queue({\n        opacity: this.blackMaskOpacity,\n        transform: 'translate3d(0, 0, 0)'\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        _this3.backgroundMask.remove();\n        done();\n      }), Animit(enterPage).saveStyle().queue({\n        css: {\n          transform: 'translate3D(-45%, 0px, 0px)',\n          opacity: 0.9\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0px, 0px, 0px)',\n          opacity: 1.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle(), Animit(leavePage).queue({\n        css: {\n          transform: 'translate3D(0px, 0px, 0px)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(100%, 0px, 0px)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).wait(0.2).queue(function (done) {\n        unblock();\n        callback();\n        done();\n      }));\n    }\n  }]);\n  return MDSlideNavigatorAnimator;\n}(NavigatorAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Lift screen transition.\n */\n\nvar MDLiftNavigatorAnimator = function (_NavigatorAnimator) {\n  inherits(MDLiftNavigatorAnimator, _NavigatorAnimator);\n\n  function MDLiftNavigatorAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0.05 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.4 : _ref$duration;\n\n    classCallCheck(this, MDLiftNavigatorAnimator);\n\n    var _this = possibleConstructorReturn(this, (MDLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this.backgroundMask = util.createElement('\\n      <div style=\"position: absolute; width: 100%; height: 100%;\\n        background-color: black;\"></div>\\n    ');\n    return _this;\n  }\n\n  /**\n   * @param {Object} enterPage\n   * @param {Object} leavePage\n   * @param {Function} callback\n   */\n\n\n  createClass(MDLiftNavigatorAnimator, [{\n    key: 'push',\n    value: function push(enterPage, leavePage, callback) {\n      var _this2 = this;\n\n      this.backgroundMask.remove();\n      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);\n\n      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      var maskClear = Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {\n        _this2.backgroundMask.remove();\n        done();\n      });\n\n      Animit.runAll(maskClear, Animit(enterPage).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 100%, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        unblock();\n        callback();\n        done();\n      }), Animit(leavePage).queue({\n        css: {\n          opacity: 1.0\n        },\n        duration: 0\n      }).queue({\n        css: {\n          opacity: 0.4\n        },\n        duration: this.duration,\n        timing: this.timing\n      }));\n    }\n\n    /**\n     * @param {Object} enterPage\n     * @param {Object} leavePage\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop(enterPage, leavePage, callback) {\n      var _this3 = this;\n\n      this.backgroundMask.remove();\n      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);\n\n      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      Animit.runAll(Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {\n        _this3.backgroundMask.remove();\n        done();\n      }), Animit(enterPage).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 0.4\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 1.0\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).queue(function (done) {\n        unblock();\n        callback();\n        done();\n      }), Animit(leavePage).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)'\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 100%, 0)'\n        },\n        duration: this.duration,\n        timing: this.timing\n      }));\n    }\n  }]);\n  return MDLiftNavigatorAnimator;\n}(NavigatorAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Fade-in + Lift screen transition.\n */\n\nvar MDFadeNavigatorAnimator = function (_NavigatorAnimator) {\n  inherits(MDFadeNavigatorAnimator, _NavigatorAnimator);\n\n  function MDFadeNavigatorAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'cubic-bezier(0.4, 0.0, 0.2, 1)' : _ref$timing,\n        _ref$timingOnPop = _ref.timingOnPop,\n        timingOnPop = _ref$timingOnPop === undefined ? 'cubic-bezier(0.4, 0.0, 1, 1)' : _ref$timingOnPop,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.2 : _ref$duration;\n\n    classCallCheck(this, MDFadeNavigatorAnimator);\n\n    var _this = possibleConstructorReturn(this, (MDFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this.timingOnPop = timingOnPop;\n    return _this;\n  }\n\n  /**\n   * @param {Object} enterPage\n   * @param {Object} leavePage\n   * @param {Function} callback\n   */\n\n\n  createClass(MDFadeNavigatorAnimator, [{\n    key: 'push',\n    value: function push(enterPage, leavePage, callback) {\n      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      Animit.runAll(Animit(enterPage).saveStyle().queue({\n        css: {\n          transform: 'translate3D(0, 42px, 0)',\n          opacity: 0\n        },\n        duration: 0\n      }).wait(this.delay).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 1\n        },\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        unblock();\n        callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {Object} enterPage\n     * @param {Object} leavePage\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop(enterPage, leavePage, callback) {\n      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);\n\n      Animit.runAll(Animit(leavePage).queue({\n        css: {\n          transform: 'translate3D(0, 0, 0)',\n          opacity: 1\n        },\n        duration: 0\n      }).wait(0.15).queue({\n        css: {\n          transform: 'translate3D(0, 38px, 0)',\n          opacity: 0\n        },\n        duration: this.duration,\n        timing: this.timingOnPop\n      }).queue(function (done) {\n        unblock();\n        callback();\n        done();\n      }));\n    }\n  }]);\n  return MDFadeNavigatorAnimator;\n}(NavigatorAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar NoneNavigatorAnimator = function (_NavigatorAnimator) {\n  inherits(NoneNavigatorAnimator, _NavigatorAnimator);\n\n  function NoneNavigatorAnimator(options) {\n    classCallCheck(this, NoneNavigatorAnimator);\n    return possibleConstructorReturn(this, (NoneNavigatorAnimator.__proto__ || Object.getPrototypeOf(NoneNavigatorAnimator)).call(this, options));\n  }\n\n  createClass(NoneNavigatorAnimator, [{\n    key: 'push',\n    value: function push(enterPage, leavePage, callback) {\n      callback();\n    }\n  }, {\n    key: 'pop',\n    value: function pop(enterPage, leavePage, callback) {\n      callback();\n    }\n  }]);\n  return NoneNavigatorAnimator;\n}(NavigatorAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar _animatorDict$4 = {\n  'default': function _default() {\n    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSSlideNavigatorAnimator;\n  },\n  'slide': function slide() {\n    return platform.isAndroid() ? MDSlideNavigatorAnimator : IOSSlideNavigatorAnimator;\n  },\n  'lift': function lift() {\n    return platform.isAndroid() ? MDLiftNavigatorAnimator : IOSLiftNavigatorAnimator;\n  },\n  'fade': function fade() {\n    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSFadeNavigatorAnimator;\n  },\n  'slide-ios': IOSSlideNavigatorAnimator,\n  'slide-md': MDSlideNavigatorAnimator,\n  'lift-ios': IOSLiftNavigatorAnimator,\n  'lift-md': MDLiftNavigatorAnimator,\n  'fade-ios': IOSFadeNavigatorAnimator,\n  'fade-md': MDFadeNavigatorAnimator,\n  'none': NoneNavigatorAnimator\n};\n\nvar rewritables = {\n  /**\n   * @param {Element} navigatorSideElement\n   * @param {Function} callback\n   */\n  ready: function ready(navigatorElement, callback) {\n    callback();\n  }\n};\n\n/**\n * @element ons-navigator\n * @category navigation\n * @description\n *   [en]\n *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.\n *\n *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.\n *   [/en]\n *   [ja][/ja]\n * @codepen yrhtv\n * @tutorial vanilla/Reference/navigator\n * @guide lifecycle.html#events\n *   [en]Overview of page events[/en]\n *   [ja]Overview of page events[/ja]\n * @seealso ons-toolbar\n *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]\n *   [ja][/ja]\n * @seealso ons-back-button\n *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]\n *   [ja][/ja]\n * @example\n * <ons-navigator id=\"navigator\">\n *   <ons-page>\n *     <ons-toolbar>\n *       <div class=\"center\">\n *         Title\n *       </div>\n *     </ons-toolbar>\n *     <p>\n *       <ons-button\n *         onclick=\"document.getElementById('navigator').pushPage('page.html')\">\n *         Push page\n *       </ons-button>\n *     </p>\n *   </ons-page>\n * </ons-navigator>\n *\n * <ons-template id=\"page.html\">\n *   <ons-page>\n *     <ons-toolbar>\n *       <div class=\"left\">\n *         <ons-back-button>Back</ons-back-button>\n *       </div>\n *       <div class=\"center\">\n *         Another page\n *       </div>\n *     </ons-toolbar>\n *   </ons-page>\n * </ons-template>\n */\n\nvar NavigatorElement = function (_BaseElement) {\n  inherits(NavigatorElement, _BaseElement);\n  createClass(NavigatorElement, [{\n    key: 'animatorFactory',\n\n\n    /**\n     * @attribute page\n     * @initonly\n     * @type {String}\n     * @description\n     *   [en]First page to show when navigator is initialized.[/en]\n     *   [ja]ナビゲーターが初期化された時に表示するページを指定します。[/ja]\n     */\n\n    /**\n     * @attribute swipeable\n     * @type {Boolean}\n     * @description\n     *   [en]Enable iOS \"swipe to pop\" feature.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @attribute swipe-target-width\n     * @type {String}\n     * @default 20px\n     * @description\n     *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]\n     *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]\n     */\n\n    /**\n     * @attribute swipe-threshold\n     * @type {Number}\n     * @default 0.2\n     * @description\n     *  [en]Specify how much the page needs to be swiped before popping. A value between `0` and `1`.[/en]\n     *  [ja][/ja]\n     */\n\n    /**\n     * @attribute animation\n     * @type {String}\n     * @default default\n     * @description\n     *   [en]\n     *     Animation name. Available animations are `\"slide\"`, `\"lift\"`, `\"fade\"` and `\"none\"`.\n     *\n     *     These are platform based animations. For fixed animations, add `\"-ios\"` or `\"-md\"` suffix to the animation name. E.g. `\"lift-ios\"`, `\"lift-md\"`. Defaults values are `\"slide-ios\"` and `\"fade-md\"` depending on the platform.\n     *   [/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @attribute animation-options\n     * @type {Expression}\n     * @description\n     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]\n     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]\n     */\n\n    /**\n     * @event prepush\n     * @description\n     *   [en]Fired just before a page is pushed.[/en]\n     *   [ja]pageがpushされる直前に発火されます。[/ja]\n     * @param {Object} event [en]Event object.[/en]\n     * @param {Object} event.navigator\n     *   [en]Component object.[/en]\n     *   [ja]コンポーネントのオブジェクト。[/ja]\n     * @param {Object} event.currentPage\n     *   [en]Current page object.[/en]\n     *   [ja]現在のpageオブジェクト。[/ja]\n     * @param {Function} event.cancel\n     *   [en]Call this function to cancel the push.[/en]\n     *   [ja]この関数を呼び出すと、push処理がキャンセルされます。[/ja]\n     */\n\n    /**\n     * @event prepop\n     * @description\n     *   [en]Fired just before a page is popped.[/en]\n     *   [ja]pageがpopされる直前に発火されます。[/ja]\n     * @param {Object} event [en]Event object.[/en]\n     * @param {Object} event.navigator\n     *   [en]Component object.[/en]\n     *   [ja]コンポーネントのオブジェクト。[/ja]\n     * @param {Object} event.currentPage\n     *   [en]Current page object.[/en]\n     *   [ja]現在のpageオブジェクト。[/ja]\n     * @param {Function} event.cancel\n     *   [en]Call this function to cancel the pop.[/en]\n     *   [ja]この関数を呼び出すと、pageのpopがキャンセルされます。[/ja]\n     */\n\n    /**\n     * @event postpush\n     * @description\n     *   [en]Fired just after a page is pushed.[/en]\n     *   [ja]pageがpushされてアニメーションが終了してから発火されます。[/ja]\n     * @param {Object} event [en]Event object.[/en]\n     * @param {Object} event.navigator\n     *   [en]Component object.[/en]\n     *   [ja]コンポーネントのオブジェクト。[/ja]\n     * @param {Object} event.enterPage\n     *   [en]Object of the next page.[/en]\n     *   [ja]pushされたpageオブジェクト。[/ja]\n     * @param {Object} event.leavePage\n     *   [en]Object of the previous page.[/en]\n     *   [ja]以前のpageオブジェクト。[/ja]\n     */\n\n    /**\n     * @event postpop\n     * @description\n     *   [en]Fired just after a page is popped.[/en]\n     *   [ja]pageがpopされてアニメーションが終わった後に発火されます。[/ja]\n     * @param {Object} event [en]Event object.[/en]\n     * @param {Object} event.navigator\n     *   [en]Component object.[/en]\n     *   [ja]コンポーネントのオブジェクト。[/ja]\n     * @param {Object} event.enterPage\n     *   [en]Object of the next page.[/en]\n     *   [ja]popされて表示されるページのオブジェクト。[/ja]\n     * @param {Object} event.leavePage\n     *   [en]Object of the previous page.[/en]\n     *   [ja]popされて消えるページのオブジェクト。[/ja]\n     */\n\n    get: function get$$1() {\n      return this._animatorFactory;\n    }\n  }]);\n\n  function NavigatorElement() {\n    classCallCheck(this, NavigatorElement);\n\n    var _this = possibleConstructorReturn(this, (NavigatorElement.__proto__ || Object.getPrototypeOf(NavigatorElement)).call(this));\n\n    _this._isRunning = false;\n    _this._initialized = false;\n    _this._pageLoader = defaultPageLoader;\n    _this._pageMap = new WeakMap();\n\n    _this._updateAnimatorFactory();\n    return _this;\n  }\n\n  /**\n   * @property pageLoader\n   * @type {PageLoader}\n   * @description\n   *   [en]PageLoader instance. It can be overriden to change the way pages are loaded by this element. Useful for lib developers.[/en]\n   *   [ja]PageLoaderインスタンスを格納しています。[/ja]\n   */\n\n\n  createClass(NavigatorElement, [{\n    key: '_getPageTarget',\n    value: function _getPageTarget() {\n      return this._page || this.getAttribute('page');\n    }\n\n    /**\n     * @property page\n     * @type {*}\n     * @description\n     *   [en]Specify the page to be loaded during initialization. This value takes precedence over the `page` attribute. Useful for lib developers.[/en]\n     *   [ja]初期化時に読み込むページを指定します。`page`属性で指定した値よりも`page`プロパティに指定した値を優先します。[/ja]\n     */\n\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);\n\n      if (!platform.isAndroid() || this.getAttribute('swipeable') === 'force') {\n        this._swipeAnimator = new IOSSwipeNavigatorAnimator();\n        var pushAnimation = { duration: this._swipeAnimator.duration, timing: this._swipeAnimator.timing };\n        var popAnimation = { duration: this._swipeAnimator.durationRestore, timing: this._swipeAnimator.timing };\n\n        this._swipe = new SwipeReveal({\n          element: this,\n          swipeMax: function swipeMax() {\n            _this2._onSwipe && _this2._onSwipe(1, pushAnimation);\n            _this2[_this2.swipeMax ? 'swipeMax' : 'popPage']({ animator: _this2._swipeAnimator });\n          },\n          swipeMid: function swipeMid(distance, width) {\n            _this2._onSwipe && _this2._onSwipe(distance / width);\n            _this2._swipeAnimator.translate(distance, width, _this2.topPage.previousElementSibling, _this2.topPage);\n          },\n          swipeMin: function swipeMin() {\n            _this2._onSwipe && _this2._onSwipe(0, popAnimation);\n            _this2._swipeAnimator.restore(_this2.topPage.previousElementSibling, _this2.topPage);\n          },\n          getThreshold: function getThreshold() {\n            return Math.max(0.2, parseFloat(_this2.getAttribute('swipe-threshold')) || 0);\n          },\n          ignoreSwipe: function ignoreSwipe(event, distance) {\n            if (/ons-back-button/i.test(event.target.tagName) || util.findParent(event.target, 'ons-back-button', function (p) {\n              return (/ons-page/i.test(p.tagName)\n              );\n            })) {\n              return true;\n            }\n            var area = parseInt(_this2.getAttribute('swipe-target-width') || 25, 10);\n            return event.gesture.direction !== 'right' || area <= distance || _this2._isRunning || _this2.children.length <= 1;\n          }\n        });\n\n        this.attributeChangedCallback('swipeable');\n      }\n\n      if (this._initialized) {\n        return;\n      }\n\n      this._initialized = true;\n\n      var deferred = util.defer();\n      this.loaded = deferred.promise;\n\n      rewritables.ready(this, function () {\n        var show = !util.hasAnyComponentAsParent(_this2);\n        var options = { animation: 'none', show: show };\n\n        if (_this2.pages.length === 0 && _this2._getPageTarget()) {\n          _this2.pushPage(_this2._getPageTarget(), options).then(function () {\n            return deferred.resolve();\n          });\n        } else if (_this2.pages.length > 0) {\n          for (var i = 0; i < _this2.pages.length; i++) {\n            if (_this2.pages[i].nodeName !== 'ONS-PAGE') {\n              throw new Error('The children of <ons-navigator> need to be of type <ons-page>');\n            }\n          }\n\n          if (_this2.topPage) {\n            contentReady(_this2.topPage, function () {\n              return setTimeout(function () {\n                deferred.resolve();\n                show && _this2.topPage._show();\n                _this2._updateLastPageBackButton();\n              }, 0);\n            });\n          }\n        } else {\n          contentReady(_this2, function () {\n            if (_this2.pages.length === 0 && _this2._getPageTarget()) {\n              _this2.pushPage(_this2._getPageTarget(), options).then(function () {\n                return deferred.resolve();\n              });\n            } else {\n              deferred.resolve();\n            }\n          });\n        }\n      });\n    }\n  }, {\n    key: '_updateAnimatorFactory',\n    value: function _updateAnimatorFactory() {\n      this._animatorFactory = new AnimatorFactory({\n        animators: _animatorDict$4,\n        baseClass: NavigatorAnimator,\n        baseClassName: 'NavigatorAnimator',\n        defaultAnimation: this.getAttribute('animation')\n      });\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this._backButtonHandler.destroy();\n      this._backButtonHandler = null;\n\n      this._swipe && this._swipe.dispose();\n      this._swipe = this._swipeAnimator = null;\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'animation':\n          this._updateAnimatorFactory();\n          break;\n        case 'swipeable':\n          this._swipe && this._swipe.update();\n          break;\n      }\n    }\n\n    /**\n     * @method popPage\n     * @signature popPage([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]\n     *     Animation name. Available animations are `\"slide\"`, `\"lift\"`, `\"fade\"` and `\"none\"`.\n     *\n     *     These are platform based animations. For fixed animations, add `\"-ios\"` or `\"-md\"` suffix to the animation name. E.g. `\"lift-ios\"`, `\"lift-md\"`. Defaults values are `\"slide-ios\"` and `\"fade-md\"`.\n     *   [/en]\n     *   [ja][/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @param {Function} [options.callback]\n     *   [en]Function that is called when the transition has ended.[/en]\n     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]\n     * @param {Object} [options.data]\n     *   [en]Custom data that will be stored in the new page element.[/en]\n     *   [ja][/ja]\n     * @return {Promise}\n     *   [en]Promise which resolves to the revealed page.[/en]\n     *   [ja]明らかにしたページを解決するPromiseを返します。[/ja]\n     * @description\n     *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]\n     *   [ja]現在表示中のページをページスタックから取り除きます。一つ前のページに戻ります。[/ja]\n     */\n\n  }, {\n    key: 'popPage',\n    value: function popPage() {\n      var _this3 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _preparePageAndOption = this._preparePageAndOptions(null, options);\n\n      options = _preparePageAndOption.options;\n\n\n      var popUpdate = function popUpdate() {\n        return new Promise(function (resolve) {\n          _this3._pageLoader.unload(_this3.pages[_this3.pages.length - 1]);\n          resolve();\n        });\n      };\n\n      return this._popPage(options, popUpdate);\n    }\n  }, {\n    key: '_popPage',\n    value: function _popPage(options) {\n      var _this4 = this;\n\n      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return Promise.resolve();\n      };\n\n      if (this._isRunning) {\n        return Promise.reject('popPage is already running.');\n      }\n\n      if (this.pages.length <= 1) {\n        return Promise.reject('ons-navigator\\'s page stack is empty.');\n      }\n\n      if (this._emitPrePopEvent()) {\n        return Promise.reject('Canceled in prepop event.');\n      }\n\n      var length = this.pages.length;\n\n      this._isRunning = true;\n\n      this.pages[length - 2].updateBackButton(length - 2 > 0);\n\n      return new Promise(function (resolve) {\n        var leavePage = _this4.pages[length - 1];\n        var enterPage = _this4.pages[length - 2];\n\n        options.animation = options.animation || (leavePage.pushedOptions ? leavePage.pushedOptions.animation : undefined);\n        options.animationOptions = util.extend({}, leavePage.pushedOptions ? leavePage.pushedOptions.animationOptions : {}, options.animationOptions || {});\n\n        if (options.data) {\n          enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});\n        }\n\n        var callback = function callback() {\n          update().then(function () {\n            _this4._isRunning = false;\n\n            enterPage._show();\n            util.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });\n\n            if (typeof options.callback === 'function') {\n              options.callback();\n            }\n\n            resolve(enterPage);\n          });\n        };\n\n        leavePage._hide();\n        var animator = options.animator || _this4._animatorFactory.newAnimator(options);\n        animator.pop(_this4.pages[length - 2], _this4.pages[length - 1], callback);\n      }).catch(function () {\n        return _this4._isRunning = false;\n      });\n    }\n\n    /**\n     * @method pushPage\n     * @signature pushPage(page, [options])\n     * @param {String} page\n     *   [en]Page URL. Can be either a HTML document or a template defined with the `<ons-template>` tag.[/en]\n     *   [ja]pageのURLか、もしくはons-templateで宣言したテンプレートのid属性の値を指定できます。[/ja]\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.page]\n     *   [en]Page URL. Only necessary if `page` parameter is null or undefined.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.pageHTML]\n     *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animation]\n     *   [en]\n     *     Animation name. Available animations are `\"slide\"`, `\"lift\"`, `\"fade\"` and `\"none\"`.\n     *\n     *     These are platform based animations. For fixed animations, add `\"-ios\"` or `\"-md\"` suffix to the animation name. E.g. `\"lift-ios\"`, `\"lift-md\"`. Defaults values are `\"slide-ios\"` and `\"fade-md\"`.\n     *   [/en]\n     *   [ja][/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]\n     * @param {Function} [options.callback]\n     *   [en]Function that is called when the transition has ended.[/en]\n     *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]\n     * @param {Object} [options.data]\n     *   [en]Custom data that will be stored in the new page element.[/en]\n     *   [ja][/ja]\n     * @return {Promise}\n     *   [en]Promise which resolves to the pushed page.[/en]\n     *   [ja]追加したページを解決するPromiseを返します。[/ja]\n     * @description\n     *   [en]Pushes the specified page into the stack.[/en]\n     *   [ja]指定したpageを新しいページスタックに追加します。新しいページが表示されます。[/ja]\n     */\n\n  }, {\n    key: 'pushPage',\n    value: function pushPage(page) {\n      var _this5 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _preparePageAndOption2 = this._preparePageAndOptions(page, options);\n\n      page = _preparePageAndOption2.page;\n      options = _preparePageAndOption2.options;\n\n\n      var prepare = function prepare(pageElement) {\n        _this5._verifyPageElement(pageElement);\n        _this5._pageMap.set(pageElement, page);\n        pageElement = util.extend(pageElement, {\n          data: options.data\n        });\n        pageElement.style.visibility = 'hidden';\n      };\n\n      if (options.pageHTML) {\n        return this._pushPage(options, function () {\n          return new Promise(function (resolve) {\n            instantPageLoader.load({ page: options.pageHTML, parent: _this5, params: options.data }, function (pageElement) {\n              prepare(pageElement);\n              resolve();\n            });\n          });\n        });\n      }\n\n      return this._pushPage(options, function () {\n        return new Promise(function (resolve) {\n          _this5._pageLoader.load({ page: page, parent: _this5, params: options.data }, function (pageElement) {\n            prepare(pageElement);\n            resolve();\n          });\n        });\n      });\n    }\n  }, {\n    key: '_pushPage',\n    value: function _pushPage() {\n      var _this6 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return Promise.resolve();\n      };\n\n      if (this._isRunning) {\n        return Promise.reject('pushPage is already running.');\n      }\n\n      if (this._emitPrePushEvent()) {\n        return Promise.reject('Canceled in prepush event.');\n      }\n\n      this._isRunning = true;\n\n      var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));\n      options = util.extend({}, this.options || {}, { animationOptions: animationOptions }, options);\n\n      var animator = this._animatorFactory.newAnimator(options);\n\n      return update().then(function () {\n        var pageLength = _this6.pages.length;\n\n        var enterPage = _this6.pages[pageLength - 1];\n        var leavePage = options.leavePage || _this6.pages[pageLength - 2];\n\n        if (enterPage.nodeName !== 'ONS-PAGE') {\n          throw new Error('Only elements of type <ons-page> can be pushed to the navigator');\n        }\n\n        enterPage.updateBackButton(pageLength > (options._replacePage ? 2 : 1));\n\n        enterPage.pushedOptions = util.extend({}, enterPage.pushedOptions || {}, options || {});\n        enterPage.data = util.extend({}, enterPage.data || {}, options.data || {});\n        enterPage.unload = enterPage.unload || options.unload;\n\n        return new Promise(function (resolve) {\n          var done = function done() {\n            _this6._isRunning = false;\n\n            options.show !== false && setImmediate(function () {\n              return enterPage._show();\n            });\n            util.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });\n\n            if (typeof options.callback === 'function') {\n              options.callback();\n            }\n\n            resolve(enterPage);\n          };\n\n          enterPage.style.visibility = '';\n          if (leavePage) {\n            leavePage._hide();\n            animator.push(enterPage, leavePage, done);\n          } else {\n            done();\n          }\n        });\n      }).catch(function (error) {\n        _this6._isRunning = false;\n        throw error;\n      });\n    }\n\n    /**\n     * @method replacePage\n     * @signature replacePage(page, [options])\n     * @return {Promise}\n     *   [en]Promise which resolves to the new page.[/en]\n     *   [ja]新しいページを解決するPromiseを返します。[/ja]\n     * @description\n     *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]\n     *   [ja]現在表示中のページをを指定したページに置き換えます。[/ja]\n     */\n\n  }, {\n    key: 'replacePage',\n    value: function replacePage(page) {\n      var _this7 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      return this.pushPage(page, options).then(function (resolvedValue) {\n        if (_this7.pages.length > 1) {\n          _this7._pageLoader.unload(_this7.pages[_this7.pages.length - 2]);\n        }\n        _this7._updateLastPageBackButton();\n\n        return Promise.resolve(resolvedValue);\n      });\n    }\n\n    /**\n     * @method insertPage\n     * @signature insertPage(index, page, [options])\n     * @param {Number} index\n     *   [en]The index where it should be inserted.[/en]\n     *   [ja]スタックに挿入する位置のインデックスを指定します。[/ja]\n     * @return {Promise}\n     *   [en]Promise which resolves to the inserted page.[/en]\n     *   [ja]指定したページを解決するPromiseを返します。[/ja]\n     * @description\n     *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]\n     *   [ja]指定したpageをページスタックのindexで指定した位置に追加します。[/ja]\n     */\n\n  }, {\n    key: 'insertPage',\n    value: function insertPage(index, page) {\n      var _this8 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _preparePageAndOption3 = this._preparePageAndOptions(page, options);\n\n      page = _preparePageAndOption3.page;\n      options = _preparePageAndOption3.options;\n\n      index = this._normalizeIndex(index);\n\n      if (index >= this.pages.length) {\n        return this.pushPage(page, options);\n      }\n\n      page = typeof options.pageHTML === 'string' ? options.pageHTML : page;\n      var loader = typeof options.pageHTML === 'string' ? instantPageLoader : this._pageLoader;\n\n      return new Promise(function (resolve) {\n        loader.load({ page: page, parent: _this8 }, function (pageElement) {\n          _this8._verifyPageElement(pageElement);\n          _this8._pageMap.set(pageElement, page);\n          pageElement = util.extend(pageElement, {\n            data: options.data,\n            pushedOptions: options\n          });\n\n          options.animationOptions = util.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});\n\n          _this8.insertBefore(pageElement, _this8.pages[index]);\n          _this8.topPage.updateBackButton(true);\n\n          setTimeout(function () {\n            pageElement = null;\n            resolve(_this8.pages[index]);\n          }, 1000 / 60);\n        });\n      });\n    }\n\n    /**\n     * @method removePage\n     * @signature removePage(index, [options])\n     * @param {Number} index\n     *   [en]The index where it should be removed.[/en]\n     *   [ja]スタックから削除するページのインデックスを指定します。[/ja]\n     * @return {Promise}\n     *   [en]Promise which resolves to the revealed page.[/en]\n     *   [ja]削除によって表示されたページを解決するPromiseを返します。[/ja]\n     * @description\n     *   [en]Remove the specified page at a position in the stack defined by the `index` argument. Extends `popPage()` parameters.[/en]\n     *   [ja]指定したインデックスにあるページを削除します。[/ja]\n     */\n\n  }, {\n    key: 'removePage',\n    value: function removePage(index) {\n      var _this9 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      index = this._normalizeIndex(index);\n\n      if (index < this.pages.length - 1) {\n        return new Promise(function (resolve) {\n          var leavePage = _this9.pages[index];\n          var enterPage = _this9.topPage;\n\n          _this9._pageMap.delete(leavePage);\n          _this9._pageLoader.unload(leavePage);\n          if (_this9.pages.length === 1) {\n            // edge case\n            _this9.topPage.updateBackButton(false);\n          }\n\n          resolve(enterPage);\n        });\n      } else {\n        return this.popPage(options);\n      }\n    }\n\n    /**\n     * @method resetToPage\n     * @signature resetToPage(page, [options])\n     * @return {Promise}\n     *   [en]Promise which resolves to the new top page.[/en]\n     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]\n     * @description\n     *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]\n     *   [ja]ページスタックをリセットし、指定したページを表示します。[/ja]\n     */\n\n  }, {\n    key: 'resetToPage',\n    value: function resetToPage(page) {\n      var _this10 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _preparePageAndOption4 = this._preparePageAndOptions(page, options);\n\n      page = _preparePageAndOption4.page;\n      options = _preparePageAndOption4.options;\n\n\n      if (!options.animator && !options.animation) {\n        options.animation = 'none';\n      }\n\n      var callback = options.callback;\n\n      options.callback = function () {\n        while (_this10.pages.length > 1) {\n          _this10._pageLoader.unload(_this10.pages[0]);\n        }\n\n        _this10.pages[0].updateBackButton(false);\n        callback && callback();\n      };\n\n      if (!options.page && !options.pageHTML && this._getPageTarget()) {\n        page = options.page = this._getPageTarget();\n      }\n\n      return this.pushPage(page, options);\n    }\n\n    /**\n     * @method bringPageTop\n     * @signature bringPageTop(item, [options])\n     * @param {String|Number} item\n     *   [en]Page URL or index of an existing page in navigator's stack.[/en]\n     *   [ja]ページのURLかもしくはons-navigatorのページスタックのインデックス値を指定します。[/ja]\n     * @return {Promise}\n     *   [en]Promise which resolves to the new top page.[/en]\n     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]\n     * @description\n     *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]\n     *   [ja]指定したページをページスタックの一番上に移動します。もし指定したページが無かった場合新しくpushされます。[/ja]\n     */\n\n  }, {\n    key: 'bringPageTop',\n    value: function bringPageTop(item) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : _typeof(item)) === -1) {\n        throw new Error('First argument must be a page name or the index of an existing page. You supplied ' + item);\n      }\n      var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);\n      var page = this.pages[index];\n\n      if (index < 0) {\n        return this.pushPage(item, options);\n      }\n\n      var _preparePageAndOption5 = this._preparePageAndOptions(page, options);\n\n      options = _preparePageAndOption5.options;\n\n\n      if (index === this.pages.length - 1) {\n        return Promise.resolve(page);\n      }\n      if (!page) {\n        throw new Error('Failed to find item ' + item);\n      }\n      if (this._isRunning) {\n        return Promise.reject('pushPage is already running.');\n      }\n      if (this._emitPrePushEvent()) {\n        return Promise.reject('Canceled in prepush event.');\n      }\n\n      page.style.visibility = 'hidden';\n      page.parentNode.appendChild(page);\n      return this._pushPage(options);\n    }\n  }, {\n    key: '_preparePageAndOptions',\n    value: function _preparePageAndOptions(page) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {\n        throw new Error('options must be an object. You supplied ' + options);\n      }\n\n      if ((page === null || page === undefined) && options.page) {\n        page = options.page;\n      }\n\n      options = util.extend({}, this.options || {}, options, { page: page });\n\n      return { page: page, options: options };\n    }\n  }, {\n    key: '_updateLastPageBackButton',\n    value: function _updateLastPageBackButton() {\n      var index = this.pages.length - 1;\n      if (index >= 0) {\n        this.pages[index].updateBackButton(index > 0);\n      }\n    }\n  }, {\n    key: '_normalizeIndex',\n    value: function _normalizeIndex(index) {\n      return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;\n    }\n  }, {\n    key: '_onDeviceBackButton',\n    value: function _onDeviceBackButton(event) {\n      if (this.pages.length > 1) {\n        this.popPage();\n      } else {\n        event.callParentHandler();\n      }\n    }\n  }, {\n    key: '_lastIndexOfPage',\n    value: function _lastIndexOfPage(pageName) {\n      var index = void 0;\n      for (index = this.pages.length - 1; index >= 0; index--) {\n        if (!this._pageMap.has(this.pages[index])) {\n          throw Error('This is bug.');\n        }\n\n        if (pageName === this._pageMap.get(this.pages[index])) {\n          break;\n        }\n      }\n      return index;\n    }\n  }, {\n    key: '_emitPreEvent',\n    value: function _emitPreEvent(name) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var isCanceled = false;\n\n      util.triggerElementEvent(this, 'pre' + name, util.extend({\n        navigator: this,\n        currentPage: this.pages[this.pages.length - 1],\n        cancel: function cancel() {\n          return isCanceled = true;\n        }\n      }, data));\n\n      return isCanceled;\n    }\n  }, {\n    key: '_emitPrePushEvent',\n    value: function _emitPrePushEvent() {\n      return this._emitPreEvent('push');\n    }\n  }, {\n    key: '_emitPrePopEvent',\n    value: function _emitPrePopEvent() {\n      var l = this.pages.length;\n      return this._emitPreEvent('pop', {\n        leavePage: this.pages[l - 1],\n        enterPage: this.pages[l - 2]\n      });\n    }\n\n    // TODO: 書き直す\n\n  }, {\n    key: '_createPageElement',\n    value: function _createPageElement(templateHTML) {\n      var pageElement = util.createElement(internal$1.normalizePageHTML(templateHTML));\n      this._verifyPageElement(pageElement);\n      return pageElement;\n    }\n\n    /**\n     * @param {Element} element\n     */\n\n  }, {\n    key: '_verifyPageElement',\n    value: function _verifyPageElement(element) {\n      if (element.nodeName.toLowerCase() !== 'ons-page') {\n        throw new Error('You must supply an \"ons-page\" element to \"ons-navigator\".');\n      }\n    }\n\n    /**\n     * @property onDeviceBackButton\n     * @type {Object}\n     * @description\n     *   [en]Back-button handler.[/en]\n     *   [ja]バックボタンハンドラ。[/ja]\n     */\n\n  }, {\n    key: '_show',\n    value: function _show() {\n      var _this11 = this;\n\n      this.loaded.then(function () {\n        return _this11.topPage && _this11.topPage._show();\n      });\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      this.topPage && this.topPage._hide();\n    }\n  }, {\n    key: '_destroy',\n    value: function _destroy() {\n      for (var i = this.pages.length - 1; i >= 0; i--) {\n        this._pageLoader.unload(this.pages[i]);\n      }\n\n      this.remove();\n    }\n\n    /**\n     * @param {String} name\n     * @param {Function} Animator\n     */\n\n  }, {\n    key: 'pageLoader',\n    get: function get$$1() {\n      return this._pageLoader;\n    },\n    set: function set$$1(pageLoader) {\n      if (!(pageLoader instanceof PageLoader)) {\n        throw Error('First parameter must be an instance of PageLoader.');\n      }\n      this._pageLoader = pageLoader;\n    }\n  }, {\n    key: 'page',\n    get: function get$$1() {\n      return this._page;\n    },\n    set: function set$$1(page) {\n      this._page = page;\n    }\n  }, {\n    key: 'onDeviceBackButton',\n    get: function get$$1() {\n      return this._backButtonHandler;\n    },\n    set: function set$$1(callback) {\n      if (this._backButtonHandler) {\n        this._backButtonHandler.destroy();\n      }\n\n      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);\n    }\n\n    /**\n     * @property topPage\n     * @readonly\n     * @type {HTMLElement}\n     * @description\n     *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]\n     *   [ja]現在のページを取得します。pushPage()やresetToPage()メソッドの引数を取得できます。[/ja]\n     */\n\n  }, {\n    key: 'topPage',\n    get: function get$$1() {\n      var last = this.lastElementChild;\n      while (last && last.tagName !== 'ONS-PAGE') {\n        last = last.previousElementSibling;\n      }\n      return last;\n    }\n\n    /**\n     * @property pages\n     * @readonly\n     * @type {Array}\n     * @description\n     *   [en]Copy of the navigator's page stack.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'pages',\n    get: function get$$1() {\n      return util.arrayFrom(this.children).filter(function (element) {\n        return element.tagName === 'ONS-PAGE';\n      });\n    }\n\n    /**\n     * @property onSwipe\n     * @type {Function}\n     * @description\n     *   [en]Hook called whenever the user slides the navigator (swipe-to-pop). It gets a decimal ratio (0-1) and an animationOptions object as arguments.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'onSwipe',\n    get: function get$$1() {\n      return this._onSwipe;\n    },\n    set: function set$$1(value) {\n      if (value && !(value instanceof Function)) {\n        throw new Error('\\'onSwipe\\' must be a function.');\n      }\n      this._onSwipe = value;\n    }\n\n    /**\n     * @property options\n     * @type {Object}\n     * @description\n     *   [en]Default options object. Attributes have priority over this property.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property options.animation\n     * @type {String}\n     * @description\n     *   [en]\n     *     Animation name. Available animations are `\"slide\"`, `\"lift\"`, `\"fade\"` and `\"none\"`.\n     *     These are platform based animations. For fixed animations, add `\"-ios\"` or `\"-md\"` suffix to the animation name. E.g. `\"lift-ios\"`, `\"lift-md\"`. Defaults values are `\"slide-ios\"` and `\"fade-md\"`.\n     *   [/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property options.animationOptions\n     * @type {String}\n     * @description\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]\n     */\n\n    /**\n     * @property options.callback\n     * @type {String}\n     * @description\n     *   [en]Function that is called when the transition has ended.[/en]\n     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]\n     */\n\n  }, {\n    key: 'options',\n    get: function get$$1() {\n      return this._options;\n    },\n    set: function set$$1(object) {\n      this._options = object;\n    }\n  }, {\n    key: '_isRunning',\n    set: function set$$1(value) {\n      this.setAttribute('_is-running', value ? 'true' : 'false');\n    },\n    get: function get$$1() {\n      return JSON.parse(this.getAttribute('_is-running'));\n    }\n  }], [{\n    key: 'registerAnimator',\n    value: function registerAnimator(name, Animator) {\n      if (!(Animator.prototype instanceof NavigatorAnimator)) {\n        throw new Error('\"Animator\" param must inherit NavigatorElement.NavigatorAnimator');\n      }\n\n      _animatorDict$4[name] = Animator;\n    }\n  }, {\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['animation', 'swipeable'];\n    }\n  }, {\n    key: 'animators',\n    get: function get$$1() {\n      return _animatorDict$4;\n    }\n  }, {\n    key: 'NavigatorAnimator',\n    get: function get$$1() {\n      return NavigatorAnimator;\n    }\n  }, {\n    key: 'events',\n    get: function get$$1() {\n      return ['prepush', 'postpush', 'prepop', 'postpop'];\n    }\n  }, {\n    key: 'rewritables',\n    get: function get$$1() {\n      return rewritables;\n    }\n  }]);\n  return NavigatorElement;\n}(BaseElement);\n\nons$1.elements.Navigator = NavigatorElement;\ncustomElements.define('ons-navigator', NavigatorElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$13 = 'toolbar';\n\nvar scheme$21 = {\n  '': 'toolbar--*',\n  '.toolbar__left': 'toolbar--*__left',\n  '.toolbar__center': 'toolbar--*__center',\n  '.toolbar__right': 'toolbar--*__right'\n};\n\n/**\n * @element ons-toolbar\n * @category page\n * @modifier material\n *   [en]Material Design toolbar.[/en]\n *   [ja][/ja]\n * @modifier transparent\n *   [en]Transparent toolbar.[/en]\n *   [ja]透明な背景を持つツールバーを表示します。[/ja]\n * @modifier cover-content\n *   [en]Displays the toolbar on top of the page's content. Should be combined with `transparent` modifier.[/en]\n *   [ja][/ja]\n * @modifier noshadow\n *   [en]Toolbar without shadow.[/en]\n *   [ja]ツールバーに影を付けずに表示します。[/ja]\n * @description\n *   [en]\n *     Toolbar component that can be used with navigation.\n *\n *     Left, center and right container can be specified by class names.\n *\n *     This component will automatically displays as a Material Design toolbar when running on Android devices.\n *   [/en]\n *   [ja]ナビゲーションで使用するツールバー用コンポーネントです。クラス名により、左、中央、右のコンテナを指定できます。[/ja]\n * @codepen aHmGL\n * @tutorial vanilla/Reference/page\n * @guide compilation.html#toolbar-compilation [en]Adding a toolbar[/en][ja]ツールバーの追加[/ja]\n * @seealso ons-bottom-toolbar\n *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]\n *   [ja]ons-bottom-toolbarコンポーネント[/ja]\n * @seealso ons-back-button\n *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]\n *   [ja]ons-back-buttonコンポーネント[/ja]\n * @seealso ons-toolbar-button\n *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]\n *   [ja]ons-toolbar-buttonコンポーネント[/ja]\n * @example\n * <ons-page>\n *   <ons-toolbar>\n *     <div class=\"left\">\n *       <ons-back-button>\n *         Back\n *       </ons-back-button>\n *     </div>\n *     <div class=\"center\">\n *       Title\n *     </div>\n *     <div class=\"right\">\n *       <ons-toolbar-button>\n *         <ons-icon icon=\"md-menu\"></ons-icon>\n *       </ons-toolbar-button>\n *     </div>\n *   </ons-toolbar>\n * </ons-page>\n */\n\nvar ToolbarElement = function (_BaseElement) {\n  inherits(ToolbarElement, _BaseElement);\n\n  /**\n   * @attribute inline\n   * @initonly\n   * @description\n   *   [en]Display the toolbar as an inline element.[/en]\n   *   [ja]ツールバーをインラインに置きます。スクロール領域内にそのまま表示されます。[/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @description\n   *   [en]The appearance of the toolbar.[/en]\n   *   [ja]ツールバーの表現を指定します。[/ja]\n   */\n\n  function ToolbarElement() {\n    classCallCheck(this, ToolbarElement);\n\n    var _this = possibleConstructorReturn(this, (ToolbarElement.__proto__ || Object.getPrototypeOf(ToolbarElement)).call(this));\n\n    contentReady(_this, function () {\n      _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(ToolbarElement, [{\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$13, scheme$21);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$21);\n          break;\n      }\n    }\n\n    /**\n     * @return {HTMLElement}\n     */\n\n  }, {\n    key: '_getToolbarLeftItemsElement',\n    value: function _getToolbarLeftItemsElement() {\n      return this.querySelector('.left') || internal$1.nullElement;\n    }\n\n    /**\n     * @return {HTMLElement}\n     */\n\n  }, {\n    key: '_getToolbarCenterItemsElement',\n    value: function _getToolbarCenterItemsElement() {\n      return this.querySelector('.center') || internal$1.nullElement;\n    }\n\n    /**\n     * @return {HTMLElement}\n     */\n\n  }, {\n    key: '_getToolbarRightItemsElement',\n    value: function _getToolbarRightItemsElement() {\n      return this.querySelector('.right') || internal$1.nullElement;\n    }\n\n    /**\n     * @return {HTMLElement}\n     */\n\n  }, {\n    key: '_getToolbarBackButtonLabelElement',\n    value: function _getToolbarBackButtonLabelElement() {\n      return this.querySelector('ons-back-button .back-button__label') || internal$1.nullElement;\n    }\n\n    /**\n     * @return {HTMLElement}\n     */\n\n  }, {\n    key: '_getToolbarBackButtonIconElement',\n    value: function _getToolbarBackButtonIconElement() {\n      return this.querySelector('ons-back-button .back-button__icon') || internal$1.nullElement;\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n      this.classList.add(defaultClassName$13);\n      this._ensureToolbarItemElements();\n      ModifierUtil.initModifier(this, scheme$21);\n    }\n  }, {\n    key: '_ensureToolbarItemElements',\n    value: function _ensureToolbarItemElements() {\n      for (var i = this.childNodes.length - 1; i >= 0; i--) {\n        // case of not element\n        if (this.childNodes[i].nodeType != 1) {\n          this.removeChild(this.childNodes[i]);\n        }\n      }\n\n      var center = this._ensureToolbarElement('center');\n      center.classList.add('toolbar__title');\n\n      if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {\n        var left = this._ensureToolbarElement('left');\n        var right = this._ensureToolbarElement('right');\n\n        if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {\n          this.appendChild(left);\n          this.appendChild(center);\n          this.appendChild(right);\n        }\n      }\n    }\n  }, {\n    key: '_ensureToolbarElement',\n    value: function _ensureToolbarElement(name) {\n      if (util.findChild(this, '.toolbar__' + name)) {\n        var _element = util.findChild(this, '.toolbar__' + name);\n        _element.classList.add(name);\n        return _element;\n      }\n\n      var element = util.findChild(this, '.' + name) || util.create('.' + name);\n      element.classList.add('toolbar__' + name);\n\n      return element;\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'];\n    }\n  }]);\n  return ToolbarElement;\n}(BaseElement);\n\nons$1.elements.Toolbar = ToolbarElement;\ncustomElements.define('ons-toolbar', ToolbarElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$12 = 'page';\nvar scheme$20 = {\n  '': 'page--*',\n  '.page__content': 'page--*__content',\n  '.page__background': 'page--*__background'\n};\n\n/**\n * @element ons-page\n * @category page\n * @modifier material\n *   [en]Material Design style[/en]\n *   [ja][/ja]\n * @description\n *   [en]\n *     This component defines the root of each page. If the content is large it will become scrollable.\n *\n *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.\n *   [/en]\n *   [ja]ページ定義のためのコンポーネントです。このコンポーネントの内容はスクロールが許可されます。[/ja]\n * @tutorial vanilla/Reference/page\n * @guide lifecycle.html#events\n *   [en]Overview of page events[/en]\n *   [ja]Overview of page events[/ja]\n * @guide fundamentals.html#managing-pages\n *   [en]Managing multiple pages[/en]\n *   [ja]複数のページを管理する[/ja]\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @seealso ons-toolbar\n *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]\n *   [ja][/ja]\n * @example\n * <ons-page>\n *   <ons-toolbar>\n *     <div class=\"left\">\n *       <ons-back-button>Back</ons-back-button>\n *     </div>\n *     <div class=\"center\">Title</div>\n *     <div class=\"right\">\n *       <ons-toolbar-button>\n *         <ons-icon icon=\"md-menu\"></ons-icon>\n *       </ons-toolbar-button>\n *     </div>\n *   </ons-toolbar>\n *\n *   <p>Page content</p>\n * </ons-page>\n *\n * @example\n * <script>\n *   myApp.handler = function(done) {\n *     loadMore().then(done);\n *   }\n * </script>\n *\n * <ons-page on-infinite-scroll=\"myApp.handler\">\n *   <ons-toolbar>\n *     <div class=\"center\">List</div>\n *   </ons-toolbar>\n *\n *   <ons-list>\n *     <ons-list-item>#1</ons-list-item>\n *     <ons-list-item>#2</ons-list-item>\n *     <ons-list-item>#3</ons-list-item>\n *     ...\n *   </ons-list>\n * </ons-page>\n */\n\nvar PageElement = function (_BaseElement) {\n  inherits(PageElement, _BaseElement);\n\n  /**\n   * @event init\n   * @description\n   *   [en]Fired right after the page is attached.[/en]\n   *   [ja]ページがアタッチされた後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   */\n\n  /**\n   * @event show\n   * @description\n   *   [en]Fired right after the page is shown.[/en]\n   *   [ja]ページが表示された後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   */\n\n  /**\n   * @event hide\n   * @description\n   *   [en]Fired right after the page is hidden.[/en]\n   *   [ja]ページが隠れた後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   */\n\n  /**\n   * @event destroy\n   * @description\n   *   [en]Fired right before the page is destroyed.[/en]\n   *   [ja]ページが破棄される前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]Specify modifier name to specify custom styles.[/en]\n   *   [ja]スタイル定義をカスタマイズするための名前を指定します。[/ja]\n   */\n\n  /**\n   * @attribute on-infinite-scroll\n   * @type {String}\n   * @description\n   *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]\n   *   [ja][/ja]\n   */\n\n  function PageElement() {\n    classCallCheck(this, PageElement);\n\n    var _this = possibleConstructorReturn(this, (PageElement.__proto__ || Object.getPrototypeOf(PageElement)).call(this));\n\n    _this._deriveHooks();\n\n    _this.classList.add(defaultClassName$12);\n    _this._initialized = false;\n\n    _this._contentObserver = new MutationObserver(function () {\n      _this._tryToSuppressLayerCreation();\n    });\n\n    contentReady(_this, function () {\n      _this._compile();\n\n      _this._isShown = false;\n      _this._contentElement = _this._getContentElement();\n      _this._backgroundElement = _this._getBackgroundElement();\n\n      _this._contentObserver.observe(_this._contentElement, { childList: true });\n      _this._tryToSuppressLayerCreation();\n    });\n    return _this;\n  }\n\n  createClass(PageElement, [{\n    key: '_tryToSuppressLayerCreation',\n    value: function _tryToSuppressLayerCreation() {\n      if (!this._contentElement) {\n        return;\n      }\n\n      var content = this._contentElement;\n      var scrollerSet = new Set(['ons-navigator', 'ons-page', 'ons-tabbar', 'ons-splitter']);\n\n      var shouldSuppress = content.children.length === 1 && scrollerSet.has(content.children[0].nodeName.toLowerCase());\n\n      // If content element has only one element and the element has scroll content, there is no need for layer creation in this content element.\n      if (shouldSuppress) {\n        content.classList.add('page__content--suppress-layer-creation');\n      } else {\n        content.classList.remove('page__content--suppress-layer-creation');\n      }\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      var _this2 = this;\n\n      autoStyle.prepare(this);\n\n      var toolbar = util.findChild(this, 'ons-toolbar');\n\n      var background = util.findChild(this, '.page__background') || util.findChild(this, '.background') || document.createElement('div');\n      background.classList.add('page__background');\n      this.insertBefore(background, !toolbar && this.firstChild || toolbar && toolbar.nextSibling);\n\n      var content = util.findChild(this, '.page__content') || util.findChild(this, '.content') || document.createElement('div');\n      content.classList.add('page__content');\n      if (!content.parentElement) {\n        util.arrayFrom(this.childNodes).forEach(function (node) {\n          if (node.nodeType !== 1 || _this2._elementShouldBeMoved(node)) {\n            content.appendChild(node); // Can trigger detached connectedCallbacks\n          }\n        });\n      }\n\n      this._tryToFillStatusBar(content); // Must run before child pages try to fill status bar.\n      this.insertBefore(content, background.nextSibling); // Can trigger attached connectedCallbacks\n\n      // Make wrapper pages transparent for animations\n      if (!background.style.backgroundColor && (!toolbar || !util.hasModifier(toolbar, 'transparent')) && content.children.length === 1 && util.isPageControl(content.children[0])) {\n        background.style.backgroundColor = 'transparent';\n      }\n\n      ModifierUtil.initModifier(this, scheme$20);\n    }\n  }, {\n    key: '_elementShouldBeMoved',\n    value: function _elementShouldBeMoved(el) {\n      if (el.classList.contains('page__background')) {\n        return false;\n      }\n      var tagName = el.tagName.toLowerCase();\n      if (tagName === 'ons-fab') {\n        return !el.hasAttribute('position');\n      }\n      var fixedElements = ['script', 'ons-toolbar', 'ons-bottom-toolbar', 'ons-modal', 'ons-speed-dial', 'ons-dialog', 'ons-alert-dialog', 'ons-popover', 'ons-action-sheet'];\n      return el.hasAttribute('inline') || fixedElements.indexOf(tagName) === -1;\n    }\n  }, {\n    key: '_tryToFillStatusBar',\n    value: function _tryToFillStatusBar() {\n      var _this3 = this;\n\n      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;\n\n      internal$1.autoStatusBarFill(function () {\n        util.toggleAttribute(_this3, 'status-bar-fill', !util.findParent(_this3, function (e) {\n          return e.hasAttribute('status-bar-fill');\n        }) // Not already filled\n        && (_this3._canAnimateToolbar(content) || !util.findChild(content, util.isPageControl)) // Has toolbar or cannot delegate\n        );\n      });\n    }\n  }, {\n    key: '_canAnimateToolbar',\n    value: function _canAnimateToolbar() {\n      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;\n\n      if (util.findChild(this, 'ons-toolbar')) {\n        return true;\n      }\n      return !!util.findChild(content, function (el) {\n        return util.match(el, 'ons-toolbar') && !el.hasAttribute('inline');\n      });\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this4 = this;\n\n      if (!util.isAttached(this)) {\n        // Avoid detached calls\n        return;\n      }\n\n      contentReady(this, function () {\n        _this4._tryToFillStatusBar(); // Ensure status bar when the element was compiled before connected\n\n        if (_this4.hasAttribute('on-infinite-scroll')) {\n          _this4.attributeChangedCallback('on-infinite-scroll', null, _this4.getAttribute('on-infinite-scroll'));\n        }\n\n        if (!_this4._initialized) {\n          _this4._initialized = true;\n\n          setImmediate(function () {\n            _this4.onInit && _this4.onInit();\n            util.triggerElementEvent(_this4, 'init');\n          });\n\n          if (!util.hasAnyComponentAsParent(_this4)) {\n            setImmediate(function () {\n              return _this4._show();\n            });\n          }\n        }\n      });\n    }\n  }, {\n    key: 'updateBackButton',\n    value: function updateBackButton(show) {\n      if (this.backButton) {\n        show ? this.backButton.show() : this.backButton.hide();\n      }\n    }\n  }, {\n    key: '_onScroll',\n    value: function _onScroll() {\n      var _this5 = this;\n\n      var c = this._contentElement,\n          overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;\n\n      if (this._onInfiniteScroll && !this._loadingContent && overLimit) {\n        this._loadingContent = true;\n        this._onInfiniteScroll(function () {\n          return _this5._loadingContent = false;\n        });\n      }\n    }\n\n    /**\n     * @property onDeviceBackButton\n     * @type {Object}\n     * @description\n     *   [en]Back-button handler.[/en]\n     *   [ja]バックボタンハンドラ。[/ja]\n     */\n\n  }, {\n    key: '_getContentElement',\n    value: function _getContentElement() {\n      var result = util.findChild(this, '.page__content');\n      if (result) {\n        return result;\n      }\n      throw Error('fail to get \".page__content\" element.');\n    }\n  }, {\n    key: '_getBackgroundElement',\n    value: function _getBackgroundElement() {\n      var result = util.findChild(this, '.page__background');\n      if (result) {\n        return result;\n      }\n      throw Error('fail to get \".page__background\" element.');\n    }\n  }, {\n    key: '_getBottomToolbarElement',\n    value: function _getBottomToolbarElement() {\n      return util.findChild(this, 'ons-bottom-toolbar') || internal$1.nullElement;\n    }\n  }, {\n    key: '_getToolbarElement',\n    value: function _getToolbarElement() {\n      return util.findChild(this, 'ons-toolbar') || document.createElement('ons-toolbar');\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      var _this6 = this;\n\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$12, scheme$20);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$20);\n          break;\n        case 'on-infinite-scroll':\n          if (current === null) {\n            this.onInfiniteScroll = null;\n          } else {\n            this.onInfiniteScroll = function (done) {\n              var f = util.findFromPath(current);\n              _this6.onInfiniteScroll = f;\n              f(done);\n            };\n          }\n          break;\n      }\n    }\n  }, {\n    key: '_show',\n    value: function _show() {\n      if (!this._isShown && util.isAttached(this)) {\n        this._isShown = true;\n        this.onShow && this.onShow();\n        util.triggerElementEvent(this, 'show');\n        util.propagateAction(this, '_show');\n      }\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      if (this._isShown) {\n        this._isShown = false;\n        this.onHide && this.onHide();\n        util.triggerElementEvent(this, 'hide');\n        util.propagateAction(this, '_hide');\n      }\n    }\n  }, {\n    key: '_destroy',\n    value: function _destroy() {\n      this._hide();\n\n      this.onDestroy && this.onDestroy();\n      util.triggerElementEvent(this, 'destroy');\n\n      if (this.onDeviceBackButton) {\n        this.onDeviceBackButton.destroy();\n      }\n\n      util.propagateAction(this, '_destroy');\n\n      this.remove();\n    }\n  }, {\n    key: '_deriveHooks',\n    value: function _deriveHooks() {\n      var _this7 = this;\n\n      this.constructor.events.forEach(function (event) {\n        var key = 'on' + event.charAt(0).toUpperCase() + event.slice(1);\n        Object.defineProperty(_this7, key, {\n          enumerable: true,\n          get: function get$$1() {\n            return _this7['_' + key];\n          },\n          set: function set$$1(value) {\n            if (!(value instanceof Function)) {\n              throw new Error(key + ' hook must be a function');\n            }\n            _this7['_' + key] = value.bind(_this7);\n          }\n        });\n      });\n    }\n  }, {\n    key: 'name',\n    set: function set$$1(str) {\n      this.setAttribute('name', str);\n    },\n    get: function get$$1() {\n      return this.getAttribute('name');\n    }\n  }, {\n    key: 'backButton',\n    get: function get$$1() {\n      return this.querySelector('ons-back-button');\n    }\n\n    /**\n     * @property onInfiniteScroll\n     * @description\n     *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]\n     *  [ja][/ja]\n     */\n\n  }, {\n    key: 'onInfiniteScroll',\n    set: function set$$1(value) {\n      var _this8 = this;\n\n      if (value && !(value instanceof Function)) {\n        throw new Error('onInfiniteScroll must be a function or null');\n      }\n\n      contentReady(this, function () {\n        if (!value) {\n          _this8._contentElement.removeEventListener('scroll', _this8._boundOnScroll);\n        } else if (!_this8._onInfiniteScroll) {\n          _this8._infiniteScrollLimit = 0.9;\n          _this8._boundOnScroll = _this8._onScroll.bind(_this8);\n          setImmediate(function () {\n            return _this8._contentElement.addEventListener('scroll', _this8._boundOnScroll);\n          });\n        }\n        _this8._onInfiniteScroll = value;\n      });\n    },\n    get: function get$$1() {\n      return this._onInfiniteScroll;\n    }\n  }, {\n    key: 'onDeviceBackButton',\n    get: function get$$1() {\n      return this._backButtonHandler;\n    },\n    set: function set$$1(callback) {\n      if (this._backButtonHandler) {\n        this._backButtonHandler.destroy();\n      }\n\n      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);\n    }\n  }, {\n    key: 'scrollTop',\n    get: function get$$1() {\n      return this._contentElement.scrollTop;\n    },\n    set: function set$$1(newValue) {\n      this._contentElement.scrollTop = newValue;\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'on-infinite-scroll', 'class'];\n    }\n  }, {\n    key: 'events',\n    get: function get$$1() {\n      return ['init', 'show', 'hide', 'destroy'];\n    }\n\n    /**\n     * @property data\n     * @type {*}\n     * @description\n     *   [en]User's custom data passed to `pushPage()`-like methods.[/en]\n     *   [ja][/ja]\n     */\n\n  }]);\n  return PageElement;\n}(BaseElement);\n\nons$1.elements.Page = PageElement;\ncustomElements.define('ons-page', PageElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\nvar PopoverAnimator = function (_BaseAnimator) {\n  inherits(PopoverAnimator, _BaseAnimator);\n\n  /**\n   * @param {Object} options\n   * @param {String} options.timing\n   * @param {Number} options.duration\n   * @param {Number} options.delay\n   */\n  function PopoverAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.2 : _ref$duration;\n\n    classCallCheck(this, PopoverAnimator);\n    return possibleConstructorReturn(this, (PopoverAnimator.__proto__ || Object.getPrototypeOf(PopoverAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  createClass(PopoverAnimator, [{\n    key: 'show',\n    value: function show(popover, callback) {\n      callback();\n    }\n  }, {\n    key: 'hide',\n    value: function hide(popover, callback) {\n      callback();\n    }\n  }, {\n    key: '_animate',\n    value: function _animate(element, _ref2) {\n      var from = _ref2.from,\n          to = _ref2.to,\n          options = _ref2.options,\n          callback = _ref2.callback,\n          _ref2$restore = _ref2.restore,\n          restore = _ref2$restore === undefined ? false : _ref2$restore,\n          animation = _ref2.animation;\n\n      options = util.extend({}, this.options, options);\n\n      if (animation) {\n        from = animation.from;\n        to = animation.to;\n      }\n\n      animation = Animit(element);\n      if (restore) {\n        animation = animation.saveStyle();\n      }\n      animation = animation.queue(from).wait(this.delay).queue({\n        css: to,\n        duration: this.duration,\n        timing: this.timing\n      });\n      if (restore) {\n        animation = animation.restoreStyle();\n      }\n      if (callback) {\n        animation = animation.queue(function (done) {\n          callback();\n          done();\n        });\n      }\n      return animation;\n    }\n  }, {\n    key: '_animateAll',\n    value: function _animateAll(element, animations) {\n      var _this2 = this;\n\n      Object.keys(animations).forEach(function (key) {\n        return _this2._animate(element[key], animations[key]).play();\n      });\n    }\n  }]);\n  return PopoverAnimator;\n}(BaseAnimator);\n\nvar fade = {\n  out: {\n    from: { opacity: 1.0 },\n    to: { opacity: 0 }\n  },\n  in: {\n    from: { opacity: 0 },\n    to: { opacity: 1.0 }\n  }\n};\n\nvar MDFadePopoverAnimator = function (_PopoverAnimator) {\n  inherits(MDFadePopoverAnimator, _PopoverAnimator);\n\n  function MDFadePopoverAnimator() {\n    classCallCheck(this, MDFadePopoverAnimator);\n    return possibleConstructorReturn(this, (MDFadePopoverAnimator.__proto__ || Object.getPrototypeOf(MDFadePopoverAnimator)).apply(this, arguments));\n  }\n\n  createClass(MDFadePopoverAnimator, [{\n    key: 'show',\n    value: function show(popover, callback) {\n      this._animateAll(popover, {\n        _mask: fade.in,\n        _popover: { animation: fade.in, restore: true, callback: callback }\n      });\n    }\n  }, {\n    key: 'hide',\n    value: function hide(popover, callback) {\n      this._animateAll(popover, {\n        _mask: fade.out,\n        _popover: { animation: fade.out, restore: true, callback: callback }\n      });\n    }\n  }]);\n  return MDFadePopoverAnimator;\n}(PopoverAnimator);\n\nvar IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {\n  inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);\n\n  function IOSFadePopoverAnimator() {\n    classCallCheck(this, IOSFadePopoverAnimator);\n    return possibleConstructorReturn(this, (IOSFadePopoverAnimator.__proto__ || Object.getPrototypeOf(IOSFadePopoverAnimator)).apply(this, arguments));\n  }\n\n  createClass(IOSFadePopoverAnimator, [{\n    key: 'show',\n    value: function show(popover, callback) {\n      this._animateAll(popover, {\n        _mask: fade.in,\n        _popover: {\n          from: {\n            transform: 'scale3d(1.3, 1.3, 1.0)',\n            opacity: 0\n          },\n          to: {\n            transform: 'scale3d(1.0, 1.0,  1.0)',\n            opacity: 1.0\n          },\n          restore: true,\n          callback: callback\n        }\n      });\n    }\n  }]);\n  return IOSFadePopoverAnimator;\n}(MDFadePopoverAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$22 = {\n  '.popover': 'popover--*',\n  '.popover-mask': 'popover-mask--*',\n  '.popover__content': 'popover--*__content',\n  '.popover__arrow': 'popover--*__arrow'\n};\n\nvar _animatorDict$5 = {\n  'default': function _default() {\n    return platform.isAndroid() ? MDFadePopoverAnimator : IOSFadePopoverAnimator;\n  },\n  'none': PopoverAnimator,\n  'fade-ios': IOSFadePopoverAnimator,\n  'fade-md': MDFadePopoverAnimator\n};\n\nvar positions = {\n  up: 'bottom',\n  left: 'right',\n  down: 'top',\n  right: 'left'\n};\n\n/**\n * @element ons-popover\n * @category dialog\n * @description\n *  [en]\n *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.\n *\n *    To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createPopover(template)` utility function and the `<ons-template>` tag.\n *\n *    Another common way to use the popover is to display a menu when a button on the screen is tapped. For Material Design, popover looks exactly as a dropdown menu.\n *  [/en]\n *  [ja]ある要素を対象とするポップオーバーを表示するコンポーネントです。[/ja]\n * @codepen ZYYRKo\n * @tutorial vanilla/Reference/popover\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @example\n * <ons-button onclick=\"showPopover(this)\">\n *   Click me!\n * </ons-button>\n *\n * <ons-popover direction=\"down\" id=\"popover\">\n *   <p>This is a popover!</p>\n * </ons-popover>\n *\n * <script>\n *   var showPopover = function(element) {\n *     var popover = document.getElementById('popover');\n *     popover.show(element);\n *   };\n * </script>\n */\n\nvar PopoverElement = function (_BaseDialogElement) {\n  inherits(PopoverElement, _BaseDialogElement);\n\n  /**\n   * @event preshow\n   * @description\n   *   [en]Fired just before the popover is displayed.[/en]\n   *   [ja]ポップオーバーが表示される直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.popover\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Call this function to stop the popover from being shown.[/en]\n   *   [ja]この関数を呼び出すと、ポップオーバーの表示がキャンセルされます。[/ja]\n   */\n\n  /**\n   * @event postshow\n   * @description\n   *   [en]Fired just after the popover is displayed.[/en]\n   *   [ja]ポップオーバーが表示された直後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.popover\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @event prehide\n   * @description\n   *   [en]Fired just before the popover is hidden.[/en]\n   *   [ja]ポップオーバーが隠れる直前に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.popover\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Call this function to stop the popover from being hidden.[/en]\n   *   [ja]この関数を呼び出すと、ポップオーバーが隠れる処理をキャンセルします。[/ja]\n   */\n\n  /**\n   * @event posthide\n   * @description\n   *   [en]Fired just after the popover is hidden.[/en]\n   *   [ja]ポップオーバーが隠れた後に発火します。[/ja]\n   * @param {Object} event [en]Event object.[/en]\n   * @param {Object} event.popover\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *  [en]The appearance of the popover.[/en]\n   *  [ja]ポップオーバーの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute direction\n   * @type {String}\n   * @description\n   *  [en]\n   *    A space separated list of directions. If more than one direction is specified,\n   *    it will be chosen automatically. Valid directions are `\"up\"`, `\"down\"`, `\"left\"` and `\"right\"`.\n   *  [/en]\n   *  [ja]\n   *    ポップオーバーを表示する方向を空白区切りで複数指定できます。\n   *    指定できる方向は、\"up\", \"down\", \"left\", \"right\"の4つです。空白区切りで複数指定することもできます。\n   *    複数指定された場合、対象とする要素に合わせて指定した値から自動的に選択されます。\n   *  [/ja]\n   */\n\n  /**\n   * @attribute cancelable\n   * @description\n   *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]\n   *   [ja]この属性があると、ポップオーバーが表示された時に、背景やバックボタンをタップした時にをポップオーバー閉じます。[/ja]\n   */\n\n  /**\n   * @attribute cover-target\n   * @description\n   *   [en]If set the popover will cover the target on the screen.[/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute animation\n   * @type {String}\n   * @description\n   *   [en]The animation used when showing an hiding the popover. Can be either `\"none\"`, `\"default\"`, `\"fade-ios\"` or `\"fade-md\"`.[/en]\n   *   [ja]ポップオーバーを表示する際のアニメーション名を指定します。[/ja]\n   */\n\n  /**\n   * @attribute animation-options\n   * @type {Expression}\n   * @description\n   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]\n   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]\n   */\n\n  /**\n   * @attribute mask-color\n   * @type {Color}\n   * @description\n   *   [en]Color of the background mask. Default is `\"rgba(0, 0, 0, 0.2)\"`.[/en]\n   *   [ja]背景のマスクの色を指定します。デフォルトは\"rgba(0, 0, 0, 0.2)\"です。[/ja]\n   */\n\n  function PopoverElement() {\n    classCallCheck(this, PopoverElement);\n\n    var _this = possibleConstructorReturn(this, (PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement)).call(this));\n\n    _this._boundOnChange = _this._onChange.bind(_this);\n\n    contentReady(_this, function () {\n      _this._compile();\n      _this.style.display = 'none';\n    });\n    return _this;\n  }\n\n  createClass(PopoverElement, [{\n    key: '_updateAnimatorFactory',\n    value: function _updateAnimatorFactory() {\n      return new AnimatorFactory({\n        animators: _animatorDict$5,\n        baseClass: PopoverAnimator,\n        baseClassName: 'PopoverAnimator',\n        defaultAnimation: this.getAttribute('animation') || 'default'\n      });\n    }\n  }, {\n    key: '_toggleStyle',\n    value: function _toggleStyle(shouldShow) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (shouldShow) {\n        this.style.display = 'block';\n        this._currentTarget = options.target;\n        this._positionPopover(options.target);\n      } else {\n        this.style.display = 'none';\n        this._clearStyles();\n      }\n    }\n  }, {\n    key: '_positionPopover',\n    value: function _positionPopover(target) {\n      var radius = this._radius,\n          contentElement = this._content,\n          margin = this._margin;\n\n      var safeAreaLengths = iPhoneXPatch.getSafeAreaLengths();\n      var safeAreaRect = iPhoneXPatch.getSafeAreaDOMRect();\n      var targetRect = target.getBoundingClientRect();\n      var isMD = util.hasModifier(this, 'material');\n      var cover = isMD && this.hasAttribute('cover-target');\n\n      // Distance from each side of the safe area (with margin) to the target element\n      var targetDistance = {\n        top: targetRect.top - (safeAreaRect.top + margin),\n        left: targetRect.left - (safeAreaRect.left + margin),\n        bottom: safeAreaRect.bottom - margin - targetRect.bottom,\n        right: safeAreaRect.right - margin - targetRect.right\n      };\n\n      // Distance from each side of the safe area (with margin) to the geometric center of the target element\n      var targetCenterDistanceFrom = {\n        top: targetRect.top + Math.round(targetRect.height / 2) - (safeAreaRect.top + margin),\n        left: targetRect.left + Math.round(targetRect.width / 2) - (safeAreaRect.left + margin),\n        bottom: safeAreaRect.bottom - margin - targetRect.bottom + Math.round(targetRect.height / 2),\n        right: safeAreaRect.right - margin - targetRect.right + Math.round(targetRect.width / 2)\n      };\n\n      var _calculateDirections2 = this._calculateDirections(targetDistance),\n          vertical = _calculateDirections2.vertical,\n          primaryDirection = _calculateDirections2.primary,\n          secondaryDirection = _calculateDirections2.secondary;\n\n      this._currentDirection = primaryDirection;\n      util.addModifier(this, primaryDirection);\n\n      var sizeName = vertical ? 'width' : 'height';\n      // Get .popover__content size\n      var contentSize = function (style) {\n        return {\n          width: parseInt(style.getPropertyValue('width'), 10),\n          height: parseInt(style.getPropertyValue('height'), 10)\n        };\n      }(window.getComputedStyle(contentElement));\n\n      // Setting .popover position.\n      var targetAndArrowLength = cover ? 0 : (vertical ? targetRect.height : targetRect.width) + (isMD ? 0 : 14);\n      var primaryOffset = Math.max(safeAreaLengths[primaryDirection] + margin, safeAreaLengths[primaryDirection] + margin + targetDistance[primaryDirection] + targetAndArrowLength);\n      var secondaryOffset = Math.max(safeAreaLengths[secondaryDirection] + margin, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - contentSize[sizeName] / 2);\n      this._popover.style[primaryDirection] = primaryOffset + 'px';\n      this._popover.style[secondaryDirection] = secondaryOffset + 'px';\n\n      // Setting .popover__arrow position.\n      this._arrow.style[secondaryDirection] = Math.max(radius, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - secondaryOffset) + 'px';\n    }\n  }, {\n    key: '_calculateDirections',\n    value: function _calculateDirections(distance) {\n      var options = (this.getAttribute('direction') || 'up down left right').split(/\\s+/).map(function (e) {\n        return positions[e];\n      });\n      var primary = options.sort(function (a, b) {\n        return distance[a] - distance[b];\n      })[0];\n      var vertical = 'top' == primary || 'bottom' == primary;\n      var secondary = void 0;\n\n      if (vertical) {\n        secondary = distance.left < distance.right ? 'left' : 'right';\n      } else {\n        secondary = distance.top < distance.bottom ? 'top' : 'bottom';\n      }\n\n      return { vertical: vertical, primary: primary, secondary: secondary };\n    }\n  }, {\n    key: '_clearStyles',\n    value: function _clearStyles() {\n      var _this2 = this;\n\n      this._currentDirection = null;\n      ['top', 'bottom', 'left', 'right'].forEach(function (e) {\n        _this2._arrow.style[e] = _this2._content.style[e] = _this2._popover.style[e] = '';\n        util.removeModifier(_this2, e);\n      });\n    }\n  }, {\n    key: '_onChange',\n    value: function _onChange() {\n      var _this3 = this;\n\n      setImmediate(function () {\n        if (_this3._currentTarget) {\n          _this3._positionPopover(_this3._currentTarget);\n        }\n      });\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      if (this._popover && this._mask) {\n        return;\n      }\n\n      var hasDefaultContainer = this._popover && this._content;\n\n      if (hasDefaultContainer) {\n\n        if (!this._mask) {\n          var mask = document.createElement('div');\n          mask.classList.add('popover-mask');\n          this.insertBefore(mask, this.firstChild);\n        }\n\n        if (!this._arrow) {\n          var arrow = document.createElement('div');\n          arrow.classList.add('popover__arrow');\n          this._popover.appendChild(arrow);\n        }\n      } else {\n\n        var template = util.createFragment('\\n        <div class=\"popover-mask\"></div>\\n        <div class=\"popover\">\\n          <div class=\"popover__content\"></div>\\n          <div class=\"popover__arrow\"></div>\\n        </div>\\n      ');\n        var content = template.querySelector('.popover__content');\n\n        while (this.childNodes[0]) {\n          content.appendChild(this.childNodes[0]);\n        }\n\n        this.appendChild(template);\n      }\n\n      // FIXME!\n      if (this.hasAttribute('style')) {\n        this._popover.setAttribute('style', this.getAttribute('style'));\n        this.removeAttribute('style');\n      }\n\n      ModifierUtil.initModifier(this, this._scheme);\n    }\n\n    /**\n     * @method show\n     * @signature show(target, [options])\n     * @param {String|Event|HTMLElement} target\n     *   [en]Target element. Can be either a CSS selector, an event object or a DOM element. It can be also provided as 'options.target' instead. [/en]\n     *   [ja]ポップオーバーのターゲットとなる要素を指定します。CSSセレクタかeventオブジェクトかDOM要素のいずれかを渡せます。[/ja]\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name.  Use one of `\"fade-ios\"`, `\"fade-md\"`, `\"none\"` and `\"default\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"fade-ios\", \"fade-md\", \"none\", \"default\"のいずれかを指定できます。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @param {Function} [options.callback]\n     *   [en]This function is called after the popover has been revealed.[/en]\n     *   [ja]ポップオーバーが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]\n     *   [ja]対象とする要素にポップオーバーを表示します。target引数には、$eventオブジェクトやDOMエレメントやCSSセレクタを渡すことが出来ます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the displayed element[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'show',\n    value: function show(target) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      // Copy options and include options.target\n      if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && !(target instanceof Event) && !(target instanceof HTMLElement)) {\n        options = _extends({}, target);\n      } else {\n        options = _extends({}, options, { target: target });\n      }\n\n      if (typeof options.target === 'string') {\n        options.target = document.querySelector(options.target);\n      } else if (options.target instanceof Event) {\n        options.target = options.target.target;\n      }\n\n      if (typeof options.target === 'undefined') {\n        throw new Error('A target or options.target argument must be defined for the popover.');\n      }\n\n      if (!(options.target instanceof HTMLElement)) {\n        throw new Error('Invalid target for popover.');\n      }\n\n      return get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'show', this).call(this, options);\n    }\n\n    /**\n     * @method hide\n     * @signature hide([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name.  Use one of `\"fade-ios\"`, `\"fade-md\"`, `\"none\"` and `\"default\"`.[/en]\n     *   [ja]アニメーション名を指定します。\"fade-ios\", \"fade-md\", \"none\", \"default\"のいずれかを指定できます。[/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @param {Function} [options.callback]\n     *   [en]This functions is called after the popover has been hidden.[/en]\n     *   [ja]ポップオーバーが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *   [en]Close the popover.[/en]\n     *   [ja]ポップオーバーを閉じます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the hidden element[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property visible\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is visible or not.[/en]\n     *   [ja]要素が見える場合に`true`。[/ja]\n     */\n\n    /**\n     * @property cancelable\n     * @type {Boolean}\n     * @description\n     *   [en]\n     *     A boolean value that specifies whether the popover is cancelable or not.\n     *\n     *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.\n     *   [/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property onDeviceBackButton\n     * @type {Object}\n     * @description\n     *   [en]Back-button handler.[/en]\n     *   [ja]バックボタンハンドラ。[/ja]\n     */\n\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this4 = this;\n\n      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'connectedCallback', this).call(this);\n\n      window.addEventListener('resize', this._boundOnChange, false);\n      this._margin = this._margin || parseInt(window.getComputedStyle(this).getPropertyValue('top'));\n      this._margin = this._margin || 6; // Fix for iframes\n\n      contentReady(this, function () {\n        _this4._radius = parseInt(window.getComputedStyle(_this4._content).getPropertyValue('border-top-left-radius'));\n      });\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'disconnectedCallback', this).call(this);\n      window.removeEventListener('resize', this._boundOnChange, false);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'direction') {\n        return this._boundOnChange();\n      } else if (name === 'modifier') {\n        this._currentDirection && util.addModifier(this, this._currentDirection);\n      }\n      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);\n    }\n\n    /**\n     * @param {String} name\n     * @param {PopoverAnimator} Animator\n     */\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$22;\n    }\n  }, {\n    key: '_mask',\n    get: function get$$1() {\n      return util.findChild(this, '.popover-mask');\n    }\n  }, {\n    key: '_popover',\n    get: function get$$1() {\n      return util.findChild(this, '.popover');\n    }\n  }, {\n    key: '_content',\n    get: function get$$1() {\n      return util.findChild(this._popover, '.popover__content');\n    }\n  }, {\n    key: '_arrow',\n    get: function get$$1() {\n      return util.findChild(this._popover, '.popover__arrow');\n    }\n  }], [{\n    key: 'registerAnimator',\n    value: function registerAnimator(name, Animator) {\n      if (!(Animator.prototype instanceof PopoverAnimator)) {\n        throw new Error('\"Animator\" param must inherit PopoverAnimator');\n      }\n      _animatorDict$5[name] = Animator;\n    }\n  }, {\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return [].concat(toConsumableArray(get(PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement), 'observedAttributes', this)), ['direction']);\n    }\n  }, {\n    key: 'animators',\n    get: function get$$1() {\n      return _animatorDict$5;\n    }\n  }, {\n    key: 'PopoverAnimator',\n    get: function get$$1() {\n      return PopoverAnimator;\n    }\n  }]);\n  return PopoverElement;\n}(BaseDialogElement);\n\nons$1.elements.Popover = PopoverElement;\ncustomElements.define('ons-popover', PopoverElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$23 = {\n  '.progress-bar': 'progress-bar--*',\n  '.progress-bar__primary': 'progress-bar--*__primary',\n  '.progress-bar__secondary': 'progress-bar--*__secondary'\n};\n\nvar template = util.createElement('\\n  <div class=\"progress-bar\">\\n    <div class=\"progress-bar__secondary\"></div>\\n    <div class=\"progress-bar__primary\"></div>\\n  </div>\\n');\n\nvar INDET = 'indeterminate';\n\n/**\n * @element ons-progress-bar\n * @category visual\n * @description\n *   [en]\n *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.\n *   [/en]\n *   [ja][/ja]\n * @codepen zvQbGj\n * @tutorial vanilla/Reference/progress\n * @seealso ons-progress-circular\n *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]\n *   [ja][/ja]\n * @example\n * <ons-progress-bar\n *  value=\"55\"\n *  secondary-value=\"87\">\n * </ons-progress-bar>\n *\n * <ons-progress-bar\n *  indeterminate>\n * </ons-progress-bar>\n */\n\nvar ProgressBarElement = function (_BaseElement) {\n  inherits(ProgressBarElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]Change the appearance of the progress indicator.[/en]\n   *   [ja]プログレスインジケータの見た目を変更します。[/ja]\n   */\n\n  /**\n   * @attribute value\n   * @type {Number}\n   * @description\n   *   [en]Current progress. Should be a value between 0 and 100.[/en]\n   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]\n   */\n\n  /**\n   * @attribute secondary-value\n   * @type {Number}\n   * @description\n   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]\n   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]\n   */\n\n  /**\n   * @attribute indeterminate\n   * @description\n   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]\n   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]\n   */\n\n  function ProgressBarElement() {\n    classCallCheck(this, ProgressBarElement);\n\n    var _this = possibleConstructorReturn(this, (ProgressBarElement.__proto__ || Object.getPrototypeOf(ProgressBarElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(ProgressBarElement, [{\n    key: '_compile',\n    value: function _compile() {\n      if (!this._isCompiled()) {\n        this._template = template.cloneNode(true);\n      } else {\n        this._template = util.findChild(this, '.progress-bar');\n      }\n\n      this._primary = util.findChild(this._template, '.progress-bar__primary');\n      this._secondary = util.findChild(this._template, '.progress-bar__secondary');\n\n      this._updateDeterminate();\n      this._updateValue();\n\n      this.appendChild(this._template);\n\n      autoStyle.prepare(this);\n      ModifierUtil.initModifier(this, scheme$23);\n    }\n  }, {\n    key: '_isCompiled',\n    value: function _isCompiled() {\n      if (!util.findChild(this, '.progress-bar')) {\n        return false;\n      }\n\n      var barElement = util.findChild(this, '.progress-bar');\n\n      if (!util.findChild(barElement, '.progress-bar__secondary')) {\n        return false;\n      }\n\n      if (!util.findChild(barElement, '.progress-bar__primary')) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'modifier') {\n        ModifierUtil.onModifierChanged(last, current, this, scheme$23);\n        this.hasAttribute(INDET) && this._updateDeterminate();\n      } else if (name === 'value' || name === 'secondary-value') {\n        this._updateValue();\n      } else if (name === INDET) {\n        this._updateDeterminate();\n      }\n    }\n  }, {\n    key: '_updateDeterminate',\n    value: function _updateDeterminate() {\n      var _this2 = this;\n\n      contentReady(this, function () {\n        return util.toggleModifier(_this2, INDET, { force: _this2.hasAttribute(INDET) });\n      });\n    }\n  }, {\n    key: '_updateValue',\n    value: function _updateValue() {\n      var _this3 = this;\n\n      contentReady(this, function () {\n        _this3._primary.style.width = _this3.hasAttribute('value') ? _this3.getAttribute('value') + '%' : '0%';\n        _this3._secondary.style.width = _this3.hasAttribute('secondary-value') ? _this3.getAttribute('secondary-value') + '%' : '0%';\n      });\n    }\n\n    /**\n     * @property value\n     * @type {Number}\n     * @description\n     *   [en]Current progress. Should be a value between 0 and 100.[/en]\n     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]\n     */\n\n  }, {\n    key: 'value',\n    set: function set$$1(value) {\n      if (typeof value !== 'number' || value < 0 || value > 100) {\n        throw new Error('Invalid value');\n      }\n\n      this.setAttribute('value', Math.floor(value));\n    },\n    get: function get$$1() {\n      return parseInt(this.getAttribute('value') || '0');\n    }\n\n    /**\n     * @property secondaryValue\n     * @type {Number}\n     * @description\n     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]\n     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]\n     */\n\n  }, {\n    key: 'secondaryValue',\n    set: function set$$1(value) {\n      if (typeof value !== 'number' || value < 0 || value > 100) {\n        throw new Error('Invalid value');\n      }\n\n      this.setAttribute('secondary-value', Math.floor(value));\n    },\n    get: function get$$1() {\n      return parseInt(this.getAttribute('secondary-value') || '0');\n    }\n\n    /**\n     * @property indeterminate\n     * @type {Boolean}\n     * @description\n     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]\n     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]\n     */\n\n  }, {\n    key: 'indeterminate',\n    set: function set$$1(value) {\n      if (value) {\n        this.setAttribute(INDET, '');\n      } else {\n        this.removeAttribute(INDET);\n      }\n    },\n    get: function get$$1() {\n      return this.hasAttribute(INDET);\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'value', 'secondary-value', INDET];\n    }\n  }]);\n  return ProgressBarElement;\n}(BaseElement);\n\nons$1.elements.ProgressBar = ProgressBarElement;\ncustomElements.define('ons-progress-bar', ProgressBarElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$24 = {\n  '.progress-circular': 'progress-circular--*',\n  '.progress-circular__background': 'progress-circular--*__background',\n  '.progress-circular__primary': 'progress-circular--*__primary',\n  '.progress-circular__secondary': 'progress-circular--*__secondary'\n};\n\nvar template$1 = util.createElement('\\n  <svg class=\"progress-circular\">\\n    <circle class=\"progress-circular__background\" />\\n    <circle class=\"progress-circular__secondary\" />\\n    <circle class=\"progress-circular__primary\" />\\n  </svg>\\n');\n\nvar INDET$1 = 'indeterminate';\n\n/**\n * @element ons-progress-circular\n * @category visual\n * @description\n *   [en]\n *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.\n *   [/en]\n *   [ja][/ja]\n * @codepen EVzMjR\n * @tutorial vanilla/Reference/progress\n * @seealso ons-progress-bar\n *   [en]The `<ons-progress-bar>` component displays a bar progress indicator.[/en]\n *   [ja][/ja]\n * @example\n * <ons-progress-circular\n *  value=\"55\"\n *  secondary-value=\"87\">\n * </ons-progress-circular>\n *\n * <ons-progress-circular\n *  indeterminate>\n * </ons-progress-circular>\n */\n\nvar ProgressCircularElement = function (_BaseElement) {\n  inherits(ProgressCircularElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]Change the appearance of the progress indicator.[/en]\n   *   [ja]プログレスインジケータの見た目を変更します。[/ja]\n   */\n\n  /**\n   * @attribute value\n   * @type {Number}\n   * @description\n   *   [en]Current progress. Should be a value between 0 and 100.[/en]\n   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]\n   */\n\n  /**\n   * @attribute secondary-value\n   * @type {Number}\n   * @description\n   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]\n   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]\n   */\n\n  /**\n   * @attribute indeterminate\n   * @description\n   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]\n   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]\n   */\n\n  function ProgressCircularElement() {\n    classCallCheck(this, ProgressCircularElement);\n\n    var _this = possibleConstructorReturn(this, (ProgressCircularElement.__proto__ || Object.getPrototypeOf(ProgressCircularElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(ProgressCircularElement, [{\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'modifier') {\n        ModifierUtil.onModifierChanged(last, current, this, scheme$24);\n        this.hasAttribute(INDET$1) && this._updateDeterminate();\n      } else if (name === 'value' || name === 'secondary-value') {\n        this._updateValue();\n      } else if (name === INDET$1) {\n        this._updateDeterminate();\n      }\n    }\n  }, {\n    key: '_updateDeterminate',\n    value: function _updateDeterminate() {\n      var _this2 = this;\n\n      contentReady(this, function () {\n        return util.toggleModifier(_this2, INDET$1, { force: _this2.hasAttribute(INDET$1) });\n      });\n    }\n  }, {\n    key: '_updateValue',\n    value: function _updateValue() {\n      var _this3 = this;\n\n      if (this.hasAttribute('value')) {\n        contentReady(this, function () {\n          var per = Math.ceil(_this3.getAttribute('value') * 251.32 * 0.01);\n          _this3._primary.style['stroke-dasharray'] = per + '%, 251.32%';\n        });\n      }\n      if (this.hasAttribute('secondary-value')) {\n        contentReady(this, function () {\n          var per = Math.ceil(_this3.getAttribute('secondary-value') * 251.32 * 0.01);\n          _this3._secondary.style.display = null;\n          _this3._secondary.style['stroke-dasharray'] = per + '%, 251.32%';\n        });\n      } else {\n        contentReady(this, function () {\n          _this3._secondary.style.display = 'none';\n        });\n      }\n    }\n\n    /**\n     * @property value\n     * @type {Number}\n     * @description\n     *   [en]Current progress. Should be a value between 0 and 100.[/en]\n     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]\n     */\n\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      if (this._isCompiled()) {\n        this._template = util.findChild(this, '.progress-circular');\n      } else {\n        this._template = template$1.cloneNode(true);\n      }\n\n      this._primary = util.findChild(this._template, '.progress-circular__primary');\n      this._secondary = util.findChild(this._template, '.progress-circular__secondary');\n\n      this._updateDeterminate();\n      this._updateValue();\n\n      this.appendChild(this._template);\n\n      autoStyle.prepare(this);\n      ModifierUtil.initModifier(this, scheme$24);\n    }\n  }, {\n    key: '_isCompiled',\n    value: function _isCompiled() {\n      if (!util.findChild(this, '.progress-circular')) {\n        return false;\n      }\n\n      var svg = util.findChild(this, '.progress-circular');\n\n      if (!util.findChild(svg, '.progress-circular__secondary')) {\n        return false;\n      }\n\n      if (!util.findChild(svg, '.progress-circular__primary')) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: 'value',\n    set: function set$$1(value) {\n      if (typeof value !== 'number' || value < 0 || value > 100) {\n        throw new Error('Invalid value');\n      }\n\n      this.setAttribute('value', Math.floor(value));\n    },\n    get: function get$$1() {\n      return parseInt(this.getAttribute('value') || '0');\n    }\n\n    /**\n     * @property secondaryValue\n     * @type {Number}\n     * @description\n     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]\n     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]\n     */\n\n  }, {\n    key: 'secondaryValue',\n    set: function set$$1(value) {\n      if (typeof value !== 'number' || value < 0 || value > 100) {\n        throw new Error('Invalid value');\n      }\n\n      this.setAttribute('secondary-value', Math.floor(value));\n    },\n    get: function get$$1() {\n      return parseInt(this.getAttribute('secondary-value') || '0');\n    }\n\n    /**\n     * @property indeterminate\n     * @type {Boolean}\n     * @description\n     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]\n     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]\n     */\n\n  }, {\n    key: 'indeterminate',\n    set: function set$$1(value) {\n      if (value) {\n        this.setAttribute(INDET$1, '');\n      } else {\n        this.removeAttribute(INDET$1);\n      }\n    },\n    get: function get$$1() {\n      return this.hasAttribute(INDET$1);\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'value', 'secondary-value', INDET$1];\n    }\n  }]);\n  return ProgressCircularElement;\n}(BaseElement);\n\nons$1.elements.ProgressCircular = ProgressCircularElement;\ncustomElements.define('ons-progress-circular', ProgressCircularElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar STATE_INITIAL = 'initial';\nvar STATE_PREACTION = 'preaction';\nvar STATE_ACTION = 'action';\n\n/**\n * @element ons-pull-hook\n * @category control\n * @description\n *   [en]\n *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.\n *\n *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.\n *   [/en]\n *   [ja][/ja]\n * @codepen WbJogM\n * @tutorial vanilla/Reference/pull-hook\n * @example\n * <ons-page>\n *   <ons-pull-hook>\n *     Release to refresh\n *   </ons-pull-hook>\n * </ons-page>\n *\n * <script>\n *   document.querySelector('ons-pull-hook').onAction = function(done) {\n *     setTimeout(done, 1000);\n *   };\n * </script>\n */\n\nvar PullHookElement = function (_BaseElement) {\n  inherits(PullHookElement, _BaseElement);\n\n  /**\n   * @event changestate\n   * @description\n   *   [en]Fired when the state is changed. The state can be either \"initial\", \"preaction\" or \"action\".[/en]\n   *   [ja]コンポーネントの状態が変わった場合に発火します。状態は、\"initial\", \"preaction\", \"action\"のいずれかです。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクト。[/ja]\n   * @param {Object} event.pullHook\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {String} event.state\n   *   [en]Current state.[/en]\n   *   [ja]現在の状態名を参照できます。[/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *   [en]If this attribute is set the \"pull-to-refresh\" functionality is disabled.[/en]\n   *   [ja]この属性がある時、disabled状態になりアクションが実行されなくなります[/ja]\n   */\n\n  /**\n   * @attribute height\n   * @type {String}\n   * @description\n   *   [en]Specify the height of the component. When pulled down further than this value it will switch to the \"preaction\" state. The default value is \"64px\".[/en]\n   *   [ja]コンポーネントの高さを指定します。この高さ以上にpull downすると\"preaction\"状態に移行します。デフォルトの値は\"64px\"です。[/ja]\n   */\n\n  /**\n   * @attribute threshold-height\n   * @type {String}\n   * @description\n   *   [en]Specify the threshold height. The component automatically switches to the \"action\" state when pulled further than this value. The default value is \"96px\". A negative value or a value less than the height will disable this property.[/en]\n   *   [ja]閾値となる高さを指定します。この値で指定した高さよりもpull downすると、このコンポーネントは自動的に\"action\"状態に移行します。[/ja]\n   */\n\n  /**\n   * @attribute fixed-content\n   * @description\n   *   [en]If this attribute is set the content of the page will not move when pulling.[/en]\n   *   [ja]この属性がある時、プルフックが引き出されている時にもコンテンツは動きません。[/ja]\n   */\n\n  function PullHookElement() {\n    classCallCheck(this, PullHookElement);\n\n    var _this = possibleConstructorReturn(this, (PullHookElement.__proto__ || Object.getPrototypeOf(PullHookElement)).call(this));\n\n    _this._onDrag = _this._onDrag.bind(_this);\n    _this._onDragStart = _this._onDragStart.bind(_this);\n    _this._onDragEnd = _this._onDragEnd.bind(_this);\n    _this._onScroll = _this._onScroll.bind(_this);\n    _this._preventScroll = _this._preventScroll.bind(_this);\n\n    _this._setState(STATE_INITIAL, true);\n    _this._hide(); // Fix for transparent toolbar transitions\n    return _this;\n  }\n\n  createClass(PullHookElement, [{\n    key: '_setStyle',\n    value: function _setStyle() {\n      var height = this.height + 'px';\n      styler(this, { height: height, lineHeight: height });\n      this.style.display === '' && this._show();\n    }\n  }, {\n    key: '_onScroll',\n    value: function _onScroll(event) {\n      var element = this._pageElement;\n\n      if (element.scrollTop < 0) {\n        element.scrollTop = 0;\n      }\n    }\n  }, {\n    key: '_canConsumeGesture',\n    value: function _canConsumeGesture(gesture) {\n      return gesture.direction === 'up' || gesture.direction === 'down';\n    }\n  }, {\n    key: '_onDragStart',\n    value: function _onDragStart(event) {\n      var _this2 = this;\n\n      if (!event.gesture || this.disabled) {\n        return;\n      }\n\n      this._ignoreDrag = event.consumed;\n\n      if (!this._ignoreDrag) {\n        var consume = event.consume;\n        event.consume = function () {\n          consume && consume();\n          _this2._ignoreDrag = true;\n          // This elements resizes .page__content so it is safer\n          // to hide it when other components are dragged.\n          _this2._hide();\n        };\n\n        if (this._canConsumeGesture(event.gesture)) {\n          consume && consume();\n          event.consumed = true;\n          this._show(); // Not enough due to 'dragLockAxis'\n        }\n      }\n\n      this._startScroll = this._pageElement.scrollTop;\n    }\n  }, {\n    key: '_onDrag',\n    value: function _onDrag(event) {\n      var _this3 = this;\n\n      if (!event.gesture || this.disabled || this._ignoreDrag || !this._canConsumeGesture(event.gesture)) {\n        return;\n      }\n\n      // Necessary due to 'dragLockAxis' (25px)\n      if (this.style.display === 'none') {\n        this._show();\n      }\n\n      event.stopPropagation();\n\n      // Hack to make it work on Android 4.4 WebView and iOS UIWebView. Scrolls manually\n      // near the top of the page so there will be no inertial scroll when scrolling down.\n      // Allowing default scrolling will kill all 'touchmove' events.\n      this._pageElement.scrollTop = this._startScroll - event.gesture.deltaY;\n      if (this._pageElement.scrollTop < window.innerHeight && event.gesture.direction !== 'up') {\n        event.gesture.preventDefault();\n      }\n\n      var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);\n      if (scroll !== this._currentTranslation) {\n        if (this._thresholdHeightEnabled() && scroll >= this.thresholdHeight) {\n          event.gesture.stopDetect();\n          setImmediate(function () {\n            return _this3._finish();\n          });\n        } else if (scroll >= this.height) {\n          this._setState(STATE_PREACTION);\n        } else {\n          this._setState(STATE_INITIAL);\n        }\n\n        this._pulling = true;\n        this._translateTo(scroll);\n      }\n    }\n  }, {\n    key: '_onDragEnd',\n    value: function _onDragEnd(event) {\n      this._pulling = false;\n      if (!event.gesture || this.disabled || this._ignoreDrag) {\n        return;\n      }\n\n      event.stopPropagation();\n\n      if (this._currentTranslation > 0) {\n        var scroll = this._currentTranslation;\n\n        if (scroll > this.height) {\n          this._finish();\n        } else {\n          this._translateTo(0, { animate: true });\n        }\n      }\n    }\n  }, {\n    key: '_preventScroll',\n    value: function _preventScroll(event) {\n      // Fix for Android & iOS when starting from scrollTop > 0 or pulling back\n      this._pulling && event.cancelable && event.preventDefault();\n    }\n\n    /**\n     * @property onAction\n     * @type {Function}\n     * @description\n     *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: '_finish',\n    value: function _finish() {\n      var _this4 = this;\n\n      this._setState(STATE_ACTION);\n      this._translateTo(this.height, { animate: true });\n      var action = this.onAction || function (done) {\n        return done();\n      };\n      action(function () {\n        _this4._translateTo(0, { animate: true });\n        _this4._setState(STATE_INITIAL);\n      });\n    }\n\n    /**\n     * @property height\n     * @type {Number}\n     * @description\n     *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: '_thresholdHeightEnabled',\n    value: function _thresholdHeightEnabled() {\n      var th = this.thresholdHeight;\n      return th > 0 && th >= this.height;\n    }\n  }, {\n    key: '_setState',\n    value: function _setState(state, noEvent) {\n      var lastState = this.state;\n\n      this.setAttribute('state', state);\n\n      if (!noEvent && lastState !== this.state) {\n        util.triggerElementEvent(this, 'changestate', {\n          pullHook: this,\n          state: state,\n          lastState: lastState\n        });\n      }\n    }\n\n    /**\n     * @property state\n     * @readonly\n     * @type {String}\n     * @description\n     *   [en]Current state of the element.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: '_show',\n    value: function _show() {\n      var _this5 = this;\n\n      // Run asyncrhonously to avoid conflicts with Animit's style clean\n      setImmediate(function () {\n        _this5.style.display = '';\n        if (_this5._pageElement) {\n          _this5._pageElement.style.marginTop = '-' + _this5.height + 'px';\n        }\n      });\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      this.style.display = 'none';\n      if (this._pageElement) {\n        this._pageElement.style.marginTop = '';\n      }\n    }\n\n    /**\n     * @param {Number} scroll\n     * @param {Object} options\n     * @param {Function} [options.callback]\n     */\n\n  }, {\n    key: '_translateTo',\n    value: function _translateTo(scroll) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this._currentTranslation == 0 && scroll == 0) {\n        return;\n      }\n\n      this._currentTranslation = scroll;\n      var opt = options.animate ? { duration: .3, timing: 'cubic-bezier(.1, .7, .1, 1)' } : {};\n      this._onPull && this._onPull((scroll / this.height).toFixed(2), opt);\n      var scrollElement = this.hasAttribute('fixed-content') ? this : this._pageElement;\n\n      Animit(scrollElement).queue({ transform: 'translate3d(0px, ' + scroll + 'px, 0px)' }, opt).play(function () {\n        scroll === 0 && styler.clear(scrollElement, 'transition transform');\n        options.callback instanceof Function && options.callback();\n      });\n    }\n  }, {\n    key: '_disableDragLock',\n    value: function _disableDragLock() {\n      // e2e tests need it\n      this._dragLockDisabled = true;\n      this._setupListeners(true);\n    }\n  }, {\n    key: '_setupListeners',\n    value: function _setupListeners(add) {\n      var _this6 = this;\n\n      var scrollToggle = function scrollToggle(action) {\n        return _this6._pageElement[action + 'EventListener']('scroll', _this6._onScroll, false);\n      };\n      var gdToggle = function gdToggle(action) {\n        _this6._gestureDetector[action]('drag', _this6._onDrag);\n        _this6._gestureDetector[action]('dragstart', _this6._onDragStart);\n        _this6._gestureDetector[action]('dragend', _this6._onDragEnd);\n        _this6._gestureDetector[action]('touchmove', _this6._preventScroll);\n      };\n\n      if (this._gestureDetector) {\n        gdToggle('off');\n        this._gestureDetector.dispose();\n        this._gestureDetector = null;\n      }\n      scrollToggle('remove');\n\n      if (add) {\n        this._gestureDetector = new GestureDetector(this._pageElement, {\n          dragMinDistance: 1,\n          dragDistanceCorrection: false,\n          dragLockToAxis: !this._dragLockDisabled\n        });\n\n        gdToggle('on');\n        scrollToggle('add');\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      this._currentTranslation = 0;\n      this._pageElement = this.parentNode;\n\n      this._setupListeners(true);\n      this._setStyle();\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this._hide();\n      this._setupListeners(false);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'height' && this._pageElement) {\n        this._setStyle();\n      }\n    }\n  }, {\n    key: 'onAction',\n    get: function get$$1() {\n      return this._onAction;\n    },\n    set: function set$$1(value) {\n      if (value && !(value instanceof Function)) {\n        throw new Error('\\'onAction\\' must be a function or null');\n      }\n      this._onAction = value;\n    }\n\n    /**\n     * @property onPull\n     * @type {Function}\n     * @description\n     *   [en]Hook called whenever the user pulls the element. It gets the pulled distance ratio (scroll / height) and an animationOptions object as arguments.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'onPull',\n    get: function get$$1() {\n      return this._onPull;\n    },\n    set: function set$$1(value) {\n      if (value && !(value instanceof Function)) {\n        throw new Error('\\'onPull\\' must be a function or null.');\n      }\n      this._onPull = value;\n    }\n  }, {\n    key: 'height',\n    set: function set$$1(value) {\n      if (!util.isInteger(value)) {\n        throw new Error('The height must be an integer');\n      }\n\n      this.setAttribute('height', value + 'px');\n    },\n    get: function get$$1() {\n      return parseInt(this.getAttribute('height') || '64', 10);\n    }\n\n    /**\n     * @property thresholdHeight\n     * @type {Number}\n     * @description\n     *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'thresholdHeight',\n    set: function set$$1(value) {\n      if (!util.isInteger(value)) {\n        throw new Error('The threshold height must be an integer');\n      }\n\n      this.setAttribute('threshold-height', value + 'px');\n    },\n    get: function get$$1() {\n      return parseInt(this.getAttribute('threshold-height') || '96', 10);\n    }\n  }, {\n    key: 'state',\n    get: function get$$1() {\n      return this.getAttribute('state');\n    }\n\n    /**\n     * @property pullDistance\n     * @readonly\n     * @type {Number}\n     * @description\n     *   [en]The current number of pixels the pull hook has moved.[/en]\n     *   [ja]現在のプルフックが引き出された距離をピクセル数。[/ja]\n     */\n\n  }, {\n    key: 'pullDistance',\n    get: function get$$1() {\n      return this._currentTranslation;\n    }\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['height'];\n    }\n  }, {\n    key: 'events',\n    get: function get$$1() {\n      return ['changestate'];\n    }\n  }]);\n  return PullHookElement;\n}(BaseElement);\n\nons$1.elements.PullHook = PullHookElement;\ncustomElements.define('ons-pull-hook', PullHookElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar scheme$25 = {\n  '': 'range--*',\n  '.range__input': 'range--*__input',\n  '.range__focus-ring': 'range--*__focus-ring'\n};\n\nvar activeClassToken = 'range__input--active';\n\n/**\n * @element ons-range\n * @category form\n * @modifier material\n *   [en]Material Design slider[/en]\n *   [ja][/ja]\n * @description\n *   [en]\n *     Range input component. Used to display a draggable slider.\n *\n *     Works very similar to the `<input type=\"range\">` element.\n *   [/en]\n *   [ja][/ja]\n * @codepen xZQomM\n * @tutorial vanilla/Reference/range\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @seealso ons-input\n *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]\n *   [ja][/ja]\n * @example\n * <ons-range value=\"20\"></ons-range>\n * <ons-range modifier=\"material\" value=\"10\"></range>\n */\n\nvar RangeElement = function (_BaseInputElement) {\n  inherits(RangeElement, _BaseInputElement);\n\n  function RangeElement() {\n    classCallCheck(this, RangeElement);\n\n    var _this = possibleConstructorReturn(this, (RangeElement.__proto__ || Object.getPrototypeOf(RangeElement)).call(this));\n\n    _this._boundOnMouseDown = _this._onMouseDown.bind(_this);\n    _this._boundOnMouseUp = _this._onMouseUp.bind(_this);\n    _this._boundOnTouchStart = _this._onTouchStart.bind(_this);\n    _this._boundOnTouchEnd = _this._onTouchEnd.bind(_this);\n    _this._boundOnInput = _this._update.bind(_this);\n    _this._boundOnDragstart = _this._onDragstart.bind(_this);\n    _this._boundOnDragend = _this._onDragend.bind(_this);\n    return _this;\n  }\n\n  createClass(RangeElement, [{\n    key: '_compile',\n    value: function _compile() {\n      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), '_compile', this).call(this);\n      this._updateDisabled(this.hasAttribute('disabled'));\n    }\n\n    /* Inherited props */\n\n  }, {\n    key: '_update',\n    value: function _update() {\n      var input = this._input;\n      var focusRing = this._focusRing;\n\n      input.style.backgroundSize = 100 * this._ratio + '% 2px';\n      focusRing.value = this.value;\n\n      // NOTE: \"_zero\" attribute is used for CSS styling.\n      if (input.min === '' && input.value === '0' || input.min === input.value) {\n        input.setAttribute('_zero', '');\n      } else {\n        input.removeAttribute('_zero');\n      }\n\n      ['min', 'max'].forEach(function (attr) {\n        return focusRing[attr] = input[attr];\n      });\n    }\n  }, {\n    key: '_onMouseDown',\n\n\n    /* Own props */\n\n    value: function _onMouseDown(e) {\n      var _this2 = this;\n\n      this._input.classList.add(activeClassToken);\n      setImmediate(function () {\n        return _this2._input.focus();\n      });\n    }\n  }, {\n    key: '_onTouchStart',\n    value: function _onTouchStart(e) {\n      this._onMouseDown();\n    }\n  }, {\n    key: '_onMouseUp',\n    value: function _onMouseUp(e) {\n      this._input.classList.remove(activeClassToken);\n    }\n  }, {\n    key: '_onTouchEnd',\n    value: function _onTouchEnd(e) {\n      this._onMouseUp(e);\n    }\n  }, {\n    key: '_onDragstart',\n    value: function _onDragstart(e) {\n      e.consumed = true;\n      e.gesture.stopPropagation();\n      this._input.classList.add(activeClassToken);\n      this.addEventListener('drag', this._onDrag);\n    }\n  }, {\n    key: '_onDrag',\n    value: function _onDrag(e) {\n      e.stopPropagation();\n    }\n  }, {\n    key: '_onDragend',\n    value: function _onDragend(e) {\n      this._input.classList.remove(activeClassToken);\n      this.removeEventListener('drag', this._onDrag);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'disabled') {\n        this._updateDisabled(current);\n      }\n      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);\n    }\n\n    /**\n     * @param {boolean} disabled\n     */\n\n  }, {\n    key: '_updateDisabled',\n    value: function _updateDisabled(disabled) {\n      if (disabled) {\n        this.classList.add('range--disabled');\n      } else {\n        this.classList.remove('range--disabled');\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      this.addEventListener('mousedown', this._boundOnMouseDown);\n      this.addEventListener('mouseup', this._boundOnMouseUp);\n      this.addEventListener('touchstart', this._boundOnTouchStart);\n      this.addEventListener('touchend', this._boundOnTouchEnd);\n      this.addEventListener('dragstart', this._boundOnDragstart);\n      this.addEventListener('dragend', this._boundOnDragend);\n      this.addEventListener('input', this._boundOnInput);\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this.removeEventListener('mousedown', this._boundOnMouseDown);\n      this.removeEventListener('mouseup', this._boundOnMouseUp);\n      this.removeEventListener('touchstart', this._boundOnTouchStart);\n      this.removeEventListener('touchend', this._boundOnTouchEnd);\n      this.removeEventListener('dragstart', this._boundOnDragstart);\n      this.removeEventListener('dragend', this._boundOnDragend);\n      this.removeEventListener('input', this._boundOnInput);\n    }\n\n    /**\n     * @attribute disabled\n     * @description\n     *   [en]Whether the element is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n    /**\n     * @property value\n     * @type {Number}\n     * @description\n     *   [en]Current value.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$25;\n    }\n  }, {\n    key: '_template',\n    get: function get$$1() {\n      return '\\n      <input type=\"' + this.type + '\" class=\"' + this._defaultClassName + '__input\">\\n      <input type=\"range\" class=\"range__focus-ring\" tabIndex=\"-1\">\\n    ';\n    }\n  }, {\n    key: '_defaultClassName',\n    get: function get$$1() {\n      return 'range';\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return 'range';\n    }\n  }, {\n    key: '_focusRing',\n    get: function get$$1() {\n      return this.children[1];\n    }\n  }, {\n    key: '_ratio',\n    get: function get$$1() {\n      // Returns the current ratio.\n      var min = this._input.min === '' ? 0 : parseInt(this._input.min);\n      var max = this._input.max === '' ? 100 : parseInt(this._input.max);\n\n      return (this.value - min) / (max - min);\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['disabled'].concat(toConsumableArray(BaseInputElement.observedAttributes));\n    }\n  }]);\n  return RangeElement;\n}(BaseInputElement);\n\nons$1.elements.Range = RangeElement;\ncustomElements.define('ons-range', RangeElement);\n\n/*\nCopyright 2013-2016 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * @class AnimatorCSS - implementation of Animator class using css transitions\n */\n\nvar AnimatorCSS = function () {\n  createClass(AnimatorCSS, [{\n    key: 'animate',\n\n\n    /**\n     * @method animate\n     * @desc main animation function\n     * @param {Element} element\n     * @param {Object} finalCSS\n     * @param {number} [duration=200] - duration in milliseconds\n     * @return {Object} result\n     * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped\n     * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback\n     * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds\n     * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here\n     * @example\n     * ````\n     *  var result = animator.animate(el, {opacity: 0.5}, 1000);\n     *\n     *  el.addEventListener('click', function(e){\n     *    result.speed(200).then(function(){\n     *      console.log('done');\n     *    });\n     *  }, 300);\n     * ````\n     */\n    value: function animate(el, final) {\n      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;\n\n      var start = new Date().getTime(),\n          initial = {},\n          stopped = false,\n          next = false,\n          timeout = false,\n          properties = Object.keys(final);\n\n      var updateStyles = function updateStyles() {\n        var s = window.getComputedStyle(el);\n        properties.forEach(s.getPropertyValue.bind(s));\n        s = el.offsetHeight;\n      };\n\n      var result = {\n        stop: function stop() {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          timeout && clearTimeout(timeout);\n          var k = Math.min(1, (new Date().getTime() - start) / duration);\n          properties.forEach(function (i) {\n            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');\n          });\n          el.style.transitionDuration = '0s';\n\n          if (options.stopNext) {\n            next = false;\n          } else if (!stopped) {\n            stopped = true;\n            next && next();\n          }\n          return result;\n        },\n        then: function then(cb) {\n          next = cb;\n          if (stopped) {\n            next && next();\n          }\n          return result;\n        },\n        speed: function speed(newDuration) {\n          if (internal$1.config.animationsDisabled) {\n            newDuration = 0;\n          }\n          if (!stopped) {\n            timeout && clearTimeout(timeout);\n\n            var passed = new Date().getTime() - start;\n            var k = passed / duration;\n            var remaining = newDuration * (1 - k);\n\n            properties.forEach(function (i) {\n              el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');\n            });\n\n            updateStyles();\n\n            start = el.speedUpTime;\n            duration = remaining;\n\n            el.style.transitionDuration = duration / 1000 + 's';\n\n            properties.forEach(function (i) {\n              el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');\n            });\n\n            timeout = setTimeout(result.stop, remaining);\n          }\n          return result;\n        },\n        finish: function finish() {\n          var milliseconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n\n          var k = (new Date().getTime() - start) / duration;\n\n          result.speed(milliseconds / (1 - k));\n          return result;\n        }\n      };\n\n      if (el.hasAttribute('disabled') || stopped || internal$1.config.animationsDisabled) {\n        return result;\n      }\n\n      var style = window.getComputedStyle(el);\n      properties.forEach(function (e) {\n        var v = parseFloat(style.getPropertyValue(e));\n        initial[e] = isNaN(v) ? 0 : v;\n      });\n\n      if (!stopped) {\n        el.style.transitionProperty = properties.join(',');\n        el.style.transitionDuration = duration / 1000 + 's';\n\n        properties.forEach(function (e) {\n          el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');\n        });\n      }\n\n      timeout = setTimeout(result.stop, duration);\n      this._onStopAnimations(el, result.stop);\n\n      return result;\n    }\n  }]);\n\n  function AnimatorCSS() {\n    classCallCheck(this, AnimatorCSS);\n\n    this._queue = [];\n    this._index = 0;\n  }\n\n  createClass(AnimatorCSS, [{\n    key: '_onStopAnimations',\n    value: function _onStopAnimations(el, listener) {\n      var queue = this._queue;\n      var i = this._index++;\n      queue[el] = queue[el] || [];\n      queue[el][i] = function (options) {\n        delete queue[el][i];\n        if (queue[el] && queue[el].length == 0) {\n          delete queue[el];\n        }\n        return listener(options);\n      };\n    }\n\n    /**\n    * @method stopAnimations\n    * @desc stops active animations on a specified element\n    * @param {Element|Array} element - element or array of elements\n    * @param {Object} [options={}]\n    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true\n    */\n\n  }, {\n    key: 'stopAnimations',\n    value: function stopAnimations(el) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Array.isArray(el)) {\n        return el.forEach(function (el) {\n          _this.stopAnimations(el, options);\n        });\n      }\n\n      (this._queue[el] || []).forEach(function (e) {\n        e(options || {});\n      });\n    }\n\n    /**\n    * @method stopAll\n    * @desc stops all active animations\n    * @param {Object} [options={}]\n    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true\n    */\n\n  }, {\n    key: 'stopAll',\n    value: function stopAll() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.stopAnimations(Object.keys(this._queue), options);\n    }\n\n    /**\n    * @method fade\n    * @desc fades the element (short version for animate(el, {opacity: 0}))\n    * @param {Element} element\n    * @param {number} [duration=200]\n    */\n\n  }, {\n    key: 'fade',\n    value: function fade(el) {\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n\n      return this.animate(el, { opacity: 0 }, duration);\n    }\n  }]);\n  return AnimatorCSS;\n}();\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$14 = 'ripple';\nvar scheme$26 = {\n  '': 'ripple--*',\n  '.ripple__wave': 'ripple--*__wave',\n  '.ripple__background': 'ripple--*__background'\n};\n\n/**\n * @element ons-ripple\n * @category visual\n * @description\n *   [en]\n *     Adds a Material Design \"ripple\" effect to an element. The ripple effect will spread from the position where the user taps.\n *\n *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.\n *   [/en]\n *   [ja]マテリアルデザインのリップル効果をDOM要素に追加します。[/ja]\n * @codepen wKQWdZ\n * @tutorial vanilla/Reference/ripple\n * @modifier light-gray\n *   [en]Change the color of effects to light gray.[/en]\n *   [ja]エフェクトの色が明るい灰色になります。[/ja]\n * @guide theming.html#cross-platform-styling-autostyling\n *  [en]Cross platform styling[/en]\n *  [ja]Cross platform styling[/ja]\n * @example\n * <div class=\"my-div\">\n *  <ons-ripple></ons-ripple>\n * </div>\n *\n * @example\n * <ons-button ripple>Click me!</ons-button>\n */\n\nvar RippleElement = function (_BaseElement) {\n  inherits(RippleElement, _BaseElement);\n\n  /**\n   * @attribute color\n   * @type {String}\n   * @description\n   *   [en]Color of the ripple effect.[/en]\n   *   [ja]リップルエフェクトの色を指定します。[/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the ripple effect.[/en]\n   *   [ja]エフェクトの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute background\n   * @type {String}\n   * @description\n   *   [en]Color of the background.[/en]\n   *   [ja]背景の色を設定します。[/ja]\n   */\n\n  /**\n   * @attribute size\n   * @type {String}\n   * @description\n   *   [en]Sizing of the wave on ripple effect. Set \"cover\" or \"contain\". Default is \"cover\".[/en]\n   *   [ja]エフェクトのサイズを指定します。\"cover\"もしくは\"contain\"を指定します。デフォルトは\"cover\"です。[/ja]\n   */\n\n  /**\n   * @attribute center\n   * @type {Boolean}\n   * @description\n   *   [en]If this attribute presents, change the position of wave effect to center of the target element.[/en]\n   *   [ja]この要素を設定すると、エフェクトの位置が要素の真ん中から始まります。[/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *   [en]If this attribute is set, the ripple effect will be disabled.[/en]\n   *   [ja]この属性が設定された場合、リップルエフェクトは無効になります。[/ja]\n   */\n\n  function RippleElement() {\n    classCallCheck(this, RippleElement);\n\n    var _this = possibleConstructorReturn(this, (RippleElement.__proto__ || Object.getPrototypeOf(RippleElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n\n    _this._animator = new AnimatorCSS();\n\n    ['color', 'center', 'start-radius', 'background', 'modifier'].forEach(function (e) {\n      _this.attributeChangedCallback(e, null, _this.getAttribute(e));\n    });\n    return _this;\n  }\n\n  createClass(RippleElement, [{\n    key: '_compile',\n    value: function _compile() {\n      this.classList.add(defaultClassName$14);\n\n      this._wave = this.getElementsByClassName('ripple__wave')[0];\n      this._background = this.getElementsByClassName('ripple__background')[0];\n\n      if (!(this._background && this._wave)) {\n        this._wave = util.create('.ripple__wave');\n        this._background = util.create('.ripple__background');\n\n        this.appendChild(this._wave);\n        this.appendChild(this._background);\n      }\n\n      ModifierUtil.initModifier(this, scheme$26);\n    }\n  }, {\n    key: '_getEffectSize',\n    value: function _getEffectSize() {\n      var sizes = ['cover', 'contain'];\n      if (this.hasAttribute('size')) {\n        var size = this.getAttribute('size');\n        if (sizes.indexOf(size) !== -1) {\n          return size;\n        }\n      }\n\n      return 'cover';\n    }\n  }, {\n    key: '_calculateCoords',\n    value: function _calculateCoords(e) {\n      var x = void 0,\n          y = void 0,\n          h = void 0,\n          w = void 0,\n          r = void 0;\n      var b = this.getBoundingClientRect();\n      var size = this._getEffectSize();\n\n      if (this._center) {\n        x = b.width / 2;\n        y = b.height / 2;\n\n        if (size === 'cover') {\n          r = Math.sqrt(x * x + y * y);\n        } else if (size === 'contain') {\n          r = Math.min(x, y);\n        } else {\n          throw Error('Invalid state. If this errors is shown, leport to GitHub issues.');\n        }\n      } else {\n        x = (typeof e.clientX === 'number' ? e.clientX : e.changedTouches[0].clientX) - b.left;\n        y = (typeof e.clientY === 'number' ? e.clientY : e.changedTouches[0].clientY) - b.top;\n        h = Math.max(y, b.height - y);\n        w = Math.max(x, b.width - x);\n\n        if (size === 'cover') {\n          r = Math.sqrt(h * h + w * w);\n        } else if (size === 'contain') {\n          r = Math.min(Math.round(h / 2), Math.round(w / 2));\n        } else {\n          throw Error('Invalid state. If this errors is shown, leport to GitHub issues.');\n        }\n      }\n\n      return { x: x, y: y, r: r };\n    }\n  }, {\n    key: '_rippleAnimation',\n    value: function _rippleAnimation(e) {\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n      var _animator = this._animator,\n          _wave = this._wave,\n          _background = this._background,\n          _minR = this._minR;\n\n      var _calculateCoords2 = this._calculateCoords(e),\n          x = _calculateCoords2.x,\n          y = _calculateCoords2.y,\n          r = _calculateCoords2.r;\n\n      _animator.stopAll({ stopNext: 1 });\n      _animator.animate(_background, { opacity: 1 }, duration);\n\n      util.extend(_wave.style, {\n        opacity: 1,\n        top: y - _minR + 'px',\n        left: x - _minR + 'px',\n        width: 2 * _minR + 'px',\n        height: 2 * _minR + 'px'\n      });\n\n      return _animator.animate(_wave, {\n        top: y - r,\n        left: x - r,\n        height: 2 * r,\n        width: 2 * r\n      }, duration);\n    }\n  }, {\n    key: '_updateParent',\n    value: function _updateParent() {\n      if (!this._parentUpdated && this.parentNode) {\n        var computedStyle = window.getComputedStyle(this.parentNode);\n        if (computedStyle.getPropertyValue('position') === 'static') {\n          this.parentNode.style.position = 'relative';\n        }\n        this._parentUpdated = true;\n      }\n    }\n  }, {\n    key: '_onTap',\n    value: function _onTap(e) {\n      var _this2 = this;\n\n      if (!this.disabled) {\n        this._updateParent();\n        this._rippleAnimation(e.gesture.srcEvent).then(function () {\n          _this2._animator.fade(_this2._wave);\n          _this2._animator.fade(_this2._background);\n        });\n      }\n    }\n  }, {\n    key: '_onHold',\n    value: function _onHold(e) {\n      if (!this.disabled) {\n        this._updateParent();\n        this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);\n        document.addEventListener('release', this._boundOnRelease);\n      }\n    }\n  }, {\n    key: '_onRelease',\n    value: function _onRelease(e) {\n      var _this3 = this;\n\n      if (this._holding) {\n        this._holding.speed(300).then(function () {\n          _this3._animator.stopAll({ stopNext: true });\n          _this3._animator.fade(_this3._wave);\n          _this3._animator.fade(_this3._background);\n        });\n\n        this._holding = false;\n      }\n\n      document.removeEventListener('release', this._boundOnRelease);\n    }\n  }, {\n    key: '_onDragStart',\n    value: function _onDragStart(e) {\n      if (this._holding) {\n        return this._onRelease(e);\n      }\n      if (['left', 'right'].indexOf(e.gesture.direction) != -1) {\n        this._onTap(e);\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      this._parentNode = this.parentNode;\n      this._boundOnTap = this._onTap.bind(this);\n      this._boundOnHold = this._onHold.bind(this);\n      this._boundOnDragStart = this._onDragStart.bind(this);\n      this._boundOnRelease = this._onRelease.bind(this);\n\n      if (internal$1.config.animationsDisabled) {\n        this.disabled = true;\n      } else {\n        this._parentNode.addEventListener('tap', this._boundOnTap);\n        this._parentNode.addEventListener('hold', this._boundOnHold);\n        this._parentNode.addEventListener('dragstart', this._boundOnDragStart);\n      }\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      var pn = this._parentNode || this.parentNode;\n      pn.removeEventListener('tap', this._boundOnTap);\n      pn.removeEventListener('hold', this._boundOnHold);\n      pn.removeEventListener('dragstart', this._boundOnDragStart);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      var _this4 = this;\n\n      switch (name) {\n\n        case 'class':\n          util.restoreClass(this, defaultClassName$14, scheme$26);\n          break;\n\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$26);\n          break;\n\n        case 'start-radius':\n          this._minR = Math.max(0, parseFloat(current) || 0);\n          break;\n\n        case 'color':\n          if (current) {\n            contentReady(this, function () {\n              _this4._wave.style.background = current;\n              if (!_this4.hasAttribute('background')) {\n                _this4._background.style.background = current;\n              }\n            });\n          }\n          break;\n\n        case 'background':\n          if (current || last) {\n            if (current === 'none') {\n              contentReady(this, function () {\n                _this4._background.setAttribute('disabled', 'disabled');\n                _this4._background.style.background = 'transparent';\n              });\n            } else {\n              contentReady(this, function () {\n                if (_this4._background.hasAttribute('disabled')) {\n                  _this4._background.removeAttribute('disabled');\n                }\n                _this4._background.style.background = current;\n              });\n            }\n          }\n          break;\n\n        case 'center':\n          if (name === 'center') {\n            this._center = current != null && current != 'false';\n          }\n          break;\n\n      }\n    }\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['start-radius', 'color', 'background', 'center', 'class', 'modifier'];\n    }\n  }]);\n  return RippleElement;\n}(BaseElement);\n\nons$1.elements.Ripple = RippleElement;\ncustomElements.define('ons-ripple', RippleElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * @element ons-row\n * @category grid\n * @description\n *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]\n *   [ja]グリッドシステムにて行を定義します。ons-colとともに使用し、コンポーネントの配置に使用します。[/ja]\n * @codepen GgujC {wide}\n * @guide theming.html\n *   [en]Layouting guide[/en]\n *   [ja]レイアウト調整[/ja]\n * @seealso ons-col\n *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]\n *   [ja]ons-colコンポーネント[/ja]\n * @note\n *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]\n *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-colを組み合わせてそれぞれのons-col要素のvertical-align属性の値に別々の値を指定すると、描画が崩れる場合があります。vertical-align属性の値には一つの値だけを指定できます。[/ja]\n * @example\n * <ons-row>\n *   <ons-col width=\"50px\"><ons-icon icon=\"fa-twitter\"></ons-icon></ons-col>\n *   <ons-col>Text</ons-col>\n * </ons-row>\n */\n\n/**\n * @attribute vertical-align\n * @type {String}\n * @description\n *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]\n *   [ja]縦に整列するために指定します。top、bottom、centerのいずれかを指定できます。[/ja]\n */\n\nvar RowElement = function (_BaseElement) {\n  inherits(RowElement, _BaseElement);\n\n  function RowElement() {\n    classCallCheck(this, RowElement);\n    return possibleConstructorReturn(this, (RowElement.__proto__ || Object.getPrototypeOf(RowElement)).apply(this, arguments));\n  }\n\n  return RowElement;\n}(BaseElement);\n\nons$1.elements.Row = RowElement;\ncustomElements.define('ons-row', RowElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$15 = 'segment';\nvar scheme$27 = {\n  '': 'segment--*',\n  '.segment__item': 'segment--*__item',\n  '.segment__input': 'segment--*__input',\n  '.segment__button': 'segment--*__button'\n};\n\nvar generateId$1 = function () {\n  var i = 0;\n  return function () {\n    return 'ons-segment-gen-' + i++;\n  };\n}();\n\n/**\n * @element ons-segment\n * @category control\n * @modifier material\n *   [en]Material Design segment[/en]\n *   [ja][/ja]\n * @description\n *   [en]\n *     Segment component. Use this component to have a button bar with automatic styles that switch on click of another button.\n *\n *     Will automatically display as a Material Design segment on Android.\n *   [/en]\n *   [ja][/ja]\n * @codepen hLayx\n * @tutorial vanilla/Reference/segment\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]\n * @example\n * <ons-segment>\n *   <ons-button>Label 1</ons-button>\n *   <ons-button>Label 2</ons-button>\n *   <ons-button>Label 3</ons-button>\n * </ons-segment>\n */\n\nvar SegmentElement = function (_BaseElement) {\n  inherits(SegmentElement, _BaseElement);\n\n  /**\n   * @event postchange\n   * @description\n   *   [en]Fires after the active button is changed.[/en]\n   *   [ja][/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja][/ja]\n   * @param {Number} event.index\n   *   [en]Tapped button index.[/en]\n   *   [ja][/ja]\n   * @param {Object} event.segmentItem\n   *   [en]Segment item object.[/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *  [en]The appearance of the segment.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute tabbar-id\n   * @initonly\n   * @type {String}\n   * @description\n   *  [en]ID of the tabbar element to \"connect\" to the segment. Must be inside the same page.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute active-index\n   * @initonly\n   * @default 0\n   * @type {Number}\n   * @description\n   *  [en]Index of the first active button, only works if there is no connected tabbar (in which case the active tab sets the active button).[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *   [en]Specify if segment should be disabled.[/en]\n   *   [ja]ボタンを無効化する場合は指定します。[/ja]\n   */\n\n  function SegmentElement() {\n    classCallCheck(this, SegmentElement);\n\n    var _this = possibleConstructorReturn(this, (SegmentElement.__proto__ || Object.getPrototypeOf(SegmentElement)).call(this));\n\n    _this._segmentId = generateId$1();\n    _this._tabbar = null;\n    _this._onChange = _this._onChange.bind(_this);\n    _this._onTabbarPreChange = _this._onTabbarPreChange.bind(_this);\n\n    contentReady(_this, function () {\n      _this._compile();\n      setImmediate(function () {\n        return _this._lastActiveIndex = _this._tabbar ? _this._tabbar.getActiveTabIndex() : _this.getActiveButtonIndex();\n      });\n    });\n    return _this;\n  }\n\n  createClass(SegmentElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n      this.classList.add(defaultClassName$15);\n\n      for (var index = this.children.length - 1; index >= 0; index--) {\n        var item = this.children[index];\n        item.classList.add('segment__item');\n\n        var input = util.findChild(item, '.segment__input') || util.create('input.segment__input');\n        input.type = 'radio';\n        input.value = index;\n        input.name = input.name || this._segmentId;\n        input.checked = !this.hasAttribute('tabbar-id') && index === (parseInt(this.getAttribute('active-index')) || 0);\n\n        var button = util.findChild(item, '.segment__button') || util.create('.segment__button');\n        if (button.parentElement !== item) {\n          while (item.firstChild) {\n            button.appendChild(item.firstChild);\n          }\n        }\n\n        item.appendChild(input);\n        item.appendChild(button);\n      }\n\n      ModifierUtil.initModifier(this, scheme$27);\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      if (this.hasAttribute('tabbar-id')) {\n        contentReady(this, function () {\n          var page = util.findParent(_this2, 'ons-page');\n          _this2._tabbar = page && page.querySelector('#' + _this2.getAttribute('tabbar-id'));\n          if (!_this2._tabbar || _this2._tabbar.tagName !== 'ONS-TABBAR') {\n            throw new Error('<ons-segment> error: no tabbar with id ' + _this2.getAttribute('tabbar-id') + ' was found.');\n          }\n\n          _this2._tabbar.setAttribute('hide-tabs', '');\n          setImmediate(function () {\n            return _this2._setChecked(_this2._tabbar.getActiveTabIndex());\n          });\n\n          _this2._tabbar.addEventListener('prechange', _this2._onTabbarPreChange);\n        });\n      }\n\n      this.addEventListener('change', this._onChange);\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      var _this3 = this;\n\n      contentReady(this, function () {\n        if (_this3._tabbar) {\n          _this3._tabbar.removeEventListener('prechange', _this3._onTabbarPreChange);\n          _this3._tabbar = null;\n        }\n      });\n      this.removeEventListener('change', this._onChange);\n    }\n  }, {\n    key: '_setChecked',\n    value: function _setChecked(index) {\n      this.children[index].firstElementChild.checked = true;\n    }\n\n    /**\n     * @method setActiveButton\n     * @signature setActiveButton(index, [options])\n     * @param {Number} index\n     *   [en]Button index.[/en]\n     *   [ja][/ja]\n     * @param {Object} [options]\n     *   [en]Parameter object, works only if there is a connected tabbar. Supports the same options as `ons-tabbar`'s `setActiveTab` method.[/en]\n     *   [ja][/ja]\n     * @description\n     *   [en]Make button with the specified index active. If there is a connected tabbar it shows the corresponding tab page. In this case animations and their options can be specified by the second parameter.[/en]\n     *   [ja][/ja]\n     * @return {Promise}\n     *   [en]Resolves to the selected index or to the new page element if there is a connected tabbar.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'setActiveButton',\n    value: function setActiveButton(index, options) {\n      if (this._tabbar) {\n        return this._tabbar.setActiveTab(index, options);\n      }\n\n      this._setChecked(index);\n      this._postChange(index);\n      return Promise.resolve(index);\n    }\n\n    /**\n     * @method getActiveButtonIndex\n     * @signature getActiveButtonIndex()\n     * @return {Number}\n     *   [en]The index of the currently active button.[/en]\n     *   [ja][/ja]\n     * @description\n     *   [en]Returns button index of current active button. If active button is not found, returns -1.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'getActiveButtonIndex',\n    value: function getActiveButtonIndex() {\n      for (var i = this.children.length - 1; i >= 0; i--) {\n        // Array.findIndex\n        if (this.children[i].firstElementChild.checked) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: '_onChange',\n    value: function _onChange(event) {\n      event.stopPropagation();\n      this._tabbar ? this._tabbar.setActiveTab(this.getActiveButtonIndex(), { reject: false }) : this._postChange(this.getActiveButtonIndex());\n    }\n  }, {\n    key: '_onTabbarPreChange',\n    value: function _onTabbarPreChange(event) {\n      var _this4 = this;\n\n      setImmediate(function () {\n        if (!event.detail.canceled) {\n          _this4._setChecked(event.index);\n          _this4._postChange(event.index);\n        }\n      });\n    }\n  }, {\n    key: '_postChange',\n    value: function _postChange(index) {\n      util.triggerElementEvent(this, 'postchange', {\n        index: index,\n        activeIndex: index,\n        lastActiveIndex: this._lastActiveIndex,\n        segmentItem: this.children[index]\n      });\n      this._lastActiveIndex = index;\n    }\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the segment is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$15, scheme$27);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$27);\n          break;\n      }\n    }\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['class', 'modifier'];\n    }\n  }, {\n    key: 'events',\n    get: function get$$1() {\n      return ['postchange'];\n    }\n  }]);\n  return SegmentElement;\n}(BaseElement);\n\nons$1.elements.Segment = SegmentElement;\ncustomElements.define('ons-segment', SegmentElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$28 = {\n  '': 'select-* select--*',\n  '.select-input': 'select-input--*'\n};\n\nvar defaultClassName$16 = 'select';\n\nvar INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'form', 'multiple', 'name', 'required', 'size'];\n\n/**\n * @element ons-select\n * @category form\n * @modifier material\n *  [en]Displays a Material Design select input.[/en]\n *  [ja][/ja]\n * @modifier underbar\n *  [en]Displays a horizontal line underneath a select input.[/en]\n *  [ja][/ja]\n * @description\n *   [en]\n *     Select component. If you want to place a select with an ID of `my-id` on a page, use `<ons-select select-id=\"my-id\">`.\n *\n *     The component will automatically display as a Material Design select on Android.\n *\n *     Most attributes that can be used for a normal `<select>` element can also be used on the `<ons-select>` element.\n *   [/en]\n *   [ja]セレクトボックスを表示するコンポーネントです。`select` 要素に使用できる属性の多くが `ons-select` 要素でも利用できます。[/ja]\n * @codepen hLayx\n * @tutorial vanilla/Reference/select\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]\n * @example\n * <ons-select>\n *   <option value=\"1\">1</option>\n *   <option value=\"2\">2nd</option>\n *   <option value=\"3\">3rd option</option>\n * </ons-select>\n */\n\nvar SelectElement = function (_BaseElement) {\n  inherits(SelectElement, _BaseElement);\n\n  /**\n   * @attribute autofocus\n   * @type {Boolean}\n   * @default false\n   * @description\n   *  [en]Element automatically gains focus on page load.[/en]\n   *  [ja]ページロード時にこのセレクトボックスにフォーカスが移るようにします。[/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @type {Boolean}\n   * @default false\n   * @description\n   *   [en]Specify if select input should be disabled.[/en]\n   *   [ja]このセレクトボックスを無効化する場合に指定します。[/ja]\n   */\n\n  /**\n   * @attribute form\n   * @type {String}\n   * @description\n   *   [en]Associate a select element to an existing form on the page, even if not nested.[/en]\n   *   [ja]このセレクトボックスを、指定した `form` 要素に紐付けます。セレクトボックスを `form` 要素の外側に配置する際に使用します。[/ja]\n   */\n\n  /**\n   * @attribute multiple\n   * @type {Boolean}\n   * @default false\n   * @description\n   *  [en]If this attribute is defined, multiple options can be selected at once.[/en]\n   *  [ja]選択肢の複数選択を有効にします。[/ja]\n   */\n\n  /**\n   * @attribute name\n   * @type {String}\n   * @description\n   *   [en]Name the select element, useful for instance if it is part of a form.[/en]\n   *   [ja]このセレクトボックスの名前を指定します。通常 `form` 要素と共に使用します。[/ja]\n   */\n\n  /**\n   * @attribute required\n   * @type {Boolean}\n   * @description\n   *   [en]Make the select input required for submitting the form it is part of.[/en]\n   *   [ja]このセレクトボックスを入力必須にする場合に指定します。通常 `form` 要素と共に使用します。[/ja]\n   */\n\n  /**\n   * @attribute select-id\n   * @type {String}\n   * @description\n   *   [en]ID given to the inner select, useful for dynamic manipulation.[/en]\n   *   [ja]このセレクトボックスが内部に持つ select 要素に与える ID を指定します。セレクトボックスの内容を動的に変更する必要がある場合に使用します。[/ja]\n   */\n\n  /**\n   * @attribute size\n   * @type {Number}\n   * @default 1\n   * @description\n   *   [en]How many options are displayed; if there are more than the size then a scroll appears to navigate them.[/en]\n   *   [ja]一度に表示する選択肢の個数を指定します。選択肢がこの属性で指定した個数よりも多い場合、スクロールが有効になります。[/ja]\n   */\n\n  function SelectElement() {\n    classCallCheck(this, SelectElement);\n\n    var _this = possibleConstructorReturn(this, (SelectElement.__proto__ || Object.getPrototypeOf(SelectElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n\n    _this._deriveGetters();\n    return _this;\n  }\n\n  createClass(SelectElement, [{\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      var _this2 = this;\n\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$16, scheme$28);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$28);\n          break;\n      }\n\n      if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {\n        contentReady(this, function () {\n          return _this2._updateBoundAttributes();\n        });\n      }\n    }\n  }, {\n    key: '_updateBoundAttributes',\n    value: function _updateBoundAttributes() {\n      var _this3 = this;\n\n      INPUT_ATTRIBUTES$1.forEach(function (attr) {\n        if (_this3.hasAttribute(attr)) {\n          _this3._select.setAttribute(attr, _this3.getAttribute(attr));\n        } else {\n          _this3._select.removeAttribute(attr);\n        }\n      });\n    }\n\n    /**\n     * @property length\n     * @description\n     *   [en]Number of options in the select box.[/en]\n     *   [ja]このセレクトボックスに含まれる選択肢の個数を返します。 `select` 要素[/ja]\n     */\n\n    /**\n     * @property options\n     * @description\n     *   [en]Several options for handling the select DOM object.[/en]\n     *   [ja]このセレクトボックスに含まれる `option` 要素の配列を返します。[/ja]\n     */\n\n    /**\n     * @property selectedIndex\n     * @description\n     *   [en]Index of the currently selected option.[/en]\n     *   [ja]現在選択されている選択肢のインデックスを返します。[/ja]\n     */\n\n    /**\n     * @property value\n     * @description\n     *   [en]Value of the currently selected option.[/en]\n     *   [ja]現在選択されている選択肢の値を返します。[/ja]\n     */\n\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.classList.add(defaultClassName$16);\n      var sel = this._select || document.createElement('select');\n      if (!sel.id && this.hasAttribute('select-id')) {\n        sel.id = this.getAttribute('select-id');\n      }\n      sel.classList.add('select-input');\n      if (!this._select) {\n        util.arrayFrom(this.childNodes).forEach(function (element) {\n          return sel.appendChild(element);\n        });\n        this.appendChild(sel);\n      }\n\n      ModifierUtil.initModifier(this, scheme$28);\n    }\n  }, {\n    key: '_deriveGetters',\n    value: function _deriveGetters() {\n      var _this4 = this;\n\n      ['disabled', 'length', 'multiple', 'name', 'options', 'selectedIndex', 'size', 'value', 'form', 'type'].forEach(function (key) {\n        Object.defineProperty(_this4, key, {\n          enumerable: true,\n          get: function get$$1() {\n            return _this4._select[key];\n          },\n          set: ['form', 'type'].indexOf(key) === -1 ? function (value) {\n            return _this4._select[key] = value;\n          } : undefined\n        });\n      });\n    }\n  }, {\n    key: 'add',\n    value: function add(option) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      this._select.add(option, index);\n    }\n  }, {\n    key: 'remove',\n    value: function remove(index) {\n      this._select.remove(index);\n    }\n  }, {\n    key: '_select',\n    get: function get$$1() {\n      return this.querySelector('select');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'].concat(INPUT_ATTRIBUTES$1);\n    }\n  }]);\n  return SelectElement;\n}(BaseElement);\n\nons$1.elements.Select = SelectElement;\ncustomElements.define('ons-select', SelectElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar defaultClassName$17 = 'fab fab--mini speed-dial__item';\n\nvar scheme$29 = {\n  '': 'fab--* speed-dial__item--*'\n};\n\n/**\n * @element ons-speed-dial-item\n * @category control\n * @description\n *   [en]\n *     This component displays the child elements of the Material Design Speed dial component.\n *   [/en]\n *   [ja]\n *     Material DesignのSpeed dialの子要素を表現する要素です。\n *   [/ja]\n * @codepen dYQYLg\n * @tutorial vanilla/Reference/speed-dial\n * @seealso ons-speed-dial\n *   [en]The `<ons-speed-dial>` component.[/en]\n *   [ja]ons-speed-dialコンポーネント[/ja]\n * @seealso ons-fab\n *   [en]ons-fab component[/en]\n *   [ja]ons-fabコンポーネント[/ja]\n * @example\n * <ons-speed-dial position=\"left bottom\">\n *   <ons-fab>\n *     <ons-icon icon=\"fa-twitter\"></ons-icon>\n *   </ons-fab>\n *   <ons-speed-dial-item>A</ons-speed-dial-item>\n *   <ons-speed-dial-item>B</ons-speed-dial-item>\n *   <ons-speed-dial-item>C</ons-speed-dial-item>\n * </ons-speed-dial>\n */\n\nvar SpeedDialItemElement = function (_BaseElement) {\n  inherits(SpeedDialItemElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the component.[/en]\n   *   [ja]このコンポーネントの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute ripple\n   * @description\n   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]\n   *  [ja][/ja]\n   */\n\n  function SpeedDialItemElement() {\n    classCallCheck(this, SpeedDialItemElement);\n\n    var _this = possibleConstructorReturn(this, (SpeedDialItemElement.__proto__ || Object.getPrototypeOf(SpeedDialItemElement)).call(this));\n\n    _this._compile();\n    _this._boundOnClick = _this._onClick.bind(_this);\n    return _this;\n  }\n\n  createClass(SpeedDialItemElement, [{\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$17, scheme$29);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$29);\n          util.addModifier(this, 'mini');\n          break;\n        case 'ripple':\n          this._updateRipple();\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      this.addEventListener('click', this._boundOnClick, false);\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this.removeEventListener('click', this._boundOnClick, false);\n    }\n  }, {\n    key: '_updateRipple',\n    value: function _updateRipple() {\n      util.updateRipple(this);\n    }\n  }, {\n    key: '_onClick',\n    value: function _onClick(e) {\n      e.stopPropagation();\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      var _this2 = this;\n\n      autoStyle.prepare(this);\n\n      defaultClassName$17.split(/\\s+/).forEach(function (token) {\n        return _this2.classList.add(token);\n      });\n\n      util.addModifier(this, 'mini');\n      this._updateRipple();\n\n      ModifierUtil.initModifier(this, scheme$29);\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'ripple', 'class'];\n    }\n  }]);\n  return SpeedDialItemElement;\n}(BaseElement);\n\nons$1.elements.SpeedDialItem = SpeedDialItemElement;\ncustomElements.define('ons-speed-dial-item', SpeedDialItemElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n   http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar defaultClassName$18 = 'speed-dial';\nvar scheme$30 = {\n  '': 'speed-dial--*'\n};\n\n/**\n * @element ons-speed-dial\n * @category control\n * @description\n *   [en]\n *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.\n *\n *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.\n *   [/en]\n *   [ja][/ja]\n * @codepen dYQYLg\n * @tutorial vanilla/Reference/speed-dial\n * @seealso ons-speed-dial-item\n *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]\n *   [ja]ons-speed-dial-itemコンポーネント[/ja]\n * @seealso ons-fab\n *   [en]ons-fab component[/en]\n *   [ja]ons-fabコンポーネント[/ja]\n * @example\n * <ons-speed-dial position=\"left bottom\">\n *   <ons-fab>\n *     <ons-icon icon=\"fa-twitter\"></ons-icon>\n *   </ons-fab>\n *   <ons-speed-dial-item>A</ons-speed-dial-item>\n *   <ons-speed-dial-item>B</ons-speed-dial-item>\n *   <ons-speed-dial-item>C</ons-speed-dial-item>\n * </ons-speed-dial>\n */\n\nvar SpeedDialElement = function (_BaseElement) {\n  inherits(SpeedDialElement, _BaseElement);\n\n  /**\n   * @event open\n   * @description\n   *   [en]Fired when the menu items are shown.[/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @event close\n   * @description\n   *   [en]Fired when the menu items are hidden.[/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the component.[/en]\n   *   [ja]このコンポーネントの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute ripple\n   * @description\n   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute position\n   * @type {String}\n   * @description\n   *   [en]\n   *     Specify the vertical and horizontal position of the component.\n   *     I.e. to display it in the top right corner specify \"right top\".\n   *     Choose from \"right\", \"left\", \"top\" and \"bottom\".\n   *   [/en]\n   *   [ja]\n   *     この要素を表示する左右と上下の位置を指定します。\n   *     例えば、右上に表示する場合には\"right top\"を指定します。\n   *     左右と上下の位置の指定には、rightとleft、topとbottomがそれぞれ指定できます。\n   *   [/ja]\n   */\n\n  /**\n   * @attribute direction\n   * @type {String}\n   * @description\n   *   [en]Specify the direction the items are displayed. Possible values are \"up\", \"down\", \"left\" and \"right\".[/en]\n   *   [ja]\n   *     要素が表示する方向を指定します。up, down, left, rightが指定できます。\n   *   [/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *   [en]Specify if button should be disabled.[/en]\n   *   [ja]無効化する場合に指定します。[/ja]\n   */\n\n  function SpeedDialElement() {\n    classCallCheck(this, SpeedDialElement);\n\n    var _this = possibleConstructorReturn(this, (SpeedDialElement.__proto__ || Object.getPrototypeOf(SpeedDialElement)).call(this));\n\n    contentReady(_this, function () {\n      _this._compile();\n    });\n\n    _this._itemShown = false;\n    _this._boundOnClick = _this._onClick.bind(_this);\n    return _this;\n  }\n\n  createClass(SpeedDialElement, [{\n    key: '_compile',\n    value: function _compile() {\n      this.classList.add(defaultClassName$18);\n      autoStyle.prepare(this);\n      this._updateRipple();\n      ModifierUtil.initModifier(this, scheme$30);\n\n      if (this.hasAttribute('direction')) {\n        this._updateDirection(this.getAttribute('direction'));\n      } else {\n        this._updateDirection('up');\n      }\n\n      this._updatePosition();\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      var _this2 = this;\n\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$18, scheme$30);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$30);\n          break;\n        case 'ripple':\n          contentReady(this, function () {\n            return _this2._updateRipple();\n          });\n          break;\n        case 'direction':\n          contentReady(this, function () {\n            return _this2._updateDirection(current);\n          });\n          break;\n        case 'position':\n          contentReady(this, function () {\n            return _this2._updatePosition();\n          });\n          break;\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      this.addEventListener('click', this._boundOnClick, false);\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this.removeEventListener('click', this._boundOnClick, false);\n    }\n  }, {\n    key: '_onClick',\n    value: function _onClick(e) {\n      if (this.onClick) {\n        this.onClick.apply(this);\n        return Promise.resolve();\n      } else if (!this.disabled && this.visible) {\n        return this.toggleItems();\n      }\n    }\n  }, {\n    key: '_show',\n    value: function _show() {\n      if (!this.inline) {\n        return this.show();\n      }\n      return Promise.resolve();\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      var _this3 = this;\n\n      return new Promise(function (resolve) {\n        if (!_this3.inline) {\n          setImmediate(function () {\n            return _this3.hide().then(resolve);\n          });\n        } else {\n          resolve();\n        }\n      });\n    }\n  }, {\n    key: '_updateRipple',\n    value: function _updateRipple() {\n      if (this._fab) {\n        this.hasAttribute('ripple') ? this._fab.setAttribute('ripple', '') : this._fab.removeAttribute('ripple');\n      }\n    }\n  }, {\n    key: '_updateDirection',\n    value: function _updateDirection(direction) {\n      var children = this.items;\n      for (var i = 0; i < children.length; i++) {\n        styler(children[i], {\n          transitionDelay: 25 * i + 'ms',\n          bottom: 'auto',\n          right: 'auto',\n          top: 'auto',\n          left: 'auto'\n        });\n      }\n      switch (direction) {\n        case 'up':\n          for (var _i = 0; _i < children.length; _i++) {\n            children[_i].style.bottom = 72 + 56 * _i + 'px';\n            children[_i].style.right = '8px';\n          }\n          break;\n        case 'down':\n          for (var _i2 = 0; _i2 < children.length; _i2++) {\n            children[_i2].style.top = 72 + 56 * _i2 + 'px';\n            children[_i2].style.left = '8px';\n          }\n          break;\n        case 'left':\n          for (var _i3 = 0; _i3 < children.length; _i3++) {\n            children[_i3].style.top = '8px';\n            children[_i3].style.right = 72 + 56 * _i3 + 'px';\n          }\n          break;\n        case 'right':\n          for (var _i4 = 0; _i4 < children.length; _i4++) {\n            children[_i4].style.top = '8px';\n            children[_i4].style.left = 72 + 56 * _i4 + 'px';\n          }\n          break;\n        default:\n          throw new Error('Argument must be one of up, down, left or right.');\n      }\n    }\n  }, {\n    key: '_updatePosition',\n    value: function _updatePosition() {\n      var position = this.getAttribute('position');\n      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');\n      switch (position) {\n        case 'top right':\n        case 'right top':\n          this.classList.add('fab--top__right');\n          break;\n        case 'top left':\n        case 'left top':\n          this.classList.add('fab--top__left');\n          break;\n        case 'bottom right':\n        case 'right bottom':\n          this.classList.add('fab--bottom__right');\n          break;\n        case 'bottom left':\n        case 'left bottom':\n          this.classList.add('fab--bottom__left');\n          break;\n        case 'center top':\n        case 'top center':\n          this.classList.add('fab--top__center');\n          break;\n        case 'center bottom':\n        case 'bottom center':\n          this.classList.add('fab--bottom__center');\n          break;\n        default:\n          break;\n      }\n    }\n  }, {\n    key: '_getTranslate',\n    value: function _getTranslate() {\n      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;\n      var translate = isBottom ? 'translate3d(0px, -' + (util.globals.fabOffset || 0) + 'px, 0px) ' : '';\n      return translate;\n    }\n\n    /**\n     * @method show\n     * @signature show()\n     * @description\n     *   [en]Show the speed dial.[/en]\n     *   [ja]Speed dialを表示します。[/ja]\n     */\n\n  }, {\n    key: 'show',\n    value: function show() {\n      this._fab.show();\n      styler(this, { transform: this._getTranslate });\n      return Promise.resolve();\n    }\n\n    /**\n     * @method hide\n     * @signature hide()\n     * @description\n     *   [en]Hide the speed dial.[/en]\n     *   [ja]Speed dialを非表示にします。[/ja]\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide() {\n      var _this4 = this;\n\n      return this.hideItems().then(function () {\n        return _this4._fab.hide();\n      });\n    }\n\n    /**\n     * @method showItems\n     * @signature showItems()\n     * @description\n     *   [en]Show the speed dial items.[/en]\n     *   [ja]Speed dialの子要素を表示します。[/ja]\n     */\n\n  }, {\n    key: 'showItems',\n    value: function showItems() {\n      if (this.hasAttribute('direction')) {\n        this._updateDirection(this.getAttribute('direction'));\n      } else {\n        this._updateDirection('up');\n      }\n\n      var totalDelay = 0;\n      if (!this._itemShown) {\n        var children = this.items;\n        for (var i = 0; i < children.length; i++) {\n          var delay = 25 * i;\n          totalDelay += delay;\n          styler(children[i], {\n            transform: 'scale(1)',\n            transitionDelay: delay + 'ms'\n          });\n        }\n        totalDelay += 50;\n\n        this._itemShown = true;\n        util.triggerElementEvent(this, 'open');\n      }\n\n      var deferred = util.defer();\n      setTimeout(deferred.resolve, totalDelay);\n      return deferred.promise;\n    }\n\n    /**\n     * @method hideItems\n     * @signature hideItems()\n     * @description\n     *   [en]Hide the speed dial items.[/en]\n     *   [ja]Speed dialの子要素を非表示にします。[/ja]\n     */\n\n  }, {\n    key: 'hideItems',\n    value: function hideItems() {\n      var totalDelay = 0;\n      if (this._itemShown) {\n        var children = this.items;\n        for (var i = 0; i < children.length; i++) {\n          var delay = 25 * (children.length - i);\n          totalDelay += delay;\n          styler(children[i], {\n            transform: 'scale(0)',\n            transitionDelay: delay + 'ms'\n          });\n        }\n        totalDelay += 50;\n\n        this._itemShown = false;\n        util.triggerElementEvent(this, 'close');\n      }\n\n      var deferred = util.defer();\n      setTimeout(deferred.resolve, totalDelay);\n      return deferred.promise;\n    }\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'isOpen',\n\n\n    /**\n     * @method isOpen\n     * @signature isOpen()\n     * @description\n     *   [en]Returns whether the menu is open or not.[/en]\n     *   [ja][/ja]\n     */\n    value: function isOpen() {\n      return this._itemShown;\n    }\n\n    /**\n     * @method toggle\n     * @signature toggle()\n     * @description\n     *   [en]Toggle visibility.[/en]\n     *   [ja]Speed dialの表示非表示を切り替えます。[/ja]\n     */\n\n  }, {\n    key: 'toggle',\n    value: function toggle() {\n      return this.visible ? this.hide() : this.show();\n    }\n\n    /**\n     * @method toggleItems\n     * @signature toggleItems()\n     * @description\n     *   [en]Toggle item visibility.[/en]\n     *   [ja]Speed dialの子要素の表示非表示を切り替えます。[/ja]\n     */\n\n  }, {\n    key: 'toggleItems',\n    value: function toggleItems() {\n      return this.isOpen() ? this.hideItems() : this.showItems();\n    }\n  }, {\n    key: 'items',\n    get: function get$$1() {\n      return util.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));\n    }\n  }, {\n    key: '_fab',\n    get: function get$$1() {\n      return util.findChild(this, 'ons-fab');\n    }\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      if (value) {\n        this.hideItems();\n      }\n      util.arrayFrom(this.children).forEach(function (e) {\n        util.match(e, '.fab') && util.toggleAttribute(e, 'disabled', value);\n      });\n\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n\n    /**\n     * @property inline\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is inline or not.[/en]\n     *   [ja]インライン要素の場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'inline',\n    get: function get$$1() {\n      return this.hasAttribute('inline');\n    }\n\n    /**\n     * @property visible\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is visible or not.[/en]\n     *   [ja]要素が見える場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'visible',\n    get: function get$$1() {\n      return this._fab.visible && this.style.display !== 'none';\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['class', 'modifier', 'ripple', 'direction', 'position'];\n    }\n  }, {\n    key: 'events',\n    get: function get$$1() {\n      return ['open', 'close'];\n    }\n  }]);\n  return SpeedDialElement;\n}(BaseElement);\n\nons$1.elements.SpeedDial = SpeedDialElement;\ncustomElements.define('ons-speed-dial', SpeedDialElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar rewritables$1 = {\n  /**\n   * @param {Element} element\n   * @param {Function} callback\n   */\n  ready: function ready(element, callback) {\n    setImmediate(callback);\n  }\n};\n\n/**\n * @element ons-splitter-content\n * @category menu\n * @description\n *  [en]\n *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.\n *\n *    It contains the main content of the page while `<ons-splitter-side>` contains the list.\n *  [/en]\n *  [ja]ons-splitter-content要素は、ons-splitter要素の子要素として利用します。[/ja]\n * @codepen rOQOML\n * @tutorial vanilla/Reference/splitter\n * @guide fundamentals.html#managing-pages\n *  [en]Managing multiple pages.[/en]\n *  [ja]複数のページを管理する[/ja]\n * @seealso ons-splitter\n *  [en]The `<ons-splitter>` component is the parent element.[/en]\n *  [ja]ons-splitterコンポーネント[/ja]\n * @seealso ons-splitter-side\n *  [en]The `<ons-splitter-side>` component contains the menu.[/en]\n *  [ja]ons-splitter-sideコンポーネント[/ja]\n * @example\n * <ons-splitter>\n *   <ons-splitter-content>\n *     ...\n *   </ons-splitter-content>\n *\n *   <ons-splitter-side side=\"left\" width=\"80%\" collapse>\n *     ...\n *   </ons-splitter-side>\n * </ons-splitter>\n */\n\nvar SplitterContentElement = function (_BaseElement) {\n  inherits(SplitterContentElement, _BaseElement);\n\n  /**\n   * @attribute page\n   * @type {String}\n   * @description\n   *   [en]\n   *     The url of the content page. If this attribute is used the content will be loaded from a `<ons-template>` tag or a remote file.\n   *\n   *     It is also possible to put `<ons-page>` element as a child of the element.\n   *   [/en]\n   *   [ja]ons-splitter-content要素に表示するページのURLを指定します。[/ja]\n   */\n\n  function SplitterContentElement() {\n    classCallCheck(this, SplitterContentElement);\n\n    var _this = possibleConstructorReturn(this, (SplitterContentElement.__proto__ || Object.getPrototypeOf(SplitterContentElement)).call(this));\n\n    _this._page = null;\n    _this._pageLoader = defaultPageLoader;\n\n    contentReady(_this, function () {\n      rewritables$1.ready(_this, function () {\n        var page = _this._getPageTarget();\n\n        if (page) {\n          _this.load(page);\n        }\n      });\n    });\n    return _this;\n  }\n\n  createClass(SplitterContentElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      if (!util.match(this.parentNode, 'ons-splitter')) {\n        throw new Error('\"ons-splitter-content\" must have \"ons-splitter\" as parentNode.');\n      }\n    }\n  }, {\n    key: '_getPageTarget',\n    value: function _getPageTarget() {\n      return this._page || this.getAttribute('page');\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {}\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {}\n\n    /**\n     * @property page\n     * @type {HTMLElement}\n     * @description\n     *   [en]The page to load in the splitter content.[/en]\n     *   [ja]この要素内に表示するページを指定します。[/ja]\n     */\n\n  }, {\n    key: 'load',\n\n\n    /**\n     * @method load\n     * @signature load(page, [options])\n     * @param {String} page, [options]\n     *   [en]Page URL. Can be either an HTML document or an `<ons-template>` id.[/en]\n     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]\n     * @param {Object} [options]\n     * @param {Function} [options.callback]\n     * @description\n     *   [en]Show the page specified in `page` in the content.[/en]\n     *   [ja]指定したURLをメインページを読み込みます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the new `<ons-page>` element[/en]\n     *   [ja]`<ons-page>`要素を解決するPromiseオブジェクトを返します。[/ja]\n     */\n    value: function load(page) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._page = page;\n      var callback = options.callback || function () {};\n\n      return new Promise(function (resolve) {\n        var oldContent = _this2._content || null;\n\n        _this2._pageLoader.load({ page: page, parent: _this2 }, function (pageElement) {\n          if (oldContent) {\n            _this2._pageLoader.unload(oldContent);\n            oldContent = null;\n          }\n\n          setImmediate(function () {\n            return _this2._show();\n          });\n\n          callback(pageElement);\n          resolve(pageElement);\n        });\n      });\n    }\n  }, {\n    key: '_show',\n    value: function _show() {\n      if (this._content) {\n        this._content._show();\n      }\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      if (this._content) {\n        this._content._hide();\n      }\n    }\n  }, {\n    key: '_destroy',\n    value: function _destroy() {\n      if (this._content) {\n        this._pageLoader.unload(this._content);\n      }\n      this.remove();\n    }\n  }, {\n    key: 'page',\n    get: function get$$1() {\n      return this._page;\n    }\n\n    /**\n     * @param {*} page\n     */\n    ,\n    set: function set$$1(page) {\n      this._page = page;\n    }\n  }, {\n    key: '_content',\n    get: function get$$1() {\n      return this.children[0];\n    }\n\n    /**\n     * @property pageLoader\n     * @type {Function}\n     * @description\n     *   [en]Page element loaded in the splitter content.[/en]\n     *   [ja]この要素内に表示するページを指定します。[/ja]\n     */\n\n  }, {\n    key: 'pageLoader',\n    get: function get$$1() {\n      return this._pageLoader;\n    },\n    set: function set$$1(loader) {\n      if (!(loader instanceof PageLoader)) {\n        throw Error('First parameter must be an instance of PageLoader');\n      }\n      this._pageLoader = loader;\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return [];\n    }\n  }, {\n    key: 'rewritables',\n    get: function get$$1() {\n      return rewritables$1;\n    }\n  }]);\n  return SplitterContentElement;\n}(BaseElement);\n\nons$1.elements.SplitterContent = SplitterContentElement;\ncustomElements.define('ons-splitter-content', SplitterContentElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar SplitterMaskElement = function (_BaseElement) {\n  inherits(SplitterMaskElement, _BaseElement);\n\n  function SplitterMaskElement() {\n    classCallCheck(this, SplitterMaskElement);\n\n    var _this = possibleConstructorReturn(this, (SplitterMaskElement.__proto__ || Object.getPrototypeOf(SplitterMaskElement)).call(this));\n\n    _this._boundOnClick = _this._onClick.bind(_this);\n    contentReady(_this, function () {\n      if (_this.parentNode._sides.every(function (side) {\n        return side.mode === 'split';\n      })) {\n        _this.setAttribute('style', 'display: none !important');\n      }\n    });\n    return _this;\n  }\n\n  createClass(SplitterMaskElement, [{\n    key: '_onClick',\n    value: function _onClick(event) {\n      if (this.onClick instanceof Function) {\n        this.onClick();\n      } else if (util.match(this.parentNode, 'ons-splitter')) {\n        this.parentNode._sides.forEach(function (side) {\n          return side.close('left').catch(function () {});\n        });\n      }\n      event.stopPropagation();\n    }\n  }, {\n    key: '_preventScroll',\n    value: function _preventScroll(e) {\n      e.cancelable && e.preventDefault(); // Fix for iOS. Prevents scrolling content behind mask.\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {}\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      this.addEventListener('click', this._boundOnClick);\n      this.addEventListener('touchmove', this._preventScroll);\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this.removeEventListener('click', this._boundOnClick);\n      this.removeEventListener('touchmove', this._preventScroll);\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return [];\n    }\n  }]);\n  return SplitterMaskElement;\n}(BaseElement);\n\nons$1.elements.SplitterMask = SplitterMaskElement;\ncustomElements.define('ons-splitter-mask', SplitterMaskElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar SplitterAnimator$1 = function (_BaseAnimator) {\n  inherits(SplitterAnimator, _BaseAnimator);\n\n  function SplitterAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.3 : _ref$duration,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay;\n\n    classCallCheck(this, SplitterAnimator);\n    return possibleConstructorReturn(this, (SplitterAnimator.__proto__ || Object.getPrototypeOf(SplitterAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));\n  }\n\n  createClass(SplitterAnimator, [{\n    key: 'updateOptions',\n    value: function updateOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      util.extend(this, {\n        timing: this.timing, duration: this.duration, delay: this.delay\n      }, options);\n    }\n\n    /**\n     * @param {Element} sideElement\n     */\n\n  }, {\n    key: 'activate',\n    value: function activate(sideElement) {\n      var _this2 = this;\n\n      var splitter = sideElement.parentNode;\n\n      contentReady(splitter, function () {\n        _this2._side = sideElement;\n        _this2._oppositeSide = splitter.right !== sideElement && splitter.right || splitter.left !== sideElement && splitter.left;\n        _this2._content = splitter.content;\n        _this2._mask = splitter.mask;\n      });\n    }\n  }, {\n    key: 'deactivate',\n    value: function deactivate() {\n      this.clearTransition();\n      this._mask && this.clearMask();\n      this._content = this._side = this._oppositeSide = this._mask = null;\n    }\n  }, {\n    key: 'clearTransition',\n    value: function clearTransition() {\n      var _this3 = this;\n\n      'side mask content'.split(/\\s+/).forEach(function (e) {\n        return _this3['_' + e] && styler.clear(_this3['_' + e], 'transform transition');\n      });\n    }\n  }, {\n    key: 'clearMask',\n    value: function clearMask() {\n      // Check if the other side needs the mask before clearing\n      if (!this._oppositeSide || this._oppositeSide.mode === 'split' || !this._oppositeSide.isOpen) {\n        this._mask.style.opacity = '';\n        this._mask.style.display = 'none';\n      }\n    }\n\n    /**\n     * @param {Number} distance\n     */\n\n  }, {\n    key: 'translate',\n    value: function translate(distance) {}\n\n    /**\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'open',\n    value: function open(done) {\n      done();\n    }\n\n    /**\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'close',\n    value: function close(done) {\n      done();\n    }\n  }, {\n    key: 'minus',\n    get: function get$$1() {\n      return this._side.side === 'right' ? '-' : '';\n    }\n  }]);\n  return SplitterAnimator;\n}(BaseAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar OverlaySplitterAnimator = function (_SplitterAnimator) {\n  inherits(OverlaySplitterAnimator, _SplitterAnimator);\n\n  function OverlaySplitterAnimator() {\n    classCallCheck(this, OverlaySplitterAnimator);\n    return possibleConstructorReturn(this, (OverlaySplitterAnimator.__proto__ || Object.getPrototypeOf(OverlaySplitterAnimator)).apply(this, arguments));\n  }\n\n  createClass(OverlaySplitterAnimator, [{\n    key: 'translate',\n    value: function translate(distance) {\n      this._mask.style.display = 'block'; // Avoid content clicks\n\n      Animit(this._side).queue({\n        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'\n      }).play();\n    }\n\n    /**\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'open',\n    value: function open(done) {\n      Animit.runAll(Animit(this._side).wait(this.delay).queue({\n        transform: 'translate3d(' + this.minus + '100%, 0px, 0px)'\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).queue(function (callback) {\n        callback();\n        done && done();\n      }), Animit(this._mask).wait(this.delay).queue({\n        display: 'block'\n      }).queue({\n        opacity: '1'\n      }, {\n        duration: this.duration,\n        timing: 'linear'\n      }));\n    }\n\n    /**\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'close',\n    value: function close(done) {\n\n      Animit.runAll(Animit(this._side).wait(this.delay).queue({\n        transform: 'translate3d(0px, 0px, 0px)'\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).queue(function (callback) {\n        done && done();\n        callback();\n      }), Animit(this._mask).wait(this.delay).queue({\n        opacity: '0'\n      }, {\n        duration: this.duration,\n        timing: 'linear'\n      }).queue({\n        display: 'none'\n      }));\n    }\n  }]);\n  return OverlaySplitterAnimator;\n}(SplitterAnimator$1);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar PushSplitterAnimator = function (_SplitterAnimator) {\n  inherits(PushSplitterAnimator, _SplitterAnimator);\n\n  function PushSplitterAnimator() {\n    classCallCheck(this, PushSplitterAnimator);\n    return possibleConstructorReturn(this, (PushSplitterAnimator.__proto__ || Object.getPrototypeOf(PushSplitterAnimator)).apply(this, arguments));\n  }\n\n  createClass(PushSplitterAnimator, [{\n    key: '_getSlidingElements',\n    value: function _getSlidingElements() {\n      var slidingElements = [this._side, this._content];\n      if (this._oppositeSide && this._oppositeSide.mode === 'split') {\n        slidingElements.push(this._oppositeSide);\n      }\n\n      return slidingElements;\n    }\n  }, {\n    key: 'translate',\n    value: function translate(distance) {\n      if (!this._slidingElements) {\n        this._slidingElements = this._getSlidingElements();\n      }\n\n      this._mask.style.display = 'block'; // Avoid content clicks\n\n      Animit(this._slidingElements).queue({\n        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'\n      }).play();\n    }\n\n    /**\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'open',\n    value: function open(done) {\n      var _this2 = this;\n\n      var max = this._side.offsetWidth;\n      this._slidingElements = this._getSlidingElements();\n\n      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({\n        transform: 'translate3d(' + (this.minus + max) + 'px, 0px, 0px)'\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).queue(function (callback) {\n        _this2._slidingElements = null;\n        callback();\n        done && done();\n      }), Animit(this._mask).wait(this.delay).queue({\n        display: 'block'\n      }));\n    }\n\n    /**\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'close',\n    value: function close(done) {\n      var _this3 = this;\n\n      this._slidingElements = this._getSlidingElements();\n\n      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({\n        transform: 'translate3d(0px, 0px, 0px)'\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).queue(function (callback) {\n        _this3._slidingElements = null;\n        get(PushSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(PushSplitterAnimator.prototype), 'clearTransition', _this3).call(_this3);\n        done && done();\n        callback();\n      }), Animit(this._mask).wait(this.delay).queue({\n        display: 'none'\n      }));\n    }\n  }]);\n  return PushSplitterAnimator;\n}(SplitterAnimator$1);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar RevealSplitterAnimator = function (_SplitterAnimator) {\n  inherits(RevealSplitterAnimator, _SplitterAnimator);\n\n  function RevealSplitterAnimator() {\n    classCallCheck(this, RevealSplitterAnimator);\n    return possibleConstructorReturn(this, (RevealSplitterAnimator.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator)).apply(this, arguments));\n  }\n\n  createClass(RevealSplitterAnimator, [{\n    key: '_getSlidingElements',\n    value: function _getSlidingElements() {\n      var slidingElements = [this._content, this._mask];\n      if (this._oppositeSide && this._oppositeSide.mode === 'split') {\n        slidingElements.push(this._oppositeSide);\n      }\n\n      return slidingElements;\n    }\n  }, {\n    key: 'activate',\n    value: function activate(sideElement) {\n      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'activate', this).call(this, sideElement);\n      if (sideElement.mode === 'collapse') {\n        this._setStyles(sideElement);\n      }\n    }\n  }, {\n    key: 'deactivate',\n    value: function deactivate() {\n      this._side && this._unsetStyles(this._side);\n      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'deactivate', this).call(this);\n    }\n  }, {\n    key: '_setStyles',\n    value: function _setStyles(sideElement) {\n      styler(sideElement, {\n        left: sideElement.side === 'right' ? 'auto' : 0,\n        right: sideElement.side === 'right' ? 0 : 'auto',\n        zIndex: 0,\n        backgroundColor: 'black',\n        transform: this._generateBehindPageStyle(0).container.transform,\n        display: 'none'\n      });\n\n      var splitter = sideElement.parentElement;\n      contentReady(splitter, function () {\n        return splitter.content && styler(splitter.content, { boxShadow: '0 0 12px 0 rgba(0, 0, 0, 0.2)' });\n      });\n    }\n  }, {\n    key: '_unsetStyles',\n    value: function _unsetStyles(sideElement) {\n      styler.clear(sideElement, 'left right zIndex backgroundColor display');\n      if (sideElement._content) {\n        sideElement._content.style.opacity = '';\n      }\n\n      // Check if the other side needs the common styles\n      if (!this._oppositeSide || this._oppositeSide.mode === 'split') {\n        sideElement.parentElement.content && styler.clear(sideElement.parentElement.content, 'boxShadow');\n      }\n    }\n  }, {\n    key: '_generateBehindPageStyle',\n    value: function _generateBehindPageStyle(distance) {\n      var max = this.maxWidth;\n\n      var behindDistance = (distance - max) / max * 10;\n      behindDistance = isNaN(behindDistance) ? 0 : Math.max(Math.min(behindDistance, 0), -10);\n\n      var behindTransform = 'translate3d(' + (this.minus ? -1 : 1) * behindDistance + '%, 0, 0)';\n      var opacity = 1 + behindDistance / 100;\n\n      return {\n        content: {\n          opacity: opacity\n        },\n        container: {\n          transform: behindTransform\n        }\n      };\n    }\n  }, {\n    key: 'translate',\n    value: function translate(distance) {\n      this._side.style.display = '';\n      this._side.style.zIndex = 1;\n      this.maxWidth = this.maxWidth || this._getMaxWidth();\n      var menuStyle = this._generateBehindPageStyle(Math.min(distance, this.maxWidth));\n\n      if (!this._slidingElements) {\n        this._slidingElements = this._getSlidingElements();\n      }\n\n      this._mask.style.display = 'block'; // Avoid content clicks\n\n      Animit.runAll(Animit(this._slidingElements).queue({\n        transform: 'translate3d(' + (this.minus + distance) + 'px, 0px, 0px)'\n      }), Animit(this._side._content).queue(menuStyle.content), Animit(this._side).queue(menuStyle.container));\n    }\n\n    /**\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'open',\n    value: function open(done) {\n      var _this2 = this;\n\n      this._side.style.display = '';\n      this._side.style.zIndex = 1;\n      this.maxWidth = this.maxWidth || this._getMaxWidth();\n      var menuStyle = this._generateBehindPageStyle(this.maxWidth);\n      this._slidingElements = this._getSlidingElements();\n\n      setTimeout(function () {\n        // Fix: Time to update previous translate3d after changing style.display\n        Animit.runAll(Animit(_this2._slidingElements).wait(_this2.delay).queue({\n          transform: 'translate3d(' + (_this2.minus + _this2.maxWidth) + 'px, 0px, 0px)'\n        }, {\n          duration: _this2.duration,\n          timing: _this2.timing\n        }), Animit(_this2._mask).wait(_this2.delay).queue({\n          display: 'block'\n        }), Animit(_this2._side._content).wait(_this2.delay).queue(menuStyle.content, {\n          duration: _this2.duration,\n          timing: _this2.timing\n        }), Animit(_this2._side).wait(_this2.delay).queue(menuStyle.container, {\n          duration: _this2.duration,\n          timing: _this2.timing\n        }).queue(function (callback) {\n          _this2._slidingElements = null;\n          callback();\n          done && done();\n        }));\n      }, 1000 / 60);\n    }\n\n    /**\n     * @param {Function} done\n     */\n\n  }, {\n    key: 'close',\n    value: function close(done) {\n      var _this3 = this;\n\n      var menuStyle = this._generateBehindPageStyle(0);\n      this._slidingElements = this._getSlidingElements();\n\n      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({\n        transform: 'translate3d(0px, 0px, 0px)'\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(this._mask).wait(this.delay).queue({\n        display: 'none'\n      }), Animit(this._side._content).wait(this.delay).queue(menuStyle.content, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(this._side).wait(this.delay).queue(menuStyle.container, {\n        duration: this.duration,\n        timing: this.timing\n      }).queue(function (callback) {\n        _this3._slidingElements = null;\n        _this3._side.style.zIndex = 0;\n        _this3._side.style.display = 'none';\n        _this3._side._content.style.opacity = '';\n        done && done();\n        callback();\n      }));\n    }\n  }, {\n    key: '_getMaxWidth',\n    value: function _getMaxWidth() {\n      return this._side.offsetWidth;\n    }\n  }]);\n  return RevealSplitterAnimator;\n}(SplitterAnimator$1);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar _animatorDict$6 = {\n  default: OverlaySplitterAnimator,\n  overlay: OverlaySplitterAnimator,\n  push: PushSplitterAnimator,\n  reveal: RevealSplitterAnimator\n};\n\n/**\n * @element ons-splitter\n * @category menu\n * @description\n *  [en]\n *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.\n *\n *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.\n *  [/en]\n *  [ja][/ja]\n * @codepen rOQOML\n * @tutorial vanilla/Reference/splitter\n * @guide fundamentals.html#managing-pages\n *  [en]Managing multiple pages.[/en]\n *  [ja]複数のページを管理する[/ja]\n * @seealso ons-splitter-content\n *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]\n *  [ja]ons-splitter-contentコンポーネント[/ja]\n * @seealso ons-splitter-side\n *  [en]The `<ons-splitter-side>` component contains the menu.[/en]\n *  [ja]ons-splitter-sideコンポーネント[/ja]\n * @example\n * <ons-splitter id=\"splitter\">\n *   <ons-splitter-content>\n *     ...\n *   </ons-splitter-content>\n *\n *   <ons-splitter-side side=\"left\" width=\"80%\" collapse swipeable>\n *     ...\n *   </ons-splitter-side>\n * </ons-splitter>\n *\n * <script>\n *   var splitter = document.getElementById('splitter');\n *   splitter.left.open();\n * </script>\n */\n\nvar SplitterElement = function (_BaseElement) {\n  inherits(SplitterElement, _BaseElement);\n  createClass(SplitterElement, [{\n    key: '_getSide',\n    value: function _getSide(side) {\n      var element = util.findChild(this, function (e) {\n        return util.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;\n      });\n      return element;\n    }\n\n    /**\n     * @property left\n     * @readonly\n     * @type {HTMLElement}\n     * @description\n     *   [en]Left `<ons-splitter-side>` element.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: '_onDeviceBackButton',\n    value: function _onDeviceBackButton(event) {\n      this._sides.some(function (s) {\n        return s.isOpen ? s.close() : false;\n      }) || event.callParentHandler();\n    }\n  }, {\n    key: '_onModeChange',\n    value: function _onModeChange(e) {\n      var _this2 = this;\n\n      if (e.target.parentNode) {\n        contentReady(this, function () {\n          _this2._layout();\n        });\n      }\n    }\n  }, {\n    key: '_layout',\n    value: function _layout() {\n      var _this3 = this;\n\n      this._sides.forEach(function (side) {\n        if (_this3.content) {\n          _this3.content.style[side.side] = side.mode === 'split' ? side.style.width : 0;\n        }\n      });\n    }\n  }, {\n    key: 'left',\n    get: function get$$1() {\n      return this._getSide('left');\n    }\n    /**\n     * @property right\n     * @readonly\n     * @type {HTMLElement}\n     * @description\n     *   [en]Right `<ons-splitter-side>` element.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'right',\n    get: function get$$1() {\n      return this._getSide('right');\n    }\n\n    /**\n     * @property side\n     * @readonly\n     * @type {HTMLElement}\n     * @description\n     *   [en]First `<ons-splitter-side>` element regardless the actual side.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'side',\n    get: function get$$1() {\n      return util.findChild(this, 'ons-splitter-side');\n    }\n  }, {\n    key: '_sides',\n    get: function get$$1() {\n      return [this.left, this.right].filter(function (e) {\n        return e;\n      });\n    }\n    /**\n     * @property content\n     * @readonly\n     * @type {HTMLElement}\n     * @description\n     *   [en]The `<ons-splitter-content>` element.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'content',\n    get: function get$$1() {\n      return util.findChild(this, 'ons-splitter-content');\n    }\n  }, {\n    key: 'topPage',\n    get: function get$$1() {\n      return this.content._content;\n    }\n  }, {\n    key: 'mask',\n    get: function get$$1() {\n      return util.findChild(this, 'ons-splitter-mask');\n    }\n\n    /**\n     * @property onDeviceBackButton\n     * @type {Object}\n     * @description\n     *   [en]Back-button handler.[/en]\n     *   [ja]バックボタンハンドラ。[/ja]\n     */\n\n  }, {\n    key: 'onDeviceBackButton',\n    get: function get$$1() {\n      return this._backButtonHandler;\n    },\n    set: function set$$1(callback) {\n      if (this._backButtonHandler) {\n        this._backButtonHandler.destroy();\n      }\n\n      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);\n    }\n  }]);\n\n  function SplitterElement() {\n    classCallCheck(this, SplitterElement);\n\n    var _this = possibleConstructorReturn(this, (SplitterElement.__proto__ || Object.getPrototypeOf(SplitterElement)).call(this));\n\n    _this._onModeChange = _this._onModeChange.bind(_this);\n\n    contentReady(_this, function () {\n      !_this.mask && _this.appendChild(document.createElement('ons-splitter-mask'));\n      _this._layout();\n    });\n    return _this;\n  }\n\n  createClass(SplitterElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);\n      this.addEventListener('modechange', this._onModeChange, false);\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this._backButtonHandler.destroy();\n      this._backButtonHandler = null;\n      this.removeEventListener('modechange', this._onModeChange, false);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {}\n  }, {\n    key: '_show',\n    value: function _show() {\n      util.propagateAction(this, '_show');\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      util.propagateAction(this, '_hide');\n    }\n  }, {\n    key: '_destroy',\n    value: function _destroy() {\n      util.propagateAction(this, '_destroy');\n      this.remove();\n    }\n  }], [{\n    key: 'registerAnimator',\n    value: function registerAnimator(name, Animator) {\n      if (!(Animator instanceof SplitterAnimator)) {\n        throw new Error('Animator parameter must be an instance of SplitterAnimator.');\n      }\n      _animatorDict$6[name] = Animator;\n    }\n  }, {\n    key: 'SplitterAnimator',\n    get: function get$$1() {\n      return SplitterAnimator;\n    }\n  }, {\n    key: 'animators',\n    get: function get$$1() {\n      return _animatorDict$6;\n    }\n  }]);\n  return SplitterElement;\n}(BaseElement);\n\nons$1.elements.Splitter = SplitterElement;\ncustomElements.define('ons-splitter', SplitterElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar SPLIT_MODE = 'split';\nvar COLLAPSE_MODE = 'collapse';\nvar CLOSED_STATE = 'closed';\nvar OPEN_STATE = 'open';\nvar CHANGING_STATE = 'changing';\n\nvar rewritables$2 = {\n  /**\n   * @param {Element} splitterSideElement\n   * @param {Function} callback\n   */\n  ready: function ready(splitterSideElement, callback) {\n    setImmediate(callback);\n  }\n};\n\nvar CollapseDetection = function () {\n  function CollapseDetection(element, target) {\n    classCallCheck(this, CollapseDetection);\n\n    this._element = element;\n    this._onChange = this._onChange.bind(this);\n    target && this.changeTarget(target);\n  }\n\n  createClass(CollapseDetection, [{\n    key: 'changeTarget',\n    value: function changeTarget(target) {\n      this.disable();\n      this._target = target;\n      if (target) {\n        this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;\n        this.activate();\n      }\n    }\n  }, {\n    key: '_match',\n    value: function _match(value) {\n      if (this._orientation) {\n        return this._target === (value.isPortrait ? 'portrait' : 'landscape');\n      }\n      return value.matches;\n    }\n  }, {\n    key: '_onChange',\n    value: function _onChange(value) {\n      this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);\n    }\n  }, {\n    key: 'activate',\n    value: function activate() {\n      if (this._orientation) {\n        orientation.on('change', this._onChange);\n        this._onChange({ isPortrait: orientation.isPortrait() });\n      } else {\n        this._queryResult = window.matchMedia(this._target);\n        this._queryResult.addListener(this._onChange);\n        this._onChange(this._queryResult);\n      }\n    }\n  }, {\n    key: 'disable',\n    value: function disable() {\n      if (this._orientation) {\n        orientation.off('change', this._onChange);\n      } else if (this._queryResult) {\n        this._queryResult.removeListener(this._onChange);\n        this._queryResult = null;\n      }\n    }\n  }]);\n  return CollapseDetection;\n}();\n\n/**\n * @element ons-splitter-side\n * @category menu\n * @description\n *  [en]\n *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.\n *\n *    It will be displayed on either the left or right side of the `<ons-splitter-content>` element.\n *\n *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.\n *  [/en]\n *  [ja]ons-splitter-side要素は、ons-splitter要素の子要素として利用します。[/ja]\n * @codepen rOQOML\n * @tutorial vanilla/Reference/splitter\n * @guide fundamentals.html#managing-pages\n *  [en]Managing multiple pages.[/en]\n *  [ja]複数のページを管理する[/ja]\n * @seealso ons-splitter\n *  [en]The `<ons-splitter>` is the parent component.[/en]\n *  [ja]ons-splitterコンポーネント[/ja]\n * @seealso ons-splitter-content\n *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]\n *  [ja]ons-splitter-contentコンポーネント[/ja]\n * @example\n * <ons-splitter>\n *   <ons-splitter-content>\n *     ...\n *   </ons-splitter-content>\n *\n *   <ons-splitter-side side=\"left\" width=\"80%\" collapse>\n *     ...\n *   </ons-splitter-side>\n * </ons-splitter>\n */\n\nvar SplitterSideElement = function (_BaseElement) {\n  inherits(SplitterSideElement, _BaseElement);\n\n  /**\n   * @event modechange\n   * @description\n   *   [en]Fired just after the component's mode changes.[/en]\n   *   [ja]この要素のモードが変化した際に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクトです。[/ja]\n   * @param {Object} event.side\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {String} event.mode\n   *   [en]Returns the current mode. Can be either `\"collapse\"` or `\"split\"`.[/en]\n   *   [ja]現在のモードを返します。[/ja]\n   */\n\n  /**\n   * @event preopen\n   * @description\n   *   [en]Fired just before the sliding menu is opened.[/en]\n   *   [ja]スライディングメニューが開く前に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクトです。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Call to cancel opening sliding menu.[/en]\n   *   [ja]スライディングメニューが開くのをキャンセルします。[/ja]\n   * @param {Object} event.side\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @event postopen\n   * @description\n   *   [en]Fired just after the sliding menu is opened.[/en]\n   *   [ja]スライディングメニューが開いた後に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクトです。[/ja]\n   * @param {Object} event.side\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @event preclose\n   * @description\n   *   [en]Fired just before the sliding menu is closed.[/en]\n   *   [ja]スライディングメニューが閉じる前に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクトです。[/ja]\n   * @param {Object} event.side\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Call to cancel opening sliding-menu.[/en]\n   *   [ja]スライディングメニューが閉じるのをキャンセルします。[/ja]\n   */\n\n  /**\n   * @event postclose\n   * @description\n   *   [en]Fired just after the sliding menu is closed.[/en]\n   *   [ja]スライディングメニューが閉じた後に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクトです。[/ja]\n   * @param {Object} event.side\n   *   [en]Component object.[/en]\n   *   [ja]コンポーネントのオブジェクト。[/ja]\n   */\n\n  /**\n   * @attribute animation\n   * @type {String}\n   * @default  default\n   * @description\n   *  [en]Specify the animation. Use one of `overlay`, `push`, `reveal` or  `default`.[/en]\n   *  [ja]アニメーションを指定します。\"overlay\", \"push\", \"reveal\", \"default\"のいずれかを指定できます。[/ja]\n   */\n\n  /**\n   * @attribute animation-options\n   * @type {Expression}\n   * @description\n   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]\n   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]\n   */\n\n  /**\n   * @attribute open-threshold\n   * @type {Number}\n   * @default  0.3\n   * @description\n   *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]\n   *  [ja]どのくらいスワイプすればスライディングメニューを開くかどうかの割合を指定します。0から1の間の数値を指定します。スワイプの距離がここで指定した数値掛けるこの要素の幅よりも大きければ、スワイプが終わった時にこの要素を開きます。デフォルトは0.3です。[/ja]\n   */\n\n  /**\n   * @attribute collapse\n   * @type {String}\n   * @description\n   *   [en]\n   *     Specify the collapse behavior. Valid values are `\"portrait\"`, `\"landscape\"` or a media query.\n   *     The strings `\"portrait\"` and `\"landscape\"` means the view will collapse when device is in landscape or portrait orientation.\n   *     If the value is a media query, the view will collapse when the media query resolves to `true`.\n   *     If the value is not defined, the view always be in `\"collapse\"` mode.\n   *   [/en]\n   *   [ja]\n   *     左側のページを非表示にする条件を指定します。portrait, landscape、width #pxもしくはメディアクエリの指定が可能です。\n   *     portraitもしくはlandscapeを指定すると、デバイスの画面が縦向きもしくは横向きになった時に適用されます。\n   *     メディアクエリを指定すると、指定したクエリに適合している場合に適用されます。\n   *     値に何も指定しない場合には、常にcollapseモードになります。\n   *   [/ja]\n   */\n\n  /**\n   * @attribute swipe-target-width\n   * @type {String}\n   * @description\n   *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]\n   *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]\n   */\n\n  /**\n   * @attribute width\n   * @type {String}\n   * @description\n   *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]\n   *   [ja]この要素の横幅を指定します。pxと%での指定が可能です。eg. 90%, 200px[/ja]\n   */\n\n  /**\n   * @attribute side\n   * @type {String}\n   * @default left\n   * @description\n   *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `\"left\"` and `\"right\"`.[/en]\n   *   [ja]この要素が左か右かを指定します。指定できる値は\"left\"か\"right\"のみです。[/ja]\n   */\n\n  /**\n   * @attribute mode\n   * @type {String}\n   * @description\n   *   [en]Current mode. Possible values are `\"collapse\"` or `\"split\"`. This attribute is read only.[/en]\n   *   [ja]現在のモードが設定されます。\"collapse\"もしくは\"split\"が指定されます。この属性は読み込み専用です。[/ja]\n   */\n\n  /**\n   * @attribute page\n   * @initonly\n   * @type {String}\n   * @description\n   *   [en]The URL of the menu page.[/en]\n   *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]\n   */\n\n  /**\n   * @attribute swipeable\n   * @type {Boolean}\n   * @description\n   *   [en]Whether to enable swipe interaction on collapse mode.[/en]\n   *   [ja]collapseモード時にスワイプ操作を有効にする場合に指定します。[/ja]\n   */\n\n  function SplitterSideElement() {\n    classCallCheck(this, SplitterSideElement);\n\n    var _this = possibleConstructorReturn(this, (SplitterSideElement.__proto__ || Object.getPrototypeOf(SplitterSideElement)).call(this));\n\n    _this._page = null;\n    _this._state = CLOSED_STATE;\n    _this._lock = new DoorLock();\n    _this._pageLoader = defaultPageLoader;\n    _this._collapseDetection = new CollapseDetection(_this);\n\n    _this._animatorFactory = new AnimatorFactory({\n      animators: SplitterElement.animators,\n      baseClass: SplitterAnimator$1,\n      baseClassName: 'SplitterAnimator',\n      defaultAnimation: _this.getAttribute('animation')\n    });\n\n    contentReady(_this, function () {\n      // These attributes are used early by the parent element\n      _this.attributeChangedCallback('width');\n      if (!_this.hasAttribute('side')) {\n        _this.setAttribute('side', 'left');\n      }\n\n      rewritables$2.ready(_this, function () {\n        var page = _this._page || _this.getAttribute('page');\n        page && _this.load(page);\n      });\n    });\n    return _this;\n  }\n\n  createClass(SplitterSideElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      if (!util.match(this.parentNode, 'ons-splitter')) {\n        throw new Error('Parent must be an ons-splitter element.');\n      }\n\n      this._swipe = new SwipeReveal({\n        element: this,\n        elementHandler: this.parentElement,\n        swipeMax: function swipeMax() {\n          _this2._onSwipe && _this2._onSwipe(1, _this2._animationOpt);\n          _this2.open();\n        },\n        swipeMid: function swipeMid(distance, width) {\n          _this2._onSwipe && _this2._onSwipe(distance / width);\n          _this2._animator.translate(distance);\n        },\n        swipeMin: function swipeMin() {\n          _this2._onSwipe && _this2._onSwipe(0, _this2._animationOpt);\n          _this2.close();\n        },\n        getThreshold: function getThreshold() {\n          return Math.max(0, Math.min(1, parseFloat(_this2.getAttribute('open-threshold')) || 0.3));\n        },\n        getSide: function getSide() {\n          return _this2.side;\n        },\n        isInitialState: function isInitialState() {\n          var closed = _this2._state === CLOSED_STATE;\n          _this2._state = CHANGING_STATE;\n          return closed;\n        },\n        ignoreSwipe: function ignoreSwipe(event, distance) {\n          var isOpen = _this2.isOpen;\n          var validDrag = function validDrag(d) {\n            return _this2.side === 'left' ? d === 'left' && isOpen || d === 'right' && !isOpen : d === 'left' && !isOpen || d === 'right' && isOpen;\n          };\n\n          var area = Math.max(0, parseInt(_this2.getAttribute('swipe-target-width'), 10) || 0);\n\n          return _this2._mode === SPLIT_MODE || _this2._lock.isLocked() || _this2._isOtherSideOpen() || !validDrag(event.gesture.direction) || !isOpen && area !== 0 && distance > area;\n        }\n      });\n\n      this.attributeChangedCallback('swipeable');\n\n      contentReady(this, function () {\n        _this2.constructor.observedAttributes.forEach(function (attr) {\n          return _this2.attributeChangedCallback(attr, null, _this2.getAttribute(attr));\n        });\n      });\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this._swipe && this._swipe.dispose();\n      this._animator = this._animationOpt = this._swipe = null;\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'swipeable':\n          this._swipe && this._swipe.update();\n          break;\n        case 'width':\n          this.style.width = /^\\d+(px|%)$/.test(current) ? current : '80%';\n          break;\n        default:\n          this[util.camelize('_update-' + name)](current);\n      }\n    }\n  }, {\n    key: '_emitEvent',\n    value: function _emitEvent(name) {\n      if (name.slice(0, 3) !== 'pre') {\n        return util.triggerElementEvent(this, name, { side: this });\n      }\n      var isCanceled = false;\n\n      util.triggerElementEvent(this, name, {\n        side: this,\n        cancel: function cancel() {\n          return isCanceled = true;\n        }\n      });\n\n      return isCanceled;\n    }\n  }, {\n    key: '_isOtherSideOpen',\n    value: function _isOtherSideOpen() {\n      var _this3 = this;\n\n      return !!util.findChild(this.parentElement, function (el) {\n        return el instanceof _this3.constructor && el !== _this3 && el._mode === COLLAPSE_MODE && el.isOpen;\n      });\n    }\n  }, {\n    key: '_updateCollapse',\n    value: function _updateCollapse() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('collapse');\n\n      if (value === null || value === 'split') {\n        this._collapseDetection.disable();\n        return this._updateMode(SPLIT_MODE);\n      }\n      if (value === '' || value === 'collapse') {\n        this._collapseDetection.disable();\n        return this._updateMode(COLLAPSE_MODE);\n      }\n\n      this._collapseDetection.changeTarget(value);\n    }\n  }, {\n    key: '_updateMode',\n    value: function _updateMode(mode) {\n      if (mode !== this._mode) {\n        this._mode = mode;\n        this.setAttribute('mode', mode); // readonly attribute for the users\n\n        if (mode === SPLIT_MODE) {\n          this._animator && this._animator.deactivate();\n          this._state = CLOSED_STATE;\n        } else {\n          this._animator && this._animator.activate(this);\n          this._state === OPEN_STATE && this._animator.open();\n        }\n\n        util.triggerElementEvent(this, 'modechange', { side: this, mode: mode });\n      }\n    }\n  }, {\n    key: '_updateAnimation',\n    value: function _updateAnimation() {\n      var animation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation');\n\n      this._animator && this._animator.deactivate();\n      this._animator = this._animatorFactory.newAnimator({ animation: animation });\n      this._animator.activate(this);\n      this._animationOpt = {\n        timing: this._animator.duration,\n        duration: this._animator.duration\n      };\n    }\n  }, {\n    key: '_updateAnimationOptions',\n    value: function _updateAnimationOptions() {\n      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation-options');\n\n      this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));\n    }\n\n    /**\n     * @property page\n     * @type {*}\n     * @description\n     *   [en]Page location to load in the splitter side.[/en]\n     *   [ja]この要素内に表示するページを指定します。[/ja]\n     */\n\n  }, {\n    key: 'open',\n\n\n    /**\n     * @method open\n     * @signature open([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {Function} [options.callback]\n     *   [en]This function will be called after the menu has been opened.[/en]\n     *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *   [en]Open menu in collapse mode.[/en]\n     *   [ja]collapseモードになっているons-splitter-side要素を開きます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]\n     *   [ja][/ja]\n     */\n    value: function open(options) {\n      return this.toggle(options, true);\n    }\n\n    /**\n     * @method close\n     * @signature close([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {Function} [options.callback]\n     *   [en]This function will be called after the menu has been closed.[/en]\n     *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]\n     * @description\n     *   [en]Close menu in collapse mode.[/en]\n     *   [ja]collapseモードになっているons-splitter-side要素を閉じます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'close',\n    value: function close(options) {\n      return this.toggle(options, false);\n    }\n\n    /**\n     * @method toggle\n     * @signature toggle([options])\n     * @param {Object} [options]\n     * @description\n     *   [en]Opens if it's closed. Closes if it's open.[/en]\n     *   [ja]開けている場合は要素を閉じますそして開けている場合は要素を開きます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'toggle',\n    value: function toggle() {\n      var _this4 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var force = arguments[1];\n\n      var shouldOpen = typeof force === 'boolean' ? force : !this.isOpen;\n      var action = shouldOpen ? 'open' : 'close',\n          FINAL_STATE = shouldOpen ? OPEN_STATE : CLOSED_STATE;\n\n      if (this._mode === SPLIT_MODE) {\n        return Promise.resolve(false);\n      }\n      if (this._state === FINAL_STATE) {\n        return Promise.resolve(this);\n      }\n      if (this._lock.isLocked()) {\n        return Promise.reject('Another splitter-side action is already running.');\n      }\n      if (shouldOpen && this._isOtherSideOpen()) {\n        return Promise.reject('Another menu is already open.');\n      }\n      if (this._emitEvent('pre' + action)) {\n        return Promise.reject('Canceled in pre' + action + ' event.');\n      }\n\n      var unlock = this._lock.lock();\n      this._state = CHANGING_STATE;\n\n      return new Promise(function (resolve) {\n        _this4._animator[action](function () {\n          _this4._state = FINAL_STATE;\n          unlock();\n          _this4._emitEvent('post' + action);\n          options.callback instanceof Function && options.callback(_this4);\n          resolve(_this4);\n        });\n      });\n    }\n\n    /**\n     * @method load\n     * @signature load(page, [options])\n     * @param {String} page\n     *   [en]Page URL. Can be either an HTML document or an <ons-template>.[/en]\n     *   [ja]pageのURLか、ons-templateで宣言したテンプレートのid属性の値を指定します。[/ja]\n     * @param {Object} [options]\n     * @param {Function} [options.callback]\n     * @description\n     *   [en]Show the page specified in pageUrl in the right section[/en]\n     *   [ja]指定したURLをメインページを読み込みます。[/ja]\n     * @return {Promise}\n     *   [en]Resolves to the new page element[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'load',\n    value: function load(page) {\n      var _this5 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._page = page;\n      var callback = options.callback || function () {};\n\n      return new Promise(function (resolve) {\n        var oldContent = _this5._content || null;\n\n        _this5._pageLoader.load({ page: page, parent: _this5 }, function (pageElement) {\n          if (oldContent) {\n            _this5._pageLoader.unload(oldContent);\n            oldContent = null;\n          }\n\n          setImmediate(function () {\n            return _this5._show();\n          });\n\n          callback(pageElement);\n          resolve(pageElement);\n        });\n      });\n    }\n  }, {\n    key: '_show',\n    value: function _show() {\n      if (this._content) {\n        this._content._show();\n      }\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      if (this._content) {\n        this._content._hide();\n      }\n    }\n  }, {\n    key: '_destroy',\n    value: function _destroy() {\n      if (this._content) {\n        this._pageLoader.unload(this._content);\n      }\n      this.remove();\n    }\n  }, {\n    key: 'side',\n    get: function get$$1() {\n      return this.getAttribute('side') === 'right' ? 'right' : 'left';\n    }\n  }, {\n    key: 'page',\n    get: function get$$1() {\n      return this._page;\n    }\n\n    /**\n     * @param {*} page\n     */\n    ,\n    set: function set$$1(page) {\n      this._page = page;\n    }\n  }, {\n    key: '_content',\n    get: function get$$1() {\n      return this.children[0];\n    }\n\n    /**\n     * @property pageLoader\n     * @description\n     *   [en][/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'pageLoader',\n    get: function get$$1() {\n      return this._pageLoader;\n    },\n    set: function set$$1(loader) {\n      if (!(loader instanceof PageLoader)) {\n        throw Error('First parameter must be an instance of PageLoader.');\n      }\n      this._pageLoader = loader;\n    }\n\n    /**\n     * @property mode\n     * @readonly\n     * @type {String}\n     * @description\n     *   [en]Current mode. Possible values are \"split\", \"collapse\", \"closed\", \"open\" or \"changing\".[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'mode',\n    get: function get$$1() {\n      return this._mode;\n    }\n\n    /**\n     * @property onSwipe\n     * @type {Function}\n     * @description\n     *   [en]Hook called whenever the user slides the splitter. It gets a decimal ratio (0-1) and an animationOptions object as arguments.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'onSwipe',\n    get: function get$$1() {\n      return this._onSwipe;\n    },\n    set: function set$$1(value) {\n      if (value && !(value instanceof Function)) {\n        throw new Error('\\'onSwipe\\' must be a function.');\n      }\n      this._onSwipe = value;\n    }\n\n    /**\n     * @property isOpen\n     * @type {Boolean}\n     * @readonly\n     * @description\n     *   [en]This value is `true` when the menu is open.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'isOpen',\n    get: function get$$1() {\n      return this._mode === COLLAPSE_MODE && this._state !== CLOSED_STATE;\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['animation', 'width', 'collapse', 'swipeable', 'animation-options'];\n    }\n  }, {\n    key: 'events',\n    get: function get$$1() {\n      return ['preopen', 'postopen', 'preclose', 'postclose', 'modechange'];\n    }\n  }, {\n    key: 'rewritables',\n    get: function get$$1() {\n      return rewritables$2;\n    }\n  }]);\n  return SplitterSideElement;\n}(BaseElement);\n\nons$1.elements.SplitterSide = SplitterSideElement;\ncustomElements.define('ons-splitter-side', SplitterSideElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$31 = {\n  '': 'switch--*',\n  '.switch__input': 'switch--*__input',\n  '.switch__handle': 'switch--*__handle',\n  '.switch__toggle': 'switch--*__toggle'\n};\n\nvar locations = {\n  ios: [1, 21],\n  material: [0, 16]\n};\n\n/**\n * @element ons-switch\n * @category form\n * @description\n *   [en]\n *     Switch component. The switch can be toggled both by dragging and tapping.\n *\n *     Will automatically displays a Material Design switch on Android devices.\n *   [/en]\n *   [ja]スイッチを表示するコンポーネントです。[/ja]\n * @modifier material\n *   [en]Material Design switch[/en]\n *   [ja][/ja]\n * @codepen LpXZQQ\n * @tutorial vanilla/Reference/switch\n * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]\n * @example\n * <ons-switch checked></ons-switch>\n * <ons-switch disabled></ons-switch>\n * <ons-switch modifier=\"material\"></ons-switch>\n */\n\nvar SwitchElement = function (_BaseCheckboxElement) {\n  inherits(SwitchElement, _BaseCheckboxElement);\n\n  function SwitchElement() {\n    classCallCheck(this, SwitchElement);\n\n    var _this = possibleConstructorReturn(this, (SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement)).call(this));\n\n    contentReady(_this, function () {\n      _this.attributeChangedCallback('modifier', null, _this.getAttribute('modifier'));\n    });\n\n    _this._boundOnChange = _this._onChange.bind(_this);\n    _this._boundOnRelease = _this._onRelease.bind(_this);\n    return _this;\n  }\n\n  createClass(SwitchElement, [{\n    key: '_getPosition',\n\n\n    /* Own props */\n\n    value: function _getPosition(e) {\n      var l = this._locations;\n      return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));\n    }\n  }, {\n    key: '_emitChangeEvent',\n    value: function _emitChangeEvent() {\n      util.triggerElementEvent(this, 'change', {\n        value: this.checked,\n        switch: this,\n        isInteractive: true\n      });\n    }\n  }, {\n    key: '_onChange',\n    value: function _onChange(event) {\n      if (event && event.stopPropagation) {\n        event.stopPropagation();\n      }\n\n      this._emitChangeEvent();\n    }\n  }, {\n    key: '_onClick',\n    value: function _onClick(ev) {\n      if (ev.target.classList.contains(this.defaultElementClass + '__touch')) {\n        ev.preventDefault();\n      }\n    }\n  }, {\n    key: '_onHold',\n    value: function _onHold(e) {\n      if (!this.disabled) {\n        ModifierUtil.addModifier(this, 'active');\n        document.addEventListener('release', this._boundOnRelease);\n      }\n    }\n  }, {\n    key: '_onDragStart',\n    value: function _onDragStart(e) {\n      if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {\n        ModifierUtil.removeModifier(this, 'active');\n        return;\n      }\n\n      e.consumed = true;\n\n      ModifierUtil.addModifier(this, 'active');\n      this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;\n\n      this.addEventListener('drag', this._onDrag);\n      document.addEventListener('release', this._boundOnRelease);\n    }\n  }, {\n    key: '_onDrag',\n    value: function _onDrag(e) {\n      e.stopPropagation();\n      e.gesture.preventDefault();\n      this._handle.style.left = this._getPosition(e) + 'px';\n    }\n  }, {\n    key: '_onRelease',\n    value: function _onRelease(e) {\n      var l = this._locations;\n      var position = this._getPosition(e);\n      var previousValue = this.checked;\n\n      this.checked = position >= (l[0] + l[1]) / 2;\n\n      if (this.checked !== previousValue) {\n        this._emitChangeEvent();\n      }\n\n      this.removeEventListener('drag', this._onDrag);\n      document.removeEventListener('release', this._boundOnRelease);\n\n      this._handle.style.left = '';\n      ModifierUtil.removeModifier(this, 'active');\n    }\n  }, {\n    key: 'click',\n    value: function click() {\n      if (!this.disabled) {\n        this.checked = !this.checked;\n        this._emitChangeEvent();\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      contentReady(this, function () {\n        _this2._input.addEventListener('change', _this2._boundOnChange);\n      });\n\n      this.addEventListener('dragstart', this._onDragStart);\n      this.addEventListener('hold', this._onHold);\n      this.addEventListener('tap', this.click);\n      this.addEventListener('click', this._onClick);\n      this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251 });\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      var _this3 = this;\n\n      contentReady(this, function () {\n        _this3._input.removeEventListener('change', _this3._boundOnChange);\n      });\n\n      this.removeEventListener('dragstart', this._onDragStart);\n      this.removeEventListener('hold', this._onHold);\n      this.removeEventListener('tap', this.click);\n      this.removeEventListener('click', this._onClick);\n      if (this._gestureDetector) {\n        this._gestureDetector.dispose();\n      }\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'modifier') {\n        var md = (current || '').indexOf('material') !== -1;\n        this._locations = locations[md ? 'material' : 'ios'];\n      }\n\n      get(SwitchElement.prototype.__proto__ || Object.getPrototypeOf(SwitchElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);\n    }\n\n    /**\n     * @event change\n     * @description\n     *   [en]Fired when the switch is toggled.[/en]\n     *   [ja]ON/OFFが変わった時に発火します。[/ja]\n     * @param {Object} event\n     *   [en]Event object.[/en]\n     *   [ja]イベントオブジェクト。[/ja]\n     * @param {Object} event.switch\n     *   [en]Switch object.[/en]\n     *   [ja]イベントが発火したSwitchオブジェクトを返します。[/ja]\n     * @param {Boolean} event.value\n     *   [en]Current value.[/en]\n     *   [ja]現在の値を返します。[/ja]\n     * @param {Boolean} event.isInteractive\n     *   [en]True if the change was triggered by the user clicking on the switch.[/en]\n     *   [ja]タップやクリックなどのユーザの操作によって変わった場合にはtrueを返します。[/ja]\n     */\n\n    /**\n     * @attribute modifier\n     * @type {String}\n     * @description\n     *  [en]The appearance of the switch.[/en]\n     *  [ja]スイッチの表現を指定します。[/ja]\n     */\n\n    /**\n     * @attribute disabled\n     * @description\n     *   [en]Whether the switch is be disabled.[/en]\n     *   [ja]スイッチを無効の状態にする場合に指定します。[/ja]\n     */\n\n    /**\n     * @attribute checked\n     * @description\n     *   [en]Whether the switch is checked.[/en]\n     *   [ja]スイッチがONの状態にするときに指定します。[/ja]\n     */\n\n    /**\n     * @attribute input-id\n     * @type {String}\n     * @description\n     *   [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for=\"...\">` elements.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property checked\n     * @type {Boolean}\n     * @description\n     *   [en]This value is `true` if the switch is checked.[/en]\n     *   [ja]スイッチがONの場合に`true`。[/ja]\n     */\n\n    /**\n     * @property value\n     * @type {String}\n     * @description\n     *   [en]The current value of the input.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @property disabled\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is disabled or not.[/en]\n     *   [ja]無効化されている場合に`true`。[/ja]\n     */\n\n    /**\n     * @property checkbox\n     * @readonly\n     * @type {HTMLElement}\n     * @description\n     *   [en]The underlying checkbox element.[/en]\n     *   [ja]コンポーネント内部のcheckbox要素になります。[/ja]\n     */\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$31;\n    }\n  }, {\n    key: '_defaultClassName',\n    get: function get$$1() {\n      return 'switch';\n    }\n  }, {\n    key: '_template',\n    get: function get$$1() {\n      return '\\n      <input type=\"' + this.type + '\" class=\"' + this._defaultClassName + '__input\">\\n      <div class=\"' + this._defaultClassName + '__toggle\">\\n        <div class=\"' + this._defaultClassName + '__handle\">\\n          <div class=\"' + this._defaultClassName + '__touch\"></div>\\n        </div>\\n      </div>\\n    ';\n    }\n  }, {\n    key: 'type',\n    get: function get$$1() {\n      return 'checkbox';\n    }\n  }, {\n    key: '_handle',\n    get: function get$$1() {\n      return this.querySelector('.' + this._defaultClassName + '__handle');\n    }\n  }, {\n    key: 'checkbox',\n    get: function get$$1() {\n      return this._input;\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return [].concat(toConsumableArray(get(SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement), 'observedAttributes', this)), ['modifier']);\n    }\n  }]);\n  return SwitchElement;\n}(BaseCheckboxElement);\n\nons$1.elements.Switch = SwitchElement;\ncustomElements.define('ons-switch', SwitchElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$33 = {\n  '.tabbar__content': 'tabbar--*__content',\n  '.tabbar__border': 'tabbar--*__border',\n  '.tabbar': 'tabbar--*'\n};\n\nvar rewritables$3 = {\n  /**\n   * @param {Element} tabbarElement\n   * @param {Function} callback\n   */\n  ready: function ready(tabbarElement, callback) {\n    callback();\n  }\n};\n\nvar lerp = function lerp(x0, x1, t) {\n  return (1 - t) * x0 + t * x1;\n};\n\n/**\n * @element ons-tabbar\n * @category tabbar\n * @description\n *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]\n *   [ja]タブバーをページ下部に表示するためのコンポーネントです。ons-tabと組み合わせて使うことで、ページを管理できます。[/ja]\n * @codepen pGuDL\n * @tutorial vanilla/Reference/tabbar\n * @modifier material\n *   [en]A tabbar in Material Design.[/en]\n *   [ja][/ja]\n * @modifier autogrow\n *   [en]Tabs automatically grow depending on their content instead of having a fixed width.[/en]\n *   [ja][/ja]\n * @modifier top-border\n *   [en]Shows a static border-bottom in tabs for iOS top tabbars.[/en]\n *   [ja][/ja]\n * @guide fundamentals.html#managing-pages\n *  [en]Managing multiple pages.[/en]\n *  [ja]複数のページを管理する[/ja]\n * @seealso ons-tab\n *   [en]The `<ons-tab>` component.[/en]\n *   [ja]ons-tabコンポーネント[/ja]\n * @seealso ons-page\n *   [en]The `<ons-page>` component.[/en]\n *   [ja]ons-pageコンポーネント[/ja]\n * @example\n * <ons-tabbar>\n *   <ons-tab\n *     page=\"home.html\"\n *     label=\"Home\"\n *     active>\n *   </ons-tab>\n *   <ons-tab\n *     page=\"settings.html\"\n *     label=\"Settings\"\n *     active>\n *   </ons-tab>\n * </ons-tabbar>\n *\n * <ons-template id=\"home.html\">\n *   ...\n * </ons-template>\n *\n * <ons-template id=\"settings.html\">\n *   ...\n * </ons-template>\n */\n\nvar TabbarElement = function (_BaseElement) {\n  inherits(TabbarElement, _BaseElement);\n\n  /**\n   * @event prechange\n   * @description\n   *   [en]Fires just before the tab is changed.[/en]\n   *   [ja]アクティブなタブが変わる前に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクト。[/ja]\n   * @param {Number} event.index\n   *   [en]Current index.[/en]\n   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]\n   * @param {Object} event.tabItem\n   *   [en]Tab item object.[/en]\n   *   [ja]tabItemオブジェクト。[/ja]\n   * @param {Function} event.cancel\n   *   [en]Call this function to cancel the change event.[/en]\n   *   [ja]この関数を呼び出すと、アクティブなタブの変更がキャンセルされます。[/ja]\n   */\n\n  /**\n   * @event postchange\n   * @description\n   *   [en]Fires just after the tab is changed.[/en]\n   *   [ja]アクティブなタブが変わった後に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクト。[/ja]\n   * @param {Number} event.index\n   *   [en]Current index.[/en]\n   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]\n   * @param {Object} event.tabItem\n   *   [en]Tab item object.[/en]\n   *   [ja]tabItemオブジェクト。[/ja]\n   */\n\n  /**\n   * @event reactive\n   * @description\n   *   [en]Fires if the already open tab is tapped again.[/en]\n   *   [ja]すでにアクティブになっているタブがもう一度タップやクリックされた場合に発火します。[/ja]\n   * @param {Object} event\n   *   [en]Event object.[/en]\n   *   [ja]イベントオブジェクト。[/ja]\n   * @param {Number} event.index\n   *   [en]Current index.[/en]\n   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]\n   * @param {Object} event.tabItem\n   *   [en]Tab item object.[/en]\n   *   [ja]tabItemオブジェクト。[/ja]\n   */\n\n  /**\n   * @attribute animation\n   * @type {String}\n   * @default none\n   * @description\n   *   [en]If this attribute is set to `\"none\"` the transitions will not be animated.[/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute animation-options\n   * @type {Expression}\n   * @description\n   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]\n   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]\n   */\n\n  /**\n   * @attribute position\n   * @initonly\n   * @type {String}\n   * @default bottom\n   * @description\n   *   [en]Tabbar's position. Available values are `\"bottom\"` and `\"top\"`. Use `\"auto\"` to choose position depending on platform (bottom for iOS flat design, top for Material Design).[/en]\n   *   [ja]タブバーの位置を指定します。\"bottom\"もしくは\"top\"を選択できます。デフォルトは\"bottom\"です。[/ja]\n   */\n\n  /**\n   * @attribute swipeable\n   * @description\n   *   [en]If this attribute is set the tab bar can be scrolled by drag or swipe.[/en]\n   *   [ja]この属性がある時、タブバーをスワイプやドラッグで移動できるようになります。[/ja]\n   */\n\n  /**\n   * @attribute ignore-edge-width\n   * @type {Number}\n   * @default 20\n   * @description\n   *   [en]Distance in pixels from both edges. Swiping on these areas will prioritize parent components such as `ons-splitter` or `ons-navigator`.[/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute hide-tabs\n   * @description\n   *   [en]Whether to hide the tabs.[/en]\n   *   [ja]タブを非表示にする場合に指定します。[/ja]\n   */\n\n  /**\n   * @attribute tab-border\n   * @description\n   *   [en]If this attribute is set the tabs show a dynamic bottom border. Only works for iOS flat design since the border is always visible in Material Design.[/en]\n   *   [ja][/ja]\n   */\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the tabbar.[/en]\n   *   [ja]タブバーの表現を指定します。[/ja]\n   */\n\n  function TabbarElement() {\n    classCallCheck(this, TabbarElement);\n\n    var _this = possibleConstructorReturn(this, (TabbarElement.__proto__ || Object.getPrototypeOf(TabbarElement)).call(this));\n\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(TabbarElement, [{\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this2 = this;\n\n      if (!this._swiper) {\n        this._swiper = new Swiper({\n          getElement: function getElement() {\n            return _this2._contentElement;\n          },\n          getInitialIndex: function getInitialIndex() {\n            return _this2.getAttribute('activeIndex') || _this2.getAttribute('active-index');\n          },\n          getAutoScrollRatio: this._getAutoScrollRatio.bind(this),\n          getBubbleWidth: function getBubbleWidth() {\n            return parseInt(_this2.getAttribute('ignore-edge-width') || 25, 10);\n          },\n          isAutoScrollable: function isAutoScrollable() {\n            return true;\n          },\n          preChangeHook: this._onPreChange.bind(this),\n          postChangeHook: this._onPostChange.bind(this),\n          refreshHook: this._onRefresh.bind(this),\n          scrollHook: this._onScroll.bind(this)\n        });\n\n        contentReady(this, function () {\n          _this2._tabbarBorder = util.findChild(_this2._tabbarElement, '.tabbar__border');\n          _this2._swiper.init({ swipeable: _this2.hasAttribute('swipeable') });\n          setTimeout(function () {\n            return _this2._onRefresh();\n          }, 1000 / 60); // Fix tabbar border in some iframes\n        });\n      }\n\n      contentReady(this, function () {\n        return _this2._updatePosition();\n      });\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      if (this._swiper && this._swiper.initialized) {\n        this._swiper.dispose();\n        this._swiper = null;\n        this._tabbarBorder = null;\n        this._tabsRect = null;\n      }\n    }\n  }, {\n    key: '_normalizeEvent',\n    value: function _normalizeEvent(event) {\n      return _extends({}, event, { index: event.activeIndex, tabItem: this.tabs[event.activeIndex] });\n    }\n  }, {\n    key: '_onPostChange',\n    value: function _onPostChange(event) {\n      event = this._normalizeEvent(event);\n      util.triggerElementEvent(this, 'postchange', event);\n      var page = event.tabItem.pageElement;\n      page && page._show();\n    }\n  }, {\n    key: '_onPreChange',\n    value: function _onPreChange(event) {\n      event = this._normalizeEvent(event);\n      event.cancel = function () {\n        return event.canceled = true;\n      };\n\n      util.triggerElementEvent(this, 'prechange', event);\n\n      if (!event.canceled) {\n        var _event = event,\n            activeIndex = _event.activeIndex,\n            lastActiveIndex = _event.lastActiveIndex;\n\n        var tabs = this.tabs;\n\n        tabs[activeIndex].setActive(true);\n        if (lastActiveIndex >= 0) {\n          var prevTab = tabs[lastActiveIndex];\n          prevTab.setActive(false);\n          prevTab.pageElement && prevTab.pageElement._hide();\n        }\n      }\n\n      return event.canceled;\n    }\n  }, {\n    key: '_onScroll',\n    value: function _onScroll(index) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this._tabbarBorder) {\n        this._tabbarBorder.style.transition = 'all ' + (options.duration || 0) + 's ' + (options.timing || '');\n\n        if (this._autogrow && this._tabsRect.length > 0) {\n          var a = Math.floor(index),\n              b = Math.ceil(index),\n              r = index % 1;\n          this._tabbarBorder.style.width = lerp(this._tabsRect[a].width, this._tabsRect[b].width, r) + 'px';\n          this._tabbarBorder.style.transform = 'translate3d(' + lerp(this._tabsRect[a].left, this._tabsRect[b].left, r) + 'px, 0, 0)';\n        } else {\n          this._tabbarBorder.style.transform = 'translate3d(' + index * 100 + '%, 0, 0)';\n        }\n      }\n\n      this._onSwipe && this._onSwipe(index, options);\n    }\n  }, {\n    key: '_onRefresh',\n    value: function _onRefresh() {\n      this._autogrow = util.hasModifier(this, 'autogrow');\n      this._tabsRect = this.tabs.map(function (tab) {\n        return tab.getBoundingClientRect();\n      });\n      if (this._tabbarBorder) {\n        this._tabbarBorder.style.display = this.hasAttribute('tab-border') || util.hasModifier(this, 'material') ? 'block' : 'none';\n        var index = this.getActiveTabIndex();\n        if (this._tabsRect.length > 0 && index >= 0) {\n          this._tabbarBorder.style.width = this._tabsRect[index].width + 'px';\n        }\n      }\n    }\n  }, {\n    key: '_getAutoScrollRatio',\n    value: function _getAutoScrollRatio(matches, velocity, size) {\n      var ratio = .6; // Base ratio\n      var modifier = size / 300 * (matches ? -1 : 1); // Based on screen size\n      return Math.min(1, Math.max(0, ratio + velocity * modifier));\n    }\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      var content = this._contentElement || util.create('.tabbar__content');\n      content.classList.add('ons-tabbar__content');\n      var tabbar = this._tabbarElement || util.create('.tabbar');\n      tabbar.classList.add('ons-tabbar__footer');\n\n      if (!tabbar.parentNode) {\n        while (this.firstChild) {\n          tabbar.appendChild(this.firstChild);\n        }\n      }\n\n      var activeIndex = Number(this.getAttribute('activeIndex')); // 0 by default\n      if (tabbar.children.length > activeIndex && !util.findChild(tabbar, '[active]')) {\n        tabbar.children[activeIndex].setAttribute('active', '');\n      }\n\n      this._tabbarBorder = util.findChild(tabbar, '.tabbar__border') || util.create('.tabbar__border');\n      tabbar.appendChild(this._tabbarBorder);\n      tabbar.classList.add('ons-swiper-tabbar'); // Hides material border\n\n      !content.children[0] && content.appendChild(document.createElement('div'));\n      !content.children[1] && content.appendChild(document.createElement('div'));\n      content.appendChild = content.appendChild.bind(content.children[0]);\n      content.insertBefore = content.insertBefore.bind(content.children[0]);\n\n      this.appendChild(content);\n      this.appendChild(tabbar); // Triggers ons-tab connectedCallback\n\n      ModifierUtil.initModifier(this, scheme$33);\n    }\n  }, {\n    key: '_updatePosition',\n    value: function _updatePosition() {\n      var _this3 = this;\n\n      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('position');\n\n      var top = this._top = position === 'top' || position === 'auto' && util.hasModifier(this, 'material');\n      var action = top ? util.addModifier : util.removeModifier;\n\n      action(this, 'top');\n\n      var page = util.findParent(this, 'ons-page');\n      if (page) {\n        contentReady(page, function () {\n          var p = 0;\n          if (page.children[0] && util.match(page.children[0], 'ons-toolbar')) {\n            action(page.children[0], 'noshadow');\n            p = 1; // Visual fix for some devices\n          }\n\n          var content = page._getContentElement();\n          var cs = window.getComputedStyle(page._getContentElement(), null);\n\n          _this3.style.top = top ? parseInt(cs.getPropertyValue('padding-top'), 10) - p + 'px' : '';\n\n          // Refresh content top - Fix for iOS 8\n          content.style.top = cs.top;\n          content.style.top = '';\n        });\n      }\n\n      internal$1.autoStatusBarFill(function () {\n        var filled = util.findParent(_this3, function (e) {\n          return e.hasAttribute('status-bar-fill');\n        });\n        util.toggleAttribute(_this3, 'status-bar-fill', top && !filled);\n      });\n    }\n  }, {\n    key: 'setActiveTab',\n\n\n    /**\n     * @method setActiveTab\n     * @signature setActiveTab(index, [options])\n     * @param {Number} index\n     *   [en]Tab index.[/en]\n     *   [ja]タブのインデックスを指定します。[/ja]\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {Function} [options.callback]\n     *   [en]Function that runs when the new page has loaded.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animation]\n     *   [en]If this option is \"none\", the transition won't slide.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @description\n     *   [en]Show specified tab page. Animations and their options can be specified by the second parameter.[/en]\n     *   [ja]指定したインデックスのタブを表示します。アニメーションなどのオプションを指定できます。[/ja]\n     * @return {Promise}\n     *   [en]A promise that resolves to the new page element.[/en]\n     *   [ja][/ja]\n     */\n    value: function setActiveTab(nextIndex) {\n      var _this4 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var prevIndex = this.getActiveTabIndex();\n      var prevTab = this.tabs[prevIndex],\n          nextTab = this.tabs[nextIndex];\n\n      if (!nextTab) {\n        return Promise.reject('Specified index does not match any tab.');\n      }\n\n      if (nextIndex === prevIndex) {\n        util.triggerElementEvent(this, 'reactive', { index: nextIndex, activeIndex: nextIndex, tabItem: nextTab });\n        return Promise.resolve(nextTab.pageElement);\n      }\n\n      // FIXME: nextTab.loaded is broken in Zone.js promises (Angular2)\n      var nextPage = nextTab.pageElement;\n      return (nextPage ? Promise.resolve(nextPage) : nextTab.loaded).then(function (nextPage) {\n        return _this4._swiper.setActiveIndex(nextIndex, _extends({\n          reject: true\n        }, options, {\n          animation: prevTab && nextPage ? options.animation || _this4.getAttribute('animation') : 'none',\n          animationOptions: util.extend({ duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }, _this4.hasAttribute('animation-options') ? util.animationOptionsParse(_this4.getAttribute('animation-options')) : {}, options.animationOptions || {})\n        })).then(function () {\n          options.callback instanceof Function && options.callback(nextPage);\n          return nextPage;\n        });\n      });\n    }\n\n    /**\n     * @method setTabbarVisibility\n     * @signature setTabbarVisibility(visible)\n     * @param {Boolean} visible\n     * @description\n     *   [en]Used to hide or show the tab bar.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'setTabbarVisibility',\n    value: function setTabbarVisibility(visible) {\n      var _this5 = this;\n\n      contentReady(this, function () {\n        _this5._contentElement.style[_this5._top ? 'top' : 'bottom'] = visible ? '' : '0px';\n        _this5._tabbarElement.style.display = visible ? '' : 'none';\n        visible && _this5._onRefresh();\n      });\n    }\n  }, {\n    key: 'show',\n    value: function show() {\n      this.setTabbarVisibility(true);\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      this.setTabbarVisibility(false);\n    }\n\n    /**\n     * @property visible\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the tabbar is visible or not.[/en]\n     *   [ja]タブバーが見える場合に`true`。[/ja]\n     */\n\n  }, {\n    key: 'getActiveTabIndex',\n\n\n    /**\n     * @method getActiveTabIndex\n     * @signature getActiveTabIndex()\n     * @return {Number}\n     *   [en]The index of the currently active tab.[/en]\n     *   [ja]現在アクティブになっているタブのインデックスを返します。[/ja]\n     * @description\n     *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]\n     *   [ja]現在アクティブになっているタブのインデックスを返します。現在アクティブなタブがない場合には-1を返します。[/ja]\n     */\n    value: function getActiveTabIndex() {\n      for (var tabs = this.tabs, i = 0; i < tabs.length; i++) {\n        if (tabs[i] && tabs[i].tagName === 'ONS-TAB' && tabs[i].isActive()) {\n          return i;\n        }\n      }\n      return -1;\n    }\n  }, {\n    key: '_show',\n    value: function _show() {\n      var _this6 = this;\n\n      this._swiper.show();\n      setImmediate(function () {\n        return _this6.tabs.length > 0 && _this6.tabs[_this6.getActiveTabIndex()].loaded.then(function (el) {\n          return el && setImmediate(function () {\n            return el._show();\n          });\n        });\n      });\n    }\n  }, {\n    key: '_hide',\n    value: function _hide() {\n      this._swiper.hide();\n      var topPage = this.topPage;\n      topPage && topPage._hide();\n    }\n  }, {\n    key: '_destroy',\n    value: function _destroy() {\n      this.tabs.forEach(function (tab) {\n        return tab.remove();\n      });\n      this.remove();\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      if (name === 'modifier') {\n        ModifierUtil.onModifierChanged(last, current, this, scheme$33);\n        var isTop = function isTop(m) {\n          return (/(^|\\s+)top($|\\s+)/i.test(m)\n          );\n        };\n        isTop(last) !== isTop(current) && this._updatePosition();\n      } else if (name === 'position') {\n        util.isAttached(this) && this._updatePosition();\n      } else if (name === 'swipeable') {\n        this._swiper && this._swiper.updateSwipeable(this.hasAttribute('swipeable'));\n      } else if (name === 'hide-tabs') {\n        this.setTabbarVisibility(!this.hasAttribute('hide-tabs') || current === 'false');\n      }\n    }\n  }, {\n    key: '_tabbarElement',\n    get: function get$$1() {\n      return util.findChild(this, '.tabbar');\n    }\n  }, {\n    key: '_contentElement',\n    get: function get$$1() {\n      return util.findChild(this, '.tabbar__content');\n    }\n  }, {\n    key: '_targetElement',\n    get: function get$$1() {\n      var content = this._contentElement;\n      return content && content.children[0] || null;\n    }\n  }, {\n    key: 'topPage',\n    get: function get$$1() {\n      var tabs = this.tabs,\n          index = this.getActiveTabIndex();\n      return tabs[index] ? tabs[index].pageElement || this.pages[0] || null : null;\n    }\n  }, {\n    key: 'pages',\n    get: function get$$1() {\n      return util.arrayFrom(this._targetElement.children);\n    }\n  }, {\n    key: 'tabs',\n    get: function get$$1() {\n      return Array.prototype.filter.call(this._tabbarElement.children, function (e) {\n        return e.tagName === 'ONS-TAB';\n      });\n    }\n  }, {\n    key: 'visible',\n    get: function get$$1() {\n      return this._tabbarElement.style.display !== 'none';\n    }\n\n    /**\n     * @property swipeable\n     * @type {Boolean}\n     * @description\n     *   [en]Enable swipe interaction.[/en]\n     *   [ja]swipeableであればtrueを返します。[/ja]\n     */\n\n  }, {\n    key: 'swipeable',\n    get: function get$$1() {\n      return this.hasAttribute('swipeable');\n    },\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'swipeable', value);\n    }\n\n    /**\n     * @property onSwipe\n     * @type {Function}\n     * @description\n     *   [en]Hook called whenever the user slides the tabbar. It gets a decimal index and an animationOptions object as arguments.[/en]\n     *   [ja][/ja]\n     */\n\n  }, {\n    key: 'onSwipe',\n    get: function get$$1() {\n      return this._onSwipe;\n    },\n    set: function set$$1(value) {\n      if (value && !(value instanceof Function)) {\n        throw new Error('\\'onSwipe\\' must be a function.');\n      }\n      this._onSwipe = value;\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'position', 'swipeable', 'tab-border', 'hide-tabs'];\n    }\n  }, {\n    key: 'rewritables',\n    get: function get$$1() {\n      return rewritables$3;\n    }\n  }, {\n    key: 'events',\n    get: function get$$1() {\n      return ['prechange', 'postchange', 'reactive'];\n    }\n  }]);\n  return TabbarElement;\n}(BaseElement);\n\nons$1.elements.Tabbar = TabbarElement;\ncustomElements.define('ons-tabbar', TabbarElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$19 = 'tabbar__item';\n\nvar scheme$32 = {\n  '': 'tabbar--*__item',\n  '.tabbar__button': 'tabbar--*__button'\n};\n\n/**\n * @element ons-tab\n * @category tabbar\n * @description\n *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]\n *   [ja]\n *     タブバーに配置される各アイテムのコンポーネントです。それぞれのons-tabはページを表します。\n *     ons-tab要素の中には、タブに表示されるコンテンツを直接記述することが出来ます。\n *   [/ja]\n * @codepen pGuDL\n * @tutorial vanilla/Reference/tabbar\n * @guide fundamentals.html#managing-pages\n *   [en]Managing multiple pages.[/en]\n *   [ja]複数のページを管理する[/ja]]\n * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]\n * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]\n * @seealso ons-tabbar\n *   [en]ons-tabbar component[/en]\n *   [ja]ons-tabbarコンポーネント[/ja]\n * @seealso ons-page\n *   [en]ons-page component[/en]\n *   [ja]ons-pageコンポーネント[/ja]\n * @seealso ons-icon\n *   [en]ons-icon component[/en]\n *   [ja]ons-iconコンポーネント[/ja]\n * @example\n * <ons-tabbar>\n *   <ons-tab\n *     page=\"home.html\"\n *     label=\"Home\"\n *     active>\n *   </ons-tab>\n *   <ons-tab\n *     page=\"settings.html\"\n *     label=\"Settings\"\n *     active>\n *   </ons-tab>\n * </ons-tabbar>\n *\n * <ons-template id=\"home.html\">\n *   ...\n * </ons-template>\n *\n * <ons-template id=\"settings.html\">\n *   ...\n * </ons-template>\n\n */\n\nvar TabElement = function (_BaseElement) {\n  inherits(TabElement, _BaseElement);\n\n  /**\n   * @attribute page\n   * @initonly\n   * @type {String}\n   * @description\n   *   [en]The page that is displayed when the tab is tapped.[/en]\n   *   [ja]ons-tabが参照するページへのURLを指定します。[/ja]\n   */\n\n  /**\n   * @attribute icon\n   * @type {String}\n   * @description\n   *   [en]\n   *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`. Check [See also](#seealso) section for more information.\n   *   [/en]\n   *   [ja]\n   *     アイコン名を指定します。ons-iconと同じアイコン名を指定できます。\n   *     個別にアイコンをカスタマイズする場合は、background-imageなどのCSSスタイルを用いて指定できます。\n   *   [/ja]\n   */\n\n  /**\n   * @attribute active-icon\n   * @type {String}\n   * @description\n   *   [en]The name of the icon when the tab is active.[/en]\n   *   [ja]アクティブの際のアイコン名を指定します。[/ja]\n   */\n\n  /**\n   * @attribute label\n   * @type {String}\n   * @description\n   *   [en]The label of the tab item.[/en]\n   *   [ja]アイコン下に表示されるラベルを指定します。[/ja]\n   */\n\n  /**\n   * @attribute badge\n   * @type {String}\n   * @description\n   *   [en]Display a notification badge on top of the tab.[/en]\n   *   [ja]バッジに表示する内容を指定します。[/ja]\n   */\n\n  /**\n   * @attribute active\n   * @description\n   *   [en]This attribute should be set to the tab that is active by default.[/en]\n   *   [ja][/ja]\n   */\n\n  function TabElement() {\n    classCallCheck(this, TabElement);\n\n    var _this = possibleConstructorReturn(this, (TabElement.__proto__ || Object.getPrototypeOf(TabElement)).call(this));\n\n    if (['label', 'icon', 'badge'].some(_this.hasAttribute.bind(_this))) {\n      _this._compile();\n    } else {\n      contentReady(_this, function () {\n        return _this._compile();\n      });\n    }\n\n    _this._pageLoader = defaultPageLoader;\n    _this._boundOnClick = _this._onClick.bind(_this);\n    return _this;\n  }\n\n  createClass(TabElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n      this.classList.add(defaultClassName$19);\n\n      if (this._button) {\n        return;\n      }\n\n      var button = util.create('button.tabbar__button');\n      while (this.childNodes[0]) {\n        button.appendChild(this.childNodes[0]);\n      }\n\n      var input = util.create('input', { display: 'none' });\n      input.type = 'radio';\n\n      this.appendChild(input);\n      this.appendChild(button);\n\n      this._updateButtonContent();\n      ModifierUtil.initModifier(this, scheme$32);\n      this._updateRipple();\n    }\n  }, {\n    key: '_updateRipple',\n    value: function _updateRipple() {\n      this._button && util.updateRipple(this._button, this.hasAttribute('ripple'));\n    }\n  }, {\n    key: '_updateButtonContent',\n    value: function _updateButtonContent() {\n      var _this2 = this;\n\n      var button = this._button;\n\n      var iconWrapper = this._icon;\n      if (this.hasAttribute('icon')) {\n        iconWrapper = iconWrapper || util.createElement('<div class=\"tabbar__icon\"><ons-icon></ons-icon></div>');\n        var icon = iconWrapper.children[0];\n        var fix = function (last) {\n          return function () {\n            return icon.attributeChangedCallback('icon', last, _this2.getAttribute('icon'));\n          };\n        }(icon.getAttribute('icon'));\n        icon.setAttribute('icon', this.getAttribute('icon'));\n        iconWrapper.parentElement !== button && button.insertBefore(iconWrapper, button.firstChild);\n\n        // dirty fix for https://github.com/OnsenUI/OnsenUI/issues/1654\n        icon.attributeChangedCallback instanceof Function ? fix() : setImmediate(function () {\n          return icon.attributeChangedCallback instanceof Function && fix();\n        });\n      } else {\n        iconWrapper && iconWrapper.remove();\n      }\n\n      ['label', 'badge'].forEach(function (attr, index) {\n        var prop = _this2.querySelector('.tabbar__' + attr);\n        if (_this2.hasAttribute(attr)) {\n          prop = prop || util.create('.tabbar__' + attr + (attr === 'badge' ? ' notification' : ''));\n          prop.textContent = _this2.getAttribute(attr);\n          prop.parentElement !== button && button.appendChild(prop);\n        } else {\n          prop && prop.remove();\n        }\n      });\n    }\n  }, {\n    key: '_onClick',\n    value: function _onClick() {\n      if (this.onClick instanceof Function) {\n        this.onClick();\n      } else {\n        this._tabbar.setActiveTab(this.index, { reject: false });\n      }\n    }\n  }, {\n    key: 'setActive',\n    value: function setActive() {\n      var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      this._input.checked = active;\n      this.classList.toggle('active', active);\n      util.toggleAttribute(this, 'active', active);\n\n      if (this.hasAttribute('icon') && this.hasAttribute('active-icon')) {\n        this._icon.children[0].setAttribute('icon', this.getAttribute(active ? 'active-icon' : 'icon'));\n      }\n    }\n  }, {\n    key: '_loadPageElement',\n    value: function _loadPageElement(parent, page) {\n      var _this3 = this;\n\n      this._hasLoaded = true;\n      return new Promise(function (resolve) {\n        _this3._pageLoader.load({ parent: parent, page: page }, function (pageElement) {\n          parent.replaceChild(pageElement, parent.children[_this3.index]); // Ensure position\n          _this3._loadedPage = pageElement;\n          resolve(pageElement);\n        });\n      });\n    }\n  }, {\n    key: 'isActive',\n\n\n    /**\n     * @return {Boolean}\n     */\n    value: function isActive() {\n      return this.classList.contains('active');\n    }\n  }, {\n    key: 'disconnectedCallback',\n    value: function disconnectedCallback() {\n      this.loaded = null;\n      this.removeEventListener('click', this._boundOnClick, false);\n      if (this._loadedPage) {\n        this._pageLoader.unload(this._loadedPage);\n        this._loadedPage = null;\n        this._hasLoaded = false;\n      }\n    }\n  }, {\n    key: 'connectedCallback',\n    value: function connectedCallback() {\n      var _this4 = this;\n\n      if (!util.isAttached(this) || this.loaded) {\n        return; // ons-tabbar compilation may trigger this\n      }\n\n      var deferred = util.defer();\n      this.loaded = deferred.promise;\n\n      contentReady(this, function () {\n        var index = _this4.index;\n        var tabbar = _this4._tabbar;\n        if (!tabbar) {\n          throw new Error('This ons-tab element must be child of ons-tabbar element.');\n        }\n\n        if (tabbar.hasAttribute('modifier')) {\n          util.addModifier(_this4, tabbar.getAttribute('modifier'));\n        }\n\n        if (!_this4._hasLoaded) {\n          if (_this4.hasAttribute('active')) {\n            _this4.setActive(true);\n            tabbar.setAttribute('activeIndex', index);\n          }\n\n          if (index === tabbar.tabs.length - 1) {\n            tabbar._onRefresh();\n            setImmediate(function () {\n              return tabbar._onRefresh();\n            });\n          }\n\n          TabbarElement.rewritables.ready(tabbar, function () {\n            var pageTarget = _this4.page || _this4.getAttribute('page');\n            if (!_this4.pageElement && pageTarget) {\n              var parentTarget = tabbar._targetElement;\n              var dummyPage = util.create('div', { height: '100%', width: '100%', backgroundColor: 'transparent' });\n              parentTarget.insertBefore(dummyPage, parentTarget.children[index]); // Ensure position\n              return _this4._loadPageElement(parentTarget, pageTarget).then(deferred.resolve);\n            }\n\n            return deferred.resolve(_this4.pageElement);\n          });\n        }\n\n        _this4.addEventListener('click', _this4._boundOnClick, false);\n      });\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      var _this5 = this;\n\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$19, scheme$32);\n          break;\n        case 'modifier':\n          contentReady(this, function () {\n            return ModifierUtil.onModifierChanged(last, current, _this5, scheme$32);\n          });\n          break;\n        case 'ripple':\n          contentReady(this, function () {\n            return _this5._updateRipple();\n          });\n          break;\n        case 'icon':\n        case 'label':\n        case 'badge':\n          contentReady(this, function () {\n            return _this5._updateButtonContent();\n          });\n          break;\n        case 'page':\n          this.page = current || '';\n          break;\n      }\n    }\n  }, {\n    key: 'pageLoader',\n    set: function set$$1(loader) {\n      if (!(loader instanceof PageLoader)) {\n        throw Error('First parameter must be an instance of PageLoader.');\n      }\n      this._pageLoader = loader;\n    },\n    get: function get$$1() {\n      return this._pageLoader;\n    }\n  }, {\n    key: '_input',\n    get: function get$$1() {\n      return util.findChild(this, 'input');\n    }\n  }, {\n    key: '_button',\n    get: function get$$1() {\n      return util.findChild(this, '.tabbar__button');\n    }\n  }, {\n    key: '_icon',\n    get: function get$$1() {\n      return this.querySelector('.tabbar__icon');\n    }\n  }, {\n    key: '_tabbar',\n    get: function get$$1() {\n      return util.findParent(this, 'ons-tabbar');\n    }\n  }, {\n    key: 'index',\n    get: function get$$1() {\n      return Array.prototype.indexOf.call(this.parentElement.children, this);\n    }\n  }, {\n    key: 'pageElement',\n    get: function get$$1() {\n      // It has been loaded by ons-tab\n      if (this._loadedPage) {\n        return this._loadedPage;\n      }\n      // Manually attached to DOM, 1 per tab\n      var tabbar = this._tabbar;\n      if (tabbar.pages.length === tabbar.tabs.length) {\n        return tabbar.pages[this.index];\n      }\n      // Loaded in another way\n      return null;\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'ripple', 'icon', 'label', 'page', 'badge', 'class'];\n    }\n  }]);\n  return TabElement;\n}(BaseElement);\n\nons$1.elements.Tab = TabElement;\ncustomElements.define('ons-tab', TabElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar ToastAnimator = function (_BaseAnimator) {\n  inherits(ToastAnimator, _BaseAnimator);\n\n  /**\n   * @param {Object} options\n   * @param {String} options.timing\n   * @param {Number} options.duration\n   * @param {Number} options.delay\n   */\n  function ToastAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'linear' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.2 : _ref$duration;\n\n    classCallCheck(this, ToastAnimator);\n    return possibleConstructorReturn(this, (ToastAnimator.__proto__ || Object.getPrototypeOf(ToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {HTMLElement} modal\n   * @param {Function} callback\n   */\n\n\n  createClass(ToastAnimator, [{\n    key: 'show',\n    value: function show(modal, callback) {\n      callback();\n    }\n\n    /**\n     * @param {HTMLElement} modal\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(modal, callback) {\n      callback();\n    }\n  }]);\n  return ToastAnimator;\n}(BaseAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * iOS style animator for dialog.\n */\n\nvar FadeToastAnimator = function (_ToastAnimator) {\n  inherits(FadeToastAnimator, _ToastAnimator);\n\n  function FadeToastAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'linear' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.3 : _ref$duration;\n\n    classCallCheck(this, FadeToastAnimator);\n    return possibleConstructorReturn(this, (FadeToastAnimator.__proto__ || Object.getPrototypeOf(FadeToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n  }\n\n  /**\n   * @param {HTMLElement} toast\n   * @param {Function} callback\n   */\n\n\n  createClass(FadeToastAnimator, [{\n    key: 'show',\n    value: function show(toast, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit(toast).saveStyle().queue({\n        opacity: 0\n      }).wait(this.delay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }).play();\n    }\n\n    /**\n     * @param {HTMLElement} toast\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(toast, callback) {\n      callback = callback ? callback : function () {};\n\n      Animit(toast).saveStyle().queue({\n        opacity: 1\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback();\n        done();\n      }).play();\n    }\n  }]);\n  return FadeToastAnimator;\n}(ToastAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Ascend Toast Animator.\n */\n\nvar AscendToastAnimator = function (_ToastAnimator) {\n  inherits(AscendToastAnimator, _ToastAnimator);\n\n  function AscendToastAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'ease' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.25 : _ref$duration;\n\n    classCallCheck(this, AscendToastAnimator);\n\n    var _this = possibleConstructorReturn(this, (AscendToastAnimator.__proto__ || Object.getPrototypeOf(AscendToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this.messageDelay = _this.duration * 0.4 + _this.delay; // Delay message opacity change\n    if (platform.isAndroid()) {\n      _this.ascension = 48; // Toasts are always 1 line\n    } else {\n      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {\n        _this.ascension = 98; // 64 + 34\n      } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {\n        _this.ascension = 85; // 64 + 21\n      } else {\n        _this.ascension = 64;\n      }\n    }\n    return _this;\n  }\n\n  /**\n   * @param {HTMLElement} toast\n   * @param {Function} callback\n   */\n\n\n  createClass(AscendToastAnimator, [{\n    key: 'show',\n    value: function show(toast, callback) {\n      toast = toast._toast;\n      util.globals.fabOffset = this.ascension;\n\n      Animit.runAll(Animit(toast).saveStyle().queue({\n        transform: 'translate3d(0, ' + this.ascension + 'px, 0)'\n      }).wait(this.delay).queue({\n        transform: 'translate3d(0, 0, 0)'\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback && callback();\n        done();\n      }), Animit(this._getFabs()).wait(this.delay).queue({\n        transform: 'translate3d(0, -' + this.ascension + 'px, 0) scale(1)'\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(util.arrayFrom(toast.children)).saveStyle().queue({\n        opacity: 0\n      }).wait(this.messageDelay).queue({\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle());\n    }\n\n    /**\n     * @param {HTMLElement} toast\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(toast, callback) {\n      toast = toast._toast;\n      util.globals.fabOffset = 0;\n\n      Animit.runAll(Animit(toast).saveStyle().queue({\n        transform: 'translate3d(0, 0, 0)'\n      }).wait(this.delay).queue({\n        transform: 'translate3d(0, ' + this.ascension + 'px, 0)'\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback && callback();\n        done();\n      }), Animit(this._getFabs()).wait(this.delay).queue({\n        transform: 'translate3d(0, 0, 0) scale(1)'\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }), Animit(util.arrayFrom(toast.children)).saveStyle().queue({\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle());\n    }\n  }, {\n    key: '_getFabs',\n    value: function _getFabs() {\n      return util.arrayFrom(document.querySelectorAll('ons-fab[position~=bottom], ons-speed-dial[position~=bottom]')).filter(function (fab) {\n        return fab.visible;\n      });\n    }\n  }]);\n  return AscendToastAnimator;\n}(ToastAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Lift-fade Toast Animator\n */\n\nvar LiftToastAnimator = function (_ToastAnimator) {\n  inherits(LiftToastAnimator, _ToastAnimator);\n\n  function LiftToastAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'ease' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.35 : _ref$duration;\n\n    classCallCheck(this, LiftToastAnimator);\n\n    var _this = possibleConstructorReturn(this, (LiftToastAnimator.__proto__ || Object.getPrototypeOf(LiftToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    _this.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout\n    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {\n      _this.liftAmount = 'calc(100% + 34px)';\n    } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {\n      _this.liftAmount = 'calc(100% + 21px)';\n    } else {\n      _this.liftAmount = '100%';\n    }\n    return _this;\n  }\n\n  /**\n   * @param {HTMLElement} toast\n   * @param {Function} callback\n   */\n\n\n  createClass(LiftToastAnimator, [{\n    key: 'show',\n    value: function show(toast, callback) {\n      toast = toast._toast;\n\n      Animit.runAll(Animit(toast).saveStyle().queue({\n        transform: 'translate3d(0, ' + this.liftAmount + ', 0)',\n        opacity: 0\n      }).wait(this.delay).queue({\n        transform: 'translate3d(0, 0, 0)',\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback && callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {HTMLElement} toast\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(toast, callback) {\n      toast = toast._toast;\n\n      Animit.runAll(Animit(toast).saveStyle().queue({\n        transform: 'translate3d(0, 0, 0)',\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        transform: 'translate3d(0, ' + this.liftAmount + ', 0)',\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback && callback();\n        done();\n      }));\n    }\n  }, {\n    key: '_updatePosition',\n    value: function _updatePosition(toast) {\n      if (parseInt(toast.style.top, 10) === 0) {\n        toast.style.top = toast.style.bottom = '';\n      }\n    }\n  }]);\n  return LiftToastAnimator;\n}(ToastAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\n/**\n * Fall-fade Toast Animator\n */\n\nvar FallToastAnimator = function (_ToastAnimator) {\n  inherits(FallToastAnimator, _ToastAnimator);\n\n  function FallToastAnimator() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$timing = _ref.timing,\n        timing = _ref$timing === undefined ? 'ease' : _ref$timing,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === undefined ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === undefined ? 0.35 : _ref$duration;\n\n    classCallCheck(this, FallToastAnimator);\n\n    var _this = possibleConstructorReturn(this, (FallToastAnimator.__proto__ || Object.getPrototypeOf(FallToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));\n\n    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {\n      _this.fallAmount = 'calc(-100% - 44px)';\n    } else {\n      _this.fallAmount = '-100%';\n    }\n    return _this;\n  }\n\n  /**\n   * @param {HTMLElement} toast\n   * @param {Function} callback\n   */\n\n\n  createClass(FallToastAnimator, [{\n    key: 'show',\n    value: function show(toast, callback) {\n      toast = toast._toast;\n      this._updatePosition(toast);\n\n      Animit.runAll(Animit(toast).saveStyle().queue({\n        transform: 'translate3d(0, ' + this.fallAmount + ', 0)',\n        opacity: 0\n      }).wait(this.delay).queue({\n        transform: 'translate3d(0, 0, 0)',\n        opacity: 1.0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        callback && callback();\n        done();\n      }));\n    }\n\n    /**\n     * @param {HTMLElement} toast\n     * @param {Function} callback\n     */\n\n  }, {\n    key: 'hide',\n    value: function hide(toast, callback) {\n      var _this2 = this;\n\n      toast = toast._toast;\n      this._updatePosition(toast);\n\n      Animit.runAll(Animit(toast).saveStyle().queue({\n        transform: 'translate3d(0, 0, 0)',\n        opacity: 1.0\n      }).wait(this.delay).queue({\n        transform: 'translate3d(0, ' + this.fallAmount + ', 0)',\n        opacity: 0\n      }, {\n        duration: this.duration,\n        timing: this.timing\n      }).restoreStyle().queue(function (done) {\n        _this2._updatePosition(toast, true);\n        callback && callback();\n        done();\n      }));\n    }\n  }, {\n    key: '_updatePosition',\n    value: function _updatePosition(toast, cleanUp) {\n      var correctTop = void 0;\n      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {\n        correctTop = '44px';\n      } else {\n        correctTop = '0';\n      }\n\n      if (toast.style.top !== correctTop) {\n        toast.style.top = correctTop;\n        toast.style.bottom = 'initial';\n      }\n    }\n  }]);\n  return FallToastAnimator;\n}(ToastAnimator);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar scheme$34 = {\n  '.toast': 'toast--*',\n  '.toast__message': 'toast--*__message',\n  '.toast__button': 'toast--*__button'\n};\n\nvar defaultClassName$20 = 'toast';\n\nvar _animatorDict$7 = {\n  'default': platform.isAndroid() ? AscendToastAnimator : LiftToastAnimator,\n  'fade': FadeToastAnimator,\n  'ascend': AscendToastAnimator,\n  'lift': LiftToastAnimator,\n  'fall': FallToastAnimator,\n  'none': ToastAnimator\n};\n\n/**\n * @element ons-toast\n * @category dialog\n * @description\n *   [en]\n *     The Toast or Snackbar component is useful for displaying dismissable information or simple actions at (normally) the bottom of the page.\n *\n *     This component does not block user input, allowing the app to continue its flow. For simple toasts, consider `ons.notification.toast` instead.\n *   [/en]\n *   [ja][/ja]\n * @tutorial vanilla/Reference/dialog\n * @seealso ons-alert-dialog\n *   [en]The `<ons-alert-dialog>` component is preferred for displaying undismissable information.[/en]\n *   [ja][/ja]\n */\n\nvar ToastElement = function (_BaseDialogElement) {\n  inherits(ToastElement, _BaseDialogElement);\n\n  /**\n   * @attribute animation\n   * @type {String}\n   * @default default\n   * @description\n   *  [en]The animation used when showing and hiding the toast. Can be either `\"default\"`, `\"ascend\"` (Android), `\"lift\"` (iOS), `\"fall\"`, `\"fade\"` or `\"none\"`.[/en]\n   *  [ja][/ja]\n   */\n\n  /**\n   * @attribute animation-options\n   * @type {Expression}\n   * @description\n   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]\n   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]\n   */\n\n  function ToastElement() {\n    classCallCheck(this, ToastElement);\n\n    var _this = possibleConstructorReturn(this, (ToastElement.__proto__ || Object.getPrototypeOf(ToastElement)).call(this));\n\n    _this._defaultDBB = function (e) {\n      return e.callParentHandler();\n    };\n    contentReady(_this, function () {\n      return _this._compile();\n    });\n    return _this;\n  }\n\n  createClass(ToastElement, [{\n    key: '_updateAnimatorFactory',\n    value: function _updateAnimatorFactory() {\n      // Reset position style\n      this._toast && (this._toast.style.top = this._toast.style.bottom = '');\n\n      return new AnimatorFactory({\n        animators: _animatorDict$7,\n        baseClass: ToastAnimator,\n        baseClassName: 'ToastAnimator',\n        defaultAnimation: this.getAttribute('animation')\n      });\n    }\n\n    /**\n     * @property onDeviceBackButton\n     * @type {Object}\n     * @description\n     *   [en]Back-button handler.[/en]\n     *   [ja]バックボタンハンドラ。[/ja]\n     */\n\n  }, {\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.style.display = 'none';\n      this.style.zIndex = 10000; // Lower than dialogs\n\n      var messageClassName = 'toast__message';\n      var buttonClassName = 'toast__button';\n\n      var toast = util.findChild(this, '.' + defaultClassName$20);\n      if (!toast) {\n        toast = document.createElement('div');\n        toast.classList.add(defaultClassName$20);\n        while (this.childNodes[0]) {\n          toast.appendChild(this.childNodes[0]);\n        }\n      }\n\n      var button = util.findChild(toast, '.' + buttonClassName);\n      if (!button) {\n        button = util.findChild(toast, function (e) {\n          return util.match(e, '.button') || util.match(e, 'button');\n        });\n        if (button) {\n          button.classList.remove('button');\n          button.classList.add(buttonClassName);\n          toast.appendChild(button);\n        }\n      }\n\n      if (!util.findChild(toast, '.' + messageClassName)) {\n        var message = util.findChild(toast, '.message');\n        if (!message) {\n          message = document.createElement('div');\n          for (var i = toast.childNodes.length - 1; i >= 0; i--) {\n            if (toast.childNodes[i] !== button) {\n              message.insertBefore(toast.childNodes[i], message.firstChild);\n            }\n          }\n        }\n        message.classList.add(messageClassName);\n\n        toast.insertBefore(message, toast.firstChild);\n      }\n\n      if (toast.parentNode !== this) {\n        this.appendChild(toast);\n      }\n\n      ModifierUtil.initModifier(this, this._scheme);\n    }\n\n    /**\n     * @property visible\n     * @readonly\n     * @type {Boolean}\n     * @description\n     *   [en]Whether the element is visible or not.[/en]\n     *   [ja]要素が見える場合に`true`。[/ja]\n     */\n\n    /**\n     * @method show\n     * @signature show([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"default\"`, `\"ascend\"` (Android), `\"lift\"` (iOS), `\"fall\"`, `\"fade\"` or `\"none\"`.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @description\n     *   [en]Show the element.[/en]\n     *   [ja][/ja]\n     * @return {Promise}\n     *   [en]Resolves to the displayed element[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @method toggle\n     * @signature toggle([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"default\"`, `\"ascend\"` (Android), `\"lift\"` (iOS), `\"fall\"`, `\"fade\"` or `\"none\"`.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @description\n     *   [en]Toggle toast visibility.[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @method hide\n     * @signature hide([options])\n     * @param {Object} [options]\n     *   [en]Parameter object.[/en]\n     *   [ja]オプションを指定するオブジェクト。[/ja]\n     * @param {String} [options.animation]\n     *   [en]Animation name. Available animations are `\"default\"`, `\"ascend\"` (Android), `\"lift\"` (iOS), `\"fall\"`, `\"fade\"` or `\"none\"`.[/en]\n     *   [ja][/ja]\n     * @param {String} [options.animationOptions]\n     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]\n     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]\n     * @description\n     *   [en]Hide toast.[/en]\n     *   [ja][/ja]\n     * @return {Promise}\n     *   [en]Resolves to the hidden element[/en]\n     *   [ja][/ja]\n     */\n\n    /**\n     * @param {String} name\n     * @param {Function} Animator\n     */\n\n  }, {\n    key: '_scheme',\n    get: function get$$1() {\n      return scheme$34;\n    }\n  }, {\n    key: '_toast',\n    get: function get$$1() {\n      return util.findChild(this, '.' + defaultClassName$20);\n    }\n  }], [{\n    key: 'registerAnimator',\n    value: function registerAnimator(name, Animator) {\n      if (!(Animator.prototype instanceof ToastAnimator)) {\n        throw new Error('\"Animator\" param must inherit OnsToastElement.ToastAnimator');\n      }\n      _animatorDict$7[name] = Animator;\n    }\n  }, {\n    key: 'animators',\n    get: function get$$1() {\n      return _animatorDict$7;\n    }\n  }, {\n    key: 'ToastAnimator',\n    get: function get$$1() {\n      return ToastAnimator;\n    }\n  }]);\n  return ToastElement;\n}(BaseDialogElement);\n\nons$1.elements.Toast = ToastElement;\ncustomElements.define('ons-toast', ToastElement);\n\n/*\nCopyright 2013-2015 ASIAL CORPORATION\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n*/\n\nvar defaultClassName$21 = 'toolbar-button';\n\nvar scheme$35 = { '': 'toolbar-button--*' };\n\n/**\n * @element ons-toolbar-button\n * @category page\n * @modifier material\n *   [en]Material Design toolbar button.[/en]\n *   [ja][/ja]\n * @modifier outline\n *   [en]A button with an outline.[/en]\n *   [ja]アウトラインをもったボタンを表示します。[/ja]\n * @description\n *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]\n *   [ja]ons-toolbarあるいはons-bottom-toolbarに設置できるボタン用コンポーネントです。[/ja]\n * @codepen aHmGL\n * @tutorial vanilla/Reference/page\n * @guide compilation.html#toolbar-compilation\n *   [en]Adding a toolbar[/en]\n *   [ja]ツールバーの追加[/ja]\n * @seealso ons-toolbar\n *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]\n *   [ja]ons-toolbarコンポーネント[/ja]\n * @seealso ons-back-button\n *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]\n *   [ja]ons-back-buttonコンポーネント[/ja]\n * @example\n * <ons-toolbar>\n *   <div class=\"left\">\n *     <ons-toolbar-button>\n *       Button\n *     </ons-toolbar-button>\n *   </div>\n *   <div class=\"center\">\n *     Title\n *   </div>\n *   <div class=\"right\">\n *     <ons-toolbar-button>\n *       <ons-icon icon=\"ion-navicon\" size=\"28px\"></ons-icon>\n *     </ons-toolbar-button>\n *   </div>\n * </ons-toolbar>\n */\n\nvar ToolbarButtonElement = function (_BaseElement) {\n  inherits(ToolbarButtonElement, _BaseElement);\n\n  /**\n   * @attribute modifier\n   * @type {String}\n   * @description\n   *   [en]The appearance of the button.[/en]\n   *   [ja]ボタンの表現を指定します。[/ja]\n   */\n\n  /**\n   * @attribute disabled\n   * @description\n   *   [en]Specify if button should be disabled.[/en]\n   *   [ja]ボタンを無効化する場合は指定してください。[/ja]\n   */\n\n  function ToolbarButtonElement() {\n    classCallCheck(this, ToolbarButtonElement);\n\n    var _this = possibleConstructorReturn(this, (ToolbarButtonElement.__proto__ || Object.getPrototypeOf(ToolbarButtonElement)).call(this));\n\n    _this._compile();\n    return _this;\n  }\n\n  /**\n   * @property disabled\n   * @type {Boolean}\n   * @description\n   *   [en]Whether the element is disabled or not.[/en]\n   *   [ja]無効化されている場合に`true`。[/ja]\n   */\n\n\n  createClass(ToolbarButtonElement, [{\n    key: '_compile',\n    value: function _compile() {\n      autoStyle.prepare(this);\n\n      this.classList.add(defaultClassName$21);\n\n      util.updateRipple(this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' });\n\n      ModifierUtil.initModifier(this, scheme$35);\n    }\n  }, {\n    key: 'attributeChangedCallback',\n    value: function attributeChangedCallback(name, last, current) {\n      switch (name) {\n        case 'class':\n          util.restoreClass(this, defaultClassName$21, scheme$35);\n          break;\n        case 'modifier':\n          ModifierUtil.onModifierChanged(last, current, this, scheme$35);\n          break;\n      }\n    }\n  }, {\n    key: 'disabled',\n    set: function set$$1(value) {\n      return util.toggleAttribute(this, 'disabled', value);\n    },\n    get: function get$$1() {\n      return this.hasAttribute('disabled');\n    }\n  }], [{\n    key: 'observedAttributes',\n    get: function get$$1() {\n      return ['modifier', 'class'];\n    }\n  }]);\n  return ToolbarButtonElement;\n}(BaseElement);\n\nons$1.elements.ToolbarButton = ToolbarButtonElement;\ncustomElements.define('ons-toolbar-button', ToolbarButtonElement);\n\n// Add and register Custom Elements\nsetup$1(ons$1); // Setup initial listeners\nwindow._superSecretOns = ons$1;\n\nreturn ons$1;\n\n})));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib25zZW51aS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vY29yZS9zcmMvb25zL3N0eWxlci5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wbGF0Zm9ybS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2ludGVybmFsLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnkuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYXV0b3N0eWxlLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL3V0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWl0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvY29udGVudC1yZWFkeS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC90b2FzdC1xdWV1ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9ub3RpZmljYXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYWN0aW9uLXNoZWV0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL21pY3JvZXZlbnQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvb3JpZW50YXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvbW9kaWZpZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvc29mdHdhcmUta2V5Ym9hcmQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvZG9vcmxvY2suanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvcGFnZS1sb2FkZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9wb2x5ZmlsbHMvcG9seWZpbGwtc3dpdGNoZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQub2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvVXRpbGl0aWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvQ3VzdG9tRWxlbWVudFN0YXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9EZWZlcnJlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0N1c3RvbUVsZW1lbnRSZWdpc3RyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL05hdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0FscmVhZHlDb25zdHJ1Y3RlZE1hcmtlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL0hUTUxFbGVtZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvSW50ZXJmYWNlL1BhcmVudE5vZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9Eb2N1bWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL05vZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9JbnRlcmZhY2UvQ2hpbGROb2RlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvRWxlbWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL2N1c3RvbS1lbGVtZW50cy5qcyIsIi4uLy4uL2NvcmUvc3JjL3BvbHlmaWxscy9NdXRhdGlvbk9ic2VydmVyQDAuNy4yMi9NdXRhdGlvbk9ic2VydmVyLmpzIiwiLi4vLi4vY29yZS9zcmMvcG9seWZpbGxzL3NldEltbWVkaWF0ZUAxLjAuMittb2Qvc2V0SW1tZWRpYXRlLmpzIiwiLi4vLi4vY29yZS9zcmMvcG9seWZpbGxzL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvdmVuZG9yL0Zhc3RDbGlja0AxLjAuNittb2QvZmFzdGNsaWNrLmpzIiwiLi4vLi4vY29yZS9zcmMvdmVuZG9yL3ZpZXdwb3J0LmpzIiwiLi4vLi4vY29yZS9zcmMvdmVuZG9yL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvc2V0dXAuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtZWxlbWVudC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10ZW1wbGF0ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1pZi5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9iYXNlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2lwaG9uZXgtcGF0Y2guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0L2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvYmFzZS9iYXNlLWRpYWxvZy5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hY3Rpb24tc2hlZXQvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2cvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy1idXR0b24uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYmFjay1idXR0b24uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYm90dG9tLXRvb2xiYXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNhcmQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtY2Fyb3VzZWwtaXRlbS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC9zd2lwZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtY2Fyb3VzZWwuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtY29sLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWRpYWxvZy9hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1kaWFsb2cvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtZmFiLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWdlc3R1cmUtZGV0ZWN0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtaWNvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC9sYXp5LXJlcGVhdC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1sYXp5LXJlcGVhdC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1saXN0LWhlYWRlci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1saXN0LXRpdGxlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWxpc3QtaXRlbS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1saXN0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvYmFzZS9iYXNlLWlucHV0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWlucHV0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvYmFzZS9iYXNlLWNoZWNrYm94LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNoZWNrYm94LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJhZGlvLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNlYXJjaC1pbnB1dC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1tb2RhbC9hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1tb2RhbC9mYWRlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW1vZGFsL2xpZnQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbW9kYWwvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvc3dpcGUtcmV2ZWFsLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLXNsaWRlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3Mtc3dpcGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1saWZ0LWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3MtZmFkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtc2xpZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL21kLWxpZnQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL21kLWZhZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL25vbmUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvb2xiYXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcGFnZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wb3BvdmVyL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXBvcG92ZXIvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcHJvZ3Jlc3MtYmFyLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXByb2dyZXNzLWNpcmN1bGFyLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXB1bGwtaG9vay5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1yYW5nZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1yaXBwbGUvYW5pbWF0b3ItY3NzLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJpcHBsZS9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1yb3cuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc2VnbWVudC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zZWxlY3QuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbC1pdGVtLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwZWVkLWRpYWwuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXItY29udGVudC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci1tYXNrLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyL292ZXJsYXktYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXIvcHVzaC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci9yZXZlYWwtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXIvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXItc2lkZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zd2l0Y2guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdGFiYmFyL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRhYi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b2FzdC9hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b2FzdC9mYWRlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2FzY2VuZC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b2FzdC9saWZ0LWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2ZhbGwtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9vbGJhci1idXR0b24uanMiLCIuLi8uLi9jb3JlL3NyYy9pbmRleC51bWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuXG4vKipcbiAqIEFkZCB2ZW5kb3IgcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmNvbnN0IHByZWZpeCA9IChmdW5jdGlvbigpIHtcbiAgY29uc3Qgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyk7XG4gIGNvbnN0IHByZWZpeCA9IChBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAuY2FsbChzdHlsZXMpXG4gICAgLmpvaW4oJycpXG4gICAgLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IChzdHlsZXMuT0xpbmsgPT09ICcnICYmIFsnJywgJ28nXSlcbiAgKVsxXTtcblxuICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiAnLScgKyBwcmVmaXggKyAnLScgKyB1dGlsLmh5cGhlbmF0ZShuYW1lKTtcbiAgfTtcbn0pKCk7XG5cblxuLyoqXG4gKiBNaW5pbWFsIHV0aWxpdHkgbGlicmFyeSBmb3IgbWFuaXB1bGF0aW5nIGVsZW1lbnQncyBzdHlsZS5cbiAqIFNldCBlbGVtZW50J3Mgc3R5bGUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5jb25zdCBzdHlsZXIgPSBmdW5jdGlvbihlbGVtZW50LCBzdHlsZSkge1xuICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoa2V5IGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSBlbHNlIGlmIChwcmVmaXgoa2V5KSBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3ByZWZpeChrZXkpXSA9IHN0eWxlW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwud2FybignTm8gc3VjaCBzdHlsZSBwcm9wZXJ0eTogJyArIGtleSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0eWxlcyBTcGFjZS1zZXBhcmF0ZWQgQ1NTIHByb3BlcnRpZXMgdG8gcmVtb3ZlXG4gKi9cbnN0eWxlci5jbGVhciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN0eWxlcyA9ICcnKSB7XG4gIGNvbnN0IGNsZWFybGlzdCA9IHN0eWxlcy5zcGxpdCgvXFxzKy8pLnJlZHVjZSgociwgcykgPT4gci5jb25jYXQoW3V0aWwuaHlwaGVuYXRlKHMpLCBwcmVmaXgocyldKSwgW10pLFxuICAgIGtleXMgPSBbXTtcblxuICBmb3IgKGxldCBpID0gZWxlbWVudC5zdHlsZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGtleSA9IGVsZW1lbnQuc3R5bGVbaV07XG4gICAgaWYgKGNsZWFybGlzdC5sZW5ndGggPT09IDAgfHwgY2xlYXJsaXN0LnNvbWUocyA9PiBrZXkuaW5kZXhPZihzKSA9PT0gMCkpIHtcbiAgICAgIGtleXMucHVzaChrZXkpOyAvLyBTdG9yZSB0aGUga2V5IHRvIGZpeCBTYWZhcmkgc3R5bGUgaW5kZXhlc1xuICAgIH1cbiAgfVxuXG4gIGtleXMuZm9yRWFjaChrZXkgPT4gZWxlbWVudC5zdHlsZVtrZXldID0gJycpO1xuICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSA9PT0gJycgJiYgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzdHlsZXI7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4vLyBTYXZlIEhUTUxFbGVtZW50IG9iamVjdCBiZWZvcmUgQ3VzdG9tIEVsZW1lbnRzIHBvbHlmaWxsIHBhdGNoIGdsb2JhbCBIVE1MRWxlbWVudC5cbmNvbnN0IE5hdGl2ZUhUTUxFbGVtZW50ID0gd2luZG93LkhUTUxFbGVtZW50O1xuXG4vKipcbiAqIEBvYmplY3Qgb25zLnBsYXRmb3JtXG4gKiBAY2F0ZWdvcnkgdXRpbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1VdGlsaXR5IG1ldGhvZHMgdG8gZGV0ZWN0IGN1cnJlbnQgcGxhdGZvcm0uWy9lbl1cbiAqICAgW2phXeePvuWcqOWun+ihjOOBleOCjOOBpuOBhOOCi+ODl+ODqeODg+ODiOODleOCqeODvOODoOOCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBn+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKi9cbmNsYXNzIFBsYXRmb3JtIHtcblxuICAvKipcbiAgICogQWxsIGVsZW1lbnRzIHdpbGwgYmUgcmVuZGVyZWQgYXMgaWYgdGhlIGFwcCB3YXMgcnVubmluZyBvbiB0aGlzIHBsYXRmb3JtLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWRQbGF0Zm9ybSA9IG51bGw7XG4gICAgdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNlbGVjdFxuICAgKiBAc2lnbmF0dXJlIHNlbGVjdChwbGF0Zm9ybSlcbiAgICogQHBhcmFtICB7c3RyaW5nfSBwbGF0Zm9ybSBOYW1lIG9mIHRoZSBwbGF0Zm9ybS5cbiAgICogICBbZW5dUG9zc2libGUgdmFsdWVzIGFyZTogXCJvcGVyYVwiLCBcImZpcmVmb3hcIiwgXCJzYWZhcmlcIiwgXCJjaHJvbWVcIiwgXCJpZVwiLCBcImFuZHJvaWRcIiwgXCJibGFja2JlcnJ5XCIsIFwiaW9zXCIgb3IgXCJ3cFwiLlsvZW5dXG4gICAqICAgW2phXVwib3BlcmFcIiwgXCJmaXJlZm94XCIsIFwic2FmYXJpXCIsIFwiY2hyb21lXCIsIFwiaWVcIiwgXCJhbmRyb2lkXCIsIFwiYmxhY2tiZXJyeVwiLCBcImlvc1wiLCBcIndwXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2V0cyB0aGUgcGxhdGZvcm0gdXNlZCB0byByZW5kZXIgdGhlIGVsZW1lbnRzLiBVc2VmdWwgZm9yIHRlc3RpbmcuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44KS5o+P55S744GZ44KL44Gf44KB44Gr5Yip55So44GZ44KL44OX44Op44OD44OI44OV44Kp44O844Og5ZCN44KS6Kit5a6a44GX44G+44GZ44CC44OG44K544OI44Gr5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIHNlbGVjdChwbGF0Zm9ybSkge1xuICAgIGlmICh0eXBlb2YgcGxhdGZvcm0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZFBsYXRmb3JtID0gcGxhdGZvcm0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFNlbGVjdGVkUGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lnbm9yZVBsYXRmb3JtU2VsZWN0ID8gbnVsbCA6IHRoaXMuX3NlbGVjdGVkUGxhdGZvcm07XG4gIH1cblxuICBfcnVuT25BY3R1YWxQbGF0Zm9ybShmbikge1xuICAgIHRoaXMuX2lnbm9yZVBsYXRmb3JtU2VsZWN0ID0gdHJ1ZTtcbiAgICBjb25zdCByZXN1bHQgPSBmbigpO1xuICAgIHRoaXMuX2lnbm9yZVBsYXRmb3JtU2VsZWN0ID0gZmFsc2U7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEdlbmVyYWxcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzV2ViVmlld1xuICAgKiBAc2lnbmF0dXJlIGlzV2ViVmlldygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxuICAgKiAgIFtqYV1Db3Jkb3Zh5YaF44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzV2ViVmlldygpIHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT0gJ3VuaW5pdGlhbGl6ZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzV2ViVmlldygpIG1ldGhvZCBpcyBhdmFpbGFibGUgYWZ0ZXIgZG9tIGNvbnRlbnRzIGxvYWRlZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gISEod2luZG93LmNvcmRvdmEgfHwgd2luZG93LnBob25lZ2FwIHx8IHdpbmRvdy5QaG9uZUdhcCk7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gaU9TIGRldmljZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBob25lXG4gICAqIEBzaWduYXR1cmUgaXNJUGhvbmUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBob25lLlsvZW5dXG4gICAqICAgW2phXWlQaG9uZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQaG9uZSgpIHtcbiAgICByZXR1cm4gL2lQaG9uZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lQaG9uZVhcbiAgICogQHNpZ25hdHVyZSBpc0lQaG9uZVgoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgaVBob25lIFguWy9lbl1cbiAgICogICBbamFdaVBob25lIFjkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUGhvbmVYKCkge1xuICAgIC8vIGlQaG9uZSA4IGFuZCBpUGhvbmUgWCBoYXZlIGEgc2FtZSB1c2VyIGFnZW50LiBXZSBjYW5ub3QgYXZvaWQgdXNpbmcgd2luZG93LnNjcmVlbi5cbiAgICAvLyBUaGlzIHdvcmtzIHdlbGwgYm90aCBpbiBpT1MgU2FmYXJpIGFuZCAoVUl8V0spV2ViVmlldyBvZiBpUGhvbmUgWC5cbiAgICByZXR1cm4gdGhpcy5pc0lQaG9uZSgpICYmIHdpbmRvdy5zY3JlZW4ud2lkdGggPT09IDM3NSAmJiB3aW5kb3cuc2NyZWVuLmhlaWdodCA9PT0gODEyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJUGFkXG4gICAqIEBzaWduYXR1cmUgaXNJUGFkKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIGlQYWQuWy9lbl1cbiAgICogICBbamFdaVBhZOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQYWQoKSB7XG4gICAgcmV0dXJuIC9pUGFkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUG9kKCkge1xuICAgIHJldHVybiAvaVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gaU9TIHZlcnNpb25zXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPU1xuICAgKiBAc2lnbmF0dXJlIGlzSU9TKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgaU9TLlsvZW5dXG4gICAqICAgW2phXWlPU+S4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lPUygpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnaW9zJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPUzdhYm92ZVxuICAgKiBAc2lnbmF0dXJlIGlzSU9TN2Fib3ZlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgaU9TIHZlcnNpb24gaXMgNyBvciBhYm92ZS5bL2VuXVxuICAgKiAgIFtqYV1pT1M35Lul5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSU9TN2Fib3ZlKCkge1xuICAgIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAoL2lPUy9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSAmJiAocGFyc2VJbnQoZGV2aWNlLnZlcnNpb24uc3BsaXQoJy4nKVswXSkgPj0gNykpO1xuICAgIH0gZWxzZSBpZigvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIGNvbnN0IHZlciA9IChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9cXGJbMC05XStfWzAtOV0rKD86X1swLTldKyk/XFxiLykgfHwgWycnXSlbMF0ucmVwbGFjZSgvXy9nLCAnLicpO1xuICAgICAgcmV0dXJuIChwYXJzZUludCh2ZXIuc3BsaXQoJy4nKVswXSkgPj0gNyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBpT1MgYnJvd3NlcnNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSU9TU2FmYXJpXG4gICAqIEBzaWduYXR1cmUgaXNJT1NTYWZhcmkoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIGFwcCBpcyBydW5uaW5nIGluIGlPUyBTYWZhcmkuWy9lbl1cbiAgICogICBbamFdaU9TIFNhZmFyaeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lPU1NhZmFyaSgpIHtcbiAgICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yO1xuICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICAgIHJldHVybiAhISh0aGlzLmlzSU9TKCkgJiYgdWEuaW5kZXhPZignU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ1ZlcnNpb24nKSAhPT0gLTEgJiYgIW5hdmlnYXRvci5zdGFuZGFsb25lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzV0tXZWJWaWV3XG4gICAqIEBzaWduYXR1cmUgaXNXS1dlYlZpZXcoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIGFwcCBpcyBydW5uaW5nIGluIFdLV2ViVmlldy5bL2VuXVxuICAgKiAgIFtqYV1XS1dlYlZpZXfjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNXS1dlYlZpZXcoKSB7XG4gICAgY29uc3QgbHRlOSA9IC9jb25zdHJ1Y3Rvci9pLnRlc3QoTmF0aXZlSFRNTEVsZW1lbnQpO1xuICAgIHJldHVybiAhISh0aGlzLmlzSU9TKCkgJiYgd2luZG93LndlYmtpdCAmJiB3aW5kb3cud2Via2l0Lm1lc3NhZ2VIYW5kbGVycyAmJiB3aW5kb3cuaW5kZXhlZERCICYmICFsdGU5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzVUlXZWJWaWV3XG4gICAqIEBzaWduYXR1cmUgaXNVSVdlYlZpZXcoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIGFwcCBpcyBydW5uaW5nIGluIFVJV2ViVmlldy5bL2VuXVxuICAgKiAgIFtqYV1VSVdlYlZpZXfjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNVSVdlYlZpZXcoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuaXNJT1MoKSAmJiAhdGhpcy5pc0lPU1NhZmFyaSgpICYmICF0aGlzLmlzV0tXZWJWaWV3KCkpO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEFuZHJvaWQgZGV2aWNlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkUGhvbmVcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWRQaG9uZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBBbmRyb2lkIHBob25lLlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTmkLrluK/kuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkUGhvbmUoKSB7XG4gICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQW5kcm9pZFRhYmxldFxuICAgKiBAc2lnbmF0dXJlIGlzQW5kcm9pZFRhYmxldCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBBbmRyb2lkIHRhYmxldC5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk44K/44OW44Os44OD44OI5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZFRhYmxldCgpIHtcbiAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBbmRyb2lkIHZlcnNpb25zXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBPUyBpcyBBbmRyb2lkLlsvZW5dXG4gICAqICAgW2phXUFuZHJvaWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBbmRyb2lkKCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdhbmRyb2lkJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE90aGVyIGRldmljZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNXUCgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnd3AnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAvV2luMzJOVHxXaW5DRS9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9XaW5kb3dzIFBob25lfElFTW9iaWxlfFdQRGVza3RvcC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNCbGFja0JlcnJ5XG4gICAqIEBzaWduYXR1cmUgaXNCbGFja0JlcnJ5KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIGlzIEJsYWNrQmVycnkuWy9lbl1cbiAgICogICBbamFdQmxhY2tCZXJyeeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0JsYWNrQmVycnkoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2JsYWNrYmVycnknO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0JyAmJiAhL2Jyb3dzZXIvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkpIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeS9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC9CbGFja0JlcnJ5fFJJTSBUYWJsZXQgT1N8QkIxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE90aGVyIGJyb3dzZXJzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQG1ldGhvZCBpc09wZXJhXG4gICAqIEBzaWduYXR1cmUgaXNPcGVyYSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgT3BlcmEuWy9lbl1cbiAgICogICBbamFdT3BlcmHkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNPcGVyYSgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnb3BlcmEnO1xuICAgIH1cblxuICAgIHJldHVybiAoISF3aW5kb3cub3BlcmEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgT1BSLycpID49IDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNGaXJlZm94XG4gICAqIEBzaWduYXR1cmUgaXNGaXJlZm94KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBGaXJlZm94LlsvZW5dXG4gICAqICAgW2phXUZpcmVmb3jkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNGaXJlZm94KCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdmaXJlZm94JztcbiAgICB9XG5cbiAgICByZXR1cm4gKHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNTYWZhcmlcbiAgICogQHNpZ25hdHVyZSBpc1NhZmFyaSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgU2FmYXJpLlsvZW5dXG4gICAqICAgW2phXVNhZmFyaeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1NhZmFyaSgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnc2FmYXJpJztcbiAgICB9XG5cbiAgICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cuSFRNTEVsZW1lbnQpLmluZGV4T2YoJ0NvbnN0cnVjdG9yJykgPiAwKSB8fCAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2FmYXJpUmVtb3RlTm90aWZpY2F0aW9uXScgfSkoIXdpbmRvd1snc2FmYXJpJ10gfHwgc2FmYXJpLnB1c2hOb3RpZmljYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNDaHJvbWVcbiAgICogQHNpZ25hdHVyZSBpc0Nocm9tZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgQ2hyb21lLlsvZW5dXG4gICAqICAgW2phXUNocm9tZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0Nocm9tZSgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnY2hyb21lJztcbiAgICB9XG5cbiAgICByZXR1cm4gKCEhd2luZG93LmNocm9tZSAmJiAhKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKSAmJiAhKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIEVkZ2UvJykgPj0gMCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJRVxuICAgKiBAc2lnbmF0dXJlIGlzSUUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyLlsvZW5dXG4gICAqICAgW2phXUludGVybmV0IEV4cGxvcmVy5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSUUoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2llJztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgfHwgISFkb2N1bWVudC5kb2N1bWVudE1vZGU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0VkZ2VcbiAgICogQHNpZ25hdHVyZSBpc0VkZ2UoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIEVkZ2UuWy9lbl1cbiAgICogICBbamFdRWRnZeS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0VkZ2UoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2VkZ2UnO1xuICAgIH1cblxuICAgIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBFZGdlLycpID49IDA7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVXRpbGl0eSBmdW5jdGlvbnNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICBnZXRNb2JpbGVPUygpIHtcbiAgICBpZiAodGhpcy5pc0FuZHJvaWQoKSkge1xuICAgICAgcmV0dXJuICdhbmRyb2lkJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc0lPUygpKSB7XG4gICAgICByZXR1cm4gJ2lvcyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNXUCgpKSB7XG4gICAgICByZXR1cm4gJ3dwJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gJ290aGVyJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0SU9TRGV2aWNlKCkge1xuICAgIGlmICh0aGlzLmlzSVBob25lKCkpIHtcbiAgICAgIHJldHVybiAnaXBob25lJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc0lQYWQoKSkge1xuICAgICAgcmV0dXJuICdpcGFkJztcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5pc0lQb2QoKSkge1xuICAgICAgcmV0dXJuICdpcG9kJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gJ25hJztcbiAgICB9XG4gIH1cbn1cblxuXG5leHBvcnQgZGVmYXVsdCBuZXcgUGxhdGZvcm0oKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcblxuY29uc3QgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gPSB7XG4gIF92YXJpYWJsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlIFZhbHVlIG9mIHRoZSB2YXJpYWJsZS4gQ2FuIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGUgSWYgdGhpcyB2YWx1ZSBpcyBmYWxzZSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gd2hlbiB0cnlpbmcgdG8gZGVmaW5lIGEgdmFyaWFibGUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXG4gICAqL1xuICBkZWZpbmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSwgdmFsdWUsIG92ZXJ3cml0ZT1mYWxzZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFyaWFibGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYXJpYWJsZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhb3ZlcndyaXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgZGVmaW5lZC5gKTtcbiAgICB9XG4gICAgdGhpcy5fdmFyaWFibGVzW25hbWVdID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHZhcmlhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAgICogQHJldHVybiB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XG4gICAqL1xuICBnZXRWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyYWlibGUuXG4gICAqL1xuICByZW1vdmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLl92YXJpYWJsZXNbbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRBbGxWYXJpYWJsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXM7XG4gIH0sXG4gIF9wYXJzZVBhcnQ6IGZ1bmN0aW9uKHBhcnQpIHtcbiAgICBsZXQgYyxcbiAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlLFxuICAgICAgY3VycmVudEluZGV4ID0gMDtcblxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuXG4gICAgaWYgKHBhcnQubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBlbXB0eSBzdHJpbmcuJyk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjID0gcGFydC5jaGFyQXQoaSk7XG5cbiAgICAgIGlmIChjID09PSAnJCcgJiYgcGFydC5jaGFyQXQoaSArIDEpID09PSAneycpIHtcbiAgICAgICAgaWYgKGluSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmVzdGVkIGludGVycG9sYXRpb24gbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpKTtcbiAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGk7XG4gICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjID09PSAnfScpIHtcbiAgICAgICAgaWYgKCFpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ30gbXVzdCBiZSBwcmVjZWVkZWQgYnkgJHsnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRva2VuID0gcGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpICsgMSk7XG4gICAgICAgIGlmICh0b2tlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBpICsgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4ID0gaSArIDE7XG4gICAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW50ZXJtaW5hdGVkIGludGVycG9sYXRpb24uJyk7XG4gICAgfVxuXG4gICAgdG9rZW5zLnB1c2gocGFydC5zdWJzdHJpbmcoY3VycmVudEluZGV4LCBwYXJ0Lmxlbmd0aCkpO1xuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfSxcbiAgX3JlcGxhY2VUb2tlbjogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBjb25zdCByZSA9IC9eXFwkeyguKj8pfSQvLFxuICAgICAgbWF0Y2ggPSB0b2tlbi5tYXRjaChyZSk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBtYXRjaFsxXS50cmltKCk7XG4gICAgICBjb25zdCB2YXJpYWJsZSA9IHRoaXMuZ2V0VmFyaWFibGUobmFtZSk7XG5cbiAgICAgIGlmICh2YXJpYWJsZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhcmlhYmxlIFwiJHtuYW1lfVwiIGRvZXMgbm90IGV4aXN0LmApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHZhcmlhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcnYgPSB2YXJpYWJsZSgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcnYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHJldHVybiBhIHN0cmluZy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuICB9LFxuICBfcmVwbGFjZVRva2VuczogZnVuY3Rpb24odG9rZW5zKSB7XG4gICAgcmV0dXJuIHRva2Vucy5tYXAodGhpcy5fcmVwbGFjZVRva2VuLmJpbmQodGhpcykpO1xuICB9LFxuICBfcGFyc2VFeHByZXNzaW9uOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24uc3BsaXQoJywnKVxuICAgICAgLm1hcChcbiAgICAgICAgZnVuY3Rpb24ocGFydCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0LnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgLm1hcCh0aGlzLl9wYXJzZVBhcnQuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAodGhpcy5fcmVwbGFjZVRva2Vucy5iaW5kKHRoaXMpKVxuICAgICAgLm1hcCgocGFydCkgPT4gcGFydC5qb2luKCcnKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIGFuIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBleHByZXNzaW9uIEFuIHBhZ2UgYXR0cmlidXRlIGV4cHJlc3Npb24uXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgZXZhbHVhdGU6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcGFyc2VFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICB9XG59O1xuXG4vLyBEZWZpbmUgZGVmYXVsdCB2YXJpYWJsZXMuXG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnbW9iaWxlT1MnLCBwbGF0Zm9ybS5nZXRNb2JpbGVPUygpKTtcbnBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLmRlZmluZVZhcmlhYmxlKCdpT1NEZXZpY2UnLCBwbGF0Zm9ybS5nZXRJT1NEZXZpY2UoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgncnVudGltZScsICgpID0+IHtcbiAgcmV0dXJuIHBsYXRmb3JtLmlzV2ViVmlldygpID8gJ2NvcmRvdmEnIDogJ2Jyb3dzZXInO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuaW1wb3J0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIGZyb20gJy4uL3BhZ2UtYXR0cmlidXRlLWV4cHJlc3Npb24nO1xuXG5jb25zdCBpbnRlcm5hbCA9IHt9O1xuXG5pbnRlcm5hbC5jb25maWcgPSB7XG4gIGF1dG9TdGF0dXNCYXJGaWxsOiB0cnVlLFxuICBhbmltYXRpb25zRGlzYWJsZWQ6IGZhbHNlLFxuICB3YXJuaW5nc0Rpc2FibGVkOiBmYWxzZVxufTtcblxuaW50ZXJuYWwubnVsbEVsZW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbi8qKlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuaW50ZXJuYWwuaXNFbmFibGVkQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIHJldHVybiAhIWludGVybmFsLmNvbmZpZy5hdXRvU3RhdHVzQmFyRmlsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwgPSBodG1sID0+ICgnJyArIGh0bWwpLnRyaW0oKTtcblxuaW50ZXJuYWwud2FpdERPTUNvbnRlbnRMb2FkZWQgPSBjYWxsYmFjayA9PiB7XG4gIGlmICh3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnIHx8IHdpbmRvdy5kb2N1bWVudC5yZWFkeVN0YXRlID09ICd1bmluaXRpYWxpemVkJykge1xuICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHdyYXBwZWRDYWxsYmFjayk7XG4gICAgfTtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHdyYXBwZWRDYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwgPSBhY3Rpb24gPT4ge1xuICBjb25zdCBvblJlYWR5ID0gKCkgPT4ge1xuICAgIGlmIChpbnRlcm5hbC5zaG91bGRGaWxsU3RhdHVzQmFyKCkpIHtcbiAgICAgIGFjdGlvbigpO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZGV2aWNlID09PSAnb2JqZWN0Jykge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5Jywgb25SZWFkeSk7XG4gIH0gZWxzZSBpZiAoWydjb21wbGV0ZScsICdpbnRlcmFjdGl2ZSddLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPT09IC0xKSB7XG4gICAgaW50ZXJuYWwud2FpdERPTUNvbnRlbnRMb2FkZWQob25SZWFkeSk7XG4gIH0gZWxzZSB7XG4gICAgb25SZWFkeSgpO1xuICB9XG59O1xuXG5pbnRlcm5hbC5zaG91bGRGaWxsU3RhdHVzQmFyID0gKCkgPT4gaW50ZXJuYWwuaXNFbmFibGVkQXV0b1N0YXR1c0JhckZpbGwoKSAmJlxuICAocGxhdGZvcm0uaXNXZWJWaWV3KCkgJiYgcGxhdGZvcm0uaXNJT1M3YWJvdmUoKSAmJiAhcGxhdGZvcm0uaXNJUGhvbmVYKCkgfHwgZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKCcub25zLXN0YXR1cy1iYXItbW9jay5pb3MnKSk7XG5cbmludGVybmFsLnRlbXBsYXRlU3RvcmUgPSB7XG4gIF9zdG9yYWdlOiB7fSxcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtTdHJpbmcvbnVsbH0gdGVtcGxhdGVcbiAgICovXG4gIGdldChrZXkpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5fc3RvcmFnZVtrZXldIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAqL1xuICBzZXQoa2V5LCB0ZW1wbGF0ZSkge1xuICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuX3N0b3JhZ2Vba2V5XSA9IHRlbXBsYXRlO1xuICB9XG59O1xuXG53aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignX3RlbXBsYXRlbG9hZGVkJywgZnVuY3Rpb24oZSkge1xuICBpZiAoZS50YXJnZXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10ZW1wbGF0ZScpIHtcbiAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldChlLnRlbXBsYXRlSWQsIGUudGVtcGxhdGUpO1xuICB9XG59LCBmYWxzZSk7XG5cbmludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkKGZ1bmN0aW9uKCkge1xuICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L29ucy10ZW1wbGF0ZVwiXScpO1xuICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L3RlbXBsYXRlXCJdJyk7XG4gIHJlZ2lzdGVyKCdzY3JpcHRbdHlwZT1cInRleHQvbmctdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3RlbXBsYXRlJyk7XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXIocXVlcnkpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZXMgPSB3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChxdWVyeSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wbGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KHRlbXBsYXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ2lkJyksIHRlbXBsYXRlc1tpXS50ZXh0Q29udGVudCB8fCB0ZW1wbGF0ZXNbaV0uY29udGVudCk7XG4gICAgfVxuICB9XG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuaW50ZXJuYWwuZ2V0VGVtcGxhdGVIVE1MQXN5bmMgPSBmdW5jdGlvbihwYWdlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaW50ZXJuYWwud2FpdERPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xuICAgICAgY29uc3QgY2FjaGUgPSBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLmdldChwYWdlKTtcbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoY2FjaGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaHRtbCA9IHR5cGVvZiBjYWNoZSA9PT0gJ3N0cmluZycgPyBjYWNoZSA6IGNhY2hlWzFdO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShpbnRlcm5hbC5ub3JtYWxpemVQYWdlSFRNTChodG1sKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvY2FsID0gd2luZG93LmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHBhZ2UpO1xuICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBsb2NhbC50ZXh0Q29udGVudCB8fCBsb2NhbC5jb250ZW50O1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShodG1sKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJywgcGFnZSwgdHJ1ZSk7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGh0bWwgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSA0MDAgJiYgeGhyLnN0YXR1cyA8IDYwMCkge1xuICAgICAgICAgIHJlamVjdChodG1sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZWZyZXNoIHNjcmlwdCB0YWdzXG4gICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB1dGlsLmNyZWF0ZUZyYWdtZW50KGh0bWwpO1xuICAgICAgICAgIHV0aWwuYXJyYXlGcm9tKGZyYWdtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdCcpKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgc2NyaXB0LnR5cGUgPSBlbC50eXBlIHx8ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICAgICAgc2NyaXB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGVsLnRleHQgfHwgZWwudGV4dENvbnRlbnQgfHwgZWwuaW5uZXJIVE1MKSk7XG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzY3JpcHQsIGVsKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGludGVybmFsLnRlbXBsYXRlU3RvcmUuc2V0KHBhZ2UsIGZyYWdtZW50KTtcbiAgICAgICAgICByZXNvbHZlKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHBhZ2UgaXMgbm90IGZvdW5kOiAke3BhZ2V9YCk7XG4gICAgICB9O1xuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyA9IGZ1bmN0aW9uKHBhZ2UpIHtcbiAgY29uc3QgcGFnZXMgPSBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5ldmFsdWF0ZShwYWdlKTtcblxuICBjb25zdCBnZXRQYWdlID0gKHBhZ2UpID0+IHtcbiAgICBpZiAodHlwZW9mIHBhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ011c3Qgc3BlY2lmeSBhIHBhZ2UuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jKHBhZ2UpXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKHBhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0UGFnZShwYWdlcy5zaGlmdCgpKTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBnZXRQYWdlKHBhZ2VzLnNoaWZ0KCkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWw7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9pbnRlcm5hbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdG9yRmFjdG9yeSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLmFuaW1hdG9ycyBUaGUgZGljdGlvbmFyeSBmb3IgYW5pbWF0b3IgY2xhc3Nlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRzLmJhc2VDbGFzcyBUaGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmJhc2VDbGFzc05hbWVdIFRoZSBuYW1lIG9mIHRoZSBiYXNlIGNsYXNzIG9mIGFuaW1hdG9yc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdHMuZGVmYXVsdEFuaW1hdGlvbl0gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25PcHRpb25zXSBUaGUgZGVmYXVsdCBhbmltYXRpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMuX2FuaW1hdG9ycyA9IG9wdHMuYW5pbWF0b3JzO1xuICAgIHRoaXMuX2Jhc2VDbGFzcyA9IG9wdHMuYmFzZUNsYXNzO1xuICAgIHRoaXMuX2Jhc2VDbGFzc05hbWUgPSBvcHRzLmJhc2VDbGFzc05hbWUgfHwgb3B0cy5iYXNlQ2xhc3MubmFtZTtcbiAgICB0aGlzLl9hbmltYXRpb24gPSBvcHRzLmRlZmF1bHRBbmltYXRpb24gfHwgJ2RlZmF1bHQnO1xuICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMgPSBvcHRzLmRlZmF1bHRBbmltYXRpb25PcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKCF0aGlzLl9hbmltYXRvcnNbdGhpcy5fYW5pbWF0aW9uXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdWNoIGFuaW1hdGlvbjogJyArIHRoaXMuX2FuaW1hdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBqc29uU3RyaW5nXG4gICAqIEByZXR1cm4ge09iamVjdC9udWxsfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyhqc29uU3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YganNvblN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1wiYW5pbWF0aW9uLW9wdGlvbnNcIiBhdHRyaWJ1dGUgbXVzdCBiZSBhIEpTT04gb2JqZWN0IHN0cmluZzogJyArIGpzb25TdHJpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignXCJhbmltYXRpb24tb3B0aW9uc1wiIGF0dHJpYnV0ZSBtdXN0IGJlIGEgSlNPTiBvYmplY3Qgc3RyaW5nOiAnICsganNvblN0cmluZyk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBzZXRBbmltYXRpb25PcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXSBUaGUgYW5pbWF0aW9uIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdIFRoZSBhbmltYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdEFuaW1hdG9yIFRoZSBkZWZhdWx0IGFuaW1hdG9yIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQW4gYW5pbWF0b3IgaW5zdGFuY2VcbiAgICovXG4gIG5ld0FuaW1hdG9yKG9wdGlvbnMgPSB7fSwgZGVmYXVsdEFuaW1hdG9yKSB7XG5cbiAgICBsZXQgYW5pbWF0b3IgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uIGluc3RhbmNlb2YgdGhpcy5fYmFzZUNsYXNzKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5hbmltYXRpb247XG4gICAgfVxuXG4gICAgbGV0IEFuaW1hdG9yID0gbnVsbDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbmltYXRpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICBBbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yc1tvcHRpb25zLmFuaW1hdGlvbl07XG4gICAgfVxuXG4gICAgaWYgKCFBbmltYXRvciAmJiBkZWZhdWx0QW5pbWF0b3IpIHtcbiAgICAgIGFuaW1hdG9yID0gZGVmYXVsdEFuaW1hdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBBbmltYXRvciA9IEFuaW1hdG9yIHx8IHRoaXMuX2FuaW1hdG9yc1t0aGlzLl9hbmltYXRpb25dO1xuXG4gICAgICBjb25zdCBhbmltYXRpb25PcHRzID0gdXRpbC5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zLFxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge30sXG4gICAgICAgIGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPyB7ZHVyYXRpb246IDAsIGRlbGF5OiAwfSA6IHt9XG4gICAgICApO1xuXG4gICAgICBhbmltYXRvciA9IG5ldyBBbmltYXRvcihhbmltYXRpb25PcHRzKTtcblxuICAgICAgaWYgKHR5cGVvZiBhbmltYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBhbmltYXRvciA9IG5ldyBhbmltYXRvcihhbmltYXRpb25PcHRzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoYW5pbWF0b3IgaW5zdGFuY2VvZiB0aGlzLl9iYXNlQ2xhc3MpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiYW5pbWF0b3JcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgJyArIHRoaXMuX2Jhc2VDbGFzc05hbWUgKyAnLicpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxubGV0IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlO1xuXG4vLyBNb2RpZmllcnNcbmNvbnN0IG1vZGlmaWVyc01hcCA9IHtcbiAgJ3F1aWV0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2xpZ2h0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ291dGxpbmUnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAnY3RhJzogJycsXG4gICdsYXJnZS0tcXVpZXQnOiAnbWF0ZXJpYWwtLWZsYXQgbGFyZ2UnLFxuICAnbGFyZ2UtLWN0YSc6ICdsYXJnZScsXG4gICdub2JvcmRlcic6ICcnLFxuICAndGFwcGFibGUnOiAnJ1xufTtcblxuY29uc3QgcGxhdGZvcm1zID0ge307XG5cbnBsYXRmb3Jtcy5hbmRyb2lkID0gZWxlbWVudCA9PiB7XG5cbiAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAoIXV0aWwuaGFzTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsJykpIHtcbiAgICBjb25zdCBvbGRNb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnO1xuXG4gICAgY29uc3QgbmV3TW9kaWZpZXIgPSBvbGRNb2RpZmllci50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZSA9PiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkoZSkgPyBtb2RpZmllcnNNYXBbZV0gOiBlKTtcbiAgICBuZXdNb2RpZmllci51bnNoaWZ0KCdtYXRlcmlhbCcpO1xuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbmV3TW9kaWZpZXIuam9pbignICcpLnRyaW0oKSk7XG4gIH1cblxuICBjb25zdCBlbGVtZW50cyA9IFtcbiAgICAnb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nLFxuICAgICdvbnMtdG9vbGJhci1idXR0b24nLFxuICAgICdvbnMtYmFjay1idXR0b24nLFxuICAgICdvbnMtYnV0dG9uJyxcbiAgICAnb25zLWxpc3QtaXRlbScsXG4gICAgJ29ucy1mYWInLFxuICAgICdvbnMtc3BlZWQtZGlhbCcsXG4gICAgJ29ucy1zcGVlZC1kaWFsLWl0ZW0nLFxuICAgICdvbnMtdGFiJ1xuICBdO1xuXG5cbiAgLy8gRWZmZWN0c1xuICBpZiAoZWxlbWVudHMuaW5kZXhPZihlbGVtZW50TmFtZSkgIT09IC0xXG4gICAgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKVxuICAgICYmICFlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ29ucy1yaXBwbGUnKSkge1xuXG4gICAgaWYgKGVsZW1lbnROYW1lID09PSAnb25zLWxpc3QtaXRlbScpIHtcbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFwcGFibGUnKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFwcGFibGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICB9XG4gIH1cbn07XG5cbnBsYXRmb3Jtcy5pb3MgPSBlbGVtZW50ID0+IHtcblxuIC8vIE1vZGlmaWVyc1xuIGlmICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbCcpKSB7XG4gICBpZiAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwtLWZsYXQnKSkge1xuICAgICB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdsYXJnZScpKSA/ICdsYXJnZS0tcXVpZXQnIDogJ3F1aWV0Jyk7XG4gICB9XG5cbiAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gICB9XG4gfVxuXG4gLy8gRWZmZWN0c1xuIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpIHtcbiAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YXBwYWJsZScsICcnKTtcbiAgIH1cblxuICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuIH1cbn07XG5cbmNvbnN0IHVubG9ja2VkID0ge1xuICBhbmRyb2lkOiB0cnVlXG59O1xuXG5jb25zdCBnZXRQbGF0Zm9ybSA9IChlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBpZiAoYXV0b1N0eWxlRW5hYmxlZCAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUtYXV0by1zdHlsaW5nJykpIHtcbiAgICBjb25zdCBtb2JpbGVPUyA9IG9uc1BsYXRmb3JtLmdldE1vYmlsZU9TKCk7XG4gICAgaWYgKHBsYXRmb3Jtcy5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgJiYgKHVubG9ja2VkLmhhc093blByb3BlcnR5KG1vYmlsZU9TKSB8fCBmb3JjZSkpIHtcbiAgICAgIHJldHVybiBtb2JpbGVPUztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBwcmVwYXJlID0gKGVsZW1lbnQsIGZvcmNlKSA9PiB7XG4gIGNvbnN0IHAgPSBnZXRQbGF0Zm9ybShlbGVtZW50LCBmb3JjZSk7XG4gIHAgJiYgcGxhdGZvcm1zW3BdKGVsZW1lbnQpO1xufTtcblxuY29uc3QgbWFwTW9kaWZpZXIgPSAobW9kaWZpZXIsIGVsZW1lbnQsIGZvcmNlKSA9PiB7XG4gIGlmIChnZXRQbGF0Zm9ybShlbGVtZW50LCBmb3JjZSkpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIuc3BsaXQoL1xccysvKS5tYXAobSA9PiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkobSkgPyBtb2RpZmllcnNNYXBbbV0gOiBtKS5qb2luKCcgJyk7XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVyO1xufTtcblxuY29uc3QgcmVzdG9yZU1vZGlmaWVyID0gZWxlbWVudCA9PiB7XG4gIGlmIChnZXRQbGF0Zm9ybShlbGVtZW50KSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgY29uc3QgbW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJztcbiAgICBsZXQgbmV3TW9kaWZpZXIgPSBtYXBNb2RpZmllcihtb2RpZmllciwgZWxlbWVudCk7XG5cbiAgICBpZiAoIS8oXnxcXHMrKW1hdGVyaWFsKCR8XFxzKykvaS50ZXN0KG1vZGlmaWVyKSkge1xuICAgICAgbmV3TW9kaWZpZXIgPSAnbWF0ZXJpYWwgJyArIG5ld01vZGlmaWVyO1xuICAgIH1cblxuICAgIGlmIChuZXdNb2RpZmllciAhPT0gbW9kaWZpZXIpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVyLnRyaW0oKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0VuYWJsZWQ6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQsXG4gIGVuYWJsZTogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCA9IHRydWUsXG4gIGRpc2FibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSBmYWxzZSxcbiAgcHJlcGFyZSxcbiAgbWFwTW9kaWZpZXIsXG4gIGdldFBsYXRmb3JtLFxuICByZXN0b3JlTW9kaWZpZXJcbn07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vYXV0b3N0eWxlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kaWZpZXJVdGlsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAqL1xuICBzdGF0aWMgZGlmZihsYXN0LCBjdXJyZW50KSB7XG4gICAgbGFzdCA9IG1ha2VEaWN0KCgnJyArIGxhc3QpLnRyaW0oKSk7XG4gICAgY3VycmVudCA9IG1ha2VEaWN0KCgnJyArIGN1cnJlbnQpLnRyaW0oKSk7XG5cbiAgICBjb25zdCByZW1vdmVkID0gT2JqZWN0LmtleXMobGFzdCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgYWRkZWQgPSBPYmplY3Qua2V5cyhjdXJyZW50KS5yZWR1Y2UoKHJlc3VsdCwgdG9rZW4pID0+IHtcbiAgICAgIGlmICghbGFzdFt0b2tlbl0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge2FkZGVkLCByZW1vdmVkfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VEaWN0KG1vZGlmaWVyKSB7XG4gICAgICBjb25zdCBkaWN0ID0ge307XG4gICAgICBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpLmZvckVhY2godG9rZW4gPT4gZGljdFt0b2tlbl0gPSB0b2tlbik7XG4gICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtBcnJheX0gZGlmZi5yZW1vdmVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYuYWRkZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNsYXNzTGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHN0YXRpYyBhcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCBjbGFzc0xpc3QsIHRlbXBsYXRlKSB7XG4gICAgZGlmZi5hZGRlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4ga2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGsgPT4gY2xhc3NMaXN0LmFkZChrKSkpO1xuXG4gICAgZGlmZi5yZW1vdmVkXG4gICAgICAubWFwKG1vZGlmaWVyID0+IHRlbXBsYXRlLnJlcGxhY2UoL1xcKi9nLCBtb2RpZmllcikpXG4gICAgICAuZm9yRWFjaChrbGFzcyA9PiBrbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goayA9PiBjbGFzc0xpc3QucmVtb3ZlKGspKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtBcnJheX0gZGlmZi5yZW1vdmVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYuYWRkZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9FbGVtZW50KGRpZmYsIGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIE9iamVjdC5rZXlzKHNjaGVtZSkuZm9yRWFjaChzZWxlY3RvciA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRFbGVtZW50cyA9ICFzZWxlY3RvciB8fCB1dGlsLm1hdGNoKGVsZW1lbnQsIHNlbGVjdG9yKVxuICAgICAgICA/IFtlbGVtZW50XVxuICAgICAgICA6IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChcbiAgICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0+ICF1dGlsLmZpbmRQYXJlbnQodGFyZ2V0RWxlbWVudCwgZWxlbWVudC50YWdOYW1lLCBwYXJlbnQgPT4gcGFyZW50ID09PSBlbGVtZW50KVxuICAgICAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvQ2xhc3NMaXN0KGRpZmYsIHRhcmdldEVsZW1lbnRzW2ldLmNsYXNzTGlzdCwgc2NoZW1lW3NlbGVjdG9yXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgb25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudChNb2RpZmllclV0aWwuZGlmZihsYXN0LCBjdXJyZW50KSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgICBhdXRvU3R5bGUucmVzdG9yZU1vZGlmaWVyKGVsZW1lbnQpO1xuICB9XG5cbiAgc3RhdGljIHJlZnJlc2goZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudChNb2RpZmllclV0aWwuZGlmZignJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJycpLCBlbGVtZW50LCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIGluaXRNb2RpZmllcihlbGVtZW50LCBzY2hlbWUpIHtcbiAgICBjb25zdCBtb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudCh7XG4gICAgICByZW1vdmVkOiBbXSxcbiAgICAgIGFkZGVkOiBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpXG4gICAgfSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBzcGxpdChtb2RpZmllcikge1xuICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGlmaWVyLnRyaW0oKS5zcGxpdCgvICsvKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4gIT09ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbW9kaWZpZXIgdG9rZW4gdG8gYW4gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyBhZGRNb2RpZmllcihlbGVtZW50LCBtb2RpZmllclRva2VuKSB7XG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbW9kaWZpZXJUb2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IE1vZGlmaWVyVXRpbC5zcGxpdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgICBpZiAodG9rZW5zLmluZGV4T2YobW9kaWZpZXJUb2tlbikgPT0gLTEpIHtcbiAgICAgICAgdG9rZW5zLnB1c2gobW9kaWZpZXJUb2tlbik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIHRva2Vucy5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbW9kaWZpZXIgdG9rZW4gZnJvbSBhbiBlbGVtZW50LlxuICAgKi9cbiAgc3RhdGljIHJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsIG1vZGlmaWVyVG9rZW4pIHtcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IE1vZGlmaWVyVXRpbC5zcGxpdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgICBjb25zdCBpbmRleCA9IHRva2Vucy5pbmRleE9mKG1vZGlmaWVyVG9rZW4pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0b2tlbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgdG9rZW5zLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuXG5jb25zdCB1dGlsID0ge1xuICBfcmVhZHk6IGZhbHNlLFxuXG4gIF9kb21Db250ZW50TG9hZGVkOiBmYWxzZSxcblxuICBfb25ET01Db250ZW50TG9hZGVkOiAoKSA9PiB7XG4gICAgdXRpbC5fZG9tQ29udGVudExvYWRlZCA9IHRydWU7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLl9yZWFkeSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGFkZEJhY2tCdXR0b25MaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHV0aWwuX29uRE9NQ29udGVudExvYWRlZCgpLCBmYWxzZSk7XG5cbmNvbnN0IEhhbmRsZXJSZXBvc2l0b3J5ID0ge1xuICBfc3RvcmU6IHt9LFxuXG4gIF9nZW5JZDogKCgpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuICgpID0+IGkrKztcbiAgfSkoKSxcblxuICBzZXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkID0gSGFuZGxlclJlcG9zaXRvcnkuX2dlbklkKCk7XG4gICAgdGhpcy5fc3RvcmVbaWRdID0gaGFuZGxlcjtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZF07XG4gICAgICBkZWxldGUgZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQ7XG4gICAgfVxuICB9LFxuXG4gIGdldDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIGlmICghdGhpcy5fc3RvcmVbaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RvcmVbaWRdO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudC5kYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcblxuICAgIHJldHVybiAhIXRoaXMuX3N0b3JlW2lkXTtcbiAgfVxufTtcblxuY2xhc3MgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZENhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEVuYWJsZSB0byBoYW5kbGUgJ2JhY2tidXR0b24nIGV2ZW50cy5cbiAgICovXG4gIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgdXRpbC5hZGRCYWNrQnV0dG9uTGlzdGVuZXIodGhpcy5fYm91bmRDYWxsYmFjayk7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNhYmxlIHRvIGhhbmRsZSAnYmFja2J1dHRvbicgZXZlbnRzLlxuICAgKi9cbiAgZGlzYWJsZSgpIHtcbiAgICBpZiAodGhpcy5faXNFbmFibGVkKSB7XG4gICAgICB1dGlsLnJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lcih0aGlzLl9ib3VuZENhbGxiYWNrKTtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlIGEgJ2JhY2tidXR0b24nIGV2ZW50IG1hbnVhbGx5LlxuICAgKi9cbiAgZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudCgnYmFja2J1dHRvbicsIHRydWUsIHRydWUpO1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG5cbiAgX2NhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgY3JlYXRlSGFuZGxlcihlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEhUTUxFbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKCEoY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXIgPSB7XG4gICAgICBfY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXG5cbiAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB9LFxuXG4gICAgICBzZXRMaXN0ZW5lcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0sXG5cbiAgICAgIGVuYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnNldChlbGVtZW50LCB0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIGlzRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW5kbGVyUmVwb3NpdG9yeS5nZXQoZWxlbWVudCkgPT09IHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBoYW5kbGVyLmVuYWJsZSgpO1xuXG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKSB7XG4gICAgY29uc3QgdHJlZSA9IHRoaXMuX2NhcHR1cmVUcmVlKCk7XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZmluZEhhbmRsZXJMZWFmRWxlbWVudCh0cmVlKTtcblxuICAgIGxldCBoYW5kbGVyID0gSGFuZGxlclJlcG9zaXRvcnkuZ2V0KGVsZW1lbnQpO1xuICAgIGhhbmRsZXIuX2NhbGxiYWNrKGNyZWF0ZUV2ZW50KGVsZW1lbnQpKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9lbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjYWxsUGFyZW50SGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLl9jYWxsYmFjayhjcmVhdGVFdmVudChwYXJlbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2NhcHR1cmVUcmVlKCkge1xuICAgIHJldHVybiBjcmVhdGVUcmVlKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVHJlZShlbGVtZW50KSB7XG4gICAgICBjb25zdCB0cmVlID0ge1xuICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICBjaGlsZHJlbjogQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyYXlPZihlbGVtZW50LmNoaWxkcmVuKS5tYXAoZnVuY3Rpb24oY2hpbGRFbGVtZW50KSB7XG5cbiAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fCBjaGlsZEVsZW1lbnQuX2lzU2hvd24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNoaWxkRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgIUhhbmRsZXJSZXBvc2l0b3J5LmhhcyhjaGlsZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlVHJlZShjaGlsZEVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdC5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgIUhhbmRsZXJSZXBvc2l0b3J5LmhhcyhyZXN1bHQuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdF07XG4gICAgICAgIH0pKVxuICAgICAgfTtcblxuICAgICAgaWYgKCFIYW5kbGVyUmVwb3NpdG9yeS5oYXModHJlZS5lbGVtZW50KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIGNvbnN0IHN1YlRyZWUgPSB0cmVlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgIGlmIChIYW5kbGVyUmVwb3NpdG9yeS5oYXMoc3ViVHJlZS5lbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YlRyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFycmF5T2YodGFyZ2V0KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRhcmdldFtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHJlZVxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9maW5kSGFuZGxlckxlYWZFbGVtZW50KHRyZWUpIHtcbiAgICByZXR1cm4gZmluZCh0cmVlKTtcblxuICAgIGZ1bmN0aW9uIGZpbmQobm9kZSkge1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub2RlLmVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmluZChub2RlLmNoaWxkcmVuWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gY2hpbGROb2RlLmVsZW1lbnQ7XG4gICAgICB9KS5yZWR1Y2UoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgICAgaWYgKCFsZWZ0KSB7XG4gICAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbGVmdFogPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShsZWZ0LCAnJykuekluZGV4LCAxMCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0WiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJpZ2h0LCAnJykuekluZGV4LCAxMCk7XG5cbiAgICAgICAgaWYgKCFpc05hTihsZWZ0WikgJiYgIWlzTmFOKHJpZ2h0WikpIHtcbiAgICAgICAgICByZXR1cm4gbGVmdFogPiByaWdodFogPyBsZWZ0IDogcmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhcHR1cmluZyBiYWNrYnV0dG9uLWhhbmRsZXIgaXMgZmFpbHVyZS4nKTtcbiAgICAgIH0sIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgRGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4vYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4vbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5cbmludGVybmFsLkFuaW1hdG9yRmFjdG9yeSA9IEFuaW1hdG9yRmFjdG9yeTtcbmludGVybmFsLk1vZGlmaWVyVXRpbCA9IE1vZGlmaWVyVXRpbDtcbmludGVybmFsLmRiYkRpc3BhdGNoZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcjtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWw7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3RhcnRzV2l0aCA9IChzLCBjKSA9PiBzLnN1YnN0cigwLCBjLmxlbmd0aCkgPT09IGM7XG5jb25zdCBlbmRzV2l0aCA9IChzLCBjKSA9PiBzLnN1YnN0cihzLmxlbmd0aCAtIGMubGVuZ3RoLCBjLmxlbmd0aCkgPT09IGM7XG5jb25zdCB1bndyYXAgPSBzID0+IHMuc2xpY2UoMSwgLTEpO1xuY29uc3QgaXNPYmplY3RTdHJpbmcgPSBzID0+IHN0YXJ0c1dpdGgocywgJ3snKSAmJiBlbmRzV2l0aChzLCAnfScpO1xuY29uc3QgaXNBcnJheVN0cmluZyA9IHMgPT4gc3RhcnRzV2l0aChzLCAnWycpICYmIGVuZHNXaXRoKHMsICddJyk7XG5jb25zdCBpc1F1b3RlZFN0cmluZyA9IHMgPT4gKHN0YXJ0c1dpdGgocywgJ1xcJycpICYmIGVuZHNXaXRoKHMsICdcXCcnKSkgfHwgKHN0YXJ0c1dpdGgocywgJ1wiJykgJiYgZW5kc1dpdGgocywgJ1wiJykpO1xuXG5jb25zdCBlcnJvciA9ICh0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgdG9rZW4gXFwnJyArIHRva2VuICsgJ1xcJyBhdCBwb3NpdGlvbiAnICsgKG9yaWdpbmFsU3RyaW5nLmxlbmd0aCAtIHN0cmluZy5sZW5ndGggLSAxKSArICcgaW4gc3RyaW5nOiBcXCcnICsgb3JpZ2luYWxTdHJpbmcgKyAnXFwnJyk7XG59O1xuXG5jb25zdCBwcm9jZXNzVG9rZW4gPSAodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpID0+IHtcbiAgaWYgKHRva2VuID09PSAndHJ1ZScgfHwgdG9rZW4gPT09ICdmYWxzZScpIHtcbiAgICByZXR1cm4gdG9rZW4gPT09ICd0cnVlJztcbiAgfSBlbHNlIGlmIChpc1F1b3RlZFN0cmluZyh0b2tlbikpIHtcbiAgICByZXR1cm4gdW53cmFwKHRva2VuKTtcbiAgfSBlbHNlIGlmICghaXNOYU4odG9rZW4pKSB7XG4gICAgcmV0dXJuICsodG9rZW4pO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAodG9rZW4pKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5U3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5KHVud3JhcCh0b2tlbikpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgfVxufTtcblxuY29uc3QgbmV4dFRva2VuID0gKHN0cmluZykgPT4ge1xuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBsZXQgbGltaXQgPSBzdHJpbmcubGVuZ3RoO1xuXG4gIGlmIChzdHJpbmdbMF0gPT09ICc6JyB8fCBzdHJpbmdbMF0gPT09ICcsJykge1xuXG4gICAgbGltaXQgPSAxO1xuXG4gIH0gZWxzZSBpZiAoc3RyaW5nWzBdID09PSAneycgfHwgc3RyaW5nWzBdID09PSAnWycpIHtcblxuICAgIGNvbnN0IGMgPSBzdHJpbmcuY2hhckNvZGVBdCgwKTtcbiAgICBsZXQgbmVzdGVkT2JqZWN0ID0gMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09PSBjKSB7XG4gICAgICAgIG5lc3RlZE9iamVjdCsrO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuY2hhckNvZGVBdChpKSA9PT0gYyArIDIpIHtcbiAgICAgICAgbmVzdGVkT2JqZWN0LS07XG4gICAgICAgIGlmIChuZXN0ZWRPYmplY3QgPT09IDApIHtcbiAgICAgICAgICBsaW1pdCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoc3RyaW5nWzBdID09PSAnXFwnJyB8fCBzdHJpbmdbMF0gPT09ICdcIicpIHtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nW2ldID09PSBzdHJpbmdbMF0pIHtcbiAgICAgICAgbGltaXQgPSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFsnICcsICcsJywgJzonXS5pbmRleE9mKHN0cmluZ1tpXSkgIT09IC0xKSB7XG4gICAgICAgIGxpbWl0ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxpbWl0KTtcbn07XG5cbmNvbnN0IHBhcnNlT2JqZWN0ID0gKHN0cmluZykgPT4ge1xuICBjb25zdCBpc1ZhbGlkS2V5ID0ga2V5ID0+IC9eW0EtWl8kXVtBLVowLTlfJF0qJC9pLnRlc3Qoa2V5KTtcblxuICBzdHJpbmcgPSBzdHJpbmcudHJpbSgpO1xuICBjb25zdCBvcmlnaW5hbFN0cmluZyA9IHN0cmluZztcbiAgY29uc3Qgb2JqZWN0ID0ge307XG4gIGxldCByZWFkaW5nS2V5ID0gdHJ1ZSwga2V5LCBwcmV2aW91c1Rva2VuLCB0b2tlbjtcblxuICB3aGlsZShzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICB0b2tlbiA9IG5leHRUb2tlbihzdHJpbmcpO1xuICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSh0b2tlbi5sZW5ndGgsIHN0cmluZy5sZW5ndGgpLnRyaW0oKTtcblxuICAgIGlmICgodG9rZW4gPT09ICc6JyAmJiAoIXJlYWRpbmdLZXkgfHwgIXByZXZpb3VzVG9rZW4gfHwgcHJldmlvdXNUb2tlbiA9PT0gJywnKSlcbiAgICAgICB8fCAodG9rZW4gPT09ICcsJyAmJiByZWFkaW5nS2V5KVxuICAgICAgIHx8ICh0b2tlbiAhPT0gJzonICYmIHRva2VuICE9PSAnLCcgJiYgKHByZXZpb3VzVG9rZW4gJiYgcHJldmlvdXNUb2tlbiAhPT0gJywnICYmIHByZXZpb3VzVG9rZW4gIT09ICc6JykpKSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJzonICYmIHJlYWRpbmdLZXkgJiYgcHJldmlvdXNUb2tlbikge1xuICAgICAgcHJldmlvdXNUb2tlbiA9IGlzUXVvdGVkU3RyaW5nKHByZXZpb3VzVG9rZW4pID8gdW53cmFwKHByZXZpb3VzVG9rZW4pIDogcHJldmlvdXNUb2tlbjtcbiAgICAgIGlmIChpc1ZhbGlkS2V5KHByZXZpb3VzVG9rZW4pKSB7XG4gICAgICAgIGtleSA9IHByZXZpb3VzVG9rZW47XG4gICAgICAgIHJlYWRpbmdLZXkgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgdG9rZW4gXFwnJyArIHByZXZpb3VzVG9rZW4gKyAnXFwnIGF0IHBvc2l0aW9uIDAgaW4gc3RyaW5nOiBcXCcnICsgb3JpZ2luYWxTdHJpbmcgKyAnXFwnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJywnICYmICFyZWFkaW5nS2V5ICYmIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgIG9iamVjdFtrZXldID0gcHJvY2Vzc1Rva2VuKHByZXZpb3VzVG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgICAgcmVhZGluZ0tleSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgb2JqZWN0W2tleV0gPSBwcm9jZXNzVG9rZW4odG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmNvbnN0IHBhcnNlQXJyYXkgPSAoc3RyaW5nKSA9PiB7XG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gIGNvbnN0IG9yaWdpbmFsU3RyaW5nID0gc3RyaW5nO1xuICBjb25zdCBhcnJheSA9IFtdO1xuICBsZXQgcHJldmlvdXNUb2tlbiwgdG9rZW47XG5cbiAgd2hpbGUoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBwcmV2aW91c1Rva2VuID0gdG9rZW47XG4gICAgdG9rZW4gPSBuZXh0VG9rZW4oc3RyaW5nKTtcbiAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UodG9rZW4ubGVuZ3RoLCBzdHJpbmcubGVuZ3RoKS50cmltKCk7XG5cbiAgICBpZiAodG9rZW4gPT09ICcsJyAmJiAoIXByZXZpb3VzVG9rZW4gfHwgcHJldmlvdXNUb2tlbiA9PT0gJywnKSkge1xuICAgICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09ICcsJykge1xuICAgICAgYXJyYXkucHVzaChwcm9jZXNzVG9rZW4ocHJldmlvdXNUb2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b2tlbikge1xuICAgIGlmICh0b2tlbiAhPT0gJywnKSB7XG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuY29uc3QgcGFyc2UgPSAoc3RyaW5nKSA9PiB7XG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG5cbiAgaWYgKGlzT2JqZWN0U3RyaW5nKHN0cmluZykpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3QodW53cmFwKHN0cmluZykpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlTdHJpbmcoc3RyaW5nKSkge1xuICAgIHJldHVybiBwYXJzZUFycmF5KHVud3JhcChzdHJpbmcpKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHN0cmluZyBtdXN0IGJlIG9iamVjdCBvciBhcnJheSBsaWtlOiAnICsgc3RyaW5nKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgc3R5bGVyIGZyb20gJy4vc3R5bGVyJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IGFuaW1hdGlvbk9wdGlvbnNQYXJzZSBmcm9tICcuL2FuaW1hdGlvbi1vcHRpb25zLXBhcnNlcic7XG5cbmNvbnN0IHV0aWwgPSB7fTtcblxudXRpbC5nbG9iYWxzID0ge1xuICBmYWJPZmZzZXQ6IDBcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHF1ZXJ5IGRvdCBjbGFzcyBuYW1lIG9yIG5vZGUgbmFtZSBvciBtYXRjaGVyIGZ1bmN0aW9uLlxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbnV0aWwucHJlcGFyZVF1ZXJ5ID0gKHF1ZXJ5KSA9PiB7XG4gIHJldHVybiBxdWVyeSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gcXVlcnkgOiAoZWxlbWVudCkgPT4gdXRpbC5tYXRjaChlbGVtZW50LCBxdWVyeSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZVxuICogQHBhcmFtIHtTdHJpbmcvRnVuY3Rpb259IHMgQ1NTIFNlbGVjdG9yLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudXRpbC5tYXRjaCA9IChlLCBzKSA9PiAoZS5tYXRjaGVzIHx8IGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGUubXNNYXRjaGVzU2VsZWN0b3IpLmNhbGwoZSwgcyk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRDaGlsZCA9IChlbGVtZW50LCBxdWVyeSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IHV0aWwucHJlcGFyZVF1ZXJ5KHF1ZXJ5KTtcblxuICAvLyBDYXV0aW9uOiBgZWxlbWVudC5jaGlsZHJlbmAgaXMgYHVuZGVmaW5lZGAgaW4gc29tZSBlbnZpcm9ubWVudHMgaWYgYGVsZW1lbnRgIGlzIGBzdmdgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHsgLy8gcHJvY2VzcyBvbmx5IGVsZW1lbnQgbm9kZXNcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobWF0Y2gobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudC9udWxsfVxuICovXG51dGlsLmZpbmRQYXJlbnQgPSAoZWxlbWVudCwgcXVlcnksIHVudGlsKSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gdXRpbC5wcmVwYXJlUXVlcnkocXVlcnkpO1xuXG4gIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIGZvciAoOzspIHtcbiAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IGRvY3VtZW50IHx8IHBhcmVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQgfHwgKHVudGlsICYmIHVudGlsKHBhcmVudCkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKG1hdGNoKHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc0F0dGFjaGVkID0gZWxlbWVudCA9PiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsZW1lbnQpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCA9IChlbGVtZW50KSA9PiB7XG4gIHdoaWxlIChlbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC8ob25zLW5hdmlnYXRvcnxvbnMtdGFiYmFyfG9ucy1tb2RhbCkvKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmlzUGFnZUNvbnRyb2wgPSBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUubWF0Y2goL15vbnMtKG5hdmlnYXRvcnxzcGxpdHRlcnx0YWJiYXJ8cGFnZSkkL2kpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0byBwcm9wYWdhdGVcbiAqL1xudXRpbC5wcm9wYWdhdGVBY3Rpb24gPSAoZWxlbWVudCwgYWN0aW9uKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBlbGVtZW50LmNoaWxkTm9kZXNbaV07XG4gICAgaWYgKGNoaWxkW2FjdGlvbl0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgY2hpbGRbYWN0aW9uXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbihjaGlsZCwgYWN0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIHN0cmluZyB0byBiZSBjYW1lbGl6ZWRcbiAqIEByZXR1cm4ge1N0cmluZ30gQ2FtZWxpemVkIHN0cmluZ1xuICovXG51dGlsLmNhbWVsaXplID0gc3RyaW5nID0+IHN0cmluZy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLy0oW2Etel0pL2csIChtLCBsKSA9PiBsLnRvVXBwZXJDYXNlKCkpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgLSBzdHJpbmcgdG8gYmUgaHlwaGVuYXRlZFxuICogQHJldHVybiB7U3RyaW5nfSBIeXBoZW5hdGVkIHN0cmluZ1xuICovXG51dGlsLmh5cGhlbmF0ZSA9IHN0cmluZyA9PiBzdHJpbmcucmVwbGFjZSgvKFthLXpBLVpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgLSB0YWcgYW5kIGNsYXNzIG9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZVxuICogQHBhcmFtIHtFbGVtZW50fVxuICovXG51dGlsLmNyZWF0ZSA9IChzZWxlY3RvciA9ICcnLCBzdHlsZSA9IHt9KSA9PiB7XG4gIGNvbnN0IGNsYXNzTGlzdCA9IHNlbGVjdG9yLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGNsYXNzTGlzdC5zaGlmdCgpIHx8ICdkaXYnKTtcblxuICBpZiAoY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NMaXN0LmpvaW4oJyAnKTtcbiAgfVxuXG4gIHN0eWxlcihlbGVtZW50LCBzdHlsZSk7XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG51dGlsLmNyZWF0ZUVsZW1lbnQgPSAoaHRtbCkgPT4ge1xuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgaWYgKGh0bWwgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChkb2N1bWVudC5pbXBvcnROb2RlKGh0bWwsIHRydWUpKTtcbiAgfSBlbHNlIHtcbiAgICB3cmFwcGVyLmlubmVySFRNTCA9IGh0bWwudHJpbSgpO1xuICB9XG5cbiAgaWYgKHdyYXBwZXIuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJodG1sXCIgbXVzdCBiZSBvbmUgd3JhcHBlciBlbGVtZW50LicpO1xuICB9XG5cbiAgY29uc3QgZWxlbWVudCA9IHdyYXBwZXIuY2hpbGRyZW5bMF07XG4gIHdyYXBwZXIuY2hpbGRyZW5bMF0ucmVtb3ZlKCk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7SFRNTEZyYWdtZW50fVxuICovXG51dGlsLmNyZWF0ZUZyYWdtZW50ID0gKGh0bWwpID0+IHtcbiAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSBodG1sO1xuICByZXR1cm4gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0cnVlKTtcbn07XG5cbi8qXG4gKiBAcGFyYW0ge09iamVjdH0gZHN0IERlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzcmMgU291cmNlIG9iamVjdChzKS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlZmVyZW5jZSB0byBgZHN0YC5cbiAqL1xudXRpbC5leHRlbmQgPSAoZHN0LCAuLi5hcmdzKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcmdzW2ldKSB7XG4gICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJnc1tpXSk7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tqXTtcbiAgICAgICAgZHN0W2tleV0gPSBhcmdzW2ldW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFycmF5TGlrZVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbnV0aWwuYXJyYXlGcm9tID0gKGFycmF5TGlrZSkgPT4ge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFycmF5TGlrZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBqc29uU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW2ZhaWxTYWZlXVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLnBhcnNlSlNPTk9iamVjdFNhZmVseSA9IChqc29uU3RyaW5nLCBmYWlsU2FmZSA9IHt9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gSlNPTi5wYXJzZSgnJyArIGpzb25TdHJpbmcpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFpbFNhZmU7XG4gIH1cbiAgcmV0dXJuIGZhaWxTYWZlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIHBhdGggc3VjaCBhcyAnbXlBcHAuY29udHJvbGxlcnMuZGF0YS5sb2FkRGF0YSdcbiAqIEByZXR1cm4ge0FueX0gLSB3aGF0ZXZlciBpcyBsb2NhdGVkIGF0IHRoYXQgcGF0aFxuICovXG51dGlsLmZpbmRGcm9tUGF0aCA9IChwYXRoKSA9PiB7XG4gIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciBlbCA9IHdpbmRvdywga2V5O1xuICB3aGlsZSAoa2V5ID0gcGF0aC5zaGlmdCgpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICBlbCA9IGVsW2tleV07XG4gIH1cbiAgcmV0dXJuIGVsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBQYWdlIG9yIHBhZ2UtY29udGFpbmVyIHRoYXQgaW1wbGVtZW50cyAndG9wUGFnZSdcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx9IC0gVmlzaWJsZSBwYWdlIGVsZW1lbnQgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gKi9cbnV0aWwuZ2V0VG9wUGFnZSA9IGNvbnRhaW5lciA9PiBjb250YWluZXIgJiYgKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtcGFnZScgPyBjb250YWluZXIgOiBjb250YWluZXIudG9wUGFnZSkgfHwgbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXIgLSBFbGVtZW50IHdoZXJlIHRoZSBzZWFyY2ggYmVnaW5zXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfSAtIFBhZ2UgZWxlbWVudCB0aGF0IGNvbnRhaW5zIHRoZSB2aXNpYmxlIHRvb2xiYXIgb3IgbnVsbC5cbiAqL1xudXRpbC5maW5kVG9vbGJhclBhZ2UgPSBjb250YWluZXIgPT4ge1xuICBjb25zdCBwYWdlID0gdXRpbC5nZXRUb3BQYWdlKGNvbnRhaW5lcik7XG5cbiAgaWYgKHBhZ2UpIHtcbiAgICBpZiAocGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKSkge1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlLl9jb250ZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbmV4dFBhZ2UgPSB1dGlsLmdldFRvcFBhZ2UocGFnZS5fY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0pO1xuICAgICAgaWYgKG5leHRQYWdlICYmICEvb25zLXRhYmJhci9pLnRlc3QocGFnZS5fY29udGVudEVsZW1lbnQuY2hpbGRyZW5baV0udGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZmluZFRvb2xiYXJQYWdlKG5leHRQYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gW2RldGFpbF1cbiAqIEByZXR1cm4ge0N1c3RvbUV2ZW50fVxuICovXG51dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQgPSAodGFyZ2V0LCBldmVudE5hbWUsIGRldGFpbCA9IHt9KSA9PiB7XG5cbiAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7XG4gICAgYnViYmxlczogdHJ1ZSxcbiAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgIGRldGFpbDogZGV0YWlsXG4gIH0pO1xuXG4gIE9iamVjdC5rZXlzKGRldGFpbCkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGV2ZW50W2tleV0gPSBkZXRhaWxba2V5XTtcbiAgfSk7XG5cbiAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gIHJldHVybiBldmVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnV0aWwuaGFzTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUpID0+IHtcbiAgaWYgKCF0YXJnZXQuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFJlZ0V4cChgKF58XFxcXHMrKSR7bW9kaWZpZXJOYW1lfSgkfFxcXFxzKylgLCAnaScpLnRlc3QodGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hdXRvU3R5bGUgTWFwcyB0aGUgbW9kaWZpZXJOYW1lIHRvIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlZCBtb2RpZmllci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmZvcmNlQXV0b1N0eWxlIElnbm9yZXMgcGxhdGZvcm0gbGltaXRhdGlvbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgaXQgd2FzIGFkZGVkIG9yIG5vdC5cbiAqL1xudXRpbC5hZGRNb2RpZmllciA9ICh0YXJnZXQsIG1vZGlmaWVyTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChvcHRpb25zLmF1dG9TdHlsZSkge1xuICAgIG1vZGlmaWVyTmFtZSA9IGF1dG9TdHlsZS5tYXBNb2RpZmllcihtb2RpZmllck5hbWUsIHRhcmdldCwgb3B0aW9ucy5mb3JjZUF1dG9TdHlsZSk7XG4gIH1cblxuICBpZiAodXRpbC5oYXNNb2RpZmllcih0YXJnZXQsIG1vZGlmaWVyTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB0YXJnZXQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsICgodGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJykgKyAnICcgKyBtb2RpZmllck5hbWUpLnRyaW0oKSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXV0b1N0eWxlIE1hcHMgdGhlIG1vZGlmaWVyTmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBzdHlsZWQgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5mb3JjZUF1dG9TdHlsZSBJZ25vcmVzIHBsYXRmb3JtIGxpbWl0YXRpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGl0IHdhcyBmb3VuZCBvciBub3QuXG4gKi9cbnV0aWwucmVtb3ZlTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAob3B0aW9ucy5hdXRvU3R5bGUpIHtcbiAgICBtb2RpZmllck5hbWUgPSBhdXRvU3R5bGUubWFwTW9kaWZpZXIobW9kaWZpZXJOYW1lLCB0YXJnZXQsIG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUpO1xuICB9XG5cbiAgaWYgKCF0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICF1dGlsLmhhc01vZGlmaWVyKHRhcmdldCwgbW9kaWZpZXJOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IG5ld01vZGlmaWVycyA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykuc3BsaXQoL1xccysvKS5maWx0ZXIobSA9PiBtICYmIG0gIT09IG1vZGlmaWVyTmFtZSk7XG4gIG5ld01vZGlmaWVycy5sZW5ndGggPyB0YXJnZXQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVycy5qb2luKCcgJykpIDogdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZSgnbW9kaWZpZXInKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZm9yY2UgRm9yY2VzIG1vZGlmaWVyIHRvIGJlIGFkZGVkIG9yIHJlbW92ZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hdXRvU3R5bGUgTWFwcyB0aGUgbW9kaWZpZXJOYW1lIHRvIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlZCBtb2RpZmllci5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5mb3JjZUF1dG9TdHlsZSBJZ25vcmVzIHBsYXRmb3JtIGxpbWl0YXRpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGl0IHdhcyBmb3VuZCBvciBub3QuXG4gKi9cbnV0aWwudG9nZ2xlTW9kaWZpZXIgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBvcHRpb25zID0gYXJncy5sZW5ndGggPiAyID8gYXJnc1syXSA6IHt9O1xuICBjb25zdCBmb3JjZSA9IHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zIDogb3B0aW9ucy5mb3JjZTtcblxuICBjb25zdCB0b2dnbGUgPSB0eXBlb2YgZm9yY2UgPT09ICdib29sZWFuJyA/IGZvcmNlIDogIXV0aWwuaGFzTW9kaWZpZXIoLi4uYXJncyk7XG4gIHRvZ2dsZSA/IHV0aWwuYWRkTW9kaWZpZXIoLi4uYXJncykgOiB1dGlsLnJlbW92ZU1vZGlmaWVyKC4uLmFyZ3MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZWZhdWx0Q2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWVcbiAqL1xudXRpbC5yZXN0b3JlQ2xhc3MgPSAoZWwsIGRlZmF1bHRDbGFzcywgc2NoZW1lKSA9PiB7XG4gIGRlZmF1bHRDbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goYyA9PiBjICE9PSAnJyAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGMpICYmIGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICBlbC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykgJiYgTW9kaWZpZXJVdGlsLnJlZnJlc2goZWwsIHNjaGVtZSk7XG59XG5cbi8vIFRPRE86IEZJWFxudXRpbC51cGRhdGVQYXJlbnRQb3NpdGlvbiA9IChlbCkgPT4ge1xuICBpZiAoIWVsLl9wYXJlbnRVcGRhdGVkICYmIGVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwucGFyZW50RWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIGVsLnBhcmVudEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBlbC5fcGFyZW50VXBkYXRlZCA9IHRydWU7XG4gIH1cbn07XG5cbnV0aWwudG9nZ2xlQXR0cmlidXRlID0gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSA9PiB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nID8gJycgOiB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn07XG5cbnV0aWwuYmluZExpc3RlbmVycyA9IChlbGVtZW50LCBsaXN0ZW5lck5hbWVzKSA9PiB7XG4gIGxpc3RlbmVyTmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICBjb25zdCBib3VuZE5hbWUgPSBuYW1lLnJlcGxhY2UoL15fW2Etel0vLCAnX2JvdW5kJyArIG5hbWVbMV0udG9VcHBlckNhc2UoKSk7XG4gICAgZWxlbWVudFtib3VuZE5hbWVdID0gZWxlbWVudFtib3VuZE5hbWVdIHx8IGVsZW1lbnRbbmFtZV0uYmluZChlbGVtZW50KTtcbiAgfSk7XG59O1xuXG51dGlsLmVhY2ggPSAob2JqLCBmKSA9PiBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IGYoa2V5LCBvYmpba2V5XSkpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUmlwcGxlXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnNcbiAqL1xudXRpbC51cGRhdGVSaXBwbGUgPSAodGFyZ2V0LCBoYXNSaXBwbGUsIGF0dHJzID0ge30pID0+IHtcbiAgaWYgKGhhc1JpcHBsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGFzUmlwcGxlID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJyk7XG4gIH1cblxuICBjb25zdCByaXBwbGVFbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGFyZ2V0LCAnb25zLXJpcHBsZScpO1xuXG4gIGlmIChoYXNSaXBwbGUpIHtcbiAgICBpZiAoIXJpcHBsZUVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtcmlwcGxlJyk7XG4gICAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChrZXkgPT4gZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKSk7XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIHRhcmdldC5maXJzdENoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmlwcGxlRWxlbWVudCkge1xuICAgIHJpcHBsZUVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbnV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlID0gYW5pbWF0aW9uT3B0aW9uc1BhcnNlO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xudXRpbC5pc0ludGVnZXIgPSAodmFsdWUpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICBpc0Zpbml0ZSh2YWx1ZSkgJiZcbiAgICBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdH0gRGVmZXJyZWQgcHJvbWlzZS5cbiAqL1xudXRpbC5kZWZlciA9ICgpID0+IHtcbiAgY29uc3QgZGVmZXJyZWQgPSB7fTtcbiAgZGVmZXJyZWQucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuICByZXR1cm4gZGVmZXJyZWQ7XG59O1xuXG4vKipcbiAqIFNob3cgd2FybmluZ3Mgd2hlbiB0aGV5IGFyZSBlbmFibGVkLlxuICpcbiAqIEBwYXJhbSB7Kn0gYXJndW1lbnRzIHRvIGNvbnNvbGUud2FyblxuICovXG51dGlsLndhcm4gPSAoLi4uYXJncykgPT4ge1xuICBpZiAoIWludGVybmFsLmNvbmZpZy53YXJuaW5nc0Rpc2FibGVkKSB7XG4gICAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByZXZlbnQgc2Nyb2xsaW5nIHdoaWxlIGRyYWdpbmcgaG9yaXpvbnRhbGx5LlxuICpcbiAqIEBwYXJhbSB7Z2R9IEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZVxuICovXG51dGlsLnByZXZlbnRTY3JvbGwgPSBnZCA9PiB7XG4gIGNvbnN0IHByZXZlbnQgPSBlID0+IGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgY29uc3QgY2xlYW4gPSAoZSkgPT4ge1xuICAgIGdkLm9mZigndG91Y2htb3ZlJywgcHJldmVudCk7XG4gICAgZ2Qub2ZmKCdkcmFnZW5kJywgY2xlYW4pO1xuICB9O1xuXG4gIGdkLm9uKCd0b3VjaG1vdmUnLCBwcmV2ZW50KTtcbiAgZ2Qub24oJ2RyYWdlbmQnLCBjbGVhbik7XG59O1xuXG4vKipcbiAqIERpc3RhbmNlIGFuZCBkZWx0YVRpbWUgZmlsdGVyIHNvbWUgd2VpcmQgZHJhZ3N0YXJ0IGV2ZW50cyB0aGF0IGFyZSBub3QgZmlyZWQgaW1tZWRpYXRlbHkuXG4gKlxuICogQHBhcmFtIHtldmVudH1cbiAqL1xudXRpbC5pc1ZhbGlkR2VzdHVyZSA9IGV2ZW50ID0+IGV2ZW50Lmdlc3R1cmUgIT09IHVuZGVmaW5lZCAmJiAoZXZlbnQuZ2VzdHVyZS5kaXN0YW5jZSA8PSAxNSB8fCBldmVudC5nZXN0dXJlLmRlbHRhVGltZSA8PSAxMDApO1xuXG5leHBvcnQgZGVmYXVsdCB1dGlsO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuXG4vKipcbiAqIE1pbmltYWwgYW5pbWF0aW9uIGxpYnJhcnkgZm9yIG1hbmFnaW5nIGNzcyB0cmFuc2l0aW9uIG9uIG1vYmlsZSBicm93c2Vycy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVElNRU9VVF9SQVRJTyA9IDEuNDtcblxudmFyIHV0aWwgPSB7XG59O1xuXG4vLyBjYXBpdGFsaXplIHN0cmluZ1xudXRpbC5jYXBpdGFsaXplID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMucHJvcGVydHlcbiAqIEBwYXJhbSB7RmxvYXR9IHBhcmFtcy5kdXJhdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy50aW1pbmdcbiAqL1xudXRpbC5idWlsZFRyYW5zaXRpb25WYWx1ZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBwYXJhbXMucHJvcGVydHkgPSBwYXJhbXMucHJvcGVydHkgfHwgJ2FsbCc7XG4gIHBhcmFtcy5kdXJhdGlvbiA9IHBhcmFtcy5kdXJhdGlvbiB8fCAwLjQ7XG4gIHBhcmFtcy50aW1pbmcgPSBwYXJhbXMudGltaW5nIHx8ICdsaW5lYXInO1xuXG4gIHZhciBwcm9wcyA9IHBhcmFtcy5wcm9wZXJ0eS5zcGxpdCgvICsvKTtcblxuICByZXR1cm4gcHJvcHMubWFwKGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCArICcgJyArIHBhcmFtcy5kdXJhdGlvbiArICdzICcgKyBwYXJhbXMudGltaW5nO1xuICB9KS5qb2luKCcsICcpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgaGFuZGxlciBvbiBcInRyYW5zaXRpb25lbmRcIiBldmVudC5cbiAqL1xudXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gIH1cblxuICB2YXIgZm4gPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChlbGVtZW50ID09IGV2ZW50LnRhcmdldCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcblxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBmYWxzZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuLCBmYWxzZSk7XG4gIH0pO1xuXG4gIHJldHVybiByZW1vdmVMaXN0ZW5lcnM7XG59O1xuXG51dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzID0gKGZ1bmN0aW9uKCkge1xuXG4gIGlmICgnb250cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcbiAgICByZXR1cm4gWyd0cmFuc2l0aW9uZW5kJ107XG4gIH1cblxuICBpZiAoJ29ud2Via2l0dHJhbnNpdGlvbmVuZCcgaW4gd2luZG93KSB7XG4gICAgcmV0dXJuIFsnd2Via2l0VHJhbnNpdGlvbkVuZCddO1xuICB9XG5cbiAgaWYgKHV0aWwudmVuZG9yUHJlZml4ID09PSAnd2Via2l0JyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ28nIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbW96JyB8fCB1dGlsLnZlbmRvclByZWZpeCA9PT0gJ21zJykge1xuICAgIHJldHVybiBbdXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkVuZCcsICd0cmFuc2l0aW9uZW5kJ107XG4gIH1cblxuICByZXR1cm4gW107XG59KSgpO1xuXG51dGlsLl9jc3NQcm9wZXJ0eURpY3QgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcbiAgdmFyIGRpY3QgPSB7fTtcbiAgdmFyIGEgPSAnQScuY2hhckNvZGVBdCgwKTtcbiAgdmFyIHogPSAneicuY2hhckNvZGVBdCgwKTtcblxuICB2YXIgdXBwZXIgPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIHMuc3Vic3RyKDEpLnRvVXBwZXJDYXNlKCk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgIHZhciBrZXkgPSBzdHlsZXNbaV1cbiAgICAucmVwbGFjZSgvXlstXSsvLCAnJylcbiAgICAucmVwbGFjZSgvWy1dW2Etel0vZywgdXBwZXIpXG4gICAgLnJlcGxhY2UoL15tb3ovLCAnTW96Jyk7XG5cbiAgICBpZiAoYSA8PSBrZXkuY2hhckNvZGVBdCgwKSAmJiB6ID49IGtleS5jaGFyQ29kZUF0KDApKSB7XG4gICAgICBpZiAoa2V5ICE9PSAnY3NzVGV4dCcgJiYga2V5ICE9PSAncGFyZW50VGV4dCcpIHtcbiAgICAgICAgZGljdFtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGljdDtcbn0pKCk7XG5cbnV0aWwuaGFzQ3NzUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiBuYW1lIGluIHV0aWwuX2Nzc1Byb3BlcnR5RGljdDtcbn07XG5cbi8qKlxuICogVmVuZG9yIHByZWZpeCBmb3IgY3NzIHByb3BlcnR5LlxuICovXG51dGlsLnZlbmRvclByZWZpeCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpLFxuICAgIHByZSA9IChBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgIC5jYWxsKHN0eWxlcylcbiAgICAgIC5qb2luKCcnKVxuICAgICAgLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IChzdHlsZXMuT0xpbmsgPT09ICcnICYmIFsnJywgJ28nXSlcbiAgICApWzFdO1xuICAgIHJldHVybiBwcmU7XG59KSgpO1xuXG51dGlsLmZvcmNlTGF5b3V0QXRPbmNlID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKSB7XG4gIHRoaXMuYmF0Y2hJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAvLyBmb3JjZSBsYXlvdXRcbiAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIH0pO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xufTtcblxudXRpbC5iYXRjaEltbWVkaWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IFtdO1xuXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb25jcmVhdGVDYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB9O1xufSkoKTtcblxudXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgdmFyIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb25jcmVhdGVDYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgICAgIGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICBjb25jcmVhdGVDYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICB9O1xufSkoKTtcblxudXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSgndHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICByZXR1cm4gJ3RyYW5zaXRpb24nO1xuICB9XG5cbiAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkodXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkR1cmF0aW9uJykpIHtcbiAgICByZXR1cm4gdXRpbC52ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbic7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbn0pKCk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKi9cbnZhciBBbmltaXQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBbmltaXQpKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltaXQoZWxlbWVudCk7XG4gIH1cblxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtlbGVtZW50XTtcbiAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudDtcblxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheSBvciBhbiBpbnN0YW5jZSBvZiBIVE1MRWxlbWVudC4nKTtcbiAgfVxuXG4gIHRoaXMudHJhbnNpdGlvblF1ZXVlID0gW107XG4gIHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdCA9IFtdO1xufTtcblxuQW5pbWl0LnByb3RvdHlwZSA9IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICovXG4gIHRyYW5zaXRpb25RdWV1ZTogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0FycmF5fVxuICAgKi9cbiAgZWxlbWVudHM6IHVuZGVmaW5lZCxcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlIHdpdGggcGFzc2VkIGFuaW1hdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwbGF5OiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zIG9yIG90aGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9KVxuICAgKiBlLmcuIGFuaW1pdChlbHQpLnF1ZXVlKHtjb2xvcjogJ3JlZCd9LCB7ZHVyYXRpb246IDAuNH0pXG4gICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2Nzczoge2NvbG9yOiAncmVkJ30sIGR1cmF0aW9uOiAwLjJ9KVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdHxBbmltaXQuVHJhbnNpdGlvbnxGdW5jdGlvbn0gdHJhbnNpdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICBxdWV1ZTogZnVuY3Rpb24odHJhbnNpdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMudHJhbnNpdGlvblF1ZXVlO1xuXG4gICAgaWYgKHRyYW5zaXRpb24gJiYgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucy5jc3MgPSB0cmFuc2l0aW9uO1xuICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbihvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoISh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgdHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSkge1xuICAgICAgaWYgKHRyYW5zaXRpb24uY3NzKSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKHtcbiAgICAgICAgICBjc3M6IHRyYW5zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBbmltaXQuVHJhbnNpdGlvbikge1xuICAgICAgcXVldWUucHVzaCh0cmFuc2l0aW9uLmJ1aWxkKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFF1ZXVlIHRyYW5zaXRpb24gYW5pbWF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtGbG9hdH0gc2Vjb25kc1xuICAgKi9cbiAgd2FpdDogZnVuY3Rpb24oc2Vjb25kcykge1xuICAgIGlmIChzZWNvbmRzID4gMCkge1xuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZG9uZSwgMTAwMCAqIHNlY29uZHMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc2F2ZVN0eWxlOiBmdW5jdGlvbigpIHtcblxuICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBjc3MgPSB0aGlzLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdID0ge307XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gZWxlbWVudC5zdHlsZVtlbGVtZW50LnN0eWxlW2ldXTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIGRvbmUoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgZWxlbWVudCdzIHN0eWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RmxvYXR9IFtvcHRpb25zLmR1cmF0aW9uXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHJhbnNpdGlvbl1cbiAgICovXG4gIHJlc3RvcmVTdHlsZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmIChvcHRpb25zLnRyYW5zaXRpb24gJiYgIW9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLmR1cmF0aW9uXCIgaXMgcmVxdWlyZWQgd2hlbiBcIm9wdGlvbnMudHJhbnNpdGlvblwiIGlzIGVuYWJsZWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25OYW1lID0gdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiB8fCAob3B0aW9ucy5kdXJhdGlvbiAmJiBvcHRpb25zLmR1cmF0aW9uID4gMCkpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uVmFsdWUgPSBvcHRpb25zLnRyYW5zaXRpb24gfHwgKCdhbGwgJyArIG9wdGlvbnMuZHVyYXRpb24gKyAncyAnICsgKG9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInKSk7XG5cbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgdGltZW91dElkO1xuXG4gICAgICAgIHZhciBjbGVhclRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gJyc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gYWRkIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBmb3IgZmFpbCBzYWZlLlxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIGNsZWFyVHJhbnNpdGlvbigpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSwgb3B0aW9ucy5kdXJhdGlvbiAqIDEwMDAgKiBUSU1FT1VUX1JBVElPKTtcblxuICAgICAgICAvLyB0cmFuc2l0aW9uIGFuZCBzdHlsZSBzZXR0aW5nc1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG5cbiAgICAgICAgICB2YXIgY3NzID0gc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XTtcblxuICAgICAgICAgIGlmICghY3NzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbmFtZSA9IGVsZW1lbnQuc3R5bGVbaV07XG4gICAgICAgICAgICBpZiAoY3NzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3NzW25hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSB0cmFuc2l0aW9uTmFtZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gdHJhbnNpdGlvblZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIC8vIENsZWFyIHRyYW5zaXRpb24gYW5pbWF0aW9uIHNldHRpbmdzLlxuICAgICAgc2VsZi5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbdHJhbnNpdGlvbk5hbWVdID0gJ25vbmUnO1xuXG4gICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgIGlmICghY3NzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXN0b3JlU3R5bGUoKTogVGhlIHN0eWxlIGlzIG5vdCBzYXZlZC4gSW52b2tlIHNhdmVTdHlsZSgpIGJlZm9yZS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5hbWUgPSAnJzsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNzc1tlbGVtZW50LnN0eWxlW2ldXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW2tleV0gPSBjc3Nba2V5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3RhcnQgYW5pbWF0aW9uIHNlcXVlbmNlLlxuICAgKi9cbiAgc3RhcnRBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBfZGVxdWV1ZVRyYW5zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0cmFuc2l0aW9uID0gdGhpcy50cmFuc2l0aW9uUXVldWUuc2hpZnQoKTtcbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zaXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudCB0cmFuc2l0aW9uIGV4aXN0cy4nKTtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fY3VycmVudFRyYW5zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHNlbGYuX2RlcXVldWVUcmFuc2l0aW9uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGU6IFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHR3aWNlLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgdHJhbnNpdGlvbi5jYWxsKHRoaXMsIGRvbmUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QW5pbWl0fSBhcmd1bWVudHNcbiAqL1xuQW5pbWl0LnJ1bkFsbCA9IGZ1bmN0aW9uKC8qIGFyZ3VtZW50cy4uLiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGFyZ3VtZW50c1tpXS5wbGF5KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuZHVyYXRpb25dXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucHJvcGVydHldXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGltaW5nXVxuICovXG5BbmltaXQuVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5vcHRpb25zLmR1cmF0aW9uID0gdGhpcy5vcHRpb25zLmR1cmF0aW9uIHx8IDA7XG4gIHRoaXMub3B0aW9ucy50aW1pbmcgPSB0aGlzLm9wdGlvbnMudGltaW5nIHx8ICdsaW5lYXInO1xuICB0aGlzLm9wdGlvbnMuY3NzID0gdGhpcy5vcHRpb25zLmNzcyB8fCB7fTtcbiAgdGhpcy5vcHRpb25zLnByb3BlcnR5ID0gdGhpcy5vcHRpb25zLnByb3BlcnR5IHx8ICdhbGwnO1xufTtcblxuQW5pbWl0LlRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAgKi9cbiAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5jc3MpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLmNzcyBpcyByZXF1aXJlZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgY3NzID0gY3JlYXRlQWN0dWFsQ3NzUHJvcHModGhpcy5vcHRpb25zLmNzcyk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uID4gMCkge1xuICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IHV0aWwuYnVpbGRUcmFuc2l0aW9uVmFsdWUodGhpcy5vcHRpb25zKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB0aW1lb3V0ID0gc2VsZi5vcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU87XG4gICAgICAgIHZhciB0aW1lb3V0SWQ7XG5cbiAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHV0aWwub25jZU9uVHJhbnNpdGlvbkVuZChlbGVtZW50c1swXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcblxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG5cbiAgICAgICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtuYW1lXSA9IGNzc1tuYW1lXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kdXJhdGlvbiA8PSAwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3V0aWwudHJhbnNpdGlvblByb3BlcnR5TmFtZV0gPSAnJztcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHV0aWwuZm9yY2VMYXlvdXRBdE9uY2UoZWxlbWVudHMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdXRpbC5iYXRjaEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdHVhbENzc1Byb3BzKGNzcykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICBPYmplY3Qua2V5cyhjc3MpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBjc3NbbmFtZV07XG5cbiAgICAgICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJlZml4ZWQgPSB1dGlsLnZlbmRvclByZWZpeCArIHV0aWwuY2FwaXRhbGl6ZShuYW1lKTtcbiAgICAgICAgaWYgKHV0aWwuaGFzQ3NzUHJvcGVydHkocHJlZml4ZWQpKSB7XG4gICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtwcmVmaXhlZF0gPSB2YWx1ZTtcbiAgICAgICAgICByZXN1bHRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0ICBBbmltaXQ7XG5cbiIsIi8qXG4gKiBHZXN0dXJlIGRldGVjdG9yIGxpYnJhcnkgdGhhdCBmb3JrZWQgZnJvbSBnaXRodWIuY29tL0VpZ2h0TWVkaWEvaGFtbWVyLmpzLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50LCBVdGlscywgRGV0ZWN0aW9uLCBQb2ludGVyRXZlbnQ7XG5cbi8qKlxuICogQG9iamVjdCBvbnMuR2VzdHVyZURldGVjdG9yXG4gKiBAY2F0ZWdvcnkgZ2VzdHVyZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1VdGlsaXR5IGNsYXNzIGZvciBnZXN0dXJlIGRldGVjdGlvbi5bL2VuXVxuICogICBbamFd44K444Kn44K544OB44Oj44KS5qSc55+l44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Kv44Op44K544Gn44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAqIEBzaWduYXR1cmUgY29uc3RydWN0b3IoZWxlbWVudFssIG9wdGlvbnNdKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXUNyZWF0ZSBhIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2UuWy9lbl1cbiAqICBbamFdR2VzdHVyZURldGVjdG9y44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+OCkuaknOefpeOBmeOCi0RPTeimgee0oOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1PcHRpb25zIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEByZXR1cm4ge29ucy5HZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9XG4gKi9cbnZhciBHZXN0dXJlRGV0ZWN0b3IgPSBmdW5jdGlvbiBHZXN0dXJlRGV0ZWN0b3IoZWxlbWVudCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IEdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZShlbGVtZW50LCBvcHRpb25zIHx8IHt9KTtcbn07XG5cblxuLyoqXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICogbW9yZSBzZXR0aW5ncyBhcmUgZGVmaW5lZCBwZXIgZ2VzdHVyZSBhdCBgL2dlc3R1cmVzYC4gRWFjaCBnZXN0dXJlIGNhbiBiZSBkaXNhYmxlZC9lbmFibGVkXG4gKiBieSBzZXR0aW5nIGl0J3MgbmFtZSAobGlrZSBgc3dpcGVgKSB0byBmYWxzZS5cbiAqIFlvdSBjYW4gc2V0IHRoZSBkZWZhdWx0cyBmb3IgYWxsIGluc3RhbmNlcyBieSBjaGFuZ2luZyB0aGlzIG9iamVjdCBiZWZvcmUgY3JlYXRpbmcgYW4gaW5zdGFuY2UuXG4gKiBAZXhhbXBsZVxuICogYGBgYFxuICogIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5kcmFnID0gZmFsc2U7XG4gKiAgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmJlaGF2aW9yLnRvdWNoQWN0aW9uID0gJ3Bhbi15JztcbiAqICBkZWxldGUgR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLmJlaGF2aW9yLnVzZXJTZWxlY3Q7XG4gKiBgYGBgXG4gKiBAcHJvcGVydHkgZGVmYXVsdHNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cyA9IHtcbiAgYmVoYXZpb3I6IHtcbiAgICAvLyB1c2VyU2VsZWN0OiAnbm9uZScsIC8vIEFsc28gZGlzYWJsZXMgc2VsZWN0aW9uIGluIGBpbnB1dGAgY2hpbGRyZW5cbiAgICB0b3VjaEFjdGlvbjogJ3Bhbi15JyxcbiAgICB0b3VjaENhbGxvdXQ6ICdub25lJyxcbiAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuICAgIHVzZXJEcmFnOiAnbm9uZScsXG4gICAgdGFwSGlnaGxpZ2h0Q29sb3I6ICdyZ2JhKDAsMCwwLDApJ1xuICB9XG59O1xuXG4vKipcbiAqIEdlc3R1cmVEZXRlY3RvciBkb2N1bWVudCB3aGVyZSB0aGUgYmFzZSBldmVudHMgYXJlIGFkZGVkIGF0XG4gKiBAcHJvcGVydHkgRE9DVU1FTlRcbiAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAqIEBkZWZhdWx0IHdpbmRvdy5kb2N1bWVudFxuICovXG5HZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQgPSBkb2N1bWVudDtcblxuLyoqXG4gKiBkZXRlY3Qgc3VwcG9ydCBmb3IgcG9pbnRlciBldmVudHNcbiAqIEBwcm9wZXJ0eSBIQVNfUE9JTlRFUkVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUyA9IG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZDtcblxuLyoqXG4gKiBkZXRlY3Qgc3VwcG9ydCBmb3IgdG91Y2ggZXZlbnRzXG4gKiBAcHJvcGVydHkgSEFTX1RPVUNIRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLkhBU19UT1VDSEVWRU5UUyA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xuXG4vKipcbiAqIGRldGVjdCBtb2JpbGUgYnJvd3NlcnNcbiAqIEBwcm9wZXJ0eSBJU19NT0JJTEVcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSVNfTU9CSUxFID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBkZXRlY3QgaWYgd2Ugd2FudCB0byBzdXBwb3J0IG1vdXNlZXZlbnRzIGF0IGFsbFxuICogQHByb3BlcnR5IE5PX01PVVNFRVZFTlRTXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLk5PX01PVVNFRVZFTlRTID0gKEdlc3R1cmVEZXRlY3Rvci5IQVNfVE9VQ0hFVkVOVFMgJiYgR2VzdHVyZURldGVjdG9yLklTX01PQklMRSkgfHwgR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTO1xuXG4vKipcbiAqIGludGVydmFsIGluIHdoaWNoIEdlc3R1cmVEZXRlY3RvciByZWNhbGN1bGF0ZXMgY3VycmVudCB2ZWxvY2l0eS9kaXJlY3Rpb24vYW5nbGUgaW4gbXNcbiAqIEBwcm9wZXJ0eSBDQUxDVUxBVEVfSU5URVJWQUxcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAZGVmYXVsdCAyNVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuQ0FMQ1VMQVRFX0lOVEVSVkFMID0gMjU7XG5cbi8qKlxuICogZXZlbnR0eXBlcyBwZXIgdG91Y2hldmVudCAoc3RhcnQsIG1vdmUsIGVuZCkgYXJlIGZpbGxlZCBieSBgRXZlbnQuZGV0ZXJtaW5lRXZlbnRUeXBlc2Agb24gYHNldHVwYFxuICogdGhlIG9iamVjdCBjb250YWlucyB0aGUgRE9NIGV2ZW50IG5hbWVzIHBlciB0eXBlIChgRVZFTlRfU1RBUlRgLCBgRVZFTlRfTU9WRWAsIGBFVkVOVF9FTkRgKVxuICogQHByb3BlcnR5IEVWRU5UX1RZUEVTXG4gKiBAcHJpdmF0ZVxuICogQHdyaXRlT25jZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIEVWRU5UX1RZUEVTID0ge307XG5cbi8qKlxuICogZGlyZWN0aW9uIHN0cmluZ3MsIGZvciBzYWZlIGNvbXBhcmlzb25zXG4gKiBAcHJvcGVydHkgRElSRUNUSU9OX0RPV058TEVGVHxVUHxSSUdIVFxuICogQGZpbmFsXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgJ2Rvd24nICdsZWZ0JyAndXAnICdyaWdodCdcbiAqL1xudmFyIERJUkVDVElPTl9ET1dOID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9ET1dOID0gJ2Rvd24nO1xudmFyIERJUkVDVElPTl9MRUZUID0gR2VzdHVyZURldGVjdG9yLkRJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xudmFyIERJUkVDVElPTl9VUCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fVVAgPSAndXAnO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fUklHSFQgPSAncmlnaHQnO1xuXG4vKipcbiAqIHBvaW50ZXJ0eXBlIHN0cmluZ3MsIGZvciBzYWZlIGNvbXBhcmlzb25zXG4gKiBAcHJvcGVydHkgUE9JTlRFUl9NT1VTRXxUT1VDSHxQRU5cbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdtb3VzZScgJ3RvdWNoJyAncGVuJ1xuICovXG52YXIgUE9JTlRFUl9NT1VTRSA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX01PVVNFID0gJ21vdXNlJztcbnZhciBQT0lOVEVSX1RPVUNIID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfVE9VQ0ggPSAndG91Y2gnO1xudmFyIFBPSU5URVJfUEVOID0gR2VzdHVyZURldGVjdG9yLlBPSU5URVJfUEVOID0gJ3Blbic7XG5cbi8qKlxuICogZXZlbnR0eXBlc1xuICogQHByb3BlcnR5IEVWRU5UX1NUQVJUfE1PVkV8RU5EfFJFTEVBU0V8VE9VQ0hcbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdzdGFydCcgJ2NoYW5nZScgJ21vdmUnICdlbmQnICdyZWxlYXNlJyAndG91Y2gnXG4gKi9cbnZhciBFVkVOVF9TVEFSVCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9TVEFSVCA9ICdzdGFydCc7XG52YXIgRVZFTlRfTU9WRSA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9NT1ZFID0gJ21vdmUnO1xudmFyIEVWRU5UX0VORCA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9FTkQgPSAnZW5kJztcbnZhciBFVkVOVF9SRUxFQVNFID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1JFTEVBU0UgPSAncmVsZWFzZSc7XG52YXIgRVZFTlRfVE9VQ0ggPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfVE9VQ0ggPSAndG91Y2gnO1xuXG4vKipcbiAqIGlmIHRoZSB3aW5kb3cgZXZlbnRzIGFyZSBzZXQuLi5cbiAqIEBwcm9wZXJ0eSBSRUFEWVxuICogQHdyaXRlT25jZVxuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAZGVmYXVsdCBmYWxzZVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuUkVBRFkgPSBmYWxzZTtcblxuLyoqXG4gKiBwbHVnaW5zIG5hbWVzcGFjZVxuICogQHByb3BlcnR5IHBsdWdpbnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5wbHVnaW5zID0gR2VzdHVyZURldGVjdG9yLnBsdWdpbnMgfHwge307XG5cbi8qKlxuICogZ2VzdHVyZXMgbmFtZXNwYWNlXG4gKiBzZWUgYC9nZXN0dXJlc2AgZm9yIHRoZSBkZWZpbml0aW9uc1xuICogQHByb3BlcnR5IGdlc3R1cmVzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgPSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgfHwge307XG5cbi8qKlxuICogc2V0dXAgZXZlbnRzIHRvIGRldGVjdCBnZXN0dXJlcyBvbiB0aGUgZG9jdW1lbnRcbiAqIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gY3JlYXRpbmcgYW4gbmV3IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgaWYoR2VzdHVyZURldGVjdG9yLlJFQURZKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZmluZCB3aGF0IGV2ZW50dHlwZXMgd2UgYWRkIGxpc3RlbmVycyB0b1xuICBFdmVudC5kZXRlcm1pbmVFdmVudFR5cGVzKCk7XG5cbiAgLy8gUmVnaXN0ZXIgYWxsIGdlc3R1cmVzIGluc2lkZSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgVXRpbHMuZWFjaChHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMsIGZ1bmN0aW9uKGdlc3R1cmUpIHtcbiAgICBEZXRlY3Rpb24ucmVnaXN0ZXIoZ2VzdHVyZSk7XG4gIH0pO1xuXG4gIC8vIEFkZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50XG4gIEV2ZW50Lm9uVG91Y2goR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULCBFVkVOVF9NT1ZFLCBEZXRlY3Rpb24uZGV0ZWN0KTtcbiAgRXZlbnQub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX0VORCwgRGV0ZWN0aW9uLmRldGVjdCk7XG5cbiAgLy8gR2VzdHVyZURldGVjdG9yIGlzIHJlYWR5Li4uIVxuICBHZXN0dXJlRGV0ZWN0b3IuUkVBRFkgPSB0cnVlO1xufVxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIFV0aWxzXG4gKiBAc3RhdGljXG4gKi9cblV0aWxzID0gR2VzdHVyZURldGVjdG9yLnV0aWxzID0ge1xuICAvKipcbiAgICogZXh0ZW5kIG1ldGhvZCwgY291bGQgYWxzbyBiZSB1c2VkIGZvciBjbG9uaW5nIHdoZW4gYGRlc3RgIGlzIGFuIGVtcHR5IG9iamVjdC5cbiAgICogY2hhbmdlcyB0aGUgZGVzdCBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttZXJnZT1mYWxzZV0gIGRvIGEgbWVyZ2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBkZXN0XG4gICAqL1xuICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzcmMsIG1lcmdlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChkZXN0W2tleV0gPT09IHVuZGVmaW5lZCB8fCAhbWVyZ2UpKSB7XG4gICAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIGFkZEV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogc2ltcGxlIHJlbW92ZUV2ZW50TGlzdGVuZXIgd3JhcHBlclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmb3JFYWNoIG92ZXIgYXJyYXlzIGFuZCBvYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAgICogQHBhcmFtIHthbnl9IGl0ZXJhdG9yLml0ZW1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGl0ZXJhdG9yLmluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBpdGVyYXRvci5vYmogdGhlIHNvdXJjZSBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgdmFsdWUgdG8gdXNlIGFzIGB0aGlzYCBpbiB0aGUgaXRlcmF0b3JcbiAgICovXG4gIGVhY2g6IGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciBpLCBsZW47XG5cbiAgICAvLyBuYXRpdmUgZm9yRWFjaCBvbiBhcnJheXNcbiAgICBpZignZm9yRWFjaCcgaW4gb2JqKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgICAvLyBhcnJheXNcbiAgICB9IGVsc2UgaWYob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IoaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZihpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG9iamVjdHNcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJlxuICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIHN0cmluZyBjb250YWlucyB0aGUgc3RyaW5nIHVzaW5nIGluZGV4T2ZcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgKi9cbiAgaW5TdHI6IGZ1bmN0aW9uIGluU3RyKHNyYywgZmluZCkge1xuICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKSA+IC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlmaWxsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcmNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbmRcbiAgICogQHJldHVybiB7Qm9vbGVhbnxOdW1iZXJ9IGZhbHNlIHdoZW4gbm90IGZvdW5kLCBvciB0aGUgaW5kZXhcbiAgICovXG4gIGluQXJyYXk6IGZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBkZWVwKSB7XG4gICAgaWYgKGRlZXApIHtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHNyYy5sZW5ndGg7IGkgPCBsZW47IGkrKykgeyAvLyBBcnJheS5maW5kSW5kZXhcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGZpbmQpLmV2ZXJ5KGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gc3JjW2ldW2tleV0gPT09IGZpbmRba2V5XTsgfSkpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmKHNyYy5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHNyYy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZihzcmNbaV0gPT09IGZpbmQpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogY29udmVydCBhbiBhcnJheS1saWtlIG9iamVjdCAoYGFyZ3VtZW50c2AsIGB0b3VjaGxpc3RgKSB0byBhbiBhcnJheVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqLCAwKTtcbiAgfSxcblxuICAvKipcbiAgICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBmb3VuZFxuICAgKi9cbiAgaGFzUGFyZW50OiBmdW5jdGlvbiBoYXNQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUobm9kZSkge1xuICAgICAgaWYobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSB0b3VjaGVzXG4gICAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGBwYWdlWGAsIGBwYWdlWWAsIGBjbGllbnRYYCBhbmQgYGNsaWVudFlgIHByb3BlcnRpZXNcbiAgICovXG4gIGdldENlbnRlcjogZnVuY3Rpb24gZ2V0Q2VudGVyKHRvdWNoZXMpIHtcbiAgICB2YXIgcGFnZVggPSBbXSxcbiAgICAgICAgcGFnZVkgPSBbXSxcbiAgICAgICAgY2xpZW50WCA9IFtdLFxuICAgICAgICBjbGllbnRZID0gW10sXG4gICAgICAgIG1pbiA9IE1hdGgubWluLFxuICAgICAgICBtYXggPSBNYXRoLm1heDtcblxuICAgIC8vIG5vIG5lZWQgdG8gbG9vcCB3aGVuIG9ubHkgb25lIHRvdWNoXG4gICAgaWYodG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VYOiB0b3VjaGVzWzBdLnBhZ2VYLFxuICAgICAgICBwYWdlWTogdG91Y2hlc1swXS5wYWdlWSxcbiAgICAgICAgY2xpZW50WDogdG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiB0b3VjaGVzWzBdLmNsaWVudFlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgVXRpbHMuZWFjaCh0b3VjaGVzLCBmdW5jdGlvbih0b3VjaCkge1xuICAgICAgcGFnZVgucHVzaCh0b3VjaC5wYWdlWCk7XG4gICAgICBwYWdlWS5wdXNoKHRvdWNoLnBhZ2VZKTtcbiAgICAgIGNsaWVudFgucHVzaCh0b3VjaC5jbGllbnRYKTtcbiAgICAgIGNsaWVudFkucHVzaCh0b3VjaC5jbGllbnRZKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYWdlWDogKG1pbi5hcHBseShNYXRoLCBwYWdlWCkgKyBtYXguYXBwbHkoTWF0aCwgcGFnZVgpKSAvIDIsXG4gICAgICBwYWdlWTogKG1pbi5hcHBseShNYXRoLCBwYWdlWSkgKyBtYXguYXBwbHkoTWF0aCwgcGFnZVkpKSAvIDIsXG4gICAgICBjbGllbnRYOiAobWluLmFwcGx5KE1hdGgsIGNsaWVudFgpICsgbWF4LmFwcGx5KE1hdGgsIGNsaWVudFgpKSAvIDIsXG4gICAgICBjbGllbnRZOiAobWluLmFwcGx5KE1hdGgsIGNsaWVudFkpICsgbWF4LmFwcGx5KE1hdGgsIGNsaWVudFkpKSAvIDJcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50cy4gdW5pdCBpcyBpbiBweCBwZXIgbXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVRpbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWFxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFZXG4gICAqIEByZXR1cm4ge09iamVjdH0gdmVsb2NpdHkgYHhgIGFuZCBgeWBcbiAgICovXG4gIGdldFZlbG9jaXR5OiBmdW5jdGlvbiBnZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguYWJzKGRlbHRhWCAvIGRlbHRhVGltZSkgfHwgMCxcbiAgICAgIHk6IE1hdGguYWJzKGRlbHRhWSAvIGRlbHRhVGltZSkgfHwgMFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gxXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gICAqL1xuICBnZXRBbmdsZTogZnVuY3Rpb24gZ2V0QW5nbGUodG91Y2gxLCB0b3VjaDIpIHtcbiAgICB2YXIgeCA9IHRvdWNoMi5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFgsXG4gICAgICAgIHkgPSB0b3VjaDIuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xuXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xuICB9LFxuXG4gIC8qKlxuICAgKiBkbyBhIHNtYWxsIGNvbXBhcmlzb24gdG8gZ2V0IHRoZSBkaXJlY3Rpb24gYmV0d2VlbiB0d28gdG91Y2hlcy5cbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gxXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGRpcmVjdGlvbiBtYXRjaGVzIGBESVJFQ1RJT05fTEVGVHxSSUdIVHxVUHxET1dOYFxuICAgKi9cbiAgZ2V0RGlyZWN0aW9uOiBmdW5jdGlvbiBnZXREaXJlY3Rpb24odG91Y2gxLCB0b3VjaDIpIHtcbiAgICB2YXIgeCA9IE1hdGguYWJzKHRvdWNoMS5jbGllbnRYIC0gdG91Y2gyLmNsaWVudFgpLFxuICAgICAgICB5ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSk7XG5cbiAgICBpZih4ID49IHkpIHtcbiAgICAgIHJldHVybiB0b3VjaDEuY2xpZW50WCAtIHRvdWNoMi5jbGllbnRYID4gMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cbiAgICByZXR1cm4gdG91Y2gxLmNsaWVudFkgLSB0b3VjaDIuY2xpZW50WSA+IDAgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0b3VjaGVzXG4gICAqIEBwYXJhbSB7VG91Y2h9dG91Y2gxXG4gICAqIEBwYXJhbSB7VG91Y2h9IHRvdWNoMlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuICBnZXREaXN0YW5jZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2UodG91Y2gxLCB0b3VjaDIpIHtcbiAgICB2YXIgeCA9IHRvdWNoMi5jbGllbnRYIC0gdG91Y2gxLmNsaWVudFgsXG4gICAgICAgIHkgPSB0b3VjaDIuY2xpZW50WSAtIHRvdWNoMS5jbGllbnRZO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHRvdWNoTGlzdHNcbiAgICogbm8gc2NhbGUgaXMgMSwgYW5kIGdvZXMgZG93biB0byAwIHdoZW4gcGluY2hlZCB0b2dldGhlciwgYW5kIGJpZ2dlciB3aGVuIHBpbmNoZWQgb3V0XG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICAgKi9cbiAgZ2V0U2NhbGU6IGZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgICAvLyBuZWVkIHR3byBmaW5nZXJzLi4uXG4gICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSkgLyB0aGlzLmdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSk7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgKiBAcGFyYW0ge0FycmF5fSBzdGFydCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiB0b3VjaGVzXG4gICAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAgICovXG4gIGdldFJvdGF0aW9uOiBmdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgLy8gbmVlZCB0d28gZmluZ2Vyc1xuICAgIGlmKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5nbGUoZW5kWzFdLCBlbmRbMF0pIC0gdGhpcy5nZXRBbmdsZShzdGFydFsxXSwgc3RhcnRbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcblxuICAvKipcbiAgICogZmluZCBvdXQgaWYgdGhlIGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbCAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiBtYXRjaGVzIGBESVJFQ1RJT05fVVB8RE9XTmBcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gaXNfdmVydGljYWxcbiAgICovXG4gIGlzVmVydGljYWw6IGZ1bmN0aW9uIGlzVmVydGljYWwoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVAgfHwgZGlyZWN0aW9uID09IERJUkVDVElPTl9ET1dOO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzZXQgY3NzIHByb3BlcnRpZXMgd2l0aCB0aGVpciBwcmVmaXhlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b2dnbGU9dHJ1ZV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIHNldFByZWZpeGVkQ3NzOiBmdW5jdGlvbiBzZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKSB7XG4gICAgdmFyIHByZWZpeGVzID0gWycnLCAnV2Via2l0JywgJ01veicsICdPJywgJ21zJ107XG4gICAgcHJvcCA9IFV0aWxzLnRvQ2FtZWxDYXNlKHByb3ApO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHByb3A7XG4gICAgICAvLyBwcmVmaXhlc1xuICAgICAgaWYocHJlZml4ZXNbaV0pIHtcbiAgICAgICAgcCA9IHByZWZpeGVzW2ldICsgcC5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsgcC5zbGljZSgxKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGVzdCB0aGUgc3R5bGVcbiAgICAgIGlmKHAgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlW3BdID0gKHRvZ2dsZSA9PT0gbnVsbCB8fCB0b2dnbGUpICYmIHZhbHVlIHx8ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRvZ2dsZSBicm93c2VyIGRlZmF1bHQgYmVoYXZpb3IgYnkgc2V0dGluZyBjc3MgcHJvcGVydGllcy5cbiAgICogYHVzZXJTZWxlY3Q9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25zZWxlY3RzdGFydGAgdG8gZmFsc2VcbiAgICogYHVzZXJEcmFnPSdub25lJ2AgYWxzbyBzZXRzIGBlbGVtZW50Lm9uZHJhZ3N0YXJ0YCB0byBmYWxzZVxuICAgKlxuICAgKiBAcGFyYW0ge0h0bWxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0b2dnbGU9dHJ1ZV1cbiAgICovXG4gIHRvZ2dsZUJlaGF2aW9yOiBmdW5jdGlvbiB0b2dnbGVCZWhhdmlvcihlbGVtZW50LCBwcm9wcywgdG9nZ2xlKSB7XG4gICAgaWYoIXByb3BzIHx8ICFlbGVtZW50IHx8ICFlbGVtZW50LnN0eWxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBjc3MgcHJvcGVydGllc1xuICAgIFV0aWxzLmVhY2gocHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwcm9wKSB7XG4gICAgICBVdGlscy5zZXRQcmVmaXhlZENzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSwgdG9nZ2xlKTtcbiAgICB9KTtcblxuICAgIHZhciBmYWxzZUZuID0gdG9nZ2xlICYmIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBhbHNvIHRoZSBkaXNhYmxlIG9uc2VsZWN0c3RhcnRcbiAgICBpZihwcm9wcy51c2VyU2VsZWN0ID09ICdub25lJykge1xuICAgICAgZWxlbWVudC5vbnNlbGVjdHN0YXJ0ID0gZmFsc2VGbjtcbiAgICB9XG4gICAgLy8gYW5kIGRpc2FibGUgb25kcmFnc3RhcnRcbiAgICBpZihwcm9wcy51c2VyRHJhZyA9PSAnbm9uZScpIHtcbiAgICAgIGVsZW1lbnQub25kcmFnc3RhcnQgPSBmYWxzZUZuO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogY29udmVydCBhIHN0cmluZyB3aXRoIHVuZGVyc2NvcmVzIHRvIGNhbWVsQ2FzZVxuICAgKiBzbyBwcmV2ZW50X2RlZmF1bHQgYmVjb21lcyBwcmV2ZW50RGVmYXVsdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gY2FtZWxDYXNlU3RyXG4gICAqL1xuICB0b0NhbWVsQ2FzZTogZnVuY3Rpb24gdG9DYW1lbENhc2Uoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bXy1dKFthLXpdKS9nLCBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gc1sxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqL1xuLyoqXG4gKiBAY2xhc3MgRXZlbnRcbiAqIEBzdGF0aWNcbiAqL1xuRXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuZXZlbnQgPSB7XG4gIC8qKlxuICAgKiB3aGVuIHRvdWNoIGV2ZW50cyBoYXZlIGJlZW4gZmlyZWQsIHRoaXMgaXMgdHJ1ZVxuICAgKiB0aGlzIGlzIHVzZWQgdG8gc3RvcCBtb3VzZSBldmVudHNcbiAgICogQHByb3BlcnR5IHByZXZlbnRfbW91c2VldmVudHNcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBwcmV2ZW50TW91c2VFdmVudHM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBpZiBFVkVOVF9TVEFSVCBoYXMgYmVlbiBmaXJlZFxuICAgKiBAcHJvcGVydHkgc3RhcnRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHN0YXJ0ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiB3aGVuIHRoZSBtb3VzZSBpcyBob2xkIGRvd24sIHRoaXMgaXMgdHJ1ZVxuICAgKiBAcHJvcGVydHkgc2hvdWxkX2RldGVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHNob3VsZERldGVjdDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHNpbXBsZSBldmVudCBiaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIGhvb2spIHtcbiAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgVXRpbHMuZWFjaCh0eXBlcywgZnVuY3Rpb24odHlwZSkge1xuICAgICAgVXRpbHMub24oZWxlbWVudCwgdHlwZSwgaGFuZGxlcik7XG4gICAgICBob29rICYmIGhvb2sodHlwZSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNpbXBsZSBldmVudCB1bmJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtob29rXVxuICAgKiBAcGFyYW0ge09iamVjdH0gaG9vay50eXBlXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIG9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBob29rKSB7XG4gICAgdmFyIHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIFV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIFV0aWxzLm9mZihlbGVtZW50LCB0eXBlLCBoYW5kbGVyKTtcbiAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogdGhlIGNvcmUgdG91Y2ggZXZlbnQgaGFuZGxlci5cbiAgICogdGhpcyBmaW5kcyBvdXQgaWYgd2Ugc2hvdWxkIHRvIGRldGVjdCBnZXN0dXJlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiBvblRvdWNoSGFuZGxlciB7RnVuY3Rpb259IHRoZSBjb3JlIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goZWxlbWVudCwgZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIG9uVG91Y2hIYW5kbGVyID0gZnVuY3Rpb24gb25Ub3VjaEhhbmRsZXIoZXYpIHtcbiAgICAgIHZhciBzcmNUeXBlID0gZXYudHlwZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIGlzUG9pbnRlciA9IEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUyxcbiAgICAgICAgICBpc01vdXNlID0gVXRpbHMuaW5TdHIoc3JjVHlwZSwgJ21vdXNlJyksXG4gICAgICAgICAgdHJpZ2dlclR5cGU7XG5cbiAgICAgIC8vIGlmIHdlIGFyZSBpbiBhIG1vdXNlZXZlbnQsIGJ1dCB0aGVyZSBoYXMgYmVlbiBhIHRvdWNoZXZlbnQgdHJpZ2dlcmVkIGluIHRoaXMgc2Vzc2lvblxuICAgICAgLy8gd2Ugd2FudCB0byBkbyBub3RoaW5nLiBzaW1wbHkgYnJlYWsgb3V0IG9mIHRoZSBldmVudC5cbiAgICAgIGlmKGlzTW91c2UgJiYgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIG1vdXNlYnV0dG9uIG11c3QgYmUgZG93blxuICAgICAgfSBlbHNlIGlmKGlzTW91c2UgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IChldi5idXR0b25zID09PSAxIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9UT1VDSCwgZXYpKTtcbiAgICAgICAgLy8ganVzdCBhIHZhbGlkIHN0YXJ0IGV2ZW50LCBidXQgbm8gbW91c2VcbiAgICAgIH0gZWxzZSBpZighaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSB0cnVlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlciBldmVudCBiZWZvcmUgZW50ZXJpbmcgdGhlIGRldGVjdGlvblxuICAgICAgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQpIHtcbiAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGFyZSBpbiBhIHRvdWNoL2Rvd24gc3RhdGUsIHNvIGFsbG93ZWQgZGV0ZWN0aW9uIG9mIGdlc3R1cmVzXG4gICAgICBpZihzZWxmLnNob3VsZERldGVjdCkge1xuICAgICAgICB0cmlnZ2VyVHlwZSA9IHNlbGYuZG9EZXRlY3QuY2FsbChzZWxmLCBldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gLi4uYW5kIHdlIGFyZSBkb25lIHdpdGggdGhlIGRldGVjdGlvblxuICAgICAgLy8gc28gcmVzZXQgZXZlcnl0aGluZyB0byBzdGFydCBlYWNoIGRldGVjdGlvbiB0b3RhbGx5IGZyZXNoXG4gICAgICBpZih0cmlnZ2VyVHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgc2VsZi5wcmV2ZW50TW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5zaG91bGREZXRlY3QgPSBmYWxzZTtcbiAgICAgICAgUG9pbnRlckV2ZW50LnJlc2V0KCk7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9pbnRlcmV2ZW50IG9iamVjdCBhZnRlciB0aGUgZGV0ZWN0aW9uXG4gICAgICB9XG5cbiAgICAgIGlmKGlzUG9pbnRlciAmJiBldmVudFR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICAgIFBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm9uKGVsZW1lbnQsIEVWRU5UX1RZUEVTW2V2ZW50VHlwZV0sIG9uVG91Y2hIYW5kbGVyKTtcbiAgICByZXR1cm4gb25Ub3VjaEhhbmRsZXI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRoZSBjb3JlIGRldGVjdGlvbiBtZXRob2RcbiAgICogdGhpcyBmaW5kcyBvdXQgd2hhdCBHZXN0dXJlRGV0ZWN0b3ItdG91Y2gtZXZlbnRzIHRvIHRyaWdnZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRyaWdnZXJUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKi9cbiAgZG9EZXRlY3Q6IGZ1bmN0aW9uIGRvRGV0ZWN0KGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpIHtcbiAgICB2YXIgdG91Y2hMaXN0ID0gdGhpcy5nZXRUb3VjaExpc3QoZXYsIGV2ZW50VHlwZSk7XG4gICAgdmFyIHRvdWNoTGlzdExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGg7XG4gICAgdmFyIHRyaWdnZXJUeXBlID0gZXZlbnRUeXBlO1xuICAgIHZhciB0cmlnZ2VyQ2hhbmdlID0gdG91Y2hMaXN0LnRyaWdnZXI7IC8vIHVzZWQgYnkgZmFrZU11bHRpdG91Y2ggcGx1Z2luXG4gICAgdmFyIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3RMZW5ndGg7XG5cbiAgICAvLyBhdCBlYWNoIHRvdWNoc3RhcnQtbGlrZSBldmVudCB3ZSB3YW50IGFsc28gd2FudCB0byB0cmlnZ2VyIGEgVE9VQ0ggZXZlbnQuLi5cbiAgICBpZihldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9UT1VDSDtcbiAgICAgIC8vIC4uLnRoZSBzYW1lIGZvciBhIHRvdWNoZW5kLWxpa2UgZXZlbnRcbiAgICB9IGVsc2UgaWYoZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgdHJpZ2dlckNoYW5nZSA9IEVWRU5UX1JFTEVBU0U7XG5cbiAgICAgIC8vIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgdG91Y2hlcyBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgY2hhbmdlZExlbmd0aCA9IHRvdWNoTGlzdC5sZW5ndGggLSAoKGV2LmNoYW5nZWRUb3VjaGVzKSA/IGV2LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA6IDEpO1xuICAgIH1cblxuICAgIC8vIGFmdGVyIHRoZXJlIGFyZSBzdGlsbCB0b3VjaGVzIG9uIHRoZSBzY3JlZW4sXG4gICAgLy8gd2UganVzdCB3YW50IHRvIHRyaWdnZXIgYSBNT1ZFIGV2ZW50LiBzbyBjaGFuZ2UgdGhlIFNUQVJUIG9yIEVORCB0byBhIE1PVkVcbiAgICAvLyBidXQgb25seSBhZnRlciBkZXRlY3Rpb24gaGFzIGJlZW4gc3RhcnRlZCwgdGhlIGZpcnN0IHRpbWUgd2UgYWN0dWFsbHkgd2FudCBhIFNUQVJUXG4gICAgaWYoY2hhbmdlZExlbmd0aCA+IDAgJiYgdGhpcy5zdGFydGVkKSB7XG4gICAgICB0cmlnZ2VyVHlwZSA9IEVWRU5UX01PVkU7XG4gICAgfVxuXG4gICAgLy8gZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHdlIGtlZXAgdHJhY2sgb2YgdGhpcywgc2VlIGFib3ZlXG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcblxuICAgIC8vIGdlbmVyYXRlIHNvbWUgZXZlbnQgZGF0YSwgc29tZSBiYXNpYyBpbmZvcm1hdGlvblxuICAgIHZhciBldkRhdGEgPSB0aGlzLmNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgdHJpZ2dlclR5cGUsIHRvdWNoTGlzdCwgZXYpO1xuXG4gICAgLy8gdHJpZ2dlciB0aGUgdHJpZ2dlclR5cGUgZXZlbnQgYmVmb3JlIHRoZSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudHNcbiAgICAvLyBidXQgdGhlIEVORCBldmVudCBzaG91bGQgYmUgYXQgbGFzdFxuICAgIGlmKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQpIHtcbiAgICAgIGhhbmRsZXIuY2FsbChEZXRlY3Rpb24sIGV2RGF0YSk7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciBhIGNoYW5nZSAoVE9VQ0gsIFJFTEVBU0UpIGV2ZW50LCB0aGlzIG1lYW5zIHRoZSBsZW5ndGggb2YgdGhlIHRvdWNoZXMgY2hhbmdlZFxuICAgIGlmKHRyaWdnZXJDaGFuZ2UpIHtcbiAgICAgIGV2RGF0YS5jaGFuZ2VkTGVuZ3RoID0gY2hhbmdlZExlbmd0aDtcbiAgICAgIGV2RGF0YS5ldmVudFR5cGUgPSB0cmlnZ2VyQ2hhbmdlO1xuXG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuXG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlclR5cGU7XG4gICAgICBkZWxldGUgZXZEYXRhLmNoYW5nZWRMZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gdHJpZ2dlciB0aGUgRU5EIGV2ZW50XG4gICAgaWYodHJpZ2dlclR5cGUgPT0gRVZFTlRfRU5EKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuXG4gICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cmlnZ2VyVHlwZTtcbiAgfSxcblxuICAvKipcbiAgICogd2UgaGF2ZSBkaWZmZXJlbnQgZXZlbnRzIGZvciBlYWNoIGRldmljZS9icm93c2VyXG4gICAqIGRldGVybWluZSB3aGF0IHdlIG5lZWQgYW5kIHNldCB0aGVtIGluIHRoZSBFVkVOVF9UWVBFUyBjb25zdGFudFxuICAgKiB0aGUgYG9uVG91Y2hgIG1ldGhvZCBpcyBiaW5kIHRvIHRoZXNlIHByb3BlcnRpZXMuXG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZlbnRzXG4gICAqL1xuICBkZXRlcm1pbmVFdmVudFR5cGVzOiBmdW5jdGlvbiBkZXRlcm1pbmVFdmVudFR5cGVzKCkge1xuICAgIHZhciB0eXBlcztcbiAgICBpZihHZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMpIHtcbiAgICAgIGlmKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgJ3BvaW50ZXJkb3duJyxcbiAgICAgICAgICAncG9pbnRlcm1vdmUnLFxuICAgICAgICAgICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBsb3N0cG9pbnRlcmNhcHR1cmUnXG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlcyA9IFtcbiAgICAgICAgICAnTVNQb2ludGVyRG93bicsXG4gICAgICAgICAgJ01TUG9pbnRlck1vdmUnLFxuICAgICAgICAgICdNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwgTVNMb3N0UG9pbnRlckNhcHR1cmUnXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKEdlc3R1cmVEZXRlY3Rvci5OT19NT1VTRUVWRU5UUykge1xuICAgICAgdHlwZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCdcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCBtb3VzZWRvd24nLFxuICAgICAgICAndG91Y2htb3ZlIG1vdXNlbW92ZScsXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBtb3VzZXVwJ1xuICAgICAgXTtcbiAgICB9XG5cbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9TVEFSVF0gPSB0eXBlc1swXTtcbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9NT1ZFXSA9IHR5cGVzWzFdO1xuICAgIEVWRU5UX1RZUEVTW0VWRU5UX0VORF0gPSB0eXBlc1syXTtcbiAgICByZXR1cm4gRVZFTlRfVFlQRVM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNyZWF0ZSB0b3VjaExpc3QgZGVwZW5kaW5nIG9uIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gdG91Y2hlc1xuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoZXYsIGV2ZW50VHlwZSkge1xuICAgIC8vIGdldCB0aGUgZmFrZSBwb2ludGVyRXZlbnQgdG91Y2hsaXN0XG4gICAgaWYoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICByZXR1cm4gUG9pbnRlckV2ZW50LmdldFRvdWNoTGlzdCgpO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgdG91Y2hsaXN0XG4gICAgaWYoZXYudG91Y2hlcykge1xuICAgICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX01PVkUpIHtcbiAgICAgICAgcmV0dXJuIGV2LnRvdWNoZXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZGVudGlmaWVycyA9IFtdO1xuICAgICAgdmFyIGNvbmNhdCA9IFtdLmNvbmNhdChVdGlscy50b0FycmF5KGV2LnRvdWNoZXMpLCBVdGlscy50b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKSk7XG4gICAgICB2YXIgdG91Y2hMaXN0ID0gW107XG5cbiAgICAgIFV0aWxzLmVhY2goY29uY2F0LCBmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICBpZihVdGlscy5pbkFycmF5KGlkZW50aWZpZXJzLCB0b3VjaC5pZGVudGlmaWVyKSA9PT0gLTEpIHtcbiAgICAgICAgICB0b3VjaExpc3QucHVzaCh0b3VjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0b3VjaC5pZGVudGlmaWVyKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdG91Y2hMaXN0O1xuICAgIH1cblxuICAgIC8vIG1ha2UgZmFrZSB0b3VjaExpc3QgZnJvbSBtb3VzZSBwb3NpdGlvblxuICAgIGV2LmlkZW50aWZpZXIgPSAxO1xuICAgIHJldHVybiBbZXZdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjb2xsZWN0IGJhc2ljIGV2ZW50IGRhdGFcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0FycmF5fSB0b3VjaGVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2XG4gICAqL1xuICBjb2xsZWN0RXZlbnREYXRhOiBmdW5jdGlvbiBjb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIGV2ZW50VHlwZSwgdG91Y2hlcywgZXYpIHtcbiAgICAvLyBmaW5kIG91dCBwb2ludGVyVHlwZVxuICAgIHZhciBwb2ludGVyVHlwZSA9IFBPSU5URVJfVE9VQ0g7XG4gICAgaWYoVXRpbHMuaW5TdHIoZXYudHlwZSwgJ21vdXNlJykgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX01PVVNFLCBldikpIHtcbiAgICAgIHBvaW50ZXJUeXBlID0gUE9JTlRFUl9NT1VTRTtcbiAgICB9IGVsc2UgaWYoUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1BFTiwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfUEVOO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjZW50ZXI6IFV0aWxzLmdldENlbnRlcih0b3VjaGVzKSxcbiAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxuICAgICAgdG91Y2hlczogdG91Y2hlcyxcbiAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgc3JjRXZlbnQ6IGV2LFxuXG4gICAgICAvKipcbiAgICAgICAqIHByZXZlbnQgdGhlIGJyb3dzZXIgZGVmYXVsdCBhY3Rpb25zXG4gICAgICAgKiBtb3N0bHkgdXNlZCB0byBkaXNhYmxlIHNjcm9sbGluZyBvZiB0aGUgYnJvd3NlclxuICAgICAgICovXG4gICAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzcmNFdmVudCA9IHRoaXMuc3JjRXZlbnQ7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24gJiYgc3JjRXZlbnQucHJldmVudE1hbmlwdWxhdGlvbigpO1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCAmJiBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBzdG9wIGJ1YmJsaW5nIHRoZSBldmVudCB1cCB0byBpdHMgcGFyZW50c1xuICAgICAgICovXG4gICAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBpbW1lZGlhdGVseSBzdG9wIGdlc3R1cmUgZGV0ZWN0aW9uXG4gICAgICAgKiBtaWdodCBiZSB1c2VmdWwgYWZ0ZXIgYSBzd2lwZSB3YXMgZGV0ZWN0ZWRcbiAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgKi9cbiAgICAgIHN0b3BEZXRlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRGV0ZWN0aW9uLnN0b3BEZXRlY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgUG9pbnRlckV2ZW50XG4gKiBAc3RhdGljXG4gKi9cblBvaW50ZXJFdmVudCA9IEdlc3R1cmVEZXRlY3Rvci5Qb2ludGVyRXZlbnQgPSB7XG4gIC8qKlxuICAgKiBob2xkcyBhbGwgcG9pbnRlcnMsIGJ5IGBpZGVudGlmaWVyYFxuICAgKiBAcHJvcGVydHkgcG9pbnRlcnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHBvaW50ZXJzOiB7fSxcblxuICAvKipcbiAgICogZ2V0IHRoZSBwb2ludGVycyBhcyBhbiBhcnJheVxuICAgKiBAcmV0dXJuIHtBcnJheX0gdG91Y2hsaXN0XG4gICAqL1xuICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uIGdldFRvdWNoTGlzdCgpIHtcbiAgICB2YXIgdG91Y2hsaXN0ID0gW107XG4gICAgLy8gd2UgY2FuIHVzZSBmb3JFYWNoIHNpbmNlIHBvaW50ZXJFdmVudHMgb25seSBpcyBpbiBJRTEwXG4gICAgVXRpbHMuZWFjaCh0aGlzLnBvaW50ZXJzLCBmdW5jdGlvbihwb2ludGVyKSB7XG4gICAgICB0b3VjaGxpc3QucHVzaChwb2ludGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hsaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiB1cGRhdGUgdGhlIHBvc2l0aW9uIG9mIGEgcG9pbnRlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRlckV2ZW50XG4gICAqL1xuICB1cGRhdGVQb2ludGVyOiBmdW5jdGlvbiB1cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgcG9pbnRlckV2ZW50KSB7XG4gICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX0VORCB8fCAoZXZlbnRUeXBlICE9IEVWRU5UX0VORCAmJiBwb2ludGVyRXZlbnQuYnV0dG9ucyAhPT0gMSkpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnBvaW50ZXJzW3BvaW50ZXJFdmVudC5wb2ludGVySWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVyRXZlbnQuaWRlbnRpZmllciA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICB0aGlzLnBvaW50ZXJzW3BvaW50ZXJFdmVudC5wb2ludGVySWRdID0gcG9pbnRlckV2ZW50O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogY2hlY2sgaWYgZXYgbWF0Y2hlcyBwb2ludGVydHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRlclR5cGUgbWF0Y2hlcyBgUE9JTlRFUl9NT1VTRXxUT1VDSHxQRU5gXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBldlxuICAgKi9cbiAgbWF0Y2hUeXBlOiBmdW5jdGlvbiBtYXRjaFR5cGUocG9pbnRlclR5cGUsIGV2KSB7XG4gICAgaWYoIWV2LnBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHB0ID0gZXYucG9pbnRlclR5cGUsXG4gICAgICAgIHR5cGVzID0ge307XG5cbiAgICB0eXBlc1tQT0lOVEVSX01PVVNFXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX01PVVNFIHx8IFBPSU5URVJfTU9VU0UpKTtcbiAgICB0eXBlc1tQT0lOVEVSX1RPVUNIXSA9IChwdCA9PT0gKGV2Lk1TUE9JTlRFUl9UWVBFX1RPVUNIIHx8IFBPSU5URVJfVE9VQ0gpKTtcbiAgICB0eXBlc1tQT0lOVEVSX1BFTl0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9QRU4gfHwgUE9JTlRFUl9QRU4pKTtcbiAgICByZXR1cm4gdHlwZXNbcG9pbnRlclR5cGVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXNldCB0aGUgc3RvcmVkIHBvaW50ZXJzXG4gICAqL1xuICByZXNldDogZnVuY3Rpb24gcmVzZXRMaXN0KCkge1xuICAgIHRoaXMucG9pbnRlcnMgPSB7fTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIERldGVjdGlvblxuICogQHN0YXRpY1xuICovXG5EZXRlY3Rpb24gPSBHZXN0dXJlRGV0ZWN0b3IuZGV0ZWN0aW9uID0ge1xuICAvLyBjb250YWlucyBhbGwgcmVnaXN0ZXJlZCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcbiAgZ2VzdHVyZXM6IFtdLFxuXG4gIC8vIGRhdGEgb2YgdGhlIGN1cnJlbnQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uIHNlc3Npb25cbiAgY3VycmVudDogbnVsbCxcblxuICAvLyB0aGUgcHJldmlvdXMgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgc2Vzc2lvbiBkYXRhXG4gIC8vIGlzIGEgZnVsbCBjbG9uZSBvZiB0aGUgcHJldmlvdXMgZ2VzdHVyZS5jdXJyZW50IG9iamVjdFxuICBwcmV2aW91czogbnVsbCxcblxuICAvLyB3aGVuIHRoaXMgYmVjb21lcyB0cnVlLCBubyBnZXN0dXJlcyBhcmUgZmlyZWRcbiAgc3RvcHBlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHN0YXJ0IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvblxuICAgKiBAcGFyYW0ge0dlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX0gaW5zdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAqL1xuICBzdGFydERldGVjdDogZnVuY3Rpb24gc3RhcnREZXRlY3QoaW5zdCwgZXZlbnREYXRhKSB7XG4gICAgLy8gYWxyZWFkeSBidXN5IHdpdGggYSBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb24gb24gYW4gZWxlbWVudFxuICAgIGlmKHRoaXMuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuXG4gICAgLy8gaG9sZHMgY3VycmVudCBzZXNzaW9uXG4gICAgdGhpcy5jdXJyZW50ID0ge1xuICAgICAgaW5zdDogaW5zdCwgLy8gcmVmZXJlbmNlIHRvIEdlc3R1cmVEZXRlY3Rvckluc3RhbmNlIHdlJ3JlIHdvcmtpbmcgZm9yXG4gICAgICBzdGFydEV2ZW50OiBVdGlscy5leHRlbmQoe30sIGV2ZW50RGF0YSksIC8vIHN0YXJ0IGV2ZW50RGF0YSBmb3IgZGlzdGFuY2VzLCB0aW1pbmcgZXRjXG4gICAgICBsYXN0RXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YVxuICAgICAgbGFzdENhbGNFdmVudDogZmFsc2UsIC8vIGxhc3QgZXZlbnREYXRhIGZvciBjYWxjdWxhdGlvbnMuXG4gICAgICBmdXR1cmVDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgbGFzdENhbGNEYXRhOiB7fSwgLy8gbGFzdCBsYXN0Q2FsY0RhdGFcbiAgICAgIG5hbWU6ICcnIC8vIGN1cnJlbnQgZ2VzdHVyZSB3ZSdyZSBpbi9kZXRlY3RlZCwgY2FuIGJlICd0YXAnLCAnaG9sZCcgZXRjXG4gICAgfTtcblxuICAgIHRoaXMuZGV0ZWN0KGV2ZW50RGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnREYXRhXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGRldGVjdDogZnVuY3Rpb24gZGV0ZWN0KGV2ZW50RGF0YSkge1xuICAgIGlmKCF0aGlzLmN1cnJlbnQgfHwgdGhpcy5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIGV2ZW50IGRhdGEgd2l0aCBjYWxjdWxhdGlvbnMgYWJvdXQgc2NhbGUsIGRpc3RhbmNlIGV0Y1xuICAgIGV2ZW50RGF0YSA9IHRoaXMuZXh0ZW5kRXZlbnREYXRhKGV2ZW50RGF0YSk7XG5cbiAgICAvLyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2UgYW5kIGluc3RhbmNlIG9wdGlvbnNcbiAgICB2YXIgaW5zdCA9IHRoaXMuY3VycmVudC5pbnN0LFxuICAgICAgICBpbnN0T3B0aW9ucyA9IGluc3Qub3B0aW9ucztcblxuICAgIC8vIGNhbGwgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgaGFuZGxlcnNcbiAgICBVdGlscy5lYWNoKHRoaXMuZ2VzdHVyZXMsIGZ1bmN0aW9uIHRyaWdnZXJHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICAgIC8vIG9ubHkgd2hlbiB0aGUgaW5zdGFuY2Ugb3B0aW9ucyBoYXZlIGVuYWJsZWQgdGhpcyBnZXN0dXJlXG4gICAgICBpZighdGhpcy5zdG9wcGVkICYmIGluc3QuZW5hYmxlZCAmJiBpbnN0T3B0aW9uc1tnZXN0dXJlLm5hbWVdKSB7XG4gICAgICAgIGdlc3R1cmUuaGFuZGxlci5jYWxsKGdlc3R1cmUsIGV2ZW50RGF0YSwgaW5zdCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLyBzdG9yZSBhcyBwcmV2aW91cyBldmVudCBldmVudFxuICAgIGlmKHRoaXMuY3VycmVudCkge1xuICAgICAgdGhpcy5jdXJyZW50Lmxhc3RFdmVudCA9IGV2ZW50RGF0YTtcbiAgICB9XG5cbiAgICBpZihldmVudERhdGEuZXZlbnRUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgdGhpcy5zdG9wRGV0ZWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50RGF0YTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICB9LFxuXG4gIC8qKlxuICAgKiBjbGVhciB0aGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgdmFyc1xuICAgKiB0aGlzIGlzIGNhbGxlZCBvbiBlbmREZXRlY3QsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIHdoZW4gYSBmaW5hbCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBoYXMgYmVlbiBkZXRlY3RlZFxuICAgKiB0byBzdG9wIG90aGVyIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcyBmcm9tIGJlaW5nIGZpcmVkXG4gICAqL1xuICBzdG9wRGV0ZWN0OiBmdW5jdGlvbiBzdG9wRGV0ZWN0KCkge1xuICAgIC8vIGNsb25lIGN1cnJlbnQgZGF0YSB0byB0aGUgc3RvcmUgYXMgdGhlIHByZXZpb3VzIGdlc3R1cmVcbiAgICAvLyB1c2VkIGZvciB0aGUgZG91YmxlIHRhcCBnZXN0dXJlLCBzaW5jZSB0aGlzIGlzIGFuIG90aGVyIGdlc3R1cmUgZGV0ZWN0IHNlc3Npb25cbiAgICB0aGlzLnByZXZpb3VzID0gVXRpbHMuZXh0ZW5kKHt9LCB0aGlzLmN1cnJlbnQpO1xuXG4gICAgLy8gcmVzZXQgdGhlIGN1cnJlbnRcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB2ZWxvY2l0eSwgYW5nbGUgYW5kIGRpcmVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHBhcmFtIHtPYmplY3R9IGNlbnRlclxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFUaW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhWVxuICAgKi9cbiAgZ2V0Q2FsY3VsYXRlZERhdGE6IGZ1bmN0aW9uIGdldENhbGN1bGF0ZWREYXRhKGV2LCBjZW50ZXIsIGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50LFxuICAgICAgICByZWNhbGMgPSBmYWxzZSxcbiAgICAgICAgY2FsY0V2ID0gY3VyLmxhc3RDYWxjRXZlbnQsXG4gICAgICAgIGNhbGNEYXRhID0gY3VyLmxhc3RDYWxjRGF0YTtcblxuICAgIGlmKGNhbGNFdiAmJiBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wID4gR2VzdHVyZURldGVjdG9yLkNBTENVTEFURV9JTlRFUlZBTCkge1xuICAgICAgY2VudGVyID0gY2FsY0V2LmNlbnRlcjtcbiAgICAgIGRlbHRhVGltZSA9IGV2LnRpbWVTdGFtcCAtIGNhbGNFdi50aW1lU3RhbXA7XG4gICAgICBkZWx0YVggPSBldi5jZW50ZXIuY2xpZW50WCAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WDtcbiAgICAgIGRlbHRhWSA9IGV2LmNlbnRlci5jbGllbnRZIC0gY2FsY0V2LmNlbnRlci5jbGllbnRZO1xuICAgICAgcmVjYWxjID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0ggfHwgZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgIGN1ci5mdXR1cmVDYWxjRXZlbnQgPSBldjtcbiAgICB9XG5cbiAgICBpZighY3VyLmxhc3RDYWxjRXZlbnQgfHwgcmVjYWxjKSB7XG4gICAgICBjYWxjRGF0YS52ZWxvY2l0eSA9IFV0aWxzLmdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgY2FsY0RhdGEuYW5nbGUgPSBVdGlscy5nZXRBbmdsZShjZW50ZXIsIGV2LmNlbnRlcik7XG4gICAgICBjYWxjRGF0YS5kaXJlY3Rpb24gPSBVdGlscy5nZXREaXJlY3Rpb24oY2VudGVyLCBldi5jZW50ZXIpO1xuXG4gICAgICBjdXIubGFzdENhbGNFdmVudCA9IGN1ci5mdXR1cmVDYWxjRXZlbnQgfHwgZXY7XG4gICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgfVxuXG4gICAgZXYudmVsb2NpdHlYID0gY2FsY0RhdGEudmVsb2NpdHkueDtcbiAgICBldi52ZWxvY2l0eVkgPSBjYWxjRGF0YS52ZWxvY2l0eS55O1xuICAgIGV2LmludGVyaW1BbmdsZSA9IGNhbGNEYXRhLmFuZ2xlO1xuICAgIGV2LmludGVyaW1EaXJlY3Rpb24gPSBjYWxjRGF0YS5kaXJlY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIGV4dGVuZCBldmVudERhdGEgZm9yIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgKi9cbiAgZXh0ZW5kRXZlbnREYXRhOiBmdW5jdGlvbiBleHRlbmRFdmVudERhdGEoZXYpIHtcbiAgICB2YXIgY3VyID0gdGhpcy5jdXJyZW50LFxuICAgICAgICBzdGFydEV2ID0gY3VyLnN0YXJ0RXZlbnQsXG4gICAgICAgIGxhc3RFdiA9IGN1ci5sYXN0RXZlbnQgfHwgc3RhcnRFdjtcblxuICAgIC8vIHVwZGF0ZSB0aGUgc3RhcnQgdG91Y2hsaXN0IHRvIGNhbGN1bGF0ZSB0aGUgc2NhbGUvcm90YXRpb25cbiAgICBpZihldi5ldmVudFR5cGUgPT0gRVZFTlRfVE9VQ0ggfHwgZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgIHN0YXJ0RXYudG91Y2hlcyA9IFtdO1xuICAgICAgVXRpbHMuZWFjaChldi50b3VjaGVzLCBmdW5jdGlvbih0b3VjaCkge1xuICAgICAgICBzdGFydEV2LnRvdWNoZXMucHVzaCh7XG4gICAgICAgICAgY2xpZW50WDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZOiB0b3VjaC5jbGllbnRZXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhVGltZSA9IGV2LnRpbWVTdGFtcCAtIHN0YXJ0RXYudGltZVN0YW1wLFxuICAgICAgICBkZWx0YVggPSBldi5jZW50ZXIuY2xpZW50WCAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFgsXG4gICAgICAgIGRlbHRhWSA9IGV2LmNlbnRlci5jbGllbnRZIC0gc3RhcnRFdi5jZW50ZXIuY2xpZW50WTtcblxuICAgIHRoaXMuZ2V0Q2FsY3VsYXRlZERhdGEoZXYsIGxhc3RFdi5jZW50ZXIsIGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuXG4gICAgVXRpbHMuZXh0ZW5kKGV2LCB7XG4gICAgICBzdGFydEV2ZW50OiBzdGFydEV2LFxuXG4gICAgICBkZWx0YVRpbWU6IGRlbHRhVGltZSxcbiAgICAgIGRlbHRhWDogZGVsdGFYLFxuICAgICAgZGVsdGFZOiBkZWx0YVksXG5cbiAgICAgIGRpc3RhbmNlOiBVdGlscy5nZXREaXN0YW5jZShzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIGFuZ2xlOiBVdGlscy5nZXRBbmdsZShzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIGRpcmVjdGlvbjogVXRpbHMuZ2V0RGlyZWN0aW9uKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgc2NhbGU6IFV0aWxzLmdldFNjYWxlKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcyksXG4gICAgICByb3RhdGlvbjogVXRpbHMuZ2V0Um90YXRpb24oc3RhcnRFdi50b3VjaGVzLCBldi50b3VjaGVzKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV2O1xuICB9LFxuXG4gIC8qKlxuICAgKiByZWdpc3RlciBuZXcgZ2VzdHVyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZ2VzdHVyZSBvYmplY3QsIHNlZSBgZ2VzdHVyZXMvYCBmb3IgZG9jdW1lbnRhdGlvblxuICAgKiBAcmV0dXJuIHtBcnJheX0gZ2VzdHVyZXNcbiAgICovXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihnZXN0dXJlKSB7XG4gICAgLy8gYWRkIGFuIGVuYWJsZSBnZXN0dXJlIG9wdGlvbnMgaWYgdGhlcmUgaXMgbm8gZ2l2ZW5cbiAgICB2YXIgb3B0aW9ucyA9IGdlc3R1cmUuZGVmYXVsdHMgfHwge307XG4gICAgaWYob3B0aW9uc1tnZXN0dXJlLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gZXh0ZW5kIEdlc3R1cmVEZXRlY3RvciBkZWZhdWx0IG9wdGlvbnMgd2l0aCB0aGUgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgb3B0aW9uc1xuICAgIFV0aWxzLmV4dGVuZChHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgLy8gc2V0IGl0cyBpbmRleFxuICAgIGdlc3R1cmUuaW5kZXggPSBnZXN0dXJlLmluZGV4IHx8IDEwMDA7XG5cbiAgICAvLyBhZGQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgdG8gdGhlIGxpc3RcbiAgICB0aGlzLmdlc3R1cmVzLnB1c2goZ2VzdHVyZSk7XG5cbiAgICAvLyBzb3J0IHRoZSBsaXN0IGJ5IGluZGV4XG4gICAgdGhpcy5nZXN0dXJlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmKGEuaW5kZXggPCBiLmluZGV4KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmKGEuaW5kZXggPiBiLmluZGV4KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5nZXN0dXJlcztcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKi9cblxuLyoqXG4gKiBjcmVhdGUgbmV3IEdlc3R1cmVEZXRlY3RvciBpbnN0YW5jZVxuICogYWxsIG1ldGhvZHMgc2hvdWxkIHJldHVybiB0aGUgaW5zdGFuY2UgaXRzZWxmLCBzbyBpdCBpcyBjaGFpbmFibGUuXG4gKlxuICogQGNsYXNzIEluc3RhbmNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggYEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0c2BcbiAqIEByZXR1cm4ge0dlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZX1cbiAqL1xuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gc2V0dXAgR2VzdHVyZURldGVjdG9ySlMgd2luZG93IGV2ZW50cyBhbmQgcmVnaXN0ZXIgYWxsIGdlc3R1cmVzXG4gIC8vIHRoaXMgYWxzbyBzZXRzIHVwIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgc2V0dXAoKTtcblxuICAvKipcbiAgICogQHByb3BlcnR5IGVsZW1lbnRcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcblxuICAvKipcbiAgICogQHByb3BlcnR5IGVuYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgLyoqXG4gICAqIG9wdGlvbnMsIG1lcmdlZCB3aXRoIHRoZSBkZWZhdWx0c1xuICAgKiBvcHRpb25zIHdpdGggYW4gXyBhcmUgY29udmVydGVkIHRvIGNhbWVsQ2FzZVxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgVXRpbHMuZWFjaChvcHRpb25zLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgIGRlbGV0ZSBvcHRpb25zW25hbWVdO1xuICAgIG9wdGlvbnNbVXRpbHMudG9DYW1lbENhc2UobmFtZSldID0gdmFsdWU7XG4gIH0pO1xuXG4gIHRoaXMub3B0aW9ucyA9IFV0aWxzLmV4dGVuZChVdGlscy5leHRlbmQoe30sIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cyksIG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIGFkZCBzb21lIGNzcyB0byB0aGUgZWxlbWVudCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gZG9pbmcgaXRzIG5hdGl2ZSBiZWhhdmlvclxuICBpZih0aGlzLm9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogZXZlbnQgc3RhcnQgaGFuZGxlciBvbiB0aGUgZWxlbWVudCB0byBzdGFydCB0aGUgZGV0ZWN0aW9uXG4gICAqIEBwcm9wZXJ0eSBldmVudFN0YXJ0SGFuZGxlclxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5ldmVudFN0YXJ0SGFuZGxlciA9IEV2ZW50Lm9uVG91Y2goZWxlbWVudCwgRVZFTlRfU1RBUlQsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYoc2VsZi5lbmFibGVkICYmIGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgRGV0ZWN0aW9uLnN0YXJ0RGV0ZWN0KHNlbGYsIGV2KTtcbiAgICB9IGVsc2UgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XG4gICAgICBEZXRlY3Rpb24uZGV0ZWN0KGV2KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBrZWVwIGEgbGlzdCBvZiB1c2VyIGV2ZW50IGhhbmRsZXJzIHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWQgd2hlbiBjYWxsaW5nICdkaXNwb3NlJ1xuICAgKiBAcHJvcGVydHkgZXZlbnRIYW5kbGVyc1xuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcbn07XG5cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZS5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAbWV0aG9kIG9uXG4gICAqIEBzaWduYXR1cmUgb24oZ2VzdHVyZXMsIGhhbmRsZXIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUFkZHMgYW4gZXZlbnQgaGFuZGxlciBmb3IgYSBnZXN0dXJlLiBBdmFpbGFibGUgZ2VzdHVyZXMgYXJlOiBkcmFnLCBkcmFnbGVmdCwgZHJhZ3JpZ2h0LCBkcmFndXAsIGRyYWdkb3duLCBob2xkLCByZWxlYXNlLCBzd2lwZSwgc3dpcGVsZWZ0LCBzd2lwZXJpZ2h0LCBzd2lwZXVwLCBzd2lwZWRvd24sIHRhcCwgZG91YmxldGFwLCB0b3VjaCwgdHJhbnNmb3JtLCBwaW5jaCwgcGluY2hpbiwgcGluY2hvdXQgYW5kIHJvdGF0ZS4gWy9lbl1cbiAgICogIFtqYV3jgrjjgqfjgrnjg4Hjg6Pjgavlr77jgZnjgovjgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgpLov73liqDjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjgrjjgqfjgrnjg4Hjg6PlkI3jga/jgIFkcmFnIGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFndXAgZHJhZ2Rvd24gaG9sZCByZWxlYXNlIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duIHRhcCBkb3VibGV0YXAgdG91Y2ggdHJhbnNmb3JtIHBpbmNoIHBpbmNoaW4gcGluY2hvdXQgcm90YXRlIOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlc1xuICAgKiAgIFtlbl1BIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGdlc3R1cmVzLlsvZW5dXG4gICAqICAgW2phXeaknOefpeOBmeOCi+OCuOOCp+OCueODgeODo+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODmuODvOOCueOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOBjOOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogICBbZW5dQW4gZXZlbnQgaGFuZGxpbmcgZnVuY3Rpb24uWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44Go44Gq44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEV2ZW50Lm9uKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHNlbGYuZXZlbnRIYW5kbGVycy5wdXNoKHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBvZmZcbiAgICogQHNpZ25hdHVyZSBvZmYoZ2VzdHVyZXMsIGhhbmRsZXIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5bL2VuXVxuICAgKiAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkuWJiumZpOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlc1xuICAgKiAgIFtlbl1BIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGdlc3R1cmVzLlsvZW5dXG4gICAqICAgW2phXeOCuOOCp+OCueODgeODo+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODmuODvOOCueOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOBjOOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogICBbZW5dQW4gZXZlbnQgaGFuZGxpbmcgZnVuY3Rpb24uWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44Go44Gq44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmRXZlbnQoZ2VzdHVyZXMsIGhhbmRsZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBFdmVudC5vZmYoc2VsZi5lbGVtZW50LCBnZXN0dXJlcywgaGFuZGxlciwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGluZGV4ID0gVXRpbHMuaW5BcnJheShzZWxmLmV2ZW50SGFuZGxlcnMsIHsgZ2VzdHVyZTogdHlwZSwgaGFuZGxlcjogaGFuZGxlciB9LCB0cnVlKTtcbiAgICAgIGlmKGluZGV4ID49IDApIHtcbiAgICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRyaWdnZXIgZ2VzdHVyZSBldmVudFxuICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICogQHNpZ25hdHVyZSB0cmlnZ2VyKGdlc3R1cmUsIGV2ZW50RGF0YSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtldmVudERhdGFdXG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZ2VzdHVyZSwgZXZlbnREYXRhKSB7XG4gICAgLy8gb3B0aW9uYWxcbiAgICBpZighZXZlbnREYXRhKSB7XG4gICAgICBldmVudERhdGEgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgRE9NIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5ULmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudChnZXN0dXJlLCB0cnVlLCB0cnVlKTtcbiAgICBldmVudC5nZXN0dXJlID0gZXZlbnREYXRhO1xuXG4gICAgLy8gdHJpZ2dlciBvbiB0aGUgdGFyZ2V0IGlmIGl0IGlzIGluIHRoZSBpbnN0YW5jZSBlbGVtZW50LFxuICAgIC8vIHRoaXMgaXMgZm9yIGV2ZW50IGRlbGVnYXRpb24gdHJpY2tzXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgaWYoVXRpbHMuaGFzUGFyZW50KGV2ZW50RGF0YS50YXJnZXQsIGVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50ID0gZXZlbnREYXRhLnRhcmdldDtcbiAgICB9XG5cbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGVuYWJsZVxuICAgKiBAc2lnbmF0dXJlIGVuYWJsZShzdGF0ZSlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRW5hYmxlIG9yIGRpc2FibGUgZ2VzdHVyZSBkZXRlY3Rpb24uWy9lbl1cbiAgICogIFtqYV3jgrjjgqfjgrnjg4Hjg6PmpJznn6XjgpLmnInlirnljJYv54Sh5Yq55YyW44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtCb29sZWFufSBzdGF0ZVxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSBlbmFibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3mnInlirnjgavjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc3RhdGUpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBzdGF0ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQG1ldGhvZCBkaXNwb3NlXG4gICAqIEBzaWduYXR1cmUgZGlzcG9zZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVJlbW92ZSBhbmQgZGVzdHJveSBhbGwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoaXMgaW5zdGFuY2UuWy9lbl1cbiAgICogIFtqYV3jgZPjga7jgqTjg7Pjgrnjgr/jg7Pjgrnjgafjga7jgrjjgqfjgrnjg4Hjg6Pjga7mpJznn6XjgoTjgIHjgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgpLlhajjgabop6PpmaTjgZfjgablu4Pmo4TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZGlzcG9zZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICB2YXIgaSwgZWg7XG5cbiAgICAvLyB1bmRvIGFsbCBjaGFuZ2VzIG1hZGUgYnkgc3RvcF9icm93c2VyX2JlaGF2aW9yXG4gICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIGZhbHNlKTtcblxuICAgIC8vIHVuYmluZCBhbGwgY3VzdG9tIGV2ZW50IGhhbmRsZXJzXG4gICAgZm9yKGkgPSAtMTsgKGVoID0gdGhpcy5ldmVudEhhbmRsZXJzWysraV0pOykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICBVdGlscy5vZmYodGhpcy5lbGVtZW50LCBlaC5nZXN0dXJlLCBlaC5oYW5kbGVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcblxuICAgIC8vIHVuYmluZCB0aGUgc3RhcnQgZXZlbnQgbGlzdGVuZXJcbiAgICBFdmVudC5vZmYodGhpcy5lbGVtZW50LCBFVkVOVF9UWVBFU1tFVkVOVF9TVEFSVF0sIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIpO1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIGdlc3R1cmVzXG4gKi9cbi8qKlxuICogTW92ZSB3aXRoIHggZmluZ2VycyAoZGVmYXVsdCAxKSBhcm91bmQgb24gdGhlIHBhZ2UuXG4gKiBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaXMgYSBnb29kIHdheSB0byBpbXByb3ZlIGZlZWwgYW5kIHdvcmtpbmcuXG4gKiBgYGBgXG4gKiAgR2VzdHVyZURldGVjdG9ydGltZS5vbihcImRyYWdcIiwgZnVuY3Rpb24oZXYpIHtcbiAqICAgIGNvbnNvbGUubG9nKGV2KTtcbiAqICAgIGV2Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAqICB9KTtcbiAqIGBgYGBcbiAqXG4gKiBAY2xhc3MgRHJhZ1xuICogQHN0YXRpY1xuICovXG4vKipcbiAqIEBldmVudCBkcmFnXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3N0YXJ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ2VuZFxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYXBsZWZ0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3JpZ2h0XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ3VwXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhZ2Rvd25cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqL1xuKGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGRyYWdHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgdmFyIGN1ciA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgLy8gbWF4IHRvdWNoZXNcbiAgICBpZihpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMgPiAwICYmXG4gICAgICBldi50b3VjaGVzLmxlbmd0aCA+IGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgIGlmKGV2LmRpc3RhbmNlIDwgaW5zdC5vcHRpb25zLmRyYWdNaW5EaXN0YW5jZSAmJlxuICAgICAgICBjdXIubmFtZSAhPSBuYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0Q2VudGVyID0gY3VyLnN0YXJ0RXZlbnQuY2VudGVyO1xuXG4gICAgICAvLyB3ZSBhcmUgZHJhZ2dpbmchXG4gICAgICBpZihjdXIubmFtZSAhPSBuYW1lKSB7XG4gICAgICAgIGN1ci5uYW1lID0gbmFtZTtcbiAgICAgICAgaWYoaW5zdC5vcHRpb25zLmRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gJiYgZXYuZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIGRyYWcgaXMgdHJpZ2dlcmVkLCBzZXQgdGhlIGV2ZW50IGNlbnRlciB0byBkcmFnTWluRGlzdGFuY2UgcGl4ZWxzIGZyb20gdGhlIG9yaWdpbmFsIGV2ZW50IGNlbnRlci5cbiAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgY29ycmVjdGlvbiwgdGhlIGRyYWdnZWQgZGlzdGFuY2Ugd291bGQganVtcHN0YXJ0IGF0IGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgaW5zdGVhZCBvZiBhdCAwLlxuICAgICAgICAgIC8vIEl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBzYXZlIHRoZSBvcmlnaW5hbCBzdGFydCBwb2ludCBzb21ld2hlcmVcbiAgICAgICAgICB2YXIgZmFjdG9yID0gTWF0aC5hYnMoaW5zdC5vcHRpb25zLmRyYWdNaW5EaXN0YW5jZSAvIGV2LmRpc3RhbmNlKTtcbiAgICAgICAgICBzdGFydENlbnRlci5wYWdlWCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIucGFnZVkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLmNsaWVudFggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLmNsaWVudFkgKz0gZXYuZGVsdGFZICogZmFjdG9yO1xuXG4gICAgICAgICAgLy8gcmVjYWxjdWxhdGUgZXZlbnQgZGF0YSB1c2luZyBuZXcgc3RhcnQgcG9pbnRcbiAgICAgICAgICBldiA9IERldGVjdGlvbi5leHRlbmRFdmVudERhdGEoZXYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxvY2sgZHJhZyB0byBheGlzP1xuICAgICAgaWYoY3VyLmxhc3RFdmVudC5kcmFnTG9ja1RvQXhpcyB8fFxuICAgICAgICAoIGluc3Qub3B0aW9ucy5kcmFnTG9ja1RvQXhpcyAmJlxuICAgICAgICAgIGluc3Qub3B0aW9ucy5kcmFnTG9ja01pbkRpc3RhbmNlIDw9IGV2LmRpc3RhbmNlXG4gICAgICAgICkpIHtcbiAgICAgICAgICBldi5kcmFnTG9ja1RvQXhpcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBrZWVwIGRpcmVjdGlvbiBvbiB0aGUgYXhpcyB0aGF0IHRoZSBkcmFnIGdlc3R1cmUgc3RhcnRlZCBvblxuICAgICAgICB2YXIgbGFzdERpcmVjdGlvbiA9IGN1ci5sYXN0RXZlbnQuZGlyZWN0aW9uO1xuICAgICAgICBpZihldi5kcmFnTG9ja1RvQXhpcyAmJiBsYXN0RGlyZWN0aW9uICE9PSBldi5kaXJlY3Rpb24pIHtcbiAgICAgICAgICBpZihVdGlscy5pc1ZlcnRpY2FsKGxhc3REaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFZIDwgMCkgPyBESVJFQ1RJT05fVVAgOiBESVJFQ1RJT05fRE9XTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWCA8IDApID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgaWYoIXRyaWdnZXJlZCkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50c1xuICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpO1xuICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuXG4gICAgICAgIHZhciBpc1ZlcnRpY2FsID0gVXRpbHMuaXNWZXJ0aWNhbChldi5kaXJlY3Rpb24pO1xuXG4gICAgICAgIC8vIGJsb2NrIHRoZSBicm93c2VyIGV2ZW50c1xuICAgICAgICBpZigoaW5zdC5vcHRpb25zLmRyYWdCbG9ja1ZlcnRpY2FsICYmIGlzVmVydGljYWwpIHx8XG4gICAgICAgICAgKGluc3Qub3B0aW9ucy5kcmFnQmxvY2tIb3Jpem9udGFsICYmICFpc1ZlcnRpY2FsKSkge1xuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgaWYodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPD0gaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX0VORDpcbiAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5EcmFnID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiA1MCxcbiAgICAgIGhhbmRsZXI6IGRyYWdHZXN0dXJlLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltYWwgbW92ZW1lbnQgdGhhdCBoYXZlIHRvIGJlIG1hZGUgYmVmb3JlIHRoZSBkcmFnIGV2ZW50IGdldHMgdHJpZ2dlcmVkXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWluRGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMTBcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdNaW5EaXN0YW5jZTogMTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uIHRvIHRydWUgdG8gbWFrZSB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGRyYWdcbiAgICAgICAgICogYmUgY2FsY3VsYXRlZCBmcm9tIHdoZXJlIHRoZSBkcmFnIHdhcyB0cmlnZ2VyZWQsIG5vdCBmcm9tIHdoZXJlIHRoZSB0b3VjaCBzdGFydGVkLlxuICAgICAgICAgKiBVc2VmdWwgdG8gYXZvaWQgYSBqZXJrLXN0YXJ0aW5nIGRyYWcsIHdoaWNoIGNhbiBtYWtlIGZpbmUtYWRqdXN0bWVudHNcbiAgICAgICAgICogdGhyb3VnaCBkcmFnZ2luZyBkaWZmaWN1bHQsIGFuZCBiZSB2aXN1YWxseSB1bmFwcGVhbGluZy5cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb25cbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCAwIGZvciB1bmxpbWl0ZWQsIGJ1dCB0aGlzIGNhbiBjb25mbGljdCB3aXRoIHRyYW5zZm9ybVxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ01heFRvdWNoZXNcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ01heFRvdWNoZXM6IDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXZlbnQgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIHdoZW4gZHJhZ2dpbmcgb2NjdXJzXG4gICAgICAgICAqIGJlIGNhcmVmdWwgd2l0aCBpdCwgaXQgbWFrZXMgdGhlIGVsZW1lbnQgYSBibG9ja2luZyBlbGVtZW50XG4gICAgICAgICAqIHdoZW4geW91IGFyZSB1c2luZyB0aGUgZHJhZyBnZXN0dXJlLCBpdCBpcyBhIGdvb2QgcHJhY3RpY2UgdG8gc2V0IHRoaXMgdHJ1ZVxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Jsb2NrSG9yaXpvbnRhbFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdCbG9ja0hvcml6b250YWw6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzYW1lIGFzIGBkcmFnQmxvY2tIb3Jpem9udGFsYCwgYnV0IGZvciB2ZXJ0aWNhbCBtb3ZlbWVudFxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Jsb2NrVmVydGljYWxcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnQmxvY2tWZXJ0aWNhbDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYWdMb2NrVG9BeGlzIGtlZXBzIHRoZSBkcmFnIGdlc3R1cmUgb24gdGhlIGF4aXMgdGhhdCBpdCBzdGFydGVkIG9uLFxuICAgICAgICAgKiBJdCBkaXNhbGxvd3MgdmVydGljYWwgZGlyZWN0aW9ucyBpZiB0aGUgaW5pdGlhbCBkaXJlY3Rpb24gd2FzIGhvcml6b250YWwsIGFuZCB2aWNlIHZlcnNhLlxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0xvY2tUb0F4aXNcbiAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTG9ja1RvQXhpczogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRyYWcgbG9jayBvbmx5IGtpY2tzIGluIHdoZW4gZGlzdGFuY2UgPiBkcmFnTG9ja01pbkRpc3RhbmNlXG4gICAgICAgICAqIFRoaXMgd2F5LCBsb2NraW5nIG9jY3VycyBvbmx5IHdoZW4gdGhlIGRpc3RhbmNlIGhhcyBiZWNvbWUgbGFyZ2UgZW5vdWdoIHRvIHJlbGlhYmx5IGRldGVybWluZSB0aGUgZGlyZWN0aW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja01pbkRpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDI1XG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTG9ja01pbkRpc3RhbmNlOiAyNVxuICAgICAgfVxuICAgIH07XG4gIH0pKCdkcmFnJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB0cmlnZ2VyIGEgc2ltcGxlIGdlc3R1cmUgZXZlbnQsIHNvIHlvdSBjYW4gZG8gYW55dGhpbmcgaW4geW91ciBoYW5kbGVyLlxuICAgKiBvbmx5IHVzYWJsZSBpZiB5b3Uga25vdyB3aGF0IHlvdXIgZG9pbmcuLi5cbiAgICpcbiAgICogQGNsYXNzIEdlc3R1cmVcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBnZXN0dXJlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkdlc3R1cmUgPSB7XG4gICAgbmFtZTogJ2dlc3R1cmUnLFxuICAgIGluZGV4OiAxMzM3LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogVG91Y2ggc3RheXMgYXQgdGhlIHNhbWUgcGxhY2UgZm9yIHggdGltZVxuICAgKlxuICAgKiBAY2xhc3MgSG9sZFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGhvbGRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdGltZXI7XG5cbiAgICBmdW5jdGlvbiBob2xkR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnMsXG4gICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50O1xuXG4gICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgZ2VzdHVyZSBzbyB3ZSBjYW4gY2hlY2sgaW4gdGhlIHRpbWVvdXQgaWYgaXQgc3RpbGwgaXNcbiAgICAgICAgY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAvLyBzZXQgdGltZXIgYW5kIGlmIGFmdGVyIHRoZSB0aW1lb3V0IGl0IHN0aWxsIGlzIGhvbGQsXG4gICAgICAgIC8vIHdlIHRyaWdnZXIgdGhlIGhvbGQgZXZlbnRcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKGN1cnJlbnQgJiYgY3VycmVudC5uYW1lID09IG5hbWUpIHtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvcHRpb25zLmhvbGRUaW1lb3V0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgaWYoZXYuZGlzdGFuY2UgPiBvcHRpb25zLmhvbGRUaHJlc2hvbGQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Ib2xkID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiAxMCxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRpbWVvdXRcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgNTAwXG4gICAgICAgICAqL1xuICAgICAgICBob2xkVGltZW91dDogNTAwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtb3ZlbWVudCBhbGxvd2VkIHdoaWxlIGhvbGRpbmdcbiAgICAgICAgICogQHByb3BlcnR5IGhvbGRUaHJlc2hvbGRcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMlxuICAgICAgICAgKi9cbiAgICAgICAgaG9sZFRocmVzaG9sZDogMlxuICAgICAgfSxcbiAgICAgIGhhbmRsZXI6IGhvbGRHZXN0dXJlXG4gICAgfTtcbiAgfSkoJ2hvbGQnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHdoZW4gYSB0b3VjaCBpcyBiZWluZyByZWxlYXNlZCBmcm9tIHRoZSBwYWdlXG4gICAqXG4gICAqIEBjbGFzcyBSZWxlYXNlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVsZWFzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5SZWxlYXNlID0ge1xuICAgIG5hbWU6ICdyZWxlYXNlJyxcbiAgICBpbmRleDogSW5maW5pdHksXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB0cmlnZ2VycyBzd2lwZSBldmVudHMgd2hlbiB0aGUgZW5kIHZlbG9jaXR5IGlzIGFib3ZlIHRoZSB0aHJlc2hvbGRcbiAgICogZm9yIGJlc3QgdXNhZ2UsIHNldCBgcHJldmVudERlZmF1bHRgIChvbiB0aGUgZHJhZyBnZXN0dXJlKSB0byBgdHJ1ZWBcbiAgICogYGBgYFxuICAgKiAgR2VzdHVyZURldGVjdG9ydGltZS5vbihcImRyYWdsZWZ0IHN3aXBlbGVmdFwiLCBmdW5jdGlvbihldikge1xuICAgKiAgICBjb25zb2xlLmxvZyhldik7XG4gICAqICAgIGV2Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICogIH0pO1xuICAgKiBgYGBgXG4gICAqXG4gICAqIEBjbGFzcyBTd2lwZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBzd2lwZWxlZnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlcmlnaHRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBldXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlZG93blxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Td2lwZSA9IHtcbiAgICBuYW1lOiAnc3dpcGUnLFxuICAgIGluZGV4OiA0MCxcbiAgICBkZWZhdWx0czoge1xuICAgICAgLyoqXG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVNaW5Ub3VjaGVzXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICovXG4gICAgICBzd2lwZU1pblRvdWNoZXM6IDEsXG5cbiAgICAgIC8qKlxuICAgICAgICogQHByb3BlcnR5IHN3aXBlTWF4VG91Y2hlc1xuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAqL1xuICAgICAgc3dpcGVNYXhUb3VjaGVzOiAxLFxuXG4gICAgICAvKipcbiAgICAgICAqIGhvcml6b250YWwgc3dpcGUgdmVsb2NpdHlcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WFxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDAuNlxuICAgICAgICovXG4gICAgICBzd2lwZVZlbG9jaXR5WDogMC42LFxuXG4gICAgICAvKipcbiAgICAgICAqIHZlcnRpY2FsIHN3aXBlIHZlbG9jaXR5XG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVWZWxvY2l0eVlcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAwLjZcbiAgICAgICAqL1xuICAgICAgc3dpcGVWZWxvY2l0eVk6IDAuNlxuICAgIH0sXG5cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBzd2lwZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICAgIHZhciB0b3VjaGVzID0gZXYudG91Y2hlcy5sZW5ndGgsXG4gICAgICAgICAgICBvcHRpb25zID0gaW5zdC5vcHRpb25zO1xuXG4gICAgICAgIC8vIG1heCB0b3VjaGVzXG4gICAgICAgIGlmKHRvdWNoZXMgPCBvcHRpb25zLnN3aXBlTWluVG91Y2hlcyB8fFxuICAgICAgICAgIHRvdWNoZXMgPiBvcHRpb25zLnN3aXBlTWF4VG91Y2hlcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICBpZihldi52ZWxvY2l0eVggPiBvcHRpb25zLnN3aXBlVmVsb2NpdHlYIHx8XG4gICAgICAgICAgZXYudmVsb2NpdHlZID4gb3B0aW9ucy5zd2lwZVZlbG9jaXR5WSkge1xuICAgICAgICAgIC8vIHRyaWdnZXIgc3dpcGUgZXZlbnRzXG4gICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyBldi5kaXJlY3Rpb24sIGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIFNpbmdsZSB0YXAgYW5kIGEgZG91YmxlIHRhcCBvbiBhIHBsYWNlXG4gICAqXG4gICAqIEBjbGFzcyBUYXBcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0YXBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGRvdWJsZXRhcFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBoYXNNb3ZlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gdGFwR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnMsXG4gICAgICAgICAgY3VycmVudCA9IERldGVjdGlvbi5jdXJyZW50LFxuICAgICAgICAgIHByZXYgPSBEZXRlY3Rpb24ucHJldmlvdXMsXG4gICAgICAgICAgc2luY2VQcmV2LFxuICAgICAgICAgIGRpZERvdWJsZVRhcDtcblxuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgaGFzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgaGFzTW92ZWQgPSBoYXNNb3ZlZCB8fCAoZXYuZGlzdGFuY2UgPiBvcHRpb25zLnRhcE1heERpc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfRU5EOlxuICAgICAgICBpZighVXRpbHMuaW5TdHIoZXYuc3JjRXZlbnQudHlwZSwgJ2NhbmNlbCcpICYmIGV2LmRlbHRhVGltZSA8IG9wdGlvbnMudGFwTWF4VGltZSAmJiAhaGFzTW92ZWQpIHtcbiAgICAgICAgICAvLyBwcmV2aW91cyBnZXN0dXJlLCBmb3IgdGhlIGRvdWJsZSB0YXAgc2luY2UgdGhlc2UgYXJlIHR3byBkaWZmZXJlbnQgZ2VzdHVyZSBkZXRlY3Rpb25zXG4gICAgICAgICAgc2luY2VQcmV2ID0gcHJldiAmJiBwcmV2Lmxhc3RFdmVudCAmJiBldi50aW1lU3RhbXAgLSBwcmV2Lmxhc3RFdmVudC50aW1lU3RhbXA7XG4gICAgICAgICAgZGlkRG91YmxlVGFwID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBjaGVjayBpZiBkb3VibGUgdGFwXG4gICAgICAgICAgaWYocHJldiAmJiBwcmV2Lm5hbWUgPT0gbmFtZSAmJlxuICAgICAgICAgICAgKHNpbmNlUHJldiAmJiBzaW5jZVByZXYgPCBvcHRpb25zLmRvdWJsZVRhcEludGVydmFsKSAmJlxuICAgICAgICAgICAgZXYuZGlzdGFuY2UgPCBvcHRpb25zLmRvdWJsZVRhcERpc3RhbmNlKSB7XG4gICAgICAgICAgICBpbnN0LnRyaWdnZXIoJ2RvdWJsZXRhcCcsIGV2KTtcbiAgICAgICAgICAgIGRpZERvdWJsZVRhcCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZG8gYSBzaW5nbGUgdGFwXG4gICAgICAgICAgaWYoIWRpZERvdWJsZVRhcCB8fCBvcHRpb25zLnRhcEFsd2F5cykge1xuICAgICAgICAgICAgY3VycmVudC5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcihjdXJyZW50Lm5hbWUsIGV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlRhcCA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBpbmRleDogMTAwLFxuICAgICAgaGFuZGxlcjogdGFwR2VzdHVyZSxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggdGltZSBvZiBhIHRhcCwgdGhpcyBpcyBmb3IgdGhlIHNsb3cgdGFwcGVyc1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwTWF4VGltZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyNTBcbiAgICAgICAgICovXG4gICAgICAgIHRhcE1heFRpbWU6IDI1MCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IGRpc3RhbmNlIG9mIG1vdmVtZW50IG9mIGEgdGFwLCB0aGlzIGlzIGZvciB0aGUgc2xvdyB0YXBwZXJzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhEaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgKi9cbiAgICAgICAgdGFwTWF4RGlzdGFuY2U6IDEwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbHdheXMgdHJpZ2dlciB0aGUgYHRhcGAgZXZlbnQsIGV2ZW4gd2hpbGUgZG91YmxlLXRhcHBpbmdcbiAgICAgICAgICogQHByb3BlcnR5IHRhcEFsd2F5c1xuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGFwQWx3YXlzOiB0cnVlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggZGlzdGFuY2UgYmV0d2VlbiB0d28gdGFwc1xuICAgICAgICAgKiBAcHJvcGVydHkgZG91YmxlVGFwRGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjBcbiAgICAgICAgICovXG4gICAgICAgIGRvdWJsZVRhcERpc3RhbmNlOiAyMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWF4IHRpbWUgYmV0d2VlbiB0d28gdGFwc1xuICAgICAgICAgKiBAcHJvcGVydHkgZG91YmxlVGFwSW50ZXJ2YWxcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMzAwXG4gICAgICAgICAqL1xuICAgICAgICBkb3VibGVUYXBJbnRlcnZhbDogMzAwXG4gICAgICB9XG4gICAgfTtcbiAgfSkoJ3RhcCcpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogd2hlbiBhIHRvdWNoIGlzIGJlaW5nIHRvdWNoZWQgYXQgdGhlIHBhZ2VcbiAgICpcbiAgICogQGNsYXNzIFRvdWNoXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdG91Y2hcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVG91Y2ggPSB7XG4gICAgbmFtZTogJ3RvdWNoJyxcbiAgICBpbmRleDogLUluZmluaXR5LFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAvKipcbiAgICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgYXQgdG91Y2hzdGFydCwgYW5kIG1ha2VzIHRoZSBlbGVtZW50IGJsb2NraW5nIGJ5IGRpc2FibGluZyB0aGUgc2Nyb2xsaW5nIG9mIHRoZSBwYWdlLFxuICAgICAgICogYnV0IGl0IGltcHJvdmVzIGdlc3R1cmVzIGxpa2UgdHJhbnNmb3JtaW5nIGFuZCBkcmFnZ2luZy5cbiAgICAgICAqIGJlIGNhcmVmdWwgd2l0aCB1c2luZyB0aGlzLCBpdCBjYW4gYmUgdmVyeSBhbm5veWluZyBmb3IgdXNlcnMgdG8gYmUgc3R1Y2sgb24gdGhlIHBhZ2VcbiAgICAgICAqIEBwcm9wZXJ0eSBwcmV2ZW50RGVmYXVsdFxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBwcmV2ZW50RGVmYXVsdDogZmFsc2UsXG5cbiAgICAgIC8qKlxuICAgICAgICogZGlzYWJsZSBtb3VzZSBldmVudHMsIHNvIG9ubHkgdG91Y2ggKG9yIHBlbiEpIGlucHV0IHRyaWdnZXJzIGV2ZW50c1xuICAgICAgICogQHByb3BlcnR5IHByZXZlbnRNb3VzZVxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICovXG4gICAgICBwcmV2ZW50TW91c2U6IGZhbHNlXG4gICAgfSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiB0b3VjaEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50TW91c2UgJiYgZXYucG9pbnRlclR5cGUgPT0gUE9JTlRFUl9NT1VTRSkge1xuICAgICAgICBldi5zdG9wRGV0ZWN0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYoaW5zdC5vcHRpb25zLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgICBpbnN0LnRyaWdnZXIoJ3RvdWNoJywgZXYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIFVzZXIgd2FudCB0byBzY2FsZSBvciByb3RhdGUgd2l0aCAyIGZpbmdlcnNcbiAgICogUHJldmVudGluZyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGlzIGEgZ29vZCB3YXkgdG8gaW1wcm92ZSBmZWVsIGFuZCB3b3JraW5nLiBUaGlzIGNhbiBiZSBkb25lIHdpdGggdGhlXG4gICAqIGBwcmV2ZW50RGVmYXVsdGAgb3B0aW9uLlxuICAgKlxuICAgKiBAY2xhc3MgVHJhbnNmb3JtXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1zdGFydFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgdHJhbnNmb3JtZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBwaW5jaGluXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCBwaW5jaG91dFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgcm90YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBFVkVOVF9TVEFSVDpcbiAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX01PVkU6XG4gICAgICAgIC8vIGF0IGxlYXN0IG11bHRpdG91Y2hcbiAgICAgICAgaWYoZXYudG91Y2hlcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNjYWxlVGhyZXNob2xkID0gTWF0aC5hYnMoMSAtIGV2LnNjYWxlKTtcbiAgICAgICAgdmFyIHJvdGF0aW9uVGhyZXNob2xkID0gTWF0aC5hYnMoZXYucm90YXRpb24pO1xuXG4gICAgICAgIC8vIHdoZW4gdGhlIGRpc3RhbmNlIHdlIG1vdmVkIGlzIHRvbyBzbWFsbCB3ZSBza2lwIHRoaXMgZ2VzdHVyZVxuICAgICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgICBpZihzY2FsZVRocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5TY2FsZSAmJlxuICAgICAgICAgIHJvdGF0aW9uVGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblJvdGF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UgYXJlIHRyYW5zZm9ybWluZyFcbiAgICAgICAgRGV0ZWN0aW9uLmN1cnJlbnQubmFtZSA9IG5hbWU7XG5cbiAgICAgICAgLy8gZmlyc3QgdGltZSwgdHJpZ2dlciBkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgaWYoIXRyaWdnZXJlZCkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSwgZXYpOyAvLyBiYXNpYyB0cmFuc2Zvcm0gZXZlbnRcblxuICAgICAgICAvLyB0cmlnZ2VyIHJvdGF0ZSBldmVudFxuICAgICAgICBpZihyb3RhdGlvblRocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5Sb3RhdGlvbikge1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncm90YXRlJywgZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJpZ2dlciBwaW5jaCBldmVudFxuICAgICAgICBpZihzY2FsZVRocmVzaG9sZCA+IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1NaW5TY2FsZSkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnLCBldik7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcgKyAoZXYuc2NhbGUgPCAxID8gJ2luJyA6ICdvdXQnKSwgZXYpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEVWRU5UX1JFTEVBU0U6XG4gICAgICAgIGlmKHRyaWdnZXJlZCAmJiBldi5jaGFuZ2VkTGVuZ3RoIDwgMikge1xuICAgICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgJ2VuZCcsIGV2KTtcbiAgICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVHJhbnNmb3JtID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiA0NSxcbiAgICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaW5pbWFsIHNjYWxlIGZhY3Rvciwgbm8gc2NhbGUgaXMgMSwgem9vbWluIGlzIHRvIDAgYW5kIHpvb21vdXQgdW50aWwgaGlnaGVyIHRoZW4gMVxuICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluU2NhbGVcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMC4wMVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNmb3JtTWluU2NhbGU6IDAuMDEsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgICAgICogQHByb3BlcnR5IHRyYW5zZm9ybU1pblJvdGF0aW9uXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRyYW5zZm9ybU1pblJvdGF0aW9uOiAxXG4gICAgICB9LFxuXG4gICAgICBoYW5kbGVyOiB0cmFuc2Zvcm1HZXN0dXJlXG4gICAgfTtcbiAgfSkoJ3RyYW5zZm9ybScpO1xuXG5leHBvcnQgZGVmYXVsdCBHZXN0dXJlRGV0ZWN0b3I7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuY29uc3QgcmVhZHlNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcXVldWVNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBpc0NvbnRlbnRSZWFkeShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcbiAgfVxuICByZXR1cm4gcmVhZHlNYXAuaGFzKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBzZXRDb250ZW50UmVhZHkoZWxlbWVudCkge1xuICByZWFkeU1hcC5zZXQoZWxlbWVudCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENhbGxiYWNrKGVsZW1lbnQsIGZuKSB7XG4gIGlmICghcXVldWVNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgcXVldWVNYXAuc2V0KGVsZW1lbnQsIFtdKTtcbiAgfVxuICBxdWV1ZU1hcC5nZXQoZWxlbWVudCkucHVzaChmbik7XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVRdWV1ZShlbGVtZW50KSB7XG4gIGNvbnN0IGNhbGxiYWNrcyA9IHF1ZXVlTWFwLmdldChlbGVtZW50LCBbXSkgfHwgW107XG4gIHF1ZXVlTWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRlbnRSZWFkeShlbGVtZW50LCBmbiA9ICgpID0+IHt9KSB7XG4gIGFkZENhbGxiYWNrKGVsZW1lbnQsIGZuKTtcblxuICBpZiAoaXNDb250ZW50UmVhZHkoZWxlbWVudCkpIHtcbiAgICBjb25zdW1lUXVldWUoZWxlbWVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjaGFuZ2VzID0+IHtcbiAgICBzZXRDb250ZW50UmVhZHkoZWxlbWVudCk7XG4gICAgY29uc3VtZVF1ZXVlKGVsZW1lbnQpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG5cbiAgLy8gZmFpbGJhY2sgZm9yIGVsZW1lbnRzIGhhcyBlbXB0eSBjb250ZW50LlxuICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcbiAgICBjb25zdW1lUXVldWUoZWxlbWVudCk7XG4gIH0pO1xufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuY2xhc3MgVG9hc3RRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuXG4gIGFkZChmbiwgcHJvbWlzZSkge1xuICAgIHRoaXMucXVldWUucHVzaChmbik7XG5cbiAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNldEltbWVkaWF0ZSh0aGlzLnF1ZXVlWzBdKTtcbiAgICB9XG5cbiAgICBwcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xuXG4gICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5xdWV1ZVswXSwgMTAwMC8zMCk7IC8vIEFwcGx5IHNvbWUgdmlzdWFsIGRlbGF5XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFRvYXN0UXVldWUoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4vY29udGVudC1yZWFkeSc7XG5pbXBvcnQgVG9hc3RRdWV1ZSBmcm9tICcuL2ludGVybmFsL3RvYXN0LXF1ZXVlJztcblxuY29uc3QgX3NldEF0dHJpYnV0ZXMgPSAoZWxlbWVudCwgb3B0aW9ucykgPT4ge1xuICBbJ2lkJywgJ2NsYXNzJywgJ2FuaW1hdGlvbiddXG4gICAgLmZvckVhY2goYSA9PiBvcHRpb25zLmhhc093blByb3BlcnR5KGEpICYmIGVsZW1lbnQuc2V0QXR0cmlidXRlKGEsIG9wdGlvbnNbYV0pKTtcblxuICBpZiAob3B0aW9ucy5tb2RpZmllcikge1xuICAgIHV0aWwuYWRkTW9kaWZpZXIoZWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcik7XG4gIH1cbn07XG5cbi8qKlxuICogQG9iamVjdCBvbnMubm90aWZpY2F0aW9uXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFV0aWxpdHkgbWV0aG9kcyB0byBjcmVhdGUgZGlmZmVyZW50IGtpbmRzIG9mIG5vdGlmaWNhdGlvbnMuIFRoZXJlIGFyZSB0aHJlZSBtZXRob2RzIGF2YWlsYWJsZTpcbiAqXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KClgXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi50b2FzdCgpYFxuICpcbiAqICAgICBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBkaWFsb2cgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44GE44GP44Gk44GL44Gu56iu6aGe44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS5L2c5oiQ44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdIZWxsbywgd29ybGQhJyk7XG4gKlxuICogb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKCdBcmUgeW91IHJlYWR5PycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFuc3dlcikge1xuICogICAgICAgaWYgKGFuc3dlciA9PT0gMSkge1xuICogICAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdMZXRcXCdzIGdvIScpO1xuICogICAgICAgfVxuICogICAgIH1cbiAqICAgKTtcbiAqXG4gKiBvbnMubm90aWZpY2F0aW9uLnByb21wdCgnSG93IG9sZCBhcmUgPycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFnZSkge1xuICogICAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnWW91IGFyZSAnICsgYWdlICsgJyB5ZWFycyBvbGQuJyk7XG4gKiAgICAgfVxuICogICApO1xuICovXG5jb25zdCBub3RpZmljYXRpb24gPSB7fTtcblxubm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyA9IG9wdGlvbnMgPT4ge1xuICAvLyBQcm9tcHQgaW5wdXQgc3RyaW5nXG4gIGxldCBpbnB1dFN0cmluZyA9ICcnO1xuICBpZiAob3B0aW9ucy5pc1Byb21wdCkge1xuICAgIGlucHV0U3RyaW5nID0gYFxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzPVwidGV4dC1pbnB1dCB0ZXh0LWlucHV0LS11bmRlcmJhclwiXG4gICAgICAgIHR5cGU9XCIke29wdGlvbnMuaW5wdXRUeXBlIHx8ICd0ZXh0J31cIlxuICAgICAgICBwbGFjZWhvbGRlcj1cIiR7b3B0aW9ucy5wbGFjZWhvbGRlciB8fCAnJ31cIlxuICAgICAgICB2YWx1ZT1cIiR7b3B0aW9ucy5kZWZhdWx0VmFsdWUgfHwgJyd9XCJcbiAgICAgICAgc3R5bGU9XCJ3aWR0aDogMTAwJTsgbWFyZ2luLXRvcDogMTBweDtcIlxuICAgICAgLz5cbiAgICBgO1xuICB9XG5cbiAgLy8gQnV0dG9ucyBzdHJpbmdcbiAgbGV0IGJ1dHRvbnMgPSAnJztcbiAgb3B0aW9ucy5idXR0b25MYWJlbHMuZm9yRWFjaCgobGFiZWwsIGluZGV4KSA9PiB7XG4gICAgYnV0dG9ucyArPSBgXG4gICAgICA8b25zLWFsZXJ0LWRpYWxvZy1idXR0b25cbiAgICAgICAgY2xhc3M9XCJcbiAgICAgICAgICAke2luZGV4ID09PSBvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleCA/ICcgYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJyA6ICcnfVxuICAgICAgICAgICR7b3B0aW9ucy5idXR0b25MYWJlbHMubGVuZ3RoIDw9IDIgPyAnIGFsZXJ0LWRpYWxvZy1idXR0b24tLXJvd2Zvb3RlcicgOiAnJ31cbiAgICAgICAgXCIgXG4gICAgICAgIHN0eWxlPVwicG9zaXRpb246IHJlbGF0aXZlO1wiPlxuICAgICAgICAke2xhYmVsfVxuICAgICAgPC9vbnMtYWxlcnQtZGlhbG9nLWJ1dHRvbj5cbiAgICBgO1xuICB9KTtcblxuICAvLyBEaWFsb2cgRWxlbWVudFxuICBsZXQgZWwgPSB7fTtcbiAgY29uc3QgX2Rlc3Ryb3lEaWFsb2cgPSAoKSA9PiB7XG4gICAgaWYgKGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCkge1xuICAgICAgZWwuZGlhbG9nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCBlbC5kaWFsb2cub25EaWFsb2dDYW5jZWwpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKGVsKS5mb3JFYWNoKGtleSA9PiBkZWxldGUgZWxba2V5XSk7XG4gICAgZWwgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25zLmRlc3Ryb3koKTtcbiAgICB9XG4gIH07XG5cbiAgZWwuZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLWFsZXJ0LWRpYWxvZycpO1xuICBlbC5kaWFsb2cuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctbWFza1wiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2dcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctdGl0bGVcIj5cbiAgICAgICAgICAke29wdGlvbnMudGl0bGUgfHwgJyd9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRlbnRcIj5cbiAgICAgICAgICAke29wdGlvbnMubWVzc2FnZSB8fCBvcHRpb25zLm1lc3NhZ2VIVE1MfVxuICAgICAgICAgICR7aW5wdXRTdHJpbmd9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiXG4gICAgICAgICAgYWxlcnQtZGlhbG9nLWZvb3RlclxuICAgICAgICAgICR7b3B0aW9ucy5idXR0b25MYWJlbHMubGVuZ3RoIDw9IDIgPyAnIGFsZXJ0LWRpYWxvZy1mb290ZXItLXJvd2Zvb3RlcicgOiAnJ31cbiAgICAgICAgXCI+XG4gICAgICAgICAgJHtidXR0b25zfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xuICBjb250ZW50UmVhZHkoZWwuZGlhbG9nKTtcblxuICAvLyBTZXQgYXR0cmlidXRlc1xuICBfc2V0QXR0cmlidXRlcyhlbC5kaWFsb2csIG9wdGlvbnMpO1xuXG4gIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuXG4gIC8vIFByb21wdCBldmVudHNcbiAgaWYgKG9wdGlvbnMuaXNQcm9tcHQgJiYgb3B0aW9ucy5zdWJtaXRPbkVudGVyKSB7XG4gICAgZWwuaW5wdXQgPSBlbC5kaWFsb2cucXVlcnlTZWxlY3RvcignLnRleHQtaW5wdXQnKTtcbiAgICBlbC5pbnB1dC5vbmtleXByZXNzID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIGVsLmRpYWxvZy5oaWRlKClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZVZhbHVlID0gZWwuaW5wdXQudmFsdWU7XG4gICAgICAgICAgICAgIF9kZXN0cm95RGlhbG9nKCk7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2socmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBCdXR0b24gZXZlbnRzXG4gIGVsLmZvb3RlciA9IGVsLmRpYWxvZy5xdWVyeVNlbGVjdG9yKCcuYWxlcnQtZGlhbG9nLWZvb3RlcicpO1xuICB1dGlsLmFycmF5RnJvbShlbC5kaWFsb2cucXVlcnlTZWxlY3RvckFsbCgnLmFsZXJ0LWRpYWxvZy1idXR0b24nKSkuZm9yRWFjaCgoYnV0dG9uRWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICBidXR0b25FbGVtZW50Lm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgIGVsLmRpYWxvZy5oaWRlKClcbiAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgbGV0IHJlc29sdmVWYWx1ZSA9IGluZGV4O1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pc1Byb21wdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZSA9IGluZGV4ID09PSBvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleCA/IGVsLmlucHV0LnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbC5kaWFsb2cucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIF9kZXN0cm95RGlhbG9nKCk7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2socmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBlbC5mb290ZXIuYXBwZW5kQ2hpbGQoYnV0dG9uRWxlbWVudCk7XG4gIH0pO1xuXG4gIC8vIENhbmNlbCBldmVudHNcbiAgaWYgKG9wdGlvbnMuY2FuY2VsYWJsZSkge1xuICAgIGVsLmRpYWxvZy5jYW5jZWxhYmxlID0gdHJ1ZTtcbiAgICBlbC5kaWFsb2cub25EaWFsb2dDYW5jZWwgPSAoKSA9PiB7XG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICBlbC5kaWFsb2cucmVtb3ZlKCk7XG4gICAgICAgIF9kZXN0cm95RGlhbG9nKCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IG9wdGlvbnMuaXNQcm9tcHQgPyBudWxsIDogLTE7XG4gICAgICBvcHRpb25zLmNhbGxiYWNrKHJlc29sdmVWYWx1ZSk7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgfTtcbiAgICBlbC5kaWFsb2cuYWRkRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCwgZmFsc2UpO1xuICB9XG5cbiAgLy8gU2hvdyBkaWFsb2dcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbC5kaWFsb2cpO1xuICBvcHRpb25zLmNvbXBpbGUoZWwuZGlhbG9nKTtcbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBlbC5kaWFsb2cuc2hvdygpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChlbC5pbnB1dCAmJiBvcHRpb25zLmlzUHJvbXB0ICYmIG9wdGlvbnMuYXV0b2ZvY3VzKSB7XG4gICAgICAgICAgZWwuaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuY29uc3QgX25vcm1hbGl6ZUFyZ3VtZW50cyA9IChtZXNzYWdlLCBvcHRpb25zID0ge30sIGRlZmF1bHRzID0ge30pID0+IHtcbiAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyAob3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZSkgOiAob3B0aW9ucyA9IG1lc3NhZ2UpO1xuICBpZiAoIW9wdGlvbnMubWVzc2FnZSAmJiAhb3B0aW9ucy5tZXNzYWdlSFRNTCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90aWZpY2F0aW9ucyBtdXN0IGNvbnRhaW4gYSBtZXNzYWdlLicpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2J1dHRvbkxhYmVscycpIHx8IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2J1dHRvbkxhYmVsJykpIHtcbiAgICBvcHRpb25zLmJ1dHRvbkxhYmVscyA9IG9wdGlvbnMuYnV0dG9uTGFiZWxzIHx8IG9wdGlvbnMuYnV0dG9uTGFiZWw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYnV0dG9uTGFiZWxzKSkge1xuICAgICAgb3B0aW9ucy5idXR0b25MYWJlbHMgPSBbb3B0aW9ucy5idXR0b25MYWJlbHMgfHwgJyddXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHV0aWwuZXh0ZW5kKHtcbiAgICAgIGNvbXBpbGU6IHBhcmFtID0+IHBhcmFtLFxuICAgICAgY2FsbGJhY2s6IHBhcmFtID0+IHBhcmFtLFxuICAgICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIHByaW1hcnlCdXR0b25JbmRleDogKG9wdGlvbnMuYnV0dG9uTGFiZWxzIHx8IGRlZmF1bHRzLmJ1dHRvbkxhYmVscyB8fCBbXSkubGVuZ3RoIC0gMVxuICAgIH0sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBhbGVydFxuICogQHNpZ25hdHVyZSBhbGVydChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgdG8gdGhlIGluZGV4IG9mIHRoZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZCBvciBgLTFgIHdoZW4gY2FuY2VsZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dTm90aWZpY2F0aW9uIG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VdXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZS5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KL5paH5a2X5YiX44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlIGluIEhUTUwuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi0hUTUzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgXCJPS1wiYC5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJPS1wi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyB0aGUgbGFzdCBvbmUuWy9lbl1cbiAqICAgW2phXeODl+ODqeOCpOODnuODquODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryAwIOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhbmNlbGFibGVdXG4gKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIERlZmF1bHQgaXMgYGZhbHNlYC4gSWYgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgY2xpY2tpbmcgdGhlIGJhY2tncm91bmQgb3IgcHJlc3NpbmcgdGhlIEFuZHJvaWQgYmFjayBidXR0b24uWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgbm9uZWAgYW5kIGBmYWRlYC4gRGVmYXVsdCBpcyBgZmFkZWAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRdXG4gKiAgIFtlbl1UaGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCdzIElELlsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuSUTjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNsYXNzXVxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBjbGFzcy5bL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+imgee0oOOBrmNsYXNz44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aXRsZV1cbiAqICAgW2VuXURpYWxvZyB0aXRsZS4gRGVmYXVsdCBpcyBgXCJBbGVydFwiYC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu5LiK6YOo44Gr6KGo56S644GZ44KL44K/44Kk44OI44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJBbGVydFwi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAqICAgW2VuXU1vZGlmaWVyIGZvciB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgZGlhbG9nIGhhcyBiZWVuIGNsb3NlZC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KJ44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlzcGxheSBhbiBhbGVydCBkaWFsb2cgdG8gc2hvdyB0aGUgdXNlciBhIG1lc3NhZ2UuXG4gKlxuICogICAgIFRoZSBjb250ZW50IG9mIHRoZSBtZXNzYWdlIGNhbiBiZSBlaXRoZXIgc2ltcGxlIHRleHQgb3IgSFRNTC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQobWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuODvOOBuOODoeODg+OCu+ODvOOCuOOCkuimi+OBm+OCi+OBn+OCgeOBruOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOihqOekuuOBmeOCi+ODoeODg+OCu+ODvOOCuOOBr+OAgeODhuOCreOCueODiOOBi+OCguOBl+OBj+OBr0hUTUzjgpLmjIflrprjgafjgY3jgb7jgZnjgIJcbiAqICAgICDjgZPjga7jg6Hjgr3jg4Pjg4njga7lvJXmlbDjgavjga/jgIFvcHRpb25zLm1lc3NhZ2XjgoLjgZfjgY/jga9vcHRpb25zLm1lc3NhZ2VIVE1M44Gu44Gp44Gh44KJ44GL44KS5b+F44Ga5oyH5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi5hbGVydCA9IChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBfbm9ybWFsaXplQXJndW1lbnRzKG1lc3NhZ2UsIG9wdGlvbnMsIHtcbiAgICBidXR0b25MYWJlbHM6IFsnT0snXSxcbiAgICB0aXRsZTogJ0FsZXJ0J1xuICB9KTtcblxuICByZXR1cm4gbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjb25maXJtXG4gKiBAc2lnbmF0dXJlIGNvbmZpcm0obWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbmRleCBvZiB0aGUgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQgb3IgYC0xYCB3aGVuIGNhbmNlbGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgW1wiQ2FuY2VsXCIsIFwiT0tcIl1gLlsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7Pjga7jg6njg5njg6vjga7phY3liJfjgpLmjIflrprjgZfjgb7jgZnjgIJbXCJDYW5jZWxcIiwgXCJPS1wiXeOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgdGhlIGxhc3Qgb25lLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHRvIGFzayB0aGUgdXNlciBmb3IgY29uZmlybWF0aW9uLiBFeHRlbmRzIGBhbGVydCgpYCBwYXJhbWV0ZXJzLlxuICogICAgIFRoZSBkZWZhdWx0IGJ1dHRvbiBsYWJlbHMgYXJlIGBcIkNhbmNlbFwiYCBhbmQgYFwiT0tcImAgYnV0IHRoZXkgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0obWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244Gr56K66KqN44KS5L+D44GZ44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg44OH44Kq44Or44Go44Gu44Oc44K/44Oz44Op44OZ44Or44Gv44CBXCJDYW5jZWxcIuOBqFwiT0tcIuOBp+OBmeOBjOOAgeOBk+OCjOOBr+OBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBp+OCq+OCueOCv+ODnuOCpOOCuuOBp+OBjeOBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLmNvbmZpcm0gPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ0NhbmNlbCcsICdPSyddLFxuICAgIHRpdGxlOiAnQ29uZmlybSdcbiAgfSk7XG5cbiAgcmV0dXJuIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcHJvbXB0XG4gKiBAc2lnbmF0dXJlIHByb21wdChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZS4gVGhpcyBhcmd1bWVudCBpcyBvcHRpb25hbCBidXQgaWYgaXQncyBub3QgZGVmaW5lZCBlaXRoZXIgYG9wdGlvbnMubWVzc2FnZWAgb3IgYG9wdGlvbnMubWVzc2FnZUhUTUxgIG11c3QgYmUgZGVmaW5lZCBpbnN0ZWFkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB0byB0aGUgaW5wdXQgdmFsdWUgd2hlbiB0aGUgZGlhbG9nIGlzIGNsb3NlZCBvciBgbnVsbGAgd2hlbiBjYW5jZWxlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgXCJPS1wiYC5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJPS1wi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyB0aGUgbGFzdCBvbmUuWy9lbl1cbiAqICAgW2phXeODl+ODqeOCpOODnuODquODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryAwIOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGxhY2Vob2xkZXJdXG4gKiAgIFtlbl1QbGFjZWhvbGRlciBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODl+ODrOODvOOCueODm+ODq+ODgOOBq+ihqOekuuOBmeOCi+ODhuOCreOCueODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZGVmYXVsdFZhbHVlXVxuICogICBbZW5dRGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXeODhuOCreOCueODiOashOOBruODh+ODleOCqeODq+ODiOOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaW5wdXRUeXBlXVxuICogICBbZW5dVHlwZSBvZiB0aGUgaW5wdXQgZWxlbWVudCAoYHBhc3N3b3JkYCwgYGRhdGVgLi4uKS4gRGVmYXVsdCBpcyBgdGV4dGAuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9mb2N1c11cbiAqICAgW2VuXUF1dG9mb2N1cyB0aGUgaW5wdXQgZWxlbWVudC4gRGVmYXVsdCBpcyBgdHJ1ZWAuIEluIENvcmRvdmEsIGBLZXlib2FyZERpc3BsYXlSZXF1aXJlc1VzZXJBY3Rpb25gIGluIGBjb25maWcueG1sYCBtdXN0IGJlIGBmYWxzZWAgdG8gYWN0aXZhdGUgdGhpcyBmZWF0dXJlLlsvZW5dXG4gKiAgIFtqYV1pbnB1dOimgee0oOOBq+iHquWLleeahOOBq+ODleOCqeODvOOCq+OCueOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr3RydWXjgafjgZnjgIJDb3Jkb3Zh55Kw5aKD44Gn44Gv44CB44GT44Gu5qmf6IO944KS5pyJ5Yq544Gr44GZ44KL44Gf44KB44Gr44GvIGBjb25maWcueG1sYCDjgacgYEtleWJvYXJkRGlzcGxheVJlcXVpcmVzVXNlckFjdGlvbmAg44KSIGBmYWxzZWAg44Gr6Kit5a6a44GZ44KL5b+F6KaB44GM44GC44KK44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3VibWl0T25FbnRlcl1cbiAqICAgW2VuXVN1Ym1pdCBhdXRvbWF0aWNhbGx5IHdoZW4gZW50ZXIgaXMgcHJlc3NlZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuWy9lbl1cbiAqICAgW2phXUVudGVy44GM5oq844GV44KM44Gf6Zqb44Gr44Gd44GuZm9ybeOCknN1Ym1pdOOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBr3RydWXjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHdpdGggYSBwcm9tcHQgdG8gYXNrIHRoZSB1c2VyIGEgcXVlc3Rpb24uIEV4dGVuZHMgYGFsZXJ0KClgIHBhcmFtZXRlcnMuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnByb21wdChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqXG4gKiAgICAgTXVzdCBzcGVjaWZ5IGVpdGhlciBgbWVzc2FnZWAgb3IgYG1lc3NhZ2VIVE1MYC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOODpuODvOOCtuODvOOBq+WFpeWKm+OCkuS/g+OBmeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLnByb21wdCA9IChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gIG9wdGlvbnMgPSBfbm9ybWFsaXplQXJndW1lbnRzKG1lc3NhZ2UsIG9wdGlvbnMsIHtcbiAgICBidXR0b25MYWJlbHM6IFsnT0snXSxcbiAgICB0aXRsZTogJ0FsZXJ0JyxcbiAgICBpc1Byb21wdDogdHJ1ZSxcbiAgICBhdXRvZm9jdXM6IHRydWUsXG4gICAgc3VibWl0T25FbnRlcjogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB0b2FzdFxuICogQHNpZ25hdHVyZSB0b2FzdChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgd2hlbiB0aGUgdG9hc3QgaXMgaGlkZGVuLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXVRvYXN0IG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgdGhlbiBgb3B0aW9ucy5tZXNzYWdlYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VdXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZS5bL2VuXVxuICogICBbamFd44OI44O844K544OI44Gr6KGo56S644GZ44KL5paH5a2X5YiX44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5idXR0b25MYWJlbF1cbiAqICAgW2VuXUxhYmVsIGZvciB0aGUgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYG5vbmVgLCBgZmFkZWAsIGBhc2NlbmRgLCBgbGlmdGAgYW5kIGBmYWxsYC4gRGVmYXVsdCBpcyBgYXNjZW5kYCBmb3IgQW5kcm9pZCBhbmQgYGxpZnRgIGZvciBpT1MuWy9lbl1cbiAqICAgW2phXeODiOODvOOCueODiOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIiwgXCJhc2NlbmRcIiwgXCJsaWZ0XCIsIFwiZmFsbFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aW1lb3V0XVxuICogICBbZW5dTnVtYmVyIG9mIG1pbGlzZWNvbmRzIHdoZXJlIHRoZSB0b2FzdCBpcyB2aXNpYmxlIGJlZm9yZSBoaWRpbmcgYXV0b21hdGljYWxseS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZm9yY2VdXG4gKiAgIFtlbl1JZiBgdHJ1ZWAsIHRoZSB0b2FzdCBza2lwcyB0aGUgbm90aWZpY2F0aW9uIHF1ZXVlIGFuZCBpcyBzaG93biBpbW1lZGlhdGVseS4gRGVmYXVsdHMgdG8gYGZhbHNlYC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBgPG9ucy10b2FzdD5gIGVsZW1lbnQncyBJRC5bL2VuXVxuICogICBbamFdb25zLXRvYXN06KaB57Sg44GuSUTjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNsYXNzXVxuICogICBbZW5dVGhlIGA8b25zLXRvYXN0PmAgZWxlbWVudCdzIGNsYXNzLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9hc3TopoHntKDjga5jbGFzc+OAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBmb3IgdGhlIGVsZW1lbnQuWy9lbl1cbiAqICAgW2phXeODiOODvOOCueODiOOBrm1vZGlmaWVy5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciB0b2FzdCBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAqICAgW2phXeODiOODvOOCueODiOOBjOmWieOBmOOCieOCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYSBzaW1wbGUgbm90aWZpY2F0aW9uIHRvYXN0IHdpdGggYW4gb3B0aW9uYWwgYnV0dG9uIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHNpbXBsZSBhY3Rpb25zLlxuICpcbiAqICAgICBJdCBjYW4gYmUgY2FsbGVkIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi50b2FzdChtZXNzYWdlLCBvcHRpb25zKTtcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLnRvYXN0KG9wdGlvbnMpO1xuICogICAgIGBgYFxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLnRvYXN0ID0gKG1lc3NhZ2UsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IF9ub3JtYWxpemVBcmd1bWVudHMobWVzc2FnZSwgb3B0aW9ucywge1xuICAgIHRpbWVvdXQ6IDAsXG4gICAgZm9yY2U6IGZhbHNlXG4gIH0pO1xuXG4gIGxldCB0b2FzdCA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgPG9ucy10b2FzdD5cbiAgICAgICR7b3B0aW9ucy5tZXNzYWdlfVxuICAgICAgJHtvcHRpb25zLmJ1dHRvbkxhYmVscyA/IGA8YnV0dG9uPiR7b3B0aW9ucy5idXR0b25MYWJlbHNbMF19PC9idXR0b24+YCA6ICcnfVxuICAgIDwvb25zLXRvYXN0PlxuICBgKTtcblxuICBfc2V0QXR0cmlidXRlcyh0b2FzdCwgb3B0aW9ucyk7XG5cbiAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gIGNvbnN0IHJlc29sdmUgPSB2YWx1ZSA9PiB7XG4gICAgaWYgKHRvYXN0KSB7XG4gICAgICB0b2FzdFxuICAgICAgLmhpZGUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodG9hc3QpIHtcbiAgICAgICAgICB0b2FzdC5yZW1vdmUoKTtcbiAgICAgICAgICB0b2FzdCA9IG51bGw7XG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBpZiAob3B0aW9ucy5idXR0b25MYWJlbHMpIHtcbiAgICB1dGlsLmZpbmRDaGlsZCh0b2FzdC5fdG9hc3QsICdidXR0b24nKS5vbmNsaWNrID0gKCkgPT4gcmVzb2x2ZSgwKTtcbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodG9hc3QpO1xuICBvcHRpb25zLmNvbXBpbGUodG9hc3QpO1xuXG4gIGNvbnN0IHNob3cgPSAoKSA9PiB7XG4gICAgdG9hc3QucGFyZW50RWxlbWVudCAmJiB0b2FzdC5zaG93KG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoLTEpLCBvcHRpb25zLnRpbWVvdXQpXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgb3B0aW9ucy5mb3JjZSA/IHNob3coKSA6IFRvYXN0UXVldWUuYWRkKHNob3csIGRlZmVycmVkLnByb21pc2UpO1xuXG4gIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbm90aWZpY2F0aW9uO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxuLy8gVmFsaWRhdGUgcGFyYW1ldGVyc1xuY29uc3QgY2hlY2tPcHRpb25zID0gb3B0aW9ucyA9PiB7XG4gIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2J1dHRvbnMnKSB8fCAhKG9wdGlvbnMuYnV0dG9ucyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLmJ1dHRvbnNcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEFycmF5LicpXG4gIH1cbiAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdjYWxsYmFjaycpICYmICEob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLmNhbGxiYWNrXCIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbi4nKVxuICB9XG4gIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnY29tcGlsZScpICYmICEob3B0aW9ucy5jb21waWxlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIm9wdGlvbnMuY29tcGlsZVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRnVuY3Rpb24uJylcbiAgfVxuICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2Rlc3Ryb3knKSAmJiAhKG9wdGlvbnMuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJvcHRpb25zLmRlc3Ryb3lcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEZ1bmN0aW9uLicpXG4gIH1cbn07XG5cbi8vIEFjdGlvbiBTaGVldFxuZXhwb3J0IGRlZmF1bHQgKG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjaGVja09wdGlvbnMob3B0aW9ucyk7XG5cbiAgLy8gTWFpbiBjb21wb25lbnRcbiAgbGV0IGFjdGlvblNoZWV0ID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICA8b25zLWFjdGlvbi1zaGVldFxuICAgICAgJHtvcHRpb25zLnRpdGxlID8gYHRpdGxlPVwiJHtvcHRpb25zLnRpdGxlfVwiYCA6ICcnfVxuICAgICAgJHtvcHRpb25zLmNhbmNlbGFibGUgPyAnY2FuY2VsYWJsZScgOiAnJ31cbiAgICAgICR7b3B0aW9ucy5tb2RpZmllciA/IGBtb2RpZmllcj1cIiR7b3B0aW9ucy5tb2RpZmllcn1cImAgOiAnJ31cbiAgICAgICR7b3B0aW9ucy5tYXNrQ29sb3IgPyBgbWFzay1jb2xvcj1cIiR7b3B0aW9ucy5tYXNrQ29sb3J9XCJgIDogJyd9XG4gICAgICAke29wdGlvbnMuaWQgPyBgaWQ9XCIke29wdGlvbnMuaWR9XCJgIDogJyd9XG4gICAgICAke29wdGlvbnMuY2xhc3MgPyBgY2xhc3M9XCIke29wdGlvbnMuY2xhc3N9XCJgIDogJyd9XG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cImFjdGlvbi1zaGVldFwiPjwvZGl2PlxuICAgIDwvb25zLWFjdGlvbi1zaGVldD5cbiAgYCk7XG5cbiAgLy8gUmVzb2x2ZSBhY3Rpb24gYW5kIGNsZWFuIHVwXG4gIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICBjb25zdCByZXNvbHZlciA9IChldmVudCwgaW5kZXggPSAtMSkgPT4ge1xuICAgIGlmIChhY3Rpb25TaGVldCkge1xuICAgICAgb3B0aW9ucy5kZXN0cm95ICYmIG9wdGlvbnMuZGVzdHJveShhY3Rpb25TaGVldCk7XG5cbiAgICAgIGFjdGlvblNoZWV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCByZXNvbHZlciwgZmFsc2UpO1xuICAgICAgYWN0aW9uU2hlZXQucmVtb3ZlKCk7XG4gICAgICBhY3Rpb25TaGVldCA9IG51bGw7XG5cbiAgICAgIG9wdGlvbnMuY2FsbGJhY2sgJiYgb3B0aW9ucy5jYWxsYmFjayhpbmRleCk7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKGluZGV4KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gTGluayBjYW5jZWwgaGFuZGxlclxuICBhY3Rpb25TaGVldC5hZGRFdmVudExpc3RlbmVyKCdkaWFsb2ctY2FuY2VsJywgcmVzb2x2ZXIsIGZhbHNlKTtcblxuICAvLyBDcmVhdGUgYnV0dG9ucyBhbmQgbGluayBhY3Rpb24gaGFuZGxlclxuICBjb25zdCBidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBvcHRpb25zLmJ1dHRvbnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBidXR0b25PcHRpb25zID0gKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykgPyB7IGxhYmVsOiBpdGVtIH0gOiB7IC4uLml0ZW0gfTtcbiAgICBpZiAob3B0aW9ucy5kZXN0cnVjdGl2ZSA9PT0gaW5kZXgpIHtcbiAgICAgIGJ1dHRvbk9wdGlvbnMubW9kaWZpZXIgPSAoYnV0dG9uT3B0aW9ucy5tb2RpZmllciB8fCAnJykgKyAnIGRlc3RydWN0aXZlJztcbiAgICB9XG5cbiAgICBjb25zdCBidXR0b24gPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPG9ucy1hY3Rpb24tc2hlZXQtYnV0dG9uXG4gICAgICAgICR7YnV0dG9uT3B0aW9ucy5pY29uID8gYGljb249XCIke2J1dHRvbk9wdGlvbnMuaWNvbn1cImAgOiAnJ31cbiAgICAgICAgJHtidXR0b25PcHRpb25zLm1vZGlmaWVyID8gYG1vZGlmaWVyPVwiJHtidXR0b25PcHRpb25zLm1vZGlmaWVyfVwiYCA6ICcnfVxuICAgICAgPlxuICAgICAgICAke2J1dHRvbk9wdGlvbnMubGFiZWx9XG4gICAgICA8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICAgIGApO1xuXG4gICAgYnV0dG9uLm9uY2xpY2sgPSBldmVudCA9PiBhY3Rpb25TaGVldC5oaWRlKCkudGhlbigoKSA9PiByZXNvbHZlcihldmVudCwgaW5kZXgpKTtcbiAgICBidXR0b25zLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gIH0pO1xuXG4gIC8vIEZpbmlzaCBjb21wb25lbnQgYW5kIGF0dGFjaFxuICB1dGlsLmZpbmRDaGlsZChhY3Rpb25TaGVldCwgJy5hY3Rpb24tc2hlZXQnKS5hcHBlbmRDaGlsZChidXR0b25zKTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhY3Rpb25TaGVldCk7XG4gIG9wdGlvbnMuY29tcGlsZSAmJiBvcHRpb25zLmNvbXBpbGUoZWwuZGlhbG9nKTtcblxuICAvLyBTaG93XG4gIHNldEltbWVkaWF0ZSgoKSA9PiBhY3Rpb25TaGVldC5zaG93KHtcbiAgICBhbmltYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uLFxuICAgIGFuaW1hdGlvbk9wdGlvbnM6IG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc1xuICB9KSk7XG5cbiAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuIiwiLyoqXG4gKiBNaWNyb0V2ZW50IC0gdG8gbWFrZSBhbnkganMgb2JqZWN0IGFuIGV2ZW50IGVtaXR0ZXIgKHNlcnZlciBvciBicm93c2VyKVxuICpcbiAqIC0gcHVyZSBqYXZhc2NyaXB0IC0gc2VydmVyIGNvbXBhdGlibGUsIGJyb3dzZXIgY29tcGF0aWJsZVxuICogLSBkb250IHJlbHkgb24gdGhlIGJyb3dzZXIgZG9tc1xuICogLSBzdXBlciBzaW1wbGUgLSB5b3UgZ2V0IGl0IGltbWVkaWF0ZWx5LCBubyBteXN0ZXJ5LCBubyBtYWdpYyBpbnZvbHZlZFxuICpcbiAqIC0gY3JlYXRlIGEgTWljcm9FdmVudERlYnVnIHdpdGggZ29vZGllcyB0byBkZWJ1Z1xuICogICAtIG1ha2UgaXQgc2FmZXIgdG8gdXNlXG4qL1xuXG4vKiogTk9URTogVGhpcyBsaWJyYXJ5IGlzIGN1c3RvbWl6ZWQgZm9yIE9uc2VuIFVJLiAqL1xuXG5jb25zdCBNaWNyb0V2ZW50ICA9IGZ1bmN0aW9uKCl7fTtcbk1pY3JvRXZlbnQucHJvdG90eXBlICA9IHtcbiAgb246IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XSB8fCBbXTtcbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdLnB1c2goZmN0KTtcbiAgfSxcbiAgb25jZTogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9mZihldmVudCwgd3JhcHBlcik7XG4gICAgICByZXR1cm4gZmN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB0aGlzLm9uKGV2ZW50LCB3cmFwcGVyKTtcbiAgfSxcbiAgb2ZmOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gICAgaWYgKGV2ZW50IGluIHRoaXMuX2V2ZW50cyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHNbZXZlbnRdID0gdGhpcy5fZXZlbnRzW2V2ZW50XVxuICAgICAgLmZpbHRlcihmdW5jdGlvbihfZmN0KSB7XG4gICAgICAgIGlmIChmY3QpIHtcbiAgICAgICAgICAgcmV0dXJuIGZjdCAhPT0gX2ZjdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9LFxuICBlbWl0OiBmdW5jdGlvbihldmVudCAvKiAsIGFyZ3MuLi4gKi8pe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICBpZiAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRzW2V2ZW50XS5sZW5ndGg7IGkrKyl7XG4gICAgICB0aGlzLl9ldmVudHNbZXZlbnRdW2ldLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBtaXhpbiB3aWxsIGRlbGVnYXRlIGFsbCBNaWNyb0V2ZW50LmpzIGZ1bmN0aW9uIGluIHRoZSBkZXN0aW5hdGlvbiBvYmplY3RcbiAqXG4gKiAtIHJlcXVpcmUoJ01pY3JvRXZlbnQnKS5taXhpbihGb29iYXIpIHdpbGwgbWFrZSBGb29iYXIgYWJsZSB0byB1c2UgTWljcm9FdmVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGUgb2JqZWN0IHdoaWNoIHdpbGwgc3VwcG9ydCBNaWNyb0V2ZW50XG4qL1xuTWljcm9FdmVudC5taXhpbiAgPSBmdW5jdGlvbihkZXN0T2JqZWN0KXtcbiAgdmFyIHByb3BzID0gWydvbicsICdvbmNlJywgJ29mZicsICdlbWl0J107XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKyspe1xuICAgIGlmICh0eXBlb2YgZGVzdE9iamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGVzdE9iamVjdC5wcm90b3R5cGVbcHJvcHNbaV1dICA9IE1pY3JvRXZlbnQucHJvdG90eXBlW3Byb3BzW2ldXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdE9iamVjdFtwcm9wc1tpXV0gPSBNaWNyb0V2ZW50LnByb3RvdHlwZVtwcm9wc1tpXV07XG4gICAgfVxuICB9XG59XG5cbndpbmRvdy5NaWNyb0V2ZW50ID0gTWljcm9FdmVudDtcbmV4cG9ydCBkZWZhdWx0IE1pY3JvRXZlbnQ7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTWljcm9FdmVudCBmcm9tICcuL21pY3JvZXZlbnQnO1xuXG5jb25zdCBjcmVhdGUgPSAoKSA9PiB7XG5cbiAgLyoqXG4gICAqIEBvYmplY3Qgb25zLm9yaWVudGF0aW9uXG4gICAqIEBjYXRlZ29yeSB1dGlsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1VdGlsaXR5IG1ldGhvZHMgZm9yIG9yaWVudGF0aW9uIGRldGVjdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3nlLvpnaLjga7jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PmpJznn6Xjga7jgZ/jgoHjga7jg6bjg7zjg4bjgqPjg6rjg4bjgqPjg6Hjgr3jg4Pjg4njgpLlj47jgoHjgabjgYTjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKi9cbiAgY29uc3Qgb2JqID0ge1xuICAgIC8qKlxuICAgICAqIEBldmVudCBjaGFuZ2VcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBkZXZpY2Ugb3JpZW50YXRpb24gY2hhbmdlcy5bL2VuXVxuICAgICAqICAgW2phXeODh+ODkOOCpOOCueOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjOWkieWMluOBl+OBn+mam+OBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzUG9ydHJhaXRcbiAgICAgKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGN1cnJlbnQgb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgbW9kZS5bL2VuXVxuICAgICAqICAgW2phXeePvuWcqOOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Gu5aC05ZCI44GrdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIG9uXG4gICAgICogQHNpZ25hdHVyZSBvbihldmVudE5hbWUsIGxpc3RlbmVyKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXUFkZCBhbiBldmVudCBsaXN0ZW5lci5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkui/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd44GT44Gu44Kk44OZ44Oz44OI44GM55m654Gr44GV44KM44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb25jZVxuICAgICAqIEBzaWduYXR1cmUgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQncyBvbmx5IHRyaWdnZXJlZCBvbmNlLlsvZW5dXG4gICAgICogIFtqYV3kuIDluqbjgaDjgZHlkbzjgbPlh7rjgZXjgozjgovjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIG9mZlxuICAgICAqIEBzaWduYXR1cmUgb2ZmKGV2ZW50TmFtZSwgW2xpc3RlbmVyXSlcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgW2VuXVJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci4gSWYgdGhlIGxpc3RlbmVyIGlzIG5vdCBzcGVjaWZpZWQgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGV2ZW50IHR5cGUgd2lsbCBiZSByZW1vdmVkLlsvZW5dXG4gICAgICogIFtqYV3jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLliYrpmaTjgZfjgb7jgZnjgILjgoLjgZfjgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgpLmjIflrprjgZfjgarjgYvjgaPjgZ/loLTlkIjjgavjga/jgIHjgZ3jga7jgqTjg5njg7Pjg4jjgavntJDjgaXjgY/lhajjgabjga7jgqTjg5njg7Pjg4jjg6rjgrnjg4rjg7zjgYzliYrpmaTjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBldmVudC5bL2VuXVxuICAgICAqICAgW2phXeOCpOODmeODs+ODiOWQjeOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5bL2VuXVxuICAgICAqICAgW2phXeWJiumZpOOBmeOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG5cbiAgICAvLyBhY3R1YWwgaW1wbGVtZW50YXRpb24gdG8gZGV0ZWN0IGlmIHdoZXRoZXIgY3VycmVudCBzY3JlZW4gaXMgcG9ydHJhaXQgb3Igbm90XG4gICAgX2lzUG9ydHJhaXQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpc1BvcnRyYWl0XG4gICAgICogQHNpZ25hdHVyZSBpc1BvcnRyYWl0KClcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBtb2RlLlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjg6Ljg7zjg4njga7loLTlkIjjgat0cnVl44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG9yIG5vdC5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjHBvcnRyYWl044Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cbiAgICBpc1BvcnRyYWl0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1BvcnRyYWl0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgaXNMYW5kc2NhcGVcbiAgICAgKiBAc2lnbmF0dXJlIGlzTGFuZHNjYXBlKClcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBsYW5kc2NhcGUgbW9kZS5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjGxhbmRzY2FwZeODouODvOODieOBruWgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gb3JpZW50YXRpb24gaXMgbGFuZHNjYXBlIG9yIG5vdC5bL2VuXVxuICAgICAqICAgW2phXeOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+OBjGxhbmRzY2FwZeODouODvOODieOBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAgICovXG4gICAgaXNMYW5kc2NhcGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmlzUG9ydHJhaXQoKTtcbiAgICB9LFxuXG4gICAgX2luaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRE9NQ29udGVudExvYWRlZC5iaW5kKHRoaXMpLCBmYWxzZSk7XG5cbiAgICAgIGlmICgnb3JpZW50YXRpb24nIGluIHdpbmRvdykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9vblJlc2l6ZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9vbkRPTUNvbnRlbnRMb2FkZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5faW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogdGhpcy5pc1BvcnRyYWl0KCl9KTtcbiAgICB9LFxuXG4gICAgX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgaXNQb3J0cmFpdCA9IHdpbmRvdy5pbm5lcldpZHRoIDwgd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICBpZiAoISgnb3JpZW50YXRpb24nIGluIHdpbmRvdykpIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgPiB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93Lm9yaWVudGF0aW9uICUgMTgwID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5hYnMod2luZG93Lm9yaWVudGF0aW9uICUgMTgwKSA9PT0gMCA/IGlzUG9ydHJhaXQgOiAhaXNQb3J0cmFpdDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzUG9ydHJhaXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5hYnMod2luZG93Lm9yaWVudGF0aW9uICUgMTgwKSA9PT0gOTAgPyBpc1BvcnRyYWl0IDogIWlzUG9ydHJhaXQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9vbk9yaWVudGF0aW9uQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGlzUG9ydHJhaXQgPSB0aGlzLl9pc1BvcnRyYWl0KCk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBkaW1lbnNpb25zIHRvIGNoYW5nZSBiZWNhdXNlXG4gICAgICAvLyBvZiBBbmRyb2lkIGluY29uc2lzdGVuY3kuXG4gICAgICBsZXQgbkl0ZXIgPSAwO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIG5JdGVyKys7XG5cbiAgICAgICAgY29uc3QgdyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBjb25zdCBoID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgIGlmICgoaXNQb3J0cmFpdCAmJiB3IDw9IGgpIHx8XG4gICAgICAgICAgICghaXNQb3J0cmFpdCAmJiB3ID49IGgpKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogaXNQb3J0cmFpdH0pO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9IGVsc2UgaWYgKG5JdGVyID09PSA1MCkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IGlzUG9ydHJhaXR9KTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSwgMjApO1xuICAgIH0sXG5cbiAgICAvLyBSdW4gb24gbm90IG1vYmlsZSBicm93c2VyLlxuICAgIF9vblJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiB0aGlzLmlzUG9ydHJhaXQoKX0pO1xuICAgIH1cbiAgfTtcblxuICBNaWNyb0V2ZW50Lm1peGluKG9iaik7XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZSgpLl9pbml0KCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEBvYmplY3Qgb25zLm1vZGlmaWVyXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFV0aWxpdHkgbWV0aG9kcyB0byBjaGFuZ2UgbW9kaWZpZXIgYXR0cmlidXRlcyBvZiBPbnNlbiBVSSBlbGVtZW50cy4uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIG9ucy5tb2RpZmllci5hZGQobXlPbnNJbnB1dEVsZW1lbnQsICd1bmRlcmJhcicpO1xuICogb25zLm1vZGlmaWVyLnRvZ2dsZShteU9uc1RvYXN0RWxlbWVudCwgJ2N1c3RvbS1tb2RpZmllcicpO1xuICpcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAvKipcbiAgICogQG1ldGhvZCBhZGRcbiAgICogQHNpZ25hdHVyZSBhZGQoZWxlbWVudCwgbW9kaWZpZXIgWywgbW9kaWZpZXJdKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQWRkIHRoZSBzcGVjaWZpZWQgbW9kaWZpZXJzIHRvIHRoZSBlbGVtZW50IGlmIHRoZXkgYXJlIG5vdCBhbHJlYWR5IGluY2x1ZGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyXG4gICAqICAgW2VuXU5hbWUgb2YgdGhlIG1vZGlmaWVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBhZGQ6IChlbGVtZW50LCAuLi5tb2RpZmllcnMpID0+IG1vZGlmaWVycy5mb3JFYWNoKG1vZGlmaWVyID0+IHV0aWwuYWRkTW9kaWZpZXIoZWxlbWVudCwgbW9kaWZpZXIpKSxcbiAgLyoqXG4gICAqIEBtZXRob2QgcmVtb3ZlXG4gICAqIEBzaWduYXR1cmUgcmVtb3ZlKGVsZW1lbnQsIG1vZGlmaWVyIFssIG1vZGlmaWVyXSlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJlbW92ZSB0aGUgc3BlY2lmaWVkIG1vZGlmaWVycyBmcm9tIHRoZSBlbGVtZW50IGlmIHRoZXkgYXJlIGluY2x1ZGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyXG4gICAqICAgW2VuXU5hbWUgb2YgdGhlIG1vZGlmaWVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICByZW1vdmU6IChlbGVtZW50LCAuLi5tb2RpZmllcnMpID0+IG1vZGlmaWVycy5mb3JFYWNoKG1vZGlmaWVyID0+IHV0aWwucmVtb3ZlTW9kaWZpZXIoZWxlbWVudCwgbW9kaWZpZXIpKSxcbiAgLyoqXG4gICAqIEBtZXRob2QgY29udGFpbnNcbiAgICogQHNpZ25hdHVyZSBjb250YWlucyhlbGVtZW50LCBtb2RpZmllcilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNoZWNrIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBtb2RpZmllciBpcyBpbmNsdWRlZCBpbiB0aGUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqICAgW2VuXVRhcmdldCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllclxuICAgKiAgIFtlbl1OYW1lIG9mIHRoZSBtb2RpZmllci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiAgIFtlbl1gdHJ1ZWAgd2hlbiB0aGUgc3BlY2lmaWVkIG1vZGlmaWVyIGlzIGZvdW5kIGluIHRoZSBlbGVtZW50J3MgYG1vZGlmaWVyYCBhdHRyaWJ1dGUuIGBmYWxzZWAgb3RoZXJ3aXNlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBjb250YWluczogdXRpbC5oYXNNb2RpZmllcixcbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKGVsZW1lbnQsIG1vZGlmaWVyIFssIGZvcmNlXSlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSB0aGUgc3BlY2lmaWVkIG1vZGlmaWVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyXG4gICAqICAgW2VuXU5hbWUgb2YgdGhlIG1vZGlmaWVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JjZVxuICAgKiAgIFtlbl1JZiBpdCBldmFsdWF0ZXMgdG8gdHJ1ZSwgYWRkIHNwZWNpZmllZCBtb2RpZmllciB2YWx1ZSwgYW5kIGlmIGl0IGV2YWx1YXRlcyB0byBmYWxzZSwgcmVtb3ZlIGl0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICB0b2dnbGU6IHV0aWwudG9nZ2xlTW9kaWZpZXJcbn07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IE1pY3JvRXZlbnQgZnJvbSAnLi9taWNyb2V2ZW50JztcblxuY29uc3Qgc29mdHdhcmVLZXlib2FyZCA9IG5ldyBNaWNyb0V2ZW50KCk7XG5zb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gZmFsc2U7XG5cbmNvbnN0IG9uU2hvdyA9ICgpID0+IHtcbiAgc29mdHdhcmVLZXlib2FyZC5fdmlzaWJsZSA9IHRydWU7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnc2hvdycpO1xufTtcblxuY29uc3Qgb25IaWRlID0gKCkgPT4ge1xuICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gZmFsc2U7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaGlkZScpO1xufTtcblxuY29uc3QgYmluZEV2ZW50cyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiBLZXlib2FyZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWFydGlubW9zZS9jb3Jkb3ZhLWtleWJvYXJkL2Jsb2IvOTVmM2RhM2EzOGQ4ZjhlMWZhNDFmYmY0MDE0NTM1MmMxMzUzNWEwMC9SRUFETUUubWRcbiAgICBLZXlib2FyZC5vbnNob3cgPSBvblNob3c7XG4gICAgS2V5Ym9hcmQub25oaWRlID0gb25IaWRlO1xuICAgIHNvZnR3YXJlS2V5Ym9hcmQuZW1pdCgnaW5pdCcsIHt2aXNpYmxlOiBLZXlib2FyZC5pc1Zpc2libGV9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjb3Jkb3ZhLnBsdWdpbnMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb3Jkb3ZhLnBsdWdpbnMuS2V5Ym9hcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RyaWZ0eWNvL2lvbmljLXBsdWdpbnMta2V5Ym9hcmQvYmxvYi9jYTI3ZWNmL1JFQURNRS5tZFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRzaG93Jywgb25TaG93KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbmF0aXZlLmtleWJvYXJkaGlkZScsIG9uSGlkZSk7XG4gICAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdpbml0Jywge3Zpc2libGU6IGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZC5pc1Zpc2libGV9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3Qgbm9QbHVnaW5FcnJvciA9ICgpID0+IHtcbiAgdXRpbC53YXJuKCdvbnMta2V5Ym9hcmQ6IENvcmRvdmEgS2V5Ym9hcmQgcGx1Z2luIGlzIG5vdCBwcmVzZW50LicpO1xufTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCAoKSA9PiB7XG4gIGlmICghYmluZEV2ZW50cygpKSB7XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tvbnMta2V5Ym9hcmQtYWN0aXZlXScpIHx8XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbb25zLWtleWJvYXJkLWluYWN0aXZlXScpKSB7XG4gICAgICBub1BsdWdpbkVycm9yKCk7XG4gICAgfVxuXG4gICAgc29mdHdhcmVLZXlib2FyZC5vbiA9IG5vUGx1Z2luRXJyb3I7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb2Z0d2FyZUtleWJvYXJkO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuY29uc3QgZ2VuZXJhdGVJZCA9IChmdW5jdGlvbigpIHtcbiAgbGV0IGkgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGkrKztcbiAgfTtcbn0pKCk7XG5cbi8qKlxuICogRG9vciBsb2NraW5nIHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5sb2ddXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvb3JMb2NrIHtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9sb2NrTGlzdCA9IFtdO1xuICAgIHRoaXMuX3dhaXRMaXN0ID0gW107XG4gICAgdGhpcy5fbG9nID0gb3B0aW9ucy5sb2cgfHwgZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGxvY2suXG4gICAqXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBDYWxsYmFjayBmb3IgdW5sb2NraW5nLlxuICAgKi9cbiAgbG9jaygpIHtcbiAgICBjb25zdCB1bmxvY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLl91bmxvY2sodW5sb2NrKTtcbiAgICB9O1xuICAgIHVubG9jay5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICB0aGlzLl9sb2NrTGlzdC5wdXNoKHVubG9jayk7XG4gICAgdGhpcy5fbG9nKCdsb2NrOiAnICsgKHVubG9jay5pZCkpO1xuXG4gICAgcmV0dXJuIHVubG9jaztcbiAgfVxuXG4gIF91bmxvY2soZm4pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2xvY2tMaXN0LmluZGV4T2YoZm4pO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVnaXN0ZXJlZCBpbiB0aGUgbG9jayBsaXN0LicpO1xuICAgIH1cblxuICAgIHRoaXMuX2xvY2tMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5fbG9nKCd1bmxvY2s6ICcgKyBmbi5pZCk7XG5cbiAgICB0aGlzLl90cnlUb0ZyZWVXYWl0TGlzdCgpO1xuICB9XG5cbiAgX3RyeVRvRnJlZVdhaXRMaXN0KCkge1xuICAgIHdoaWxlICghdGhpcy5pc0xvY2tlZCgpICYmIHRoaXMuX3dhaXRMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX3dhaXRMaXN0LnNoaWZ0KCkoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmb3Igd2FpdGluZyB1bmxvY2tlZCBkb29yLlxuICAgKlxuICAgKiBAcGFyYW1zIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgb24gdW5sb2NraW5nIHRoZSBkb29yIGNvbXBsZXRlbHkuXG4gICAqL1xuICB3YWl0VW5sb2NrKGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNhbGxiYWNrIHBhcmFtIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0xvY2tlZCgpKSB7XG4gICAgICB0aGlzLl93YWl0TGlzdC5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzTG9ja2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NrTGlzdC5sZW5ndGggPiAwO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcblxuLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3IgZ2xvYmFsIFBhZ2VMb2FkZXIuXG5mdW5jdGlvbiBsb2FkUGFnZSh7cGFnZSwgcGFyZW50LCBwYXJhbXMgPSB7fX0sIGRvbmUpIHtcbiAgaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyhwYWdlKS50aGVuKGh0bWwgPT4ge1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChwYWdlRWxlbWVudCk7XG5cbiAgICBkb25lKHBhZ2VFbGVtZW50KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVubG9hZFBhZ2UoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5fZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgZWxlbWVudC5fZGVzdHJveSgpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFBhZ2VMb2FkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXSBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGhhcyBcImVsZW1lbnRcIiBwcm9wZXJ0eSBhbmQgXCJ1bmxvYWRcIiBmdW5jdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvYWRlciwgdW5sb2FkZXIpIHtcbiAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGxvYWRlciA6IGxvYWRQYWdlO1xuICAgIHRoaXMuX3VubG9hZGVyID0gdW5sb2FkZXIgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHVubG9hZGVyIDogdW5sb2FkUGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgaW50ZXJuYWwgbG9hZGVyIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgc2V0IGludGVybmFsTG9hZGVyKGZuKSB7XG4gICAgaWYgKCEoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZXIgPSBmbjtcbiAgfVxuXG4gIGdldCBpbnRlcm5hbExvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBvcHRpb25zLnBhZ2VcbiAgICogQHBhcmFtIHtFbGVtZW50fSBvcHRpb25zLnBhcmVudCBBIGxvY2F0aW9uIHRvIGxvYWQgcGFnZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhcmFtc10gRXh0cmEgcGFyYW1ldGVycyBmb3Igb25zLXBhZ2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgVGFrZSBhbiBvYmplY3QgdGhhdCBoYXMgXCJlbGVtZW50XCIgcHJvcGVydHkgYW5kIFwidW5sb2FkXCIgZnVuY3Rpb24uXG4gICAqL1xuICBsb2FkKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICAgIHRoaXMuX2xvYWRlcih7cGFnZSwgcGFyZW50LCBwYXJhbXN9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICBpZiAoIShwYWdlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdwYWdlRWxlbWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIGRvbmUocGFnZUVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgdW5sb2FkKHBhZ2VFbGVtZW50KSB7XG4gICAgaWYgKCEocGFnZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ3BhZ2VFbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl91bmxvYWRlcihwYWdlRWxlbWVudCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYWdlTG9hZGVyID0gbmV3IFBhZ2VMb2FkZXIoKTtcblxuZXhwb3J0IGNvbnN0IGluc3RhbnRQYWdlTG9hZGVyID0gbmV3IFBhZ2VMb2FkZXIoXG4gIGZ1bmN0aW9uKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQocGFnZS50cmltKCkpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICAgIGRvbmUoZWxlbWVudCk7XG4gIH0sXG4gIHVubG9hZFBhZ2Vcbik7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuL2FuaW1pdCdcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcbmltcG9ydCBub3RpZmljYXRpb24gZnJvbSAnLi9ub3RpZmljYXRpb24nO1xuaW1wb3J0IGFjdGlvblNoZWV0IGZyb20gJy4vYWN0aW9uLXNoZWV0JztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuL29yaWVudGF0aW9uJztcbmltcG9ydCBtb2RpZmllciBmcm9tICcuL21vZGlmaWVyJztcbmltcG9ydCBzb2Z0d2FyZUtleWJvYXJkIGZyb20gJy4vc29mdHdhcmUta2V5Ym9hcmQnO1xuaW1wb3J0IHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uIGZyb20gJy4vcGFnZS1hdHRyaWJ1dGUtZXhwcmVzc2lvbic7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4vYXV0b3N0eWxlJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuL2Rvb3Jsb2NrJztcbmltcG9ydCB7IGRlZmF1bHRQYWdlTG9hZGVyLCBQYWdlTG9hZGVyIH0gZnJvbSAnLi9wYWdlLWxvYWRlcic7XG5cbi8qKlxuICogQG9iamVjdCBvbnNcbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXU9uc2VuIFVJ44Gn5Yip55So44Gn44GN44KL44Kw44Ot44O844OQ44Or44Gq44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqICAgW2VuXUEgZ2xvYmFsIG9iamVjdCB0aGF0J3MgdXNlZCBpbiBPbnNlbiBVSS4gWy9lbl1cbiAqL1xuY29uc3Qgb25zID0ge1xuICBhbmltaXQsXG4gIGRlZmF1bHRQYWdlTG9hZGVyLFxuICBlbGVtZW50czoge30sXG4gIEdlc3R1cmVEZXRlY3RvcixcbiAgbW9kaWZpZXIsXG4gIG5vdGlmaWNhdGlvbixcbiAgb3JpZW50YXRpb24sXG4gIHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLFxuICBQYWdlTG9hZGVyLFxuICBwbGF0Zm9ybSxcbiAgc29mdHdhcmVLZXlib2FyZCxcbiAgX2F1dG9TdHlsZTogYXV0b1N0eWxlLFxuICBfaW50ZXJuYWw6IGludGVybmFsLFxuICBfcmVhZHlMb2NrOiBuZXcgRG9vckxvY2soKSxcbiAgX3V0aWw6IHV0aWwsXG59O1xuXG5vbnMucGxhdGZvcm0uc2VsZWN0KCh3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9wbGF0Zm9ybT0oW1xcdy1dKykvKSB8fCBbXSlbMV0pO1xuXG53YWl0RGV2aWNlUmVhZHkoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGlzUmVhZHlcbiAqIEBzaWduYXR1cmUgaXNSZWFkeSgpXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIE9uc2VuIFVJIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gKiAgIFtqYV3liJ3mnJ/ljJbjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXR1cm5zIHRydWUgaWYgT25zZW4gVUkgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXU9uc2VuIFVJ44GM44GZ44Gn44Gr5Yid5pyf5YyW44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GZ44Oh44K944OD44OJ44Gn44GZ44CCWy9qYV1cbiAqL1xub25zLmlzUmVhZHkgPSAoKSA9PiB7XG4gIHJldHVybiAhb25zLl9yZWFkeUxvY2suaXNMb2NrZWQoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBpc1dlYlZpZXdcbiAqIEBzaWduYXR1cmUgaXNXZWJWaWV3KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgdGhlIGFwcCBpcyBydW5uaW5nIGluIENvcmRvdmEuWy9lbl1cbiAqICAgW2phXUNvcmRvdmHjgaflrp/ooYzjgZXjgozjgabjgYTjgovloLTlkIjjgat0cnVl44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmV0dXJucyB0cnVlIGlmIHJ1bm5pbmcgaW5zaWRlIENvcmRvdmEuWy9lbl1cbiAqICAgW2phXUNvcmRvdmHjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZnjg6Hjgr3jg4Pjg4njgafjgZnjgIJbL2phXVxuICovXG5vbnMuaXNXZWJWaWV3ID0gb25zLnBsYXRmb3JtLmlzV2ViVmlldztcblxuLyoqXG4gKiBAbWV0aG9kIHJlYWR5XG4gKiBAc2lnbmF0dXJlIHJlYWR5KGNhbGxiYWNrKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtqYV3jgqLjg5fjg6rjga7liJ3mnJ/ljJbjgavliKnnlKjjgZnjgovjg6Hjgr3jg4Pjg4njgafjgZnjgILmuKHjgZXjgozjgZ/plqLmlbDjga/jgIFPbnNlbiBVSeOBruWIneacn+WMluOBjOe1guS6huOBl+OBpuOBhOOCi+aZgueCueOBp+W/heOBmuWRvOOBsOOCjOOBvuOBmeOAglsvamFdXG4gKiAgIFtlbl1NZXRob2QgdXNlZCB0byB3YWl0IGZvciBhcHAgaW5pdGlhbGl6YXRpb24uIFdhaXRzIGZvciBgRE9NQ29udGVudExvYWRlZGAgYW5kIGBkZXZpY2VyZWFkeWAsIHdoZW4gbmVjZXNzYXJ5LCBiZWZvcmUgZXhlY3V0aW5nIHRoZSBjYWxsYmFjay5bL2VuXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgT25zZW4gVUkgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXU9uc2VuIFVJ44GM5Yid5pyf5YyW44GM5a6M5LqG44GX44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLnJlYWR5ID0gY2FsbGJhY2sgPT4ge1xuICBpZiAob25zLmlzUmVhZHkoKSkge1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gZWxzZSB7XG4gICAgb25zLl9yZWFkeUxvY2sud2FpdFVubG9jayhjYWxsYmFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyXG4gKiBAc2lnbmF0dXJlIHNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXIobGlzdGVuZXIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyB3aGVuIGRldmljZSBiYWNrIGJ1dHRvbiBpcyBwcmVzc2VkLiBNdXN0IGJlIGNhbGxlZCBvbiBgb25zLnJlYWR5YC5bL2VuXVxuICogICBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44GM5oq844GV44KM44Gf5pmC44Gr5a6f6KGM44GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dU2V0IGRlZmF1bHQgaGFuZGxlciBmb3IgZGV2aWNlIGJhY2sgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7Pjga7jgZ/jgoHjga7jg4fjg5Xjgqnjg6vjg4jjga7jg4/jg7Pjg4njg6njgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gIGlmICghb25zLmlzUmVhZHkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyLnNldExpc3RlbmVyKGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXJcbiAqIEBzaWduYXR1cmUgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyKClcbiAqIEBkZXNjcmlwdGlvblxuICogW2VuXURpc2FibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuIE11c3QgYmUgY2FsbGVkIG9uIGBvbnMucmVhZHlgLlsvZW5dXG4gKiBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Kk44OZ44Oz44OI44KS5Y+X44GR5LuY44GR44Gq44GE44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIW9ucy5pc1JlYWR5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGFmdGVyIG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZS4nKTtcbiAgfVxuICBpbnRlcm5hbC5kYmJEaXNwYXRjaGVyLmRpc2FibGUoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlclxuICogQHNpZ25hdHVyZSBlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXG4gKiBAZGVzY3JpcHRpb25cbiAqIFtlbl1FbmFibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuIE11c3QgYmUgY2FsbGVkIG9uIGBvbnMucmVhZHlgLlsvZW5dXG4gKiBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Kk44OZ44Oz44OI44KS5Y+X44GR5LuY44GR44KL44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICghb25zLmlzUmVhZHkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgb25zLmlzUmVhZHkoKSBpcyB0cnVlLicpO1xuICB9XG4gIGludGVybmFsLmRiYkRpc3BhdGNoZXIuZW5hYmxlKCk7XG59O1xuXG5vbnMuZmlyZURldmljZUJhY2tCdXR0b25FdmVudCA9IGZ1bmN0aW9uKCkge1xuICBpbnRlcm5hbC5kYmJEaXNwYXRjaGVyLmZpcmVEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVBdXRvU3RhdHVzQmFyRmlsbFxuICogQHNpZ25hdHVyZSBlbmFibGVBdXRvU3RhdHVzQmFyRmlsbCgpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUVuYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZSAoZXhjZXB0IGZvciBpUGhvbmUgWCkuIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBgb25zLnJlYWR5YC5bL2VuXVxuICogICBbamFdaU9TN+S7peS4iu+8iGlQaG9uZSBY44Gv6Zmk44GP77yJ44Gn44CB44K544OG44O844K/44K544OQ44O86YOo5YiG44Gu6auY44GV44KS6Ieq5YuV55qE44Gr5Z+L44KB44KL5Yem55CG44KS5pyJ5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICBpZiAob25zLmlzUmVhZHkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZS4nKTtcbiAgfVxuICBpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbFxuICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIHN0YXR1cyBiYXIgZmlsbCBmZWF0dXJlIG9uIGlPUzcgYW5kIGFib3ZlIChleGNlcHQgZm9yIGlQaG9uZSBYKS4gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBvbnMucmVhZHlgLlsvZW5dXG4gKiAgIFtqYV1pT1M35Lul5LiK77yIaVBob25lIFjjga/pmaTjgY/vvInjgafjgIHjgrnjg4bjg7zjgr/jgrnjg5Djg7zpg6jliIbjga7pq5jjgZXjgpLoh6rli5XnmoTjgavln4vjgoHjgovlh6bnkIbjgpLnhKHlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICBpZiAob25zLmlzUmVhZHkoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZS4nKTtcbiAgfVxuICBpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBtb2NrU3RhdHVzQmFyXG4gKiBAc2lnbmF0dXJlIG1vY2tTdGF0dXNCYXIoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGVzIGEgc3RhdGljIGVsZW1lbnQgc2ltaWxhciB0byBpT1Mgc3RhdHVzIGJhci4gT25seSB1c2VmdWwgZm9yIGJyb3dzZXIgdGVzdGluZy4gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBvbnMucmVhZHlgLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMubW9ja1N0YXR1c0JhciA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvbnMuaXNSZWFkeSgpIGlzIHRydWUuJyk7XG4gIH1cblxuICBjb25zdCBtb2NrID0gKCkgPT4ge1xuICAgIGlmICghZG9jdW1lbnQuYm9keS5jaGlsZHJlblswXSB8fCAhZG9jdW1lbnQuYm9keS5jaGlsZHJlblswXS5jbGFzc0xpc3QuY29udGFpbnMoJ29ucy1zdGF0dXMtYmFyLW1vY2snKSkge1xuICAgICAgY29uc3QgYW5kcm9pZCA9IHBsYXRmb3JtLmlzQW5kcm9pZCgpLCBpID0gaSA9PiBgPGkgY2xhc3M9XCIke2kuc3BsaXQoJy0nKVswXX0gJHtpfVwiPjwvaT5gO1xuICAgICAgY29uc3QgbGVmdCA9IGFuZHJvaWQgPyBgJHtpKCd6bWRpLXR3aXR0ZXInKX0gJHtpKCd6bWRpLWdvb2dsZS1wbGF5Jyl9YCA6IGBObyBTSU0gJHtpKCdmYS13aWZpJyl9YCxcbiAgICAgICAgY2VudGVyID0gYW5kcm9pZCA/ICcnIDogJzEyOjI4IFBNJyxcbiAgICAgICAgcmlnaHQgPSBhbmRyb2lkID8gYCR7aSgnem1kaS1uZXR3b3JrJyl9ICR7aSgnem1kaS13aWZpJyl9ICR7aSgnem1kaS1iYXR0ZXJ5Jyl9IDEyOjI4IFBNYCA6IGA4MCUgJHtpKCdmYS1iYXR0ZXJ5LXRocmVlLXF1YXJ0ZXJzJyl9YDtcblxuICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRCZWZvcmUodXRpbC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBgPGRpdiBjbGFzcz1cIm9ucy1zdGF0dXMtYmFyLW1vY2sgJHthbmRyb2lkID8gJ2FuZHJvaWQnIDogJ2lvcyd9XCI+YCArXG4gICAgICAgICAgYDxkaXY+JHtsZWZ0fTwvZGl2PjxkaXY+JHtjZW50ZXJ9PC9kaXY+PGRpdj4ke3JpZ2h0fTwvZGl2PmAgK1xuICAgICAgICBgPC9kaXY+YFxuICAgICAgKSwgZG9jdW1lbnQuYm9keS5maXJzdENoaWxkKTtcbiAgICB9XG4gIH07XG5cbiAgZG9jdW1lbnQuYm9keVxuICAgID8gbW9jaygpXG4gICAgOiBpbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZChtb2NrKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQW5pbWF0aW9uc1xuICogQHNpZ25hdHVyZSBkaXNhYmxlQW5pbWF0aW9ucygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXURpc2FibGUgYWxsIGFuaW1hdGlvbnMuIENvdWxkIGJlIGhhbmR5IGZvciB0ZXN0aW5nIGFuZCBvbGRlciBkZXZpY2VzLlsvZW5dXG4gKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLlhajjgabnhKHlirnjgavjgZfjgb7jgZnjgILjg4bjgrnjg4jjga7pmpvjgavkvr/liKnjgafjgZnjgIJbL2phXVxuICovXG5vbnMuZGlzYWJsZUFuaW1hdGlvbnMgPSAoKSA9PiB7XG4gIGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUFuaW1hdGlvbnNcbiAqIEBzaWduYXR1cmUgZW5hYmxlQW5pbWF0aW9ucygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUVuYWJsZSBhbmltYXRpb25zIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFd44Ki44OL44Oh44O844K344On44Oz44KS5pyJ5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZUFuaW1hdGlvbnMgPSAoKSA9PiB7XG4gIGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQgPSBmYWxzZTtcbn07XG5cbm9ucy5fZGlzYWJsZVdhcm5pbmdzID0gKCkgPT4ge1xuICBpbnRlcm5hbC5jb25maWcud2FybmluZ3NEaXNhYmxlZCA9IHRydWU7XG59O1xuXG5vbnMuX2VuYWJsZVdhcm5pbmdzID0gKCkgPT4ge1xuICBpbnRlcm5hbC5jb25maWcud2FybmluZ3NEaXNhYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBdXRvU3R5bGluZ1xuICogQHNpZ25hdHVyZSBkaXNhYmxlQXV0b1N0eWxpbmcoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGF1dG9tYXRpYyBzdHlsaW5nLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZGlzYWJsZUF1dG9TdHlsaW5nID0gYXV0b1N0eWxlLmRpc2FibGU7XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVBdXRvU3R5bGluZ1xuICogQHNpZ25hdHVyZSBlbmFibGVBdXRvU3R5bGluZygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUVuYWJsZSBhdXRvbWF0aWMgc3R5bGluZyBiYXNlZCBvbiBPUyAoZGVmYXVsdCkuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5lbmFibGVBdXRvU3R5bGluZyA9IGF1dG9TdHlsZS5lbmFibGU7XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlSWNvbkF1dG9QcmVmaXhcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUljb25BdXRvUHJlZml4KClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBhZGRpbmcgYGZhLWAgcHJlZml4IGF1dG9tYXRpY2FsbHkgdG8gYG9ucy1pY29uYCBjbGFzc2VzLiBVc2VmdWwgd2hlbiBpbmNsdWRpbmcgY3VzdG9tIGljb24gcGFja3MuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5kaXNhYmxlSWNvbkF1dG9QcmVmaXggPSAoKSA9PiB7XG4gIGlmICghb25zLmVsZW1lbnRzLkljb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IgKGBFeHBlY3RlZCAnb25zLWljb24nIEN1c3RvbSBFbGVtZW50IHRvIGJlIHJlZ2lzdGVyZWQgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QuYCk7XG4gIH1cbiAgb25zLmVsZW1lbnRzLkljb24uc2V0QXV0b1ByZWZpeChmYWxzZSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZm9yY2VQbGF0Zm9ybVN0eWxpbmdcbiAqIEBzaWduYXR1cmUgZm9yY2VQbGF0Zm9ybVN0eWxpbmcocGxhdGZvcm0pXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlZnJlc2ggc3R5bGluZyBmb3IgdGhlIGdpdmVuIHBsYXRmb3JtLiBPbmx5IHVzZWZ1bCBmb3IgZGVtb3MuIFVzZSBgb25zLnBsYXRmb3JtLnNlbGVjdCguLi4pYCBpbnN0ZWFkIGZvciBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBwbGF0Zm9ybSBOZXcgcGxhdGZvcm0gdG8gc3R5bGUgdGhlIGVsZW1lbnRzLlxuICovXG5vbnMuZm9yY2VQbGF0Zm9ybVN0eWxpbmcgPSBuZXdQbGF0Zm9ybSA9PiB7XG4gIG9ucy5lbmFibGVBdXRvU3R5bGluZygpO1xuICBvbnMucGxhdGZvcm0uc2VsZWN0KG5ld1BsYXRmb3JtIHx8ICdpb3MnKTtcblxuICBvbnMuX3V0aWwuYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtaWYnKSB7XG4gICAgICAgIGVsZW1lbnQuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQudGFnTmFtZS5tYXRjaCgvXm9ucy0vaSkpIHtcbiAgICAgICAgYXV0b1N0eWxlLnByZXBhcmUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy10YWJiYXInKSB7XG4gICAgICAgICAgZWxlbWVudC5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHByZWxvYWRcbiAqIEBzaWduYXR1cmUgcHJlbG9hZCh0ZW1wbGF0ZVBhdGhzKVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRlbXBsYXRlUGF0aHNcbiAqICAgW2VuXVNldCBvZiBIVE1MIGZpbGUgcGF0aHMgY29udGFpbmluZyAnb25zLXBhZ2UnIGVsZW1lbnRzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCB0aGUgdGVtcGxhdGVzIGFyZSBjYWNoZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNlcGFyYXRlZCBmaWxlcyBuZWVkIHRvIGJlIHJlcXVlc3RlZCBvbiBkZW1hbmQgYW5kIHRoaXMgY2FuIHNsaWdodGx5IGRlbGF5IHB1c2hpbmcgbmV3IHBhZ2VzLiBUaGlzIG1ldGhvZCByZXF1ZXN0cyBhbmQgY2FjaGVzIHRlbXBsYXRlcyBmb3IgbGF0ZXIgdXNlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMucHJlbG9hZCA9IGZ1bmN0aW9uKHRlbXBsYXRlcyA9IFtdKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbCgodGVtcGxhdGVzIGluc3RhbmNlb2YgQXJyYXkgPyB0ZW1wbGF0ZXMgOiBbdGVtcGxhdGVzXSkubWFwKHRlbXBsYXRlID0+IHtcbiAgICBpZiAodHlwZW9mIHRlbXBsYXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yICgnRXhwZWN0ZWQgc3RyaW5nIGFyZ3VtZW50cyBidXQgZ290ICcgKyB0eXBlb2YgdGVtcGxhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZXJuYWwuZ2V0VGVtcGxhdGVIVE1MQXN5bmModGVtcGxhdGUpO1xuICB9KSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlRWxlbWVudFxuICogQHNpZ25hdHVyZSBjcmVhdGVFbGVtZW50KHRlbXBsYXRlLCBvcHRpb25zKVxuICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gKiAgIFtlbl1FaXRoZXIgYW4gSFRNTCBmaWxlIHBhdGgsIGFuIGA8b25zLXRlbXBsYXRlPmAgaWQgb3IgYW4gSFRNTCBzdHJpbmcgc3VjaCBhcyBgJzxkaXYgaWQ9XCJmb29cIj5ob2dlPC9kaXY+J2AuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufEhUTUxFbGVtZW50fSBbb3B0aW9ucy5hcHBlbmRdXG4gKiAgIFtlbl1XaGV0aGVyIG9yIG5vdCB0aGUgZWxlbWVudCBzaG91bGQgYmUgYXV0b21hdGljYWxseSBhcHBlbmRlZCB0byB0aGUgRE9NLiAgRGVmYXVsdHMgdG8gYGZhbHNlYC4gSWYgYHRydWVgIHZhbHVlIGlzIGdpdmVuLCBgZG9jdW1lbnQuYm9keWAgd2lsbCBiZSB1c2VkIGFzIHRoZSB0YXJnZXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0aW9ucy5pbnNlcnRCZWZvcmVdXG4gKiAgIFtlbl1SZWZlcmVuY2Ugbm9kZSB0aGF0IGJlY29tZXMgdGhlIG5leHQgc2libGluZyBvZiB0aGUgbmV3IG5vZGUgKGBvcHRpb25zLmFwcGVuZGAgZWxlbWVudCkuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxQcm9taXNlfVxuICogICBbZW5dSWYgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIHdhcyBhbiBpbmxpbmUgSFRNTCBzdHJpbmcsIGl0IHJldHVybnMgdGhlIG5ldyBlbGVtZW50LiBPdGhlcndpc2UsIGl0IHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5ldyBlbGVtZW50LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBuZXcgZWxlbWVudCBmcm9tIGEgdGVtcGxhdGUuIEJvdGggaW5saW5lIEhUTUwgYW5kIGV4dGVybmFsIGZpbGVzIGFyZSBzdXBwb3J0ZWQgYWx0aG91Z2ggdGhlIHJldHVybiB2YWx1ZSBkaWZmZXJzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuY3JlYXRlRWxlbWVudCA9ICh0ZW1wbGF0ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHRlbXBsYXRlID0gdGVtcGxhdGUudHJpbSgpO1xuXG4gIGNvbnN0IGNyZWF0ZSA9IGh0bWwgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBvbnMuX3V0aWwuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICBlbGVtZW50LnJlbW92ZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMuYXBwZW5kKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLmFwcGVuZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gb3B0aW9ucy5hcHBlbmQgOiBkb2N1bWVudC5ib2R5O1xuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShlbGVtZW50LCBvcHRpb25zLmluc2VydEJlZm9yZSB8fCBudWxsKTtcbiAgICAgIG9wdGlvbnMubGluayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMubGluayhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfTtcblxuICByZXR1cm4gdGVtcGxhdGUuY2hhckF0KDApID09PSAnPCcgPyBjcmVhdGUodGVtcGxhdGUpIDogaW50ZXJuYWwuZ2V0UGFnZUhUTUxBc3luYyh0ZW1wbGF0ZSkudGhlbihjcmVhdGUpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZVBvcG92ZXJcbiAqIEBzaWduYXR1cmUgY3JlYXRlUG9wb3ZlcihwYWdlLCBbb3B0aW9uc10pXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyZW50U2NvcGVdXG4gKiAgIFtlbl1QYXJlbnQgc2NvcGUgb2YgdGhlIGRpYWxvZy4gVXNlZCB0byBiaW5kIG1vZGVscyBhbmQgYWNjZXNzIHNjb3BlIG1ldGhvZHMgZnJvbSB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDlhoXjgafliKnnlKjjgZnjgovopqrjgrnjgrPjg7zjg5fjgpLmjIflrprjgZfjgb7jgZnjgILjg4DjgqTjgqLjg63jgrDjgYvjgonjg6Ljg4fjg6vjgoTjgrnjgrPjg7zjg5fjga7jg6Hjgr3jg4Pjg4njgavjgqLjgq/jgrvjgrnjgZnjgovjga7jgavkvb/jgYTjgb7jgZnjgILjgZPjga7jg5Hjg6njg6Hjg7zjgr/jga9Bbmd1bGFySlPjg5DjgqTjg7Pjg4fjgqPjg7PjgrDjgafjga7jgb/liKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBvcG92ZXIgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIHBvcG92ZXIgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlRGlhbG9nXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZURpYWxvZyhwYWdlLCBbb3B0aW9uc10pXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiA8b25zLXRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr29ucy10ZW1wbGF0ZeOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgZGlhbG9nIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBkaWFsb2cgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg4DjgqTjgqLjg63jgrDjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlQWxlcnREaWFsb2dcbiAqIEBzaWduYXR1cmUgY3JlYXRlQWxlcnREaWFsb2cocGFnZSwgW29wdGlvbnNdKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYW4gPG9ucy10ZW1wbGF0ZT4gY29udGFpbmluZyBhIDxvbnMtYWxlcnQtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGFsZXJ0IGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgYWxlcnQgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmNyZWF0ZVBvcG92ZXIgPSBvbnMuY3JlYXRlRGlhbG9nID0gb25zLmNyZWF0ZUFsZXJ0RGlhbG9nID0gKHRlbXBsYXRlLCBvcHRpb25zID0ge30pID0+IG9ucy5jcmVhdGVFbGVtZW50KHRlbXBsYXRlLCB7IGFwcGVuZDogdHJ1ZSwgLi4ub3B0aW9ucyB9KTtcblxuLyoqXG4gKiBAbWV0aG9kIG9wZW5BY3Rpb25TaGVldFxuICogQHNpZ25hdHVyZSBvcGVuQWN0aW9uU2hlZXQob3B0aW9ucylcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dU2hvd3MgYW4gaW5zdGFudCBBY3Rpb24gU2hlZXQgYW5kIGxldHMgdGhlIHVzZXIgY2hvb3NlIGFuIGFjdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5idXR0b25zXVxuICogICBbZW5dUmVwcmVzZW50IGVhY2ggYnV0dG9uIG9mIHRoZSBhY3Rpb24gc2hlZXQgZm9sbG93aW5nIHRoZSBzcGVjaWZpZWQgb3JkZXIuIEV2ZXJ5IGl0ZW0gY2FuIGJlIGVpdGhlciBhIHN0cmluZyBsYWJlbCBvciBhbiBvYmplY3QgY29udGFpbmluZyBgbGFiZWxgLCBgaWNvbmAgYW5kIGBtb2RpZmllcmAgcHJvcGVydGllcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aXRsZV1cbiAqICAgW2VuXU9wdGlvbmFsIHRpdGxlIGZvciB0aGUgYWN0aW9uIHNoZWV0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlc3RydWN0aXZlXVxuICogICBbZW5dT3B0aW9uYWwgaW5kZXggb2YgdGhlIFwiZGVzdHJ1Y3RpdmVcIiBidXR0b24gKG9ubHkgZm9yIGlPUykuIEl0IGNhbiBiZSBzcGVjaWZpZWQgaW4gdGhlIGJ1dHRvbiBhcnJheSBhcyB3ZWxsLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jYW5jZWxhYmxlXVxuICogICBbZW5dV2hldGhlciB0aGUgYWN0aW9uIHNoZWV0IGNhbiBiZSBjYW5jZWxlZCBieSB0YXBwaW5nIG9uIHRoZSBiYWNrZ3JvdW5kIG1hc2sgb3Igbm90LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxuICogICBbZW5dTW9kaWZpZXIgYXR0cmlidXRlIG9mIHRoZSBhY3Rpb24gc2hlZXQuIEUuZy4gYCdkZXN0cnVjdGl2ZSdgLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1hc2tDb2xvcl1cbiAqICAgW2VuXU9wdGlvbmFsbHkgY2hhbmdlIHRoZSBiYWNrZ3JvdW5kIG1hc2sgY29sb3IuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRdXG4gKiAgIFtlbl1UaGUgZWxlbWVudCdzIGlkIGF0dHJpYnV0ZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jbGFzc11cbiAqICAgW2VuXVRoZSBlbGVtZW50J3MgY2xhc3MgYXR0cmlidXRlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBhY3Rpb24gc2hlZXQgaXMgY2xvc2VkLiBUaGUgcmVzb2x2ZSB2YWx1ZSBpcyBlaXRoZXIgdGhlIGluZGV4IG9mIHRoZSB0YXBwZWQgYnV0dG9uIG9yIC0xIHdoZW4gY2FuY2VsZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5vcGVuQWN0aW9uU2hlZXQgPSBhY3Rpb25TaGVldDtcblxuLyoqXG4gKiBAbWV0aG9kIHJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXJcbiAqIEBzaWduYXR1cmUgcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihwYWdlKVxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqICAgW2VuXVBhZ2UgbmFtZS4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGZpbGUgb3IgYSBgPHRlbXBsYXRlPmAgaWQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9vbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUlmIG5vIHBhZ2UgaXMgZGVmaW5lZCBmb3IgdGhlIGBvbnMtbG9hZGluZy1wbGFjZWhvbGRlcmAgYXR0cmlidXRlIGl0IHdpbGwgd2FpdCBmb3IgdGhpcyBtZXRob2QgYmVpbmcgY2FsbGVkIGJlZm9yZSBsb2FkaW5nIHRoZSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1vbnMtbG9hZGluZy1wbGFjZWhvbGRlcuOBruWxnuaAp+WApOOBqOOBl+OBpuODmuODvOOCuOOBjOaMh+WumuOBleOCjOOBpuOBhOOBquOBhOWgtOWQiOOBr+OAgeODmuODvOOCuOODreODvOODieWJjeOBq+WRvOOBsOOCjOOCi29ucy5yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVy5Yem55CG44GM6KGM44KP44KM44KL44G+44Gn6KGo56S644GV44KM44G+44Gb44KT44CCWy9qYV1cbiAqL1xub25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIgPSAocGFnZSwgbGluaykgPT4ge1xuICBjb25zdCBlbGVtZW50cyA9IG9ucy5fdXRpbC5hcnJheUZyb20od2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtbG9hZGluZy1wbGFjZWhvbGRlcl0nKSk7XG4gIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyIGV4aXN0cy4nKTtcbiAgfVxuXG4gIGVsZW1lbnRzXG4gICAgLmZpbHRlcihlbGVtZW50ID0+ICFlbGVtZW50LmdldEF0dHJpYnV0ZSgncGFnZScpKVxuICAgIC5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyJywgcGFnZSk7XG4gICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSwgbGluayk7XG4gICAgfSk7XG59O1xuXG5cbm9ucy5fc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzID0gZnVuY3Rpb24oKSB7XG4gIG9ucy5yZWFkeSgoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBvbnMuX3V0aWwuYXJyYXlGcm9tKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbb25zLWxvYWRpbmctcGxhY2Vob2xkZXJdJykpO1xuXG4gICAgZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHBhZ2UgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnb25zLWxvYWRpbmctcGxhY2Vob2xkZXInKTtcbiAgICAgIGlmICh0eXBlb2YgcGFnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyKGVsZW1lbnQsIHBhZ2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbm9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciA9IGZ1bmN0aW9uKHBhcmVudCwgcGFnZSwgbGluayA9ICgoZWwsIGRvbmUpID0+IGRvbmUoKSkpIHtcbiAgcGFnZSAmJiBvbnMuY3JlYXRlRWxlbWVudChwYWdlKVxuICAgIC50aGVuKGVsZW1lbnQgPT4ge1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgbGluayhlbGVtZW50LCAoKSA9PiB7XG4gICAgICAgIHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCAmJiBwYXJlbnQuZmlyc3RDaGlsZCAhPT0gZWxlbWVudCkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICB9KTtcbiAgICB9KVxuICAgIC5jYXRjaChlcnJvciA9PiBQcm9taXNlLnJlamVjdCgnVW5hYmxlZCB0byByZXNvbHZlIHBsYWNlaG9sZGVyOiAnICsgZXJyb3IpKTtcbn07XG5cbmZ1bmN0aW9uIHdhaXREZXZpY2VSZWFkeSgpIHtcbiAgY29uc3QgdW5sb2NrRGV2aWNlUmVhZHkgPSBvbnMuX3JlYWR5TG9jay5sb2NrKCk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgIGlmIChvbnMuaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIHVubG9ja0RldmljZVJlYWR5LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVubG9ja0RldmljZVJlYWR5KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG59XG5cbi8qKlxuICogQG1ldGhvZCBnZXRTY3JpcHRQYWdlXG4gKiBAc2lnbmF0dXJlIGdldFNjcmlwdFBhZ2UoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1BY2Nlc3MgdGhlIGxhc3QgY3JlYXRlZCBwYWdlIGZyb20gdGhlIGN1cnJlbnQgYHNjcmlwdGAgc2NvcGUuIE9ubHkgd29ya3MgaW5zaWRlIGA8c2NyaXB0Pjwvc2NyaXB0PmAgdGFncyB0aGF0IGFyZSBkaXJlY3QgY2hpbGRyZW4gb2YgYG9ucy1wYWdlYCBlbGVtZW50LiBVc2UgdGhpcyB0byBhZGQgbGlmZWN5Y2xlIGhvb2tzIHRvIGEgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICogICBbZW5dUmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbmNvbnN0IGdldENTID0gJ2N1cnJlbnRTY3JpcHQnIGluIGRvY3VtZW50ID8gKCkgPT4gZG9jdW1lbnQuY3VycmVudFNjcmlwdCA6ICgpID0+IGRvY3VtZW50LnNjcmlwdHNbZG9jdW1lbnQuc2NyaXB0cy5sZW5ndGggLSAxXTtcbm9ucy5nZXRTY3JpcHRQYWdlID0gKCkgPT4gZ2V0Q1MoKSAmJiAvb25zLXBhZ2UvaS50ZXN0KGdldENTKCkucGFyZW50RWxlbWVudC50YWdOYW1lKSAmJiBnZXRDUygpLnBhcmVudEVsZW1lbnQgfHwgbnVsbDtcblxuZXhwb3J0IGRlZmF1bHQgb25zO1xuIiwiLy8gRm9yIEBvbnNlbnVpL2N1c3RvbS1lbGVtZW50c1xuaWYgKHdpbmRvdy5jdXN0b21FbGVtZW50cykgeyAvLyBldmVuIGlmIG5hdGl2ZSBDRTEgaW1wbCBleGlzdHMsIHVzZSBwb2x5ZmlsbFxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5mb3JjZVBvbHlmaWxsID0gdHJ1ZTtcbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciB0ZXN0ID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmICh0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYikgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYgKHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xuICAgIC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgaW5zdGFuY2UuaGFzKDEpOyB9KTtcbiAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSAkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikgeyBuZXcgQyhpdGVyKTsgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKCksIHRhcmdldCwgQyk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTtcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmIChJU19XRUFLICYmIHByb3RvLmNsZWFyKSBkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQyAhPSBCYXNlKSwgTyk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnU2V0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwRm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgIGFGdW5jdGlvbih0aGlzKTtcbiAgICBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAobWFwcGluZykgYUZ1bmN0aW9uKG1hcEZuKTtcbiAgICBpZiAoc291cmNlID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgQSA9IFtdO1xuICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICBuID0gMDtcbiAgICAgIGNiID0gY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgZnVuY3Rpb24gKG5leHRJdGVtKSB7XG4gICAgICAgIEEucHVzaChjYihuZXh0SXRlbSwgbisrKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgQS5wdXNoLCBBKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1NldCcpO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlNldDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJykgfSk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnTWFwJyk7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuTWFwO1xuIiwiY29uc3QgcmVzZXJ2ZWRUYWdMaXN0ID0gbmV3IFNldChbXG4gICdhbm5vdGF0aW9uLXhtbCcsXG4gICdjb2xvci1wcm9maWxlJyxcbiAgJ2ZvbnQtZmFjZScsXG4gICdmb250LWZhY2Utc3JjJyxcbiAgJ2ZvbnQtZmFjZS11cmknLFxuICAnZm9udC1mYWNlLWZvcm1hdCcsXG4gICdmb250LWZhY2UtbmFtZScsXG4gICdtaXNzaW5nLWdseXBoJyxcbl0pO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lKGxvY2FsTmFtZSkge1xuICBjb25zdCByZXNlcnZlZCA9IHJlc2VydmVkVGFnTGlzdC5oYXMobG9jYWxOYW1lKTtcbiAgY29uc3QgdmFsaWRGb3JtID0gL15bYS16XVsuMC05X2Etel0qLVtcXC0uMC05X2Etel0qJC8udGVzdChsb2NhbE5hbWUpO1xuICByZXR1cm4gIXJlc2VydmVkICYmIHZhbGlkRm9ybTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29ubmVjdGVkKG5vZGUpIHtcbiAgLy8gVXNlIGBOb2RlI2lzQ29ubmVjdGVkYCwgaWYgZGVmaW5lZC5cbiAgY29uc3QgbmF0aXZlVmFsdWUgPSBub2RlLmlzQ29ubmVjdGVkO1xuICBpZiAobmF0aXZlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuYXRpdmVWYWx1ZTtcbiAgfVxuXG4gIC8qKiBAdHlwZSB7P05vZGV8dW5kZWZpbmVkfSAqL1xuICBsZXQgY3VycmVudCA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50ICYmICEoY3VycmVudC5fX0NFX2lzSW1wb3J0RG9jdW1lbnQgfHwgY3VycmVudCBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgfHwgKHdpbmRvdy5TaGFkb3dSb290ICYmIGN1cnJlbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gY3VycmVudC5ob3N0IDogdW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gISEoY3VycmVudCAmJiAoY3VycmVudC5fX0NFX2lzSW1wb3J0RG9jdW1lbnQgfHwgY3VycmVudCBpbnN0YW5jZW9mIERvY3VtZW50KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICogQHBhcmFtIHshTm9kZX0gc3RhcnRcbiAqIEByZXR1cm4gez9Ob2RlfVxuICovXG5mdW5jdGlvbiBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIHN0YXJ0KSB7XG4gIGxldCBub2RlID0gc3RhcnQ7XG4gIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHJvb3QgJiYgIW5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiAoIW5vZGUgfHwgbm9kZSA9PT0gcm9vdCkgPyBudWxsIDogbm9kZS5uZXh0U2libGluZztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSByb290XG4gKiBAcGFyYW0geyFOb2RlfSBzdGFydFxuICogQHJldHVybiB7P05vZGV9XG4gKi9cbmZ1bmN0aW9uIG5leHROb2RlKHJvb3QsIHN0YXJ0KSB7XG4gIHJldHVybiBzdGFydC5maXJzdENoaWxkID8gc3RhcnQuZmlyc3RDaGlsZCA6IG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgc3RhcnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFFbGVtZW50KX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7IVNldDxOb2RlPj19IHZpc2l0ZWRJbXBvcnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBjYWxsYmFjaywgdmlzaXRlZEltcG9ydHMgPSBuZXcgU2V0KCkpIHtcbiAgbGV0IG5vZGUgPSByb290O1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovKG5vZGUpO1xuXG4gICAgICBjYWxsYmFjayhlbGVtZW50KTtcblxuICAgICAgY29uc3QgbG9jYWxOYW1lID0gZWxlbWVudC5sb2NhbE5hbWU7XG4gICAgICBpZiAobG9jYWxOYW1lID09PSAnbGluaycgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAnaW1wb3J0Jykge1xuICAgICAgICAvLyBJZiB0aGlzIGltcG9ydCAocG9seWZpbGxlZCBvciBub3QpIGhhcyBpdCdzIHJvb3Qgbm9kZSBhdmFpbGFibGUsXG4gICAgICAgIC8vIHdhbGsgaXQuXG4gICAgICAgIGNvbnN0IGltcG9ydE5vZGUgPSAvKiogQHR5cGUgeyFOb2RlfSAqLyAoZWxlbWVudC5pbXBvcnQpO1xuICAgICAgICBpZiAoaW1wb3J0Tm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgIXZpc2l0ZWRJbXBvcnRzLmhhcyhpbXBvcnROb2RlKSkge1xuICAgICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgd2Fsa3Mgb2YgdGhlIHNhbWUgaW1wb3J0IHJvb3QuXG4gICAgICAgICAgdmlzaXRlZEltcG9ydHMuYWRkKGltcG9ydE5vZGUpO1xuXG4gICAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBpbXBvcnROb2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhjaGlsZCwgY2FsbGJhY2ssIHZpc2l0ZWRJbXBvcnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZ25vcmUgZGVzY2VuZGFudHMgb2YgaW1wb3J0IGxpbmtzIHRvIHByZXZlbnQgYXR0ZW1wdGluZyB0byB3YWxrIHRoZVxuICAgICAgICAvLyBlbGVtZW50cyBjcmVhdGVkIGJ5IHRoZSBIVE1MIEltcG9ydHMgcG9seWZpbGwgdGhhdCB3ZSBqdXN0IHdhbGtlZFxuICAgICAgICAvLyBhYm92ZS5cbiAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgZWxlbWVudCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChsb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgLy8gSWdub3JlIGRlc2NlbmRhbnRzIG9mIHRlbXBsYXRlcy4gVGhlcmUgc2hvdWxkbid0IGJlIGFueSBkZXNjZW5kYW50c1xuICAgICAgICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBtb3ZlZCBpbnRvIGAuY29udGVudGAgZHVyaW5nIGNvbnN0cnVjdGlvbiBpblxuICAgICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgdGVtcGxhdGUgYnV0LCBpbiBjYXNlIHRoZXkgZXhpc3QgYW5kIGFyZSBzdGlsbFxuICAgICAgICAvLyB3YWl0aW5nIHRvIGJlIG1vdmVkIGJ5IGEgcG9seWZpbGwsIHRoZXkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAgICBub2RlID0gbmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyhyb290LCBlbGVtZW50KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhbGsgc2hhZG93IHJvb3RzLlxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuX19DRV9zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBzaGFkb3dSb290LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMoY2hpbGQsIGNhbGxiYWNrLCB2aXNpdGVkSW1wb3J0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbmV4dE5vZGUocm9vdCwgbm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBVc2VkIHRvIHN1cHByZXNzIENsb3N1cmUncyBcIk1vZGlmeWluZyB0aGUgcHJvdG90eXBlIGlzIG9ubHkgYWxsb3dlZCBpZiB0aGVcbiAqIGNvbnN0cnVjdG9yIGlzIGluIHRoZSBzYW1lIHNjb3BlXCIgd2FybmluZyB3aXRob3V0IHVzaW5nXG4gKiBgQHN1cHByZXNzIHtuZXdDaGVja1R5cGVzLCBkdXBsaWNhdGV9YCBiZWNhdXNlIGBuZXdDaGVja1R5cGVzYCBpcyB0b28gYnJvYWQuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFByb3BlcnR5VW5jaGVja2VkKGRlc3RpbmF0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICBkZXN0aW5hdGlvbltuYW1lXSA9IHZhbHVlO1xufVxuIiwiLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBDdXN0b21FbGVtZW50U3RhdGUgPSB7XG4gIGN1c3RvbTogMSxcbiAgZmFpbGVkOiAyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ3VzdG9tRWxlbWVudFN0YXRlO1xuIiwiaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4vVXRpbGl0aWVzLmpzJztcbmltcG9ydCBDRVN0YXRlIGZyb20gJy4vQ3VzdG9tRWxlbWVudFN0YXRlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tRWxlbWVudEludGVybmFscyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7IU1hcDxzdHJpbmcsICFDdXN0b21FbGVtZW50RGVmaW5pdGlvbj59ICovXG4gICAgdGhpcy5fbG9jYWxOYW1lVG9EZWZpbml0aW9uID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqIEB0eXBlIHshTWFwPCFGdW5jdGlvbiwgIUN1c3RvbUVsZW1lbnREZWZpbml0aW9uPn0gKi9cbiAgICB0aGlzLl9jb25zdHJ1Y3RvclRvRGVmaW5pdGlvbiA9IG5ldyBNYXAoKTtcblxuICAgIC8qKiBAdHlwZSB7IUFycmF5PCFmdW5jdGlvbighTm9kZSk+fSAqL1xuICAgIHRoaXMuX3BhdGNoZXMgPSBbXTtcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLl9oYXNQYXRjaGVzID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgKiBAcGFyYW0geyFDdXN0b21FbGVtZW50RGVmaW5pdGlvbn0gZGVmaW5pdGlvblxuICAgKi9cbiAgc2V0RGVmaW5pdGlvbihsb2NhbE5hbWUsIGRlZmluaXRpb24pIHtcbiAgICB0aGlzLl9sb2NhbE5hbWVUb0RlZmluaXRpb24uc2V0KGxvY2FsTmFtZSwgZGVmaW5pdGlvbik7XG4gICAgdGhpcy5fY29uc3RydWN0b3JUb0RlZmluaXRpb24uc2V0KGRlZmluaXRpb24uY29uc3RydWN0b3IsIGRlZmluaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHJldHVybiB7IUN1c3RvbUVsZW1lbnREZWZpbml0aW9ufHVuZGVmaW5lZH1cbiAgICovXG4gIGxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxOYW1lVG9EZWZpbml0aW9uLmdldChsb2NhbE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICAgKiBAcmV0dXJuIHshQ3VzdG9tRWxlbWVudERlZmluaXRpb258dW5kZWZpbmVkfVxuICAgKi9cbiAgY29uc3RydWN0b3JUb0RlZmluaXRpb24oY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0b3JUb0RlZmluaXRpb24uZ2V0KGNvbnN0cnVjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFmdW5jdGlvbighTm9kZSl9IGxpc3RlbmVyXG4gICAqL1xuICBhZGRQYXRjaChsaXN0ZW5lcikge1xuICAgIHRoaXMuX2hhc1BhdGNoZXMgPSB0cnVlO1xuICAgIHRoaXMuX3BhdGNoZXMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgcGF0Y2hUcmVlKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuX2hhc1BhdGNoZXMpIHJldHVybjtcblxuICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhub2RlLCBlbGVtZW50ID0+IHRoaXMucGF0Y2goZWxlbWVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICovXG4gIHBhdGNoKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuX2hhc1BhdGNoZXMpIHJldHVybjtcblxuICAgIGlmIChub2RlLl9fQ0VfcGF0Y2hlZCkgcmV0dXJuO1xuICAgIG5vZGUuX19DRV9wYXRjaGVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcGF0Y2hlc1tpXShub2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICAgKi9cbiAgY29ubmVjdFRyZWUocm9vdCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgZWxlbWVudCA9PiBlbGVtZW50cy5wdXNoKGVsZW1lbnQpKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50Ll9fQ0Vfc3RhdGUgPT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQoZWxlbWVudCkpIHtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZ3JhZGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSByb290XG4gICAqL1xuICBkaXNjb25uZWN0VHJlZShyb290KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBlbGVtZW50ID0+IGVsZW1lbnRzLnB1c2goZWxlbWVudCkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGVsZW1lbnQuX19DRV9zdGF0ZSA9PT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZXMgYWxsIHVuY3VzdG9taXplZCBjdXN0b20gZWxlbWVudHMgYXQgYW5kIGJlbG93IGEgcm9vdCBub2RlIGZvclxuICAgKiB3aGljaCB0aGVyZSBpcyBhIGRlZmluaXRpb24uIFdoZW4gY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb24gY2FsbGJhY2tzIGFyZVxuICAgKiBhc3N1bWVkIHRvIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5ICh3aGljaCwgYnkgdGhlIGN1cnJlbnQgRE9NIC8gSFRNTCBzcGVjXG4gICAqIGRlZmluaXRpb25zLCB0aGV5IGFyZSAqbm90KiksIGNhbGxiYWNrcyBmb3IgYm90aCBlbGVtZW50cyBjdXN0b21pemVkXG4gICAqIHN5bmNocm9ub3VzbHkgYnkgdGhlIHBhcnNlciBhbmQgZWxlbWVudHMgYmVpbmcgdXBncmFkZWQgb2NjdXIgaW4gdGhlIHNhbWVcbiAgICogcmVsYXRpdmUgb3JkZXIuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgZnVuY3Rpb24sIHdoZW4gdXNlZCB0byBzaW11bGF0ZSB0aGUgY29uc3RydWN0aW9uIG9mIGEgdHJlZSB0aGF0XG4gICAqIGlzIGFscmVhZHkgY3JlYXRlZCBidXQgbm90IGN1c3RvbWl6ZWQgKGkuZS4gYnkgdGhlIHBhcnNlciksIGRvZXMgKm5vdCpcbiAgICogcHJldmVudCB0aGUgZWxlbWVudCBmcm9tIHJlYWRpbmcgdGhlICdmaW5hbCcgKHRydWUpIHN0YXRlIG9mIHRoZSB0cmVlLiBGb3JcbiAgICogZXhhbXBsZSwgdGhlIGVsZW1lbnQsIGR1cmluZyB0cnVseSBzeW5jaHJvbm91cyBwYXJzaW5nIC8gY29uc3RydWN0aW9uIHdvdWxkXG4gICAqIHNlZSB0aGF0IGl0IGNvbnRhaW5zIG5vIGNoaWxkcmVuIGFzIHRoZXkgaGF2ZSBub3QgeWV0IGJlZW4gaW5zZXJ0ZWQuXG4gICAqIEhvd2V2ZXIsIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbW9kaWZ5IHRoZSB0cmVlLCB0aGUgZWxlbWVudCB3aWxsXG4gICAqIChpbmNvcnJlY3RseSkgaGF2ZSBjaGlsZHJlbi4gQWRkaXRpb25hbGx5LCBzZWxmLW1vZGlmaWNhdGlvbiByZXN0cmljdGlvbnNcbiAgICogZm9yIGN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9ycyBpbXBvc2VkIGJ5IHRoZSBET00gc3BlYyBhcmUgKm5vdCogZW5mb3JjZWQuXG4gICAqXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgbmVzdGVkIGxpc3Qgc2hvd3MgdGhlIHN0ZXBzIGV4dGVuZGluZyBkb3duIGZyb20gdGhlIEhUTUxcbiAgICogc3BlYydzIHBhcnNpbmcgc2VjdGlvbiB0aGF0IGNhdXNlIGVsZW1lbnRzIHRvIGJlIHN5bmNocm9ub3VzbHkgY3JlYXRlZCBhbmRcbiAgICogdXBncmFkZWQ6XG4gICAqXG4gICAqIFRoZSBcImluIGJvZHlcIiBpbnNlcnRpb24gbW9kZTpcbiAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgKiAtIFN3aXRjaCBvbiB0b2tlbjpcbiAgICogICAuLiBvdGhlciBjYXNlcyAuLlxuICAgKiAgIC0+IEFueSBvdGhlciBzdGFydCB0YWdcbiAgICogICAgICAtIFtJbnNlcnQgYW4gSFRNTCBlbGVtZW50XShiZWxvdykgZm9yIHRoZSB0b2tlbi5cbiAgICpcbiAgICogSW5zZXJ0IGFuIEhUTUwgZWxlbWVudDpcbiAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaW5zZXJ0LWFuLWh0bWwtZWxlbWVudFxuICAgKiAtIEluc2VydCBhIGZvcmVpZ24gZWxlbWVudCBmb3IgdGhlIHRva2VuIGluIHRoZSBIVE1MIG5hbWVzcGFjZTpcbiAgICogICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNpbnNlcnQtYS1mb3JlaWduLWVsZW1lbnRcbiAgICogICAtIENyZWF0ZSBhbiBlbGVtZW50IGZvciBhIHRva2VuOlxuICAgKiAgICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjY3JlYXRlLWFuLWVsZW1lbnQtZm9yLXRoZS10b2tlblxuICAgKiAgICAgLSBXaWxsIGV4ZWN1dGUgc2NyaXB0IGZsYWcgaXMgdHJ1ZT9cbiAgICogICAgICAgLSAoRWxlbWVudCBxdWV1ZSBwdXNoZWQgdG8gdGhlIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9ucyBzdGFjay4pXG4gICAqICAgICAtIENyZWF0ZSBhbiBlbGVtZW50OlxuICAgKiAgICAgICBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtY3JlYXRlLWVsZW1lbnRcbiAgICogICAgICAgLSBTeW5jIENFIGZsYWcgaXMgdHJ1ZT9cbiAgICogICAgICAgICAtIENvbnN0cnVjdG9yIGNhbGxlZC5cbiAgICogICAgICAgICAtIFNlbGYtbW9kaWZpY2F0aW9uIHJlc3RyaWN0aW9ucyBlbmZvcmNlZC5cbiAgICogICAgICAgLSBTeW5jIENFIGZsYWcgaXMgZmFsc2U/XG4gICAqICAgICAgICAgLSAoVXBncmFkZSByZWFjdGlvbiBlbnF1ZXVlZC4pXG4gICAqICAgICAtIEF0dHJpYnV0ZXMgYXBwZW5kZWQgdG8gZWxlbWVudC5cbiAgICogICAgICAgKGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHJlYWN0aW9ucyBlbnF1ZXVlZC4pXG4gICAqICAgICAtIFdpbGwgZXhlY3V0ZSBzY3JpcHQgZmxhZyBpcyB0cnVlP1xuICAgKiAgICAgICAtIChFbGVtZW50IHF1ZXVlIHBvcHBlZCBmcm9tIHRoZSBjdXN0b20gZWxlbWVudCByZWFjdGlvbnMgc3RhY2suXG4gICAqICAgICAgICAgUmVhY3Rpb25zIGluIHRoZSBwb3BwZWQgc3RhY2sgYXJlIGludm9rZWQuKVxuICAgKiAgIC0gKEVsZW1lbnQgcXVldWUgcHVzaGVkIHRvIHRoZSBjdXN0b20gZWxlbWVudCByZWFjdGlvbnMgc3RhY2suKVxuICAgKiAgIC0gSW5zZXJ0IHRoZSBlbGVtZW50OlxuICAgKiAgICAgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW5vZGUtaW5zZXJ0XG4gICAqICAgICAtIFNoYWRvdy1pbmNsdWRpbmcgZGVzY2VuZGFudHMgYXJlIGNvbm5lY3RlZC4gRHVyaW5nIHBhcnNpbmdcbiAgICogICAgICAgY29uc3RydWN0aW9uLCB0aGVyZSBhcmUgbm8gc2hhZG93LSpleGNsdWRpbmcqIGRlc2NlbmRhbnRzLlxuICAgKiAgICAgICBIb3dldmVyLCB0aGUgY29uc3RydWN0b3IgbWF5IGhhdmUgdmFsaWRseSBhdHRhY2hlZCBhIHNoYWRvd1xuICAgKiAgICAgICB0cmVlIHRvIGl0c2VsZiBhbmQgYWRkZWQgZGVzY2VuZGFudHMgdG8gdGhhdCBzaGFkb3cgdHJlZS5cbiAgICogICAgICAgKGBjb25uZWN0ZWRDYWxsYmFja2AgcmVhY3Rpb25zIGVucXVldWVkLilcbiAgICogICAtIChFbGVtZW50IHF1ZXVlIHBvcHBlZCBmcm9tIHRoZSBjdXN0b20gZWxlbWVudCByZWFjdGlvbnMgc3RhY2suXG4gICAqICAgICBSZWFjdGlvbnMgaW4gdGhlIHBvcHBlZCBzdGFjayBhcmUgaW52b2tlZC4pXG4gICAqXG4gICAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAgICogQHBhcmFtIHshU2V0PE5vZGU+PX0gdmlzaXRlZEltcG9ydHNcbiAgICovXG4gIHBhdGNoQW5kVXBncmFkZVRyZWUocm9vdCwgdmlzaXRlZEltcG9ydHMgPSBuZXcgU2V0KCkpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgY29uc3QgZ2F0aGVyRWxlbWVudHMgPSBlbGVtZW50ID0+IHtcbiAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PT0gJ2xpbmsnICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ2ltcG9ydCcpIHtcbiAgICAgICAgLy8gVGhlIEhUTUwgSW1wb3J0cyBwb2x5ZmlsbCBzZXRzIGEgZGVzY2VuZGFudCBlbGVtZW50IG9mIHRoZSBsaW5rIHRvXG4gICAgICAgIC8vIHRoZSBgaW1wb3J0YCBwcm9wZXJ0eSwgc3BlY2lmaWNhbGx5IHRoaXMgaXMgKm5vdCogYSBEb2N1bWVudC5cbiAgICAgICAgY29uc3QgaW1wb3J0Tm9kZSA9IC8qKiBAdHlwZSB7P05vZGV9ICovIChlbGVtZW50LmltcG9ydCk7XG5cbiAgICAgICAgaWYgKGltcG9ydE5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIGltcG9ydE5vZGUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9pc0ltcG9ydERvY3VtZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIENvbm5lY3RlZCBsaW5rcyBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaGFzUmVnaXN0cnkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoaXMgbGluaydzIGltcG9ydCByb290IGlzIG5vdCBhdmFpbGFibGUsIGl0cyBjb250ZW50cyBjYW4ndCBiZVxuICAgICAgICAgIC8vIHdhbGtlZC4gV2FpdCBmb3IgJ2xvYWQnIGFuZCB3YWxrIGl0IHdoZW4gaXQncyByZWFkeS5cbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnROb2RlID0gLyoqIEB0eXBlIHshTm9kZX0gKi8gKGVsZW1lbnQuaW1wb3J0KTtcblxuICAgICAgICAgICAgaWYgKGltcG9ydE5vZGUuX19DRV9kb2N1bWVudExvYWRIYW5kbGVkKSByZXR1cm47XG4gICAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9pc0ltcG9ydERvY3VtZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQ29ubmVjdGVkIGxpbmtzIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2hhc1JlZ2lzdHJ5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGB2aXNpdGVkSW1wb3J0c2Agc2V0IHRoYXQgd2FzIHBvcHVsYXRlZCBzeW5jIGR1cmluZ1xuICAgICAgICAgICAgLy8gdGhlIGBwYXRjaEFuZFVwZ3JhZGVUcmVlYCBjYWxsIHRoYXQgY2F1c2VkIHRoaXMgJ2xvYWQnIGhhbmRsZXIgdG9cbiAgICAgICAgICAgIC8vIGJlIGFkZGVkLiBUaGVuLCByZW1vdmUgKnRoaXMqIGxpbmsncyBpbXBvcnQgbm9kZSBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgICAgLy8gd2FsayB0aGF0IGltcG9ydCBhZ2FpbiwgZXZlbiBpZiBpdCB3YXMgcGFydGlhbGx5IHdhbGtlZCBsYXRlclxuICAgICAgICAgICAgLy8gZHVyaW5nIHRoZSBzYW1lIGBwYXRjaEFuZFVwZ3JhZGVUcmVlYCBjYWxsLlxuICAgICAgICAgICAgY29uc3QgY2xvbmVkVmlzaXRlZEltcG9ydHMgPSBuZXcgU2V0KHZpc2l0ZWRJbXBvcnRzKTtcbiAgICAgICAgICAgIHZpc2l0ZWRJbXBvcnRzLmRlbGV0ZShpbXBvcnROb2RlKTtcblxuICAgICAgICAgICAgdGhpcy5wYXRjaEFuZFVwZ3JhZGVUcmVlKGltcG9ydE5vZGUsIHZpc2l0ZWRJbXBvcnRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYHdhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzYCBwb3B1bGF0ZXMgKGFuZCBpbnRlcm5hbGx5IGNoZWNrcyBhZ2FpbnN0KVxuICAgIC8vIGB2aXNpdGVkSW1wb3J0c2Agd2hlbiB0cmF2ZXJzaW5nIGEgbG9hZGVkIGltcG9ydC5cbiAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgZ2F0aGVyRWxlbWVudHMsIHZpc2l0ZWRJbXBvcnRzKTtcblxuICAgIGlmICh0aGlzLl9oYXNQYXRjaGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucGF0Y2goZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMudXBncmFkZUVsZW1lbnQoZWxlbWVudHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICB1cGdyYWRlRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gZWxlbWVudC5fX0NFX3N0YXRlO1xuICAgIGlmIChjdXJyZW50U3RhdGUgIT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICBpZiAoIWRlZmluaXRpb24pIHJldHVybjtcblxuICAgIGRlZmluaXRpb24uY29uc3RydWN0aW9uU3RhY2sucHVzaChlbGVtZW50KTtcblxuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZGVmaW5pdGlvbi5jb25zdHJ1Y3RvcjtcbiAgICB0cnkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyAoY29uc3RydWN0b3IpKCk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvciBkaWQgbm90IHByb2R1Y2UgdGhlIGVsZW1lbnQgYmVpbmcgdXBncmFkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRlZmluaXRpb24uY29uc3RydWN0aW9uU3RhY2sucG9wKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZWxlbWVudC5fX0NFX3N0YXRlID0gQ0VTdGF0ZS5mYWlsZWQ7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX19DRV9zdGF0ZSA9IENFU3RhdGUuY3VzdG9tO1xuICAgIGVsZW1lbnQuX19DRV9kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcblxuICAgIGlmIChkZWZpbml0aW9uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaykge1xuICAgICAgY29uc3Qgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gZGVmaW5pdGlvbi5vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9ic2VydmVkQXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuYW1lID0gb2JzZXJ2ZWRBdHRyaWJ1dGVzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlbGVtZW50LCBuYW1lLCBudWxsLCB2YWx1ZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGVsZW1lbnQpKSB7XG4gICAgICB0aGlzLmNvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGVsZW1lbnQuX19DRV9kZWZpbml0aW9uO1xuICAgIGlmIChkZWZpbml0aW9uLmNvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICBkZWZpbml0aW9uLmNvbm5lY3RlZENhbGxiYWNrLmNhbGwoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5fX0NFX2lzQ29ubmVjdGVkQ2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuX19DRV9pc0Nvbm5lY3RlZENhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICB0aGlzLmNvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmluaXRpb24gPSBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmaW5pdGlvbi5kaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgZGVmaW5pdGlvbi5kaXNjb25uZWN0ZWRDYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX19DRV9pc0Nvbm5lY3RlZENhbGxiYWNrQ2FsbGVkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGRWYWx1ZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IG5ld1ZhbHVlXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAqL1xuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZWxlbWVudCwgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gZWxlbWVudC5fX0NFX2RlZmluaXRpb247XG4gICAgaWYgKFxuICAgICAgZGVmaW5pdGlvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgJiZcbiAgICAgIGRlZmluaXRpb24ub2JzZXJ2ZWRBdHRyaWJ1dGVzLmluZGV4T2YobmFtZSkgPiAtMVxuICAgICkge1xuICAgICAgZGVmaW5pdGlvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suY2FsbChlbGVtZW50LCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoaW50ZXJuYWxzLCBkb2MpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9XG4gICAgICovXG4gICAgdGhpcy5faW50ZXJuYWxzID0gaW50ZXJuYWxzO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFEb2N1bWVudH1cbiAgICAgKi9cbiAgICB0aGlzLl9kb2N1bWVudCA9IGRvYztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLl9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblxuXG4gICAgLy8gU2ltdWxhdGUgdHJlZSBjb25zdHJ1Y3Rpb24gZm9yIGFsbCBjdXJyZW50bHkgYWNjZXNzaWJsZSBub2RlcyBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC5cbiAgICB0aGlzLl9pbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZSh0aGlzLl9kb2N1bWVudCk7XG5cbiAgICBpZiAodGhpcy5fZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX2hhbmRsZU11dGF0aW9ucy5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gTm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyIGFyZSBnaXZlbiB0byB0aGUgb2JzZXJ2ZXIgKmJlZm9yZSogdGhlIG5leHRcbiAgICAgIC8vIHRhc2sgcnVucy4gSW5saW5lIHNjcmlwdHMgYXJlIHJ1biBpbiBhIG5ldyB0YXNrLiBUaGlzIG1lYW5zIHRoYXQgdGhlXG4gICAgICAvLyBvYnNlcnZlciB3aWxsIGJlIGFibGUgdG8gaGFuZGxlIHRoZSBuZXdseSBwYXJzZWQgbm9kZXMgYmVmb3JlIHRoZSBpbmxpbmVcbiAgICAgIC8vIHNjcmlwdCBpcyBydW4uXG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IG11dGF0aW9uc1xuICAgKi9cbiAgX2hhbmRsZU11dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAvLyBPbmNlIHRoZSBkb2N1bWVudCdzIGByZWFkeVN0YXRlYCBpcyAnaW50ZXJhY3RpdmUnIG9yICdjb21wbGV0ZScsIGFsbCBuZXdcbiAgICAvLyBub2RlcyBjcmVhdGVkIHdpdGhpbiB0aGF0IGRvY3VtZW50IHdpbGwgYmUgdGhlIHJlc3VsdCBvZiBzY3JpcHQgYW5kXG4gICAgLy8gc2hvdWxkIGJlIGhhbmRsZWQgYnkgcGF0Y2hpbmcuXG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHRoaXMuX2RvY3VtZW50LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgcmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFkZGVkTm9kZXMgPSBtdXRhdGlvbnNbaV0uYWRkZWROb2RlcztcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYWRkZWROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBub2RlID0gYWRkZWROb2Rlc1tqXTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmVycmVkIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5fcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFQcm9taXNlPFQ+fVxuICAgICAqL1xuICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuXG4gICAgICBpZiAodGhpcy5fdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLl92YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgKi9cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHJlc29sdmVkLicpO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAodGhpcy5fcmVzb2x2ZSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPFQ+fVxuICAgKi9cbiAgdG9Qcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICB9XG59XG4iLCJpbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0IERvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIgZnJvbSAnLi9Eb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyLmpzJztcbmltcG9ydCBEZWZlcnJlZCBmcm9tICcuL0RlZmVycmVkLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHVucmVzdHJpY3RlZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21FbGVtZW50UmVnaXN0cnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGludGVybmFscykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfVxuICAgICAqL1xuICAgIHRoaXMuX2ludGVybmFscyA9IGludGVybmFscztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFNYXA8c3RyaW5nLCAhRGVmZXJyZWQ8dW5kZWZpbmVkPj59XG4gICAgICovXG4gICAgdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZCA9IG5ldyBNYXAoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZsdXNoIGNhbGxiYWNrIHRyaWdnZXJzIHRoZSBkb2N1bWVudCB3YWxrIHN5bmNocm9ub3VzbHkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2sgPSBmbiA9PiBmbigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9mbHVzaFBlbmRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIgPSBuZXcgRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlcihpbnRlcm5hbHMsIGRvY3VtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZGVmaW5lKGxvY2FsTmFtZSwgY29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3JzIG11c3QgYmUgZnVuY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICghVXRpbGl0aWVzLmlzVmFsaWRDdXN0b21FbGVtZW50TmFtZShsb2NhbE5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBlbGVtZW50IG5hbWUgJyR7bG9jYWxOYW1lfScgaXMgbm90IHZhbGlkLmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQSBjdXN0b20gZWxlbWVudCB3aXRoIG5hbWUgJyR7bG9jYWxOYW1lfScgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGN1c3RvbSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgZGVmaW5lZC4nKTtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgbGV0IGNvbm5lY3RlZENhbGxiYWNrO1xuICAgIGxldCBkaXNjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBsZXQgYWRvcHRlZENhbGxiYWNrO1xuICAgIGxldCBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s7XG4gICAgbGV0IG9ic2VydmVkQXR0cmlidXRlcztcbiAgICB0cnkge1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgY29uc3QgcHJvdG90eXBlID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgaWYgKCEocHJvdG90eXBlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3JcXCdzIHByb3RvdHlwZSBpcyBub3QgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRDYWxsYmFjayhuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrVmFsdWUgPSBwcm90b3R5cGVbbmFtZV07XG4gICAgICAgIGlmIChjYWxsYmFja1ZhbHVlICE9PSB1bmRlZmluZWQgJiYgIShjYWxsYmFja1ZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7bmFtZX0nIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2tWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGVkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gZ2V0Q2FsbGJhY2soJ2Rpc2Nvbm5lY3RlZENhbGxiYWNrJyk7XG4gICAgICBhZG9wdGVkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnYWRvcHRlZENhbGxiYWNrJyk7XG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyk7XG4gICAgICBvYnNlcnZlZEF0dHJpYnV0ZXMgPSBjb25zdHJ1Y3Rvclsnb2JzZXJ2ZWRBdHRyaWJ1dGVzJ10gfHwgW107XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICBsb2NhbE5hbWUsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrLFxuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2ssXG4gICAgICBhZG9wdGVkQ2FsbGJhY2ssXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2ssXG4gICAgICBvYnNlcnZlZEF0dHJpYnV0ZXMsXG4gICAgICBjb25zdHJ1Y3Rpb25TdGFjazogW10sXG4gICAgfTtcblxuICAgIHRoaXMuX2ludGVybmFscy5zZXREZWZpbml0aW9uKGxvY2FsTmFtZSwgZGVmaW5pdGlvbik7XG5cbiAgICB0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzLnB1c2gobG9jYWxOYW1lKTtcblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgY2FsbGVkIHRoZSBmbHVzaCBjYWxsYmFjayBhbmQgaXQgaGFzbid0IGNhbGxlZCBiYWNrIHlldCxcbiAgICAvLyBkb24ndCBjYWxsIGl0IGFnYWluLlxuICAgIGlmICghdGhpcy5fZmx1c2hQZW5kaW5nKSB7XG4gICAgICB0aGlzLl9mbHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fZmx1c2hDYWxsYmFjaygoKSA9PiB0aGlzLl9mbHVzaCgpKTtcbiAgICB9XG4gIH1cblxuICBfZmx1c2goKSB7XG4gICAgLy8gSWYgbm8gbmV3IGRlZmluaXRpb25zIHdlcmUgZGVmaW5lZCwgZG9uJ3QgYXR0ZW1wdCB0byBmbHVzaC4gVGhpcyBjb3VsZFxuICAgIC8vIGhhcHBlbiBpZiBhIGZsdXNoIGNhbGxiYWNrIGtlZXBzIHRoZSBmdW5jdGlvbiBpdCBpcyBnaXZlbiBhbmQgY2FsbHMgaXRcbiAgICAvLyBtdWx0aXBsZSB0aW1lcy5cbiAgICBpZiAodGhpcy5fZmx1c2hQZW5kaW5nID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fZmx1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5faW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoZG9jdW1lbnQpO1xuXG4gICAgd2hpbGUgKHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbG9jYWxOYW1lID0gdGhpcy5fdW5mbHVzaGVkTG9jYWxOYW1lcy5zaGlmdCgpO1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLl93aGVuRGVmaW5lZERlZmVycmVkLmdldChsb2NhbE5hbWUpO1xuICAgICAgaWYgKGRlZmVycmVkKSB7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuICBnZXQobG9jYWxOYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuX2ludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKTtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgcmV0dXJuIGRlZmluaXRpb24uY29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHVuZGVmaW5lZD59XG4gICAqL1xuICB3aGVuRGVmaW5lZChsb2NhbE5hbWUpIHtcbiAgICBpZiAoIVV0aWxpdGllcy5pc1ZhbGlkQ3VzdG9tRWxlbWVudE5hbWUobG9jYWxOYW1lKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBTeW50YXhFcnJvcihgJyR7bG9jYWxOYW1lfScgaXMgbm90IGEgdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZS5gKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJpb3IgPSB0aGlzLl93aGVuRGVmaW5lZERlZmVycmVkLmdldChsb2NhbE5hbWUpO1xuICAgIGlmIChwcmlvcikge1xuICAgICAgcmV0dXJuIHByaW9yLnRvUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZC5zZXQobG9jYWxOYW1lLCBkZWZlcnJlZCk7XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5faW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuICAgIC8vIFJlc29sdmUgaW1tZWRpYXRlbHkgb25seSBpZiB0aGUgZ2l2ZW4gbG9jYWwgbmFtZSBoYXMgYSBkZWZpbml0aW9uICphbmQqXG4gICAgLy8gdGhlIGZ1bGwgZG9jdW1lbnQgd2FsayB0byB1cGdyYWRlIGVsZW1lbnRzIHdpdGggdGhhdCBsb2NhbCBuYW1lIGhhc1xuICAgIC8vIGFscmVhZHkgaGFwcGVuZWQuXG4gICAgaWYgKGRlZmluaXRpb24gJiYgdGhpcy5fdW5mbHVzaGVkTG9jYWxOYW1lcy5pbmRleE9mKGxvY2FsTmFtZSkgPT09IC0xKSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmVycmVkLnRvUHJvbWlzZSgpO1xuICB9XG5cbiAgcG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayhvdXRlcikge1xuICAgIHRoaXMuX2RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZmx1c2hDYWxsYmFjaztcbiAgICB0aGlzLl9mbHVzaENhbGxiYWNrID0gZmx1c2ggPT4gb3V0ZXIoKCkgPT4gaW5uZXIoZmx1c2gpKTtcbiAgfVxufVxuXG4vLyBDbG9zdXJlIGNvbXBpbGVyIGV4cG9ydHMuXG53aW5kb3dbJ0N1c3RvbUVsZW1lbnRSZWdpc3RyeSddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5O1xuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsnZGVmaW5lJ10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmRlZmluZTtcbkN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGVbJ2dldCddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQ7XG5DdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWyd3aGVuRGVmaW5lZCddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS53aGVuRGVmaW5lZDtcbkN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGVbJ3BvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2snXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjaztcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgRG9jdW1lbnRfY3JlYXRlRWxlbWVudDogd2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LFxuICBEb2N1bWVudF9jcmVhdGVFbGVtZW50TlM6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudE5TLFxuICBEb2N1bWVudF9pbXBvcnROb2RlOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGUsXG4gIERvY3VtZW50X3ByZXBlbmQ6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGVbJ3ByZXBlbmQnXSxcbiAgRG9jdW1lbnRfYXBwZW5kOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlWydhcHBlbmQnXSxcbiAgTm9kZV9jbG9uZU5vZGU6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGUsXG4gIE5vZGVfYXBwZW5kQ2hpbGQ6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCxcbiAgTm9kZV9pbnNlcnRCZWZvcmU6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUsXG4gIE5vZGVfcmVtb3ZlQ2hpbGQ6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCxcbiAgTm9kZV9yZXBsYWNlQ2hpbGQ6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQsXG4gIE5vZGVfdGV4dENvbnRlbnQ6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93Lk5vZGUucHJvdG90eXBlLCAndGV4dENvbnRlbnQnKSxcbiAgRWxlbWVudF9hdHRhY2hTaGFkb3c6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnYXR0YWNoU2hhZG93J10sXG4gIEVsZW1lbnRfaW5uZXJIVE1MOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZSwgJ2lubmVySFRNTCcpLFxuICBFbGVtZW50X2dldEF0dHJpYnV0ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSxcbiAgRWxlbWVudF9zZXRBdHRyaWJ1dGU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUsXG4gIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlLFxuICBFbGVtZW50X2dldEF0dHJpYnV0ZU5TOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTlMsXG4gIEVsZW1lbnRfc2V0QXR0cmlidXRlTlM6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyxcbiAgRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUzogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZU5TLFxuICBFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudDogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydpbnNlcnRBZGphY2VudEVsZW1lbnQnXSxcbiAgRWxlbWVudF9wcmVwZW5kOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ3ByZXBlbmQnXSxcbiAgRWxlbWVudF9hcHBlbmQ6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnYXBwZW5kJ10sXG4gIEVsZW1lbnRfYmVmb3JlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2JlZm9yZSddLFxuICBFbGVtZW50X2FmdGVyOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2FmdGVyJ10sXG4gIEVsZW1lbnRfcmVwbGFjZVdpdGg6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsncmVwbGFjZVdpdGgnXSxcbiAgRWxlbWVudF9yZW1vdmU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsncmVtb3ZlJ10sXG4gIEhUTUxFbGVtZW50OiB3aW5kb3cuSFRNTEVsZW1lbnQsXG4gIEhUTUxFbGVtZW50X2lubmVySFRNTDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5uZXJIVE1MJyksXG4gIEhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudDogd2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZVsnaW5zZXJ0QWRqYWNlbnRFbGVtZW50J10sXG59O1xuIiwiLyoqXG4gKiBUaGlzIGNsYXNzIGV4aXN0cyBvbmx5IHRvIHdvcmsgYXJvdW5kIENsb3N1cmUncyBsYWNrIG9mIGEgd2F5IHRvIGRlc2NyaWJlXG4gKiBzaW5nbGV0b25zLiBJdCByZXByZXNlbnRzIHRoZSAnYWxyZWFkeSBjb25zdHJ1Y3RlZCBtYXJrZXInIHVzZWQgaW4gY3VzdG9tXG4gKiBlbGVtZW50IGNvbnN0cnVjdGlvbiBzdGFja3MuXG4gKlxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1hbHJlYWR5LWNvbnN0cnVjdGVkLW1hcmtlclxuICovXG5jbGFzcyBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIge31cblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlcigpO1xuIiwiaW1wb3J0IE5hdGl2ZSBmcm9tICcuL05hdGl2ZS5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCBDRVN0YXRlIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRTdGF0ZS5qcyc7XG5pbXBvcnQgQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyIGZyb20gJy4uL0FscmVhZHlDb25zdHJ1Y3RlZE1hcmtlci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscykge1xuICB3aW5kb3dbJ0hUTUxFbGVtZW50J10gPSAoZnVuY3Rpb24oKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG5ldzogSFRNTEVsZW1lbnQpOiAhSFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gSFRNTEVsZW1lbnQoKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCByZWFsbHkgYmUgYG5ldy50YXJnZXRgIGJ1dCBgbmV3LnRhcmdldGAgY2FuJ3QgYmUgZW11bGF0ZWRcbiAgICAgIC8vIGluIEVTNS4gQXNzdW1pbmcgdGhlIHVzZXIga2VlcHMgdGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIGNvbnN0cnVjdG9yJ3NcbiAgICAgIC8vIHByb3RvdHlwZSdzIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHksIHRoaXMgaXMgZXF1aXZhbGVudC5cbiAgICAgIC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqL1xuICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gaW50ZXJuYWxzLmNvbnN0cnVjdG9yVG9EZWZpbml0aW9uKGNvbnN0cnVjdG9yKTtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXN0b20gZWxlbWVudCBiZWluZyBjb25zdHJ1Y3RlZCB3YXMgbm90IHJlZ2lzdGVyZWQgd2l0aCBgY3VzdG9tRWxlbWVudHNgLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb25zdHJ1Y3Rpb25TdGFjayA9IGRlZmluaXRpb24uY29uc3RydWN0aW9uU3RhY2s7XG5cbiAgICAgIGlmIChjb25zdHJ1Y3Rpb25TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IE5hdGl2ZS5Eb2N1bWVudF9jcmVhdGVFbGVtZW50LmNhbGwoZG9jdW1lbnQsIGRlZmluaXRpb24ubG9jYWxOYW1lKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGVsZW1lbnQsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgIGVsZW1lbnQuX19DRV9zdGF0ZSA9IENFU3RhdGUuY3VzdG9tO1xuICAgICAgICBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgICAgIGludGVybmFscy5wYXRjaChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGNvbnN0cnVjdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gY29uc3RydWN0aW9uU3RhY2tbbGFzdEluZGV4XTtcbiAgICAgIGlmIChlbGVtZW50ID09PSBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgSFRNTEVsZW1lbnQgY29uc3RydWN0b3Igd2FzIGVpdGhlciBjYWxsZWQgcmVlbnRyYW50bHkgZm9yIHRoaXMgY29uc3RydWN0b3Igb3IgY2FsbGVkIG11bHRpcGxlIHRpbWVzLicpO1xuICAgICAgfVxuICAgICAgY29uc3RydWN0aW9uU3RhY2tbbGFzdEluZGV4XSA9IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlcjtcblxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGVsZW1lbnQsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICBpbnRlcm5hbHMucGF0Y2goLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovIChlbGVtZW50KSk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZSA9IE5hdGl2ZS5IVE1MRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XG4gIH0pKCk7XG59O1xuIiwiaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi4vLi4vVXRpbGl0aWVzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBwcmVwZW5kOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICAqICBhcHBlbmQ6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gKiB9fVxuICovXG5sZXQgUGFyZW50Tm9kZU5hdGl2ZU1ldGhvZHM7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKiBAcGFyYW0geyFPYmplY3R9IGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0geyFQYXJlbnROb2RlTmF0aXZlTWV0aG9kc30gYnVpbHRJblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMsIGRlc3RpbmF0aW9uLCBidWlsdEluKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgKi9cbiAgZGVzdGluYXRpb25bJ3ByZXBlbmQnXSA9IGZ1bmN0aW9uKC4uLm5vZGVzKSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuICAgIGNvbnN0IGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi8gKG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgfSkpO1xuXG4gICAgYnVpbHRJbi5wcmVwZW5kLmFwcGx5KHRoaXMsIG5vZGVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ubmVjdGVkQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgKi9cbiAgZGVzdGluYXRpb25bJ2FwcGVuZCddID0gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG4gICAgY29uc3QgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqLyAobm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICB9KSk7XG5cbiAgICBidWlsdEluLmFwcGVuZC5hcHBseSh0aGlzLCBub2Rlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4iLCJpbXBvcnQgTmF0aXZlIGZyb20gJy4vTmF0aXZlLmpzJztcbmltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uL1V0aWxpdGllcy5qcyc7XG5cbmltcG9ydCBQYXRjaFBhcmVudE5vZGUgZnJvbSAnLi9JbnRlcmZhY2UvUGFyZW50Tm9kZS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscykge1xuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRG9jdW1lbnQucHJvdG90eXBlLCAnY3JlYXRlRWxlbWVudCcsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0RvY3VtZW50fVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICAgKiBAcmV0dXJuIHshRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihsb2NhbE5hbWUpIHtcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGRvY3VtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICBpZiAodGhpcy5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBpbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSk7XG4gICAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyAoZGVmaW5pdGlvbi5jb25zdHJ1Y3RvcikoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL1xuICAgICAgICAoTmF0aXZlLkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBsb2NhbE5hbWUpKTtcbiAgICAgIGludGVybmFscy5wYXRjaChyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRG9jdW1lbnQucHJvdG90eXBlLCAnaW1wb3J0Tm9kZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0RvY3VtZW50fVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWVwXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZSwgZGVlcCkge1xuICAgICAgY29uc3QgY2xvbmUgPSBOYXRpdmUuRG9jdW1lbnRfaW1wb3J0Tm9kZS5jYWxsKHRoaXMsIG5vZGUsIGRlZXApO1xuICAgICAgLy8gT25seSBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIGlmIHRoaXMgZG9jdW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgIGlmICghdGhpcy5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgIGludGVybmFscy5wYXRjaFRyZWUoY2xvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoY2xvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0pO1xuXG4gIGNvbnN0IE5TX0hUTUwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRG9jdW1lbnQucHJvdG90eXBlLCAnY3JlYXRlRWxlbWVudE5TJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RG9jdW1lbnR9XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAgICogQHJldHVybiB7IUVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZXNwYWNlLCBsb2NhbE5hbWUpIHtcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGRvY3VtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICBpZiAodGhpcy5fX0NFX2hhc1JlZ2lzdHJ5ICYmIChuYW1lc3BhY2UgPT09IG51bGwgfHwgbmFtZXNwYWNlID09PSBOU19IVE1MKSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gaW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXcgKGRlZmluaXRpb24uY29uc3RydWN0b3IpKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9cbiAgICAgICAgKE5hdGl2ZS5Eb2N1bWVudF9jcmVhdGVFbGVtZW50TlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIGxvY2FsTmFtZSkpO1xuICAgICAgaW50ZXJuYWxzLnBhdGNoKHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gIFBhdGNoUGFyZW50Tm9kZShpbnRlcm5hbHMsIERvY3VtZW50LnByb3RvdHlwZSwge1xuICAgIHByZXBlbmQ6IE5hdGl2ZS5Eb2N1bWVudF9wcmVwZW5kLFxuICAgIGFwcGVuZDogTmF0aXZlLkRvY3VtZW50X2FwcGVuZCxcbiAgfSk7XG59O1xuIiwiaW1wb3J0IE5hdGl2ZSBmcm9tICcuL05hdGl2ZS5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuLi9VdGlsaXRpZXMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgLy8gYE5vZGUjbm9kZVZhbHVlYCBpcyBpbXBsZW1lbnRlZCBvbiBgQXR0cmAuXG4gIC8vIGBOb2RlI3RleHRDb250ZW50YCBpcyBpbXBsZW1lbnRlZCBvbiBgQXR0cmAsIGBFbGVtZW50YC5cblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdpbnNlcnRCZWZvcmUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSByZWZOb2RlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZSwgcmVmTm9kZSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGluc2VydGVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkobm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfaW5zZXJ0QmVmb3JlLmNhbGwodGhpcywgbm9kZSwgcmVmTm9kZSk7XG5cbiAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgY2FuJ3QgYmUgY29ubmVjdGVkLCBzbyBgZGlzY29ubmVjdFRyZWVgIHdpbGwgbmV2ZXJcbiAgICAgICAgLy8gbmVlZCB0byBiZSBjYWxsZWQgb24gYSBEb2N1bWVudEZyYWdtZW50J3MgY2hpbGRyZW4gYWZ0ZXIgaW5zZXJ0aW5nIGl0LlxuXG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc2VydGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShpbnNlcnRlZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlV2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfaW5zZXJ0QmVmb3JlLmNhbGwodGhpcywgbm9kZSwgcmVmTm9kZSk7XG5cbiAgICAgIGlmIChub2RlV2FzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAnYXBwZW5kQ2hpbGQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIG5vZGUpO1xuXG4gICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGNhbid0IGJlIGNvbm5lY3RlZCwgc28gYGRpc2Nvbm5lY3RUcmVlYCB3aWxsIG5ldmVyXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgY2FsbGVkIG9uIGEgRG9jdW1lbnRGcmFnbWVudCdzIGNoaWxkcmVuIGFmdGVyIGluc2VydGluZyBpdC5cblxuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNlcnRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoaW5zZXJ0ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX2FwcGVuZENoaWxkLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICAgIGlmIChub2RlV2FzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAnY2xvbmVOb2RlJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWVwXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24oZGVlcCkge1xuICAgICAgY29uc3QgY2xvbmUgPSBOYXRpdmUuTm9kZV9jbG9uZU5vZGUuY2FsbCh0aGlzLCBkZWVwKTtcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGVsZW1lbnQncyBvd25lciBkb2N1bWVudCBpc1xuICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgIGlmICghdGhpcy5vd25lckRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnkpIHtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoVHJlZShjbG9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZShjbG9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAncmVtb3ZlQ2hpbGQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICBjb25zdCBub2RlV2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfcmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCBub2RlKTtcblxuICAgICAgaWYgKG5vZGVXYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ3JlcGxhY2VDaGlsZCcsXG4gICAgLyoqXG4gICAgICogQHRoaXMge05vZGV9XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVRvSW5zZXJ0XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVRvUmVtb3ZlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZVRvSW5zZXJ0LCBub2RlVG9SZW1vdmUpIHtcbiAgICAgIGlmIChub2RlVG9JbnNlcnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGluc2VydGVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkobm9kZVRvSW5zZXJ0LmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9yZXBsYWNlQ2hpbGQuY2FsbCh0aGlzLCBub2RlVG9JbnNlcnQsIG5vZGVUb1JlbW92ZSk7XG5cbiAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgY2FuJ3QgYmUgY29ubmVjdGVkLCBzbyBgZGlzY29ubmVjdFRyZWVgIHdpbGwgbmV2ZXJcbiAgICAgICAgLy8gbmVlZCB0byBiZSBjYWxsZWQgb24gYSBEb2N1bWVudEZyYWdtZW50J3MgY2hpbGRyZW4gYWZ0ZXIgaW5zZXJ0aW5nIGl0LlxuXG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZVRvUmVtb3ZlKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc2VydGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShpbnNlcnRlZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlVG9JbnNlcnRXYXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZVRvSW5zZXJ0KTtcbiAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX3JlcGxhY2VDaGlsZC5jYWxsKHRoaXMsIG5vZGVUb0luc2VydCwgbm9kZVRvUmVtb3ZlKTtcbiAgICAgIGNvbnN0IHRoaXNJc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblxuICAgICAgaWYgKHRoaXNJc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZVRvUmVtb3ZlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVUb0luc2VydFdhc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZVRvSW5zZXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNJc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZVRvSW5zZXJ0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICB9KTtcblxuXG4gIGZ1bmN0aW9uIHBhdGNoX3RleHRDb250ZW50KGRlc3RpbmF0aW9uLCBiYXNlRGVzY3JpcHRvcikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0aW5hdGlvbiwgJ3RleHRDb250ZW50Jywge1xuICAgICAgZW51bWVyYWJsZTogYmFzZURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogYmFzZURlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0OiAvKiogQHRoaXMge05vZGV9ICovIGZ1bmN0aW9uKGFzc2lnbmVkVmFsdWUpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRleHQgbm9kZSB0aGVuIHRoZXJlIGFyZSBubyBub2RlcyB0byBkaXNjb25uZWN0LlxuICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBiYXNlRGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCBhc3NpZ25lZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVtb3ZlZE5vZGVzID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBDaGVja2luZyBmb3IgYGZpcnN0Q2hpbGRgIGlzIGZhc3RlciB0aGFuIHJlYWRpbmcgYGNoaWxkTm9kZXMubGVuZ3RoYFxuICAgICAgICAvLyB0byBjb21wYXJlIHdpdGggMC5cbiAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIC8vIFVzaW5nIGBjaGlsZE5vZGVzYCBpcyBmYXN0ZXIgdGhhbiBgY2hpbGRyZW5gLCBldmVuIHRob3VnaCB3ZSBvbmx5XG4gICAgICAgICAgLy8gY2FyZSBhYm91dCBlbGVtZW50cy5cbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY2hpbGROb2Rlc0xlbmd0aCA+IDAgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgICAvLyBDb3B5aW5nIGFuIGFycmF5IGJ5IGl0ZXJhdGluZyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBzbGljZS5cbiAgICAgICAgICAgIHJlbW92ZWROb2RlcyA9IG5ldyBBcnJheShjaGlsZE5vZGVzTGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGROb2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHJlbW92ZWROb2Rlc1tpXSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYmFzZURlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgYXNzaWduZWRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUocmVtb3ZlZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBpZiAoTmF0aXZlLk5vZGVfdGV4dENvbnRlbnQgJiYgTmF0aXZlLk5vZGVfdGV4dENvbnRlbnQuZ2V0KSB7XG4gICAgcGF0Y2hfdGV4dENvbnRlbnQoTm9kZS5wcm90b3R5cGUsIE5hdGl2ZS5Ob2RlX3RleHRDb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbHMuYWRkUGF0Y2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcGF0Y2hfdGV4dENvbnRlbnQoZWxlbWVudCwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaW1wbGVtZW50YXRpb24gb2YgdGhlIGB0ZXh0Q29udGVudGAgZ2V0dGVyIGFzc3VtZXMgdGhhdFxuICAgICAgICAvLyB0ZXh0IG5vZGVzJyBgdGV4dENvbnRlbnRgIGdldHRlciB3aWxsIG5vdCBiZSBwYXRjaGVkLlxuICAgICAgICBnZXQ6IC8qKiBAdGhpcyB7Tm9kZX0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5jaGlsZE5vZGVzW2ldLnRleHRDb250ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogLyoqIEB0aGlzIHtOb2RlfSAqLyBmdW5jdGlvbihhc3NpZ25lZFZhbHVlKSB7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgTmF0aXZlLk5vZGVfcmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBOYXRpdmUuTm9kZV9hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGFzc2lnbmVkVmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwiaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi4vLi4vVXRpbGl0aWVzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBiZWZvcmU6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gKiAgIGFmdGVyOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICogICByZXBsYWNlV2l0aDogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAqICAgcmVtb3ZlOiAhZnVuY3Rpb24oKSxcbiAqIH19XG4gKi9cbmxldCBDaGlsZE5vZGVOYXRpdmVNZXRob2RzO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICogQHBhcmFtIHshT2JqZWN0fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHshQ2hpbGROb2RlTmF0aXZlTWV0aG9kc30gYnVpbHRJblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMsIGRlc3RpbmF0aW9uLCBidWlsdEluKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgKi9cbiAgZGVzdGluYXRpb25bJ2JlZm9yZSddID0gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG4gICAgY29uc3QgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqLyAobm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICB9KSk7XG5cbiAgICBidWlsdEluLmJlZm9yZS5hcHBseSh0aGlzLCBub2Rlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydhZnRlciddID0gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG4gICAgY29uc3QgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqLyAobm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICB9KSk7XG5cbiAgICBidWlsdEluLmFmdGVyLmFwcGx5KHRoaXMsIG5vZGVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ubmVjdGVkQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgKi9cbiAgZGVzdGluYXRpb25bJ3JlcGxhY2VXaXRoJ10gPSBmdW5jdGlvbiguLi5ub2Rlcykge1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIGZvciB3aGVuIG9uZSBvZiBgbm9kZXNgIGlzIGEgRG9jdW1lbnRGcmFnbWVudCFcbiAgICBjb25zdCBjb25uZWN0ZWRCZWZvcmUgPSAvKiogQHR5cGUgeyFBcnJheTwhTm9kZT59ICovIChub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgIH0pKTtcblxuICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblxuICAgIGJ1aWx0SW4ucmVwbGFjZVdpdGguYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25uZWN0ZWRCZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRCZWZvcmVbaV0pO1xuICAgIH1cblxuICAgIGlmICh3YXNDb25uZWN0ZWQpIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZSh0aGlzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZGVzdGluYXRpb25bJ3JlbW92ZSddID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgd2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpO1xuXG4gICAgYnVpbHRJbi5yZW1vdmUuY2FsbCh0aGlzKTtcblxuICAgIGlmICh3YXNDb25uZWN0ZWQpIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZSh0aGlzKTtcbiAgICB9XG4gIH07XG59O1xuIiwiaW1wb3J0IE5hdGl2ZSBmcm9tICcuL05hdGl2ZS5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCBDRVN0YXRlIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRTdGF0ZS5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi4vVXRpbGl0aWVzLmpzJztcblxuaW1wb3J0IFBhdGNoUGFyZW50Tm9kZSBmcm9tICcuL0ludGVyZmFjZS9QYXJlbnROb2RlLmpzJztcbmltcG9ydCBQYXRjaENoaWxkTm9kZSBmcm9tICcuL0ludGVyZmFjZS9DaGlsZE5vZGUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgaWYgKE5hdGl2ZS5FbGVtZW50X2F0dGFjaFNoYWRvdykge1xuICAgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ2F0dGFjaFNoYWRvdycsXG4gICAgICAvKipcbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHBhcmFtIHshe21vZGU6IHN0cmluZ319IGluaXRcbiAgICAgICAqIEByZXR1cm4ge1NoYWRvd1Jvb3R9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGluaXQpIHtcbiAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IE5hdGl2ZS5FbGVtZW50X2F0dGFjaFNoYWRvdy5jYWxsKHRoaXMsIGluaXQpO1xuICAgICAgICB0aGlzLl9fQ0Vfc2hhZG93Um9vdCA9IHNoYWRvd1Jvb3Q7XG4gICAgICAgIHJldHVybiBzaGFkb3dSb290O1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gRWxlbWVudHM6IGBFbGVtZW50I2F0dGFjaFNoYWRvd2Agd2FzIG5vdCBwYXRjaGVkLicpO1xuICB9XG5cblxuICBmdW5jdGlvbiBwYXRjaF9pbm5lckhUTUwoZGVzdGluYXRpb24sIGJhc2VEZXNjcmlwdG9yKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3RpbmF0aW9uLCAnaW5uZXJIVE1MJywge1xuICAgICAgZW51bWVyYWJsZTogYmFzZURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogYmFzZURlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0OiAvKiogQHRoaXMge0VsZW1lbnR9ICovIGZ1bmN0aW9uKGh0bWxTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cbiAgICAgICAgLy8gTk9URTogSW4gSUUxMSwgd2hlbiB1c2luZyB0aGUgbmF0aXZlIGBpbm5lckhUTUxgIHNldHRlciwgYWxsIG5vZGVzXG4gICAgICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlc2NlbmRhbnRzIG9mIHRoZSBjb250ZXh0IGVsZW1lbnQgaGF2ZSBhbGwgb2ZcbiAgICAgICAgLy8gdGhlaXIgY2hpbGRyZW4gcmVtb3ZlZCBhcyBwYXJ0IG9mIHRoZSBzZXQgLSB0aGUgZW50aXJlIHN1YnRyZWUgaXNcbiAgICAgICAgLy8gJ2Rpc2Fzc2VtYmxlZCcuIFRoaXMgd29yayBhcm91bmQgd2Fsa3MgdGhlIHN1YnRyZWUgKmJlZm9yZSogdXNpbmcgdGhlXG4gICAgICAgIC8vIG5hdGl2ZSBzZXR0ZXIuXG4gICAgICAgIC8qKiBAdHlwZSB7IUFycmF5PCFFbGVtZW50Pnx1bmRlZmluZWR9ICovXG4gICAgICAgIGxldCByZW1vdmVkRWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgIHJlbW92ZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyh0aGlzLCBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIHJlbW92ZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFzZURlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgaHRtbFN0cmluZyk7XG5cbiAgICAgICAgaWYgKHJlbW92ZWRFbGVtZW50cykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVtb3ZlZEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuX19DRV9zdGF0ZSA9PT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGVsZW1lbnQncyBvd25lciBkb2N1bWVudCBpc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgICBpZiAoIXRoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLnBhdGNoVHJlZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbFN0cmluZztcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBpZiAoTmF0aXZlLkVsZW1lbnRfaW5uZXJIVE1MICYmIE5hdGl2ZS5FbGVtZW50X2lubmVySFRNTC5nZXQpIHtcbiAgICBwYXRjaF9pbm5lckhUTUwoRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5FbGVtZW50X2lubmVySFRNTCk7XG4gIH0gZWxzZSBpZiAoTmF0aXZlLkhUTUxFbGVtZW50X2lubmVySFRNTCAmJiBOYXRpdmUuSFRNTEVsZW1lbnRfaW5uZXJIVE1MLmdldCkge1xuICAgIHBhdGNoX2lubmVySFRNTChIVE1MRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5IVE1MRWxlbWVudF9pbm5lckhUTUwpO1xuICB9IGVsc2Uge1xuXG4gICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gKi9cbiAgICBjb25zdCByYXdEaXYgPSBOYXRpdmUuRG9jdW1lbnRfY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCAnZGl2Jyk7XG5cbiAgICBpbnRlcm5hbHMuYWRkUGF0Y2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcGF0Y2hfaW5uZXJIVE1MKGVsZW1lbnQsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAvLyBJbXBsZW1lbnRzIGdldHRpbmcgYGlubmVySFRNTGAgYnkgcGVyZm9ybWluZyBhbiB1bnBhdGNoZWQgYGNsb25lTm9kZWBcbiAgICAgICAgLy8gb2YgdGhlIGVsZW1lbnQgYW5kIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIGVsZW1lbnQncyBgaW5uZXJIVE1MYC5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB0b28gZXhwZW5zaXZlP1xuICAgICAgICBnZXQ6IC8qKiBAdGhpcyB7RWxlbWVudH0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE5hdGl2ZS5Ob2RlX2Nsb25lTm9kZS5jYWxsKHRoaXMsIHRydWUpLmlubmVySFRNTDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gSW1wbGVtZW50cyBzZXR0aW5nIGBpbm5lckhUTUxgIGJ5IGNyZWF0aW5nIGFuIHVucGF0Y2hlZCBlbGVtZW50LFxuICAgICAgICAvLyBzZXR0aW5nIGBpbm5lckhUTUxgIG9mIHRoYXQgZWxlbWVudCBhbmQgcmVwbGFjaW5nIHRoZSB0YXJnZXRcbiAgICAgICAgLy8gZWxlbWVudCdzIGNoaWxkcmVuIHdpdGggdGhvc2Ugb2YgdGhlIHVucGF0Y2hlZCBlbGVtZW50LlxuICAgICAgICBzZXQ6IC8qKiBAdGhpcyB7RWxlbWVudH0gKi8gZnVuY3Rpb24oYXNzaWduZWRWYWx1ZSkge1xuICAgICAgICAgIC8vIE5PVEU6IHJlLXJvdXRlIHRvIGBjb250ZW50YCBmb3IgYHRlbXBsYXRlYCBlbGVtZW50cy5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYmVjYXVzZSBgdGVtcGxhdGUuYXBwZW5kQ2hpbGRgIGRvZXMgbm90XG4gICAgICAgICAgLy8gcm91dGUgaW50byBgdGVtcGxhdGUuY29udGVudGAuXG4gICAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi9cbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScgPyAoLyoqIEB0eXBlIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKHRoaXMpKS5jb250ZW50IDogdGhpcztcbiAgICAgICAgICByYXdEaXYuaW5uZXJIVE1MID0gYXNzaWduZWRWYWx1ZTtcblxuICAgICAgICAgIHdoaWxlIChjb250ZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgTmF0aXZlLk5vZGVfcmVtb3ZlQ2hpbGQuY2FsbChjb250ZW50LCBjb250ZW50LmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocmF3RGl2LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgTmF0aXZlLk5vZGVfYXBwZW5kQ2hpbGQuY2FsbChjb250ZW50LCByYXdEaXYuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3NldEF0dHJpYnV0ZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lLCBuZXdWYWx1ZSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgcmV0dXJuIE5hdGl2ZS5FbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIE5hdGl2ZS5FbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIG5ld1ZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbnVsbCk7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAnc2V0QXR0cmlidXRlTlMnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lc3BhY2UsIG5hbWUsIG5ld1ZhbHVlKSB7XG4gICAgICAvLyBGYXN0IHBhdGggZm9yIG5vbi1jdXN0b20gZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5fX0NFX3N0YXRlICE9PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICByZXR1cm4gTmF0aXZlLkVsZW1lbnRfc2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICBOYXRpdmUuRWxlbWVudF9zZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgbmV3VmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKTtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdyZW1vdmVBdHRyaWJ1dGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgcmV0dXJuIE5hdGl2ZS5FbGVtZW50X3JlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgTmF0aXZlLkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbnVsbCwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAncmVtb3ZlQXR0cmlidXRlTlMnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lc3BhY2UsIG5hbWUpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igbm9uLWN1c3RvbSBlbGVtZW50cy5cbiAgICAgIGlmICh0aGlzLl9fQ0Vfc3RhdGUgIT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHJldHVybiBOYXRpdmUuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgTmF0aXZlLkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgLy8gSW4gb2xkZXIgYnJvd3NlcnMsIGBFbGVtZW50I2dldEF0dHJpYnV0ZU5TYCBtYXkgcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAgIC8vIGluc3RlYWQgb2YgbnVsbCBpZiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LiBGb3IgZGV0YWlscywgc2VlO1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0QXR0cmlidXRlTlMjTm90ZXNcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gIGZ1bmN0aW9uIHBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudChkZXN0aW5hdGlvbiwgYmFzZU1ldGhvZCkge1xuICAgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChkZXN0aW5hdGlvbiwgJ2luc2VydEFkamFjZW50RWxlbWVudCcsXG4gICAgICAvKipcbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdoZXJlXG4gICAgICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAgICAgKiBAcmV0dXJuIHs/RWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24od2hlcmUsIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgd2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBpbnNlcnRlZEVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL1xuICAgICAgICAgIChiYXNlTWV0aG9kLmNhbGwodGhpcywgd2hlcmUsIGVsZW1lbnQpKTtcblxuICAgICAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZChpbnNlcnRlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNlcnRlZEVsZW1lbnQ7XG4gICAgICB9KTtcbiAgfVxuXG4gIGlmIChOYXRpdmUuSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KSB7XG4gICAgcGF0Y2hfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgTmF0aXZlLkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCk7XG4gIH0gZWxzZSBpZiAoTmF0aXZlLkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KSB7XG4gICAgcGF0Y2hfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KEVsZW1lbnQucHJvdG90eXBlLCBOYXRpdmUuRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIEVsZW1lbnRzOiBgRWxlbWVudCNpbnNlcnRBZGphY2VudEVsZW1lbnRgIHdhcyBub3QgcGF0Y2hlZC4nKTtcbiAgfVxuXG5cbiAgUGF0Y2hQYXJlbnROb2RlKGludGVybmFscywgRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICBwcmVwZW5kOiBOYXRpdmUuRWxlbWVudF9wcmVwZW5kLFxuICAgIGFwcGVuZDogTmF0aXZlLkVsZW1lbnRfYXBwZW5kLFxuICB9KTtcblxuICBQYXRjaENoaWxkTm9kZShpbnRlcm5hbHMsIEVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgYmVmb3JlOiBOYXRpdmUuRWxlbWVudF9iZWZvcmUsXG4gICAgYWZ0ZXI6IE5hdGl2ZS5FbGVtZW50X2FmdGVyLFxuICAgIHJlcGxhY2VXaXRoOiBOYXRpdmUuRWxlbWVudF9yZXBsYWNlV2l0aCxcbiAgICByZW1vdmU6IE5hdGl2ZS5FbGVtZW50X3JlbW92ZSxcbiAgfSk7XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbmltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IGZyb20gJy4vQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LmpzJztcblxuaW1wb3J0IFBhdGNoSFRNTEVsZW1lbnQgZnJvbSAnLi9QYXRjaC9IVE1MRWxlbWVudC5qcyc7XG5pbXBvcnQgUGF0Y2hEb2N1bWVudCBmcm9tICcuL1BhdGNoL0RvY3VtZW50LmpzJztcbmltcG9ydCBQYXRjaE5vZGUgZnJvbSAnLi9QYXRjaC9Ob2RlLmpzJztcbmltcG9ydCBQYXRjaEVsZW1lbnQgZnJvbSAnLi9QYXRjaC9FbGVtZW50LmpzJztcblxuY29uc3QgcHJpb3JDdXN0b21FbGVtZW50cyA9IHdpbmRvd1snY3VzdG9tRWxlbWVudHMnXTtcblxuaWYgKCFwcmlvckN1c3RvbUVsZW1lbnRzIHx8XG4gICAgIHByaW9yQ3VzdG9tRWxlbWVudHNbJ2ZvcmNlUG9seWZpbGwnXSB8fFxuICAgICAodHlwZW9mIHByaW9yQ3VzdG9tRWxlbWVudHNbJ2RlZmluZSddICE9ICdmdW5jdGlvbicpIHx8XG4gICAgICh0eXBlb2YgcHJpb3JDdXN0b21FbGVtZW50c1snZ2V0J10gIT0gJ2Z1bmN0aW9uJykpIHtcbiAgLyoqIEB0eXBlIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gKi9cbiAgY29uc3QgaW50ZXJuYWxzID0gbmV3IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMoKTtcblxuICBQYXRjaEhUTUxFbGVtZW50KGludGVybmFscyk7XG4gIFBhdGNoRG9jdW1lbnQoaW50ZXJuYWxzKTtcbiAgUGF0Y2hOb2RlKGludGVybmFscyk7XG4gIFBhdGNoRWxlbWVudChpbnRlcm5hbHMpO1xuXG4gIC8vIFRoZSBtYWluIGRvY3VtZW50IGlzIGFsd2F5cyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICBkb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5ID0gdHJ1ZTtcblxuICAvKiogQHR5cGUgeyFDdXN0b21FbGVtZW50UmVnaXN0cnl9ICovXG4gIGNvbnN0IGN1c3RvbUVsZW1lbnRzID0gbmV3IEN1c3RvbUVsZW1lbnRSZWdpc3RyeShpbnRlcm5hbHMpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdjdXN0b21FbGVtZW50cycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3VzdG9tRWxlbWVudHMsXG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vLyBAdmVyc2lvbiAwLjcuMjJcbmlmICh0eXBlb2YgV2Vha01hcCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIHZhciBjb3VudGVyID0gRGF0ZS5ub3coKSAlIDFlOTtcbiAgICB2YXIgV2Vha01hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5uYW1lID0gXCJfX3N0XCIgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCkgKyAoY291bnRlcisrICsgXCJfX1wiKTtcbiAgICB9O1xuICAgIFdlYWtNYXAucHJvdG90eXBlID0ge1xuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAoZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSkgZW50cnlbMV0gPSB2YWx1ZTsgZWxzZSBkZWZpbmVQcm9wZXJ0eShrZXksIHRoaXMubmFtZSwge1xuICAgICAgICAgIHZhbHVlOiBbIGtleSwgdmFsdWUgXSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICByZXR1cm4gKGVudHJ5ID0ga2V5W3RoaXMubmFtZV0pICYmIGVudHJ5WzBdID09PSBrZXkgPyBlbnRyeVsxXSA6IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBcImRlbGV0ZVwiOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG4gICAgICAgIGlmICghZW50cnkgfHwgZW50cnlbMF0gIT09IGtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbnRyeVswXSA9IGVudHJ5WzFdID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcbiAgICAgICAgaWYgKCFlbnRyeSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZW50cnlbMF0gPT09IGtleTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5XZWFrTWFwID0gV2Vha01hcDtcbiAgfSkoKTtcbn1cblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBpZiAoZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVnaXN0cmF0aW9uc1RhYmxlID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHNldEltbWVkaWF0ZTtcbiAgaWYgKC9UcmlkZW50fEVkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSBzZXRUaW1lb3V0O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgIHZhciBzZW50aW5lbCA9IFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuZGF0YSA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gc2V0SW1tZWRpYXRlUXVldWU7XG4gICAgICAgIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgc2V0SW1tZWRpYXRlUXVldWUucHVzaChmdW5jKTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShzZW50aW5lbCwgXCIqXCIpO1xuICAgIH07XG4gIH1cbiAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhvYnNlcnZlcikge1xuICAgIHNjaGVkdWxlZE9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRJbW1lZGlhdGUoZGlzcGF0Y2hDYWxsYmFja3MpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3cmFwSWZOZWVkZWQobm9kZSkge1xuICAgIHJldHVybiB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsLndyYXBJZk5lZWRlZChub2RlKSB8fCBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2tzKCkge1xuICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIG9ic2VydmVycyA9IHNjaGVkdWxlZE9ic2VydmVycztcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgICBvYnNlcnZlcnMuc29ydChmdW5jdGlvbihvMSwgbzIpIHtcbiAgICAgIHJldHVybiBvMS51aWRfIC0gbzIudWlkXztcbiAgICB9KTtcbiAgICB2YXIgYW55Tm9uRW1wdHkgPSBmYWxzZTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgdmFyIHF1ZXVlID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcik7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrXyhxdWV1ZSwgb2JzZXJ2ZXIpO1xuICAgICAgICBhbnlOb25FbXB0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGFueU5vbkVtcHR5KSBkaXNwYXRjaENhbGxiYWNrcygpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmV0dXJuO1xuICAgICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSBvYnNlcnZlcikgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBub2RlID0gdGFyZ2V0OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAocmVnaXN0cmF0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tqXTtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHJlZ2lzdHJhdGlvbi5vcHRpb25zO1xuICAgICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQgJiYgIW9wdGlvbnMuc3VidHJlZSkgY29udGludWU7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGNhbGxiYWNrKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChyZWNvcmQpIHJlZ2lzdHJhdGlvbi5lbnF1ZXVlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBKc011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIHRoaXMubm9kZXNfID0gW107XG4gICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIHRoaXMudWlkXyA9ICsrdWlkQ291bnRlcjtcbiAgfVxuICBKc011dGF0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICAgIG9ic2VydmU6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdGFyZ2V0ID0gd3JhcElmTmVlZGVkKHRhcmdldCk7XG4gICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0ICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSB8fCBvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldCh0YXJnZXQpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KHRhcmdldCwgcmVnaXN0cmF0aW9ucyA9IFtdKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb247XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbiA9IG5ldyBSZWdpc3RyYXRpb24odGhpcywgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHJlZ2lzdHJhdGlvbik7XG4gICAgICAgIHRoaXMubm9kZXNfLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJhdGlvbi5hZGRMaXN0ZW5lcnMoKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIH0sXG4gICAgdGFrZVJlY29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHlPZlJlY29yZHMgPSB0aGlzLnJlY29yZHNfO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgICAgcmV0dXJuIGNvcHlPZlJlY29yZHM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBudWxsO1xuICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHlNdXRhdGlvblJlY29yZChvcmlnaW5hbCkge1xuICAgIHZhciByZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQob3JpZ2luYWwudHlwZSwgb3JpZ2luYWwudGFyZ2V0KTtcbiAgICByZWNvcmQuYWRkZWROb2RlcyA9IG9yaWdpbmFsLmFkZGVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gb3JpZ2luYWwucmVtb3ZlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IG9yaWdpbmFsLnByZXZpb3VzU2libGluZztcbiAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBvcmlnaW5hbC5uZXh0U2libGluZztcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWU7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICByZWNvcmQub2xkVmFsdWUgPSBvcmlnaW5hbC5vbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG4gIHZhciBjdXJyZW50UmVjb3JkLCByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIGZ1bmN0aW9uIGdldFJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gY3VycmVudFJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSkge1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmVjb3JkV2l0aE9sZFZhbHVlID0gY29weU11dGF0aW9uUmVjb3JkKGN1cnJlbnRSZWNvcmQpO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZS5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJSZWNvcmRzKCkge1xuICAgIGN1cnJlbnRSZWNvcmQgPSByZWNvcmRXaXRoT2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkID09PSByZWNvcmRXaXRoT2xkVmFsdWUgfHwgcmVjb3JkID09PSBjdXJyZW50UmVjb3JkO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCBuZXdSZWNvcmQpIHtcbiAgICBpZiAobGFzdFJlY29yZCA9PT0gbmV3UmVjb3JkKSByZXR1cm4gbGFzdFJlY29yZDtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlICYmIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24obGFzdFJlY29yZCkpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gUmVnaXN0cmF0aW9uKG9ic2VydmVyLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgfVxuICBSZWdpc3RyYXRpb24ucHJvdG90eXBlID0ge1xuICAgIGVucXVldWU6IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLm9ic2VydmVyLnJlY29yZHNfO1xuICAgICAgdmFyIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoO1xuICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbGFzdFJlY29yZCA9IHJlY29yZHNbbGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByZWNvcmRUb1JlcGxhY2VMYXN0ID0gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIHJlY29yZCk7XG4gICAgICAgIGlmIChyZWNvcmRUb1JlcGxhY2VMYXN0KSB7XG4gICAgICAgICAgcmVjb3Jkc1tsZW5ndGggLSAxXSA9IHJlY29yZFRvUmVwbGFjZUxhc3Q7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgICAgcmVjb3Jkc1tsZW5ndGhdID0gcmVjb3JkO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZFRyYW5zaWVudE9ic2VydmVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy50YXJnZXQpIHJldHVybjtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KG5vZGUsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICByZWdpc3RyYXRpb25zLnB1c2godGhpcyk7XG4gICAgfSxcbiAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXM7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgICAgIHRyYW5zaWVudE9ic2VydmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXSA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgIGNhc2UgXCJET01BdHRyTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIG5hbWUgPSBlLmF0dHJOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gZS5yZWxhdGVkTm9kZS5uYW1lc3BhY2VVUkk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBnZXRSZWNvcmQoXCJhdHRyaWJ1dGVzXCIsIHRhcmdldCk7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5hdHRyQ2hhbmdlID09PSBNdXRhdGlvbkV2ZW50LkFERElUSU9OID8gbnVsbCA6IGUucHJldlZhbHVlO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpIHJldHVybjtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZSkgPT09IC0xICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hhcmFjdGVyRGF0YVwiLCB0YXJnZXQpO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZVJlbW92ZWRcIjpcbiAgICAgICAgdGhpcy5hZGRUcmFuc2llbnRPYnNlcnZlcihlLnRhcmdldCk7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZUluc2VydGVkXCI6XG4gICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzO1xuICAgICAgICBpZiAoZS50eXBlID09PSBcIkRPTU5vZGVJbnNlcnRlZFwiKSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlZE5vZGVzID0gW107XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBjaGFuZ2VkTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNoYW5nZWROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hpbGRMaXN0XCIsIGUudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgICByZWNvcmQuYWRkZWROb2RlcyA9IGFkZGVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHJlY29yZC5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQoZS5yZWxhdGVkTm9kZSwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNsZWFyUmVjb3JkcygpO1xuICAgIH1cbiAgfTtcbiAgZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgaWYgKCFnbG9iYWwuTXV0YXRpb25PYnNlcnZlcikge1xuICAgIGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xuICAgIEpzTXV0YXRpb25PYnNlcnZlci5faXNQb2x5ZmlsbGVkID0gdHJ1ZTtcbiAgfVxufSkoc2VsZik7IiwiLypcbkNvcHlyaWdodCAoYykgMjAxMiBCYXJuZXNhbmRub2JsZS5jb20sIGxsYywgRG9uYXZvbiBXZXN0LCBhbmQgRG9tZW5pYyBEZW5pY29sYVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4qL1xuKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgc2V0SW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmdzKSB7XG4gICAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSBwYXJ0aWFsbHlBcHBsaWVkLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhY2NlcHRzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBzZXRJbW1lZGlhdGUsIGJ1dFxuICAgIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIG5vIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBwYXJ0aWFsbHlBcHBsaWVkKGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAobmV3IEZ1bmN0aW9uKFwiXCIgKyBoYW5kbGVyKSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHNlbGYpKTtcbiIsIi8vIENhdXRpb246XG4vLyBEbyBub3QgcmVwbGFjZSB0aGlzIGltcG9ydCBzdGF0ZW1lbnQgd2l0aCBjb2Rlcy5cbi8vXG4vLyBJZiB5b3UgcmVwbGFjZSB0aGlzIGltcG9ydCBzdGF0ZW1lbnQgd2l0aCBjb2Rlcyxcbi8vIHRoZSBjb2RlcyB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBmb2xsb3dpbmcgcG9seWZpbGxzIGFyZSBpbXBvcnRlZFxuLy8gYmVjYXVzZSBpbXBvcnQgc3RhdGVtZW50cyBhcmUgaG9pc3RlZCBkdXJpbmcgY29tcGlsYXRpb24uXG5pbXBvcnQgJy4vcG9seWZpbGwtc3dpdGNoZXMnO1xuXG4vLyBQb2x5ZmlsbCBFQ01BU2NyaXB0IHN0YW5kYXJkIGZlYXR1cmVzIHdpdGggZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb25cbmltcG9ydCAnY29yZS1qcy9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZic7XG5pbXBvcnQgJ2NvcmUtanMvZm4vc2V0JztcbmltcG9ydCAnY29yZS1qcy9mbi9tYXAnO1xuXG4vLyBQb2x5ZmlsbCBDdXN0b20gRWxlbWVudHMgdjEgd2l0aCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvblxuaW1wb3J0ICdAb25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL2N1c3RvbS1lbGVtZW50cyc7XG5cbi8vIFBvbHlmaWxsIE11dGF0aW9uT2JzZXJ2ZXIgd2l0aCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvblxuaW1wb3J0ICcuL011dGF0aW9uT2JzZXJ2ZXJAMC43LjIyL011dGF0aW9uT2JzZXJ2ZXIuanMnO1xuXG4vLyBQb2x5ZmlsbCBzZXRJbW1lZGlhdGUgd2l0aCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvblxuaW1wb3J0ICcuL3NldEltbWVkaWF0ZUAxLjAuMittb2Qvc2V0SW1tZWRpYXRlLmpzJztcbiIsIjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXplIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIHRvdWNoIHN0YXJ0LCByZWNvcmQgdGhlIHBvc2l0aW9uIGFuZCBzY3JvbGwgb2Zmc2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0RWxlbWVudCwgdG91Y2gsIHNlbGVjdGlvbjtcblxuXHRcdC8vIElnbm9yZSBtdWx0aXBsZSB0b3VjaGVzLCBvdGhlcndpc2UgcGluY2gtdG8tem9vbSBpcyBwcmV2ZW50ZWQgaWYgYm90aCBmaW5nZXJzIGFyZSBvbiB0aGUgRmFzdENsaWNrIGVsZW1lbnQgKGlzc3VlICMxMTEpLlxuXHRcdGlmIChldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHRhcmdldEVsZW1lbnQgPSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KTtcblx0XHR0b3VjaCA9IGV2ZW50LnRhcmdldFRvdWNoZXNbMF07XG5cblx0XHQvLyBJZ25vcmUgdG91Y2hlcyBvbiBjb250ZW50ZWRpdGFibGUgZWxlbWVudHMgdG8gcHJldmVudCBjb25mbGljdCB3aXRoIHRleHQgc2VsZWN0aW9uLlxuXHRcdC8vIChGb3IgZGV0YWlsczogaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svcHVsbC8yMTEgKVxuXHRcdGlmICh0YXJnZXRFbGVtZW50LmlzQ29udGVudEVkaXRhYmxlKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNJT1MpIHtcblxuXHRcdFx0Ly8gT25seSB0cnVzdGVkIGV2ZW50cyB3aWxsIGRlc2VsZWN0IHRleHQgb24gaU9TIChpc3N1ZSAjNDkpXG5cdFx0XHRzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQpIHtcblxuXHRcdFx0XHQvLyBXZWlyZCB0aGluZ3MgaGFwcGVuIG9uIGlPUyB3aGVuIGFuIGFsZXJ0IG9yIGNvbmZpcm0gZGlhbG9nIGlzIG9wZW5lZCBmcm9tIGEgY2xpY2sgZXZlbnQgY2FsbGJhY2sgKGlzc3VlICMyMyk6XG5cdFx0XHRcdC8vIHdoZW4gdGhlIHVzZXIgbmV4dCB0YXBzIGFueXdoZXJlIGVsc2Ugb24gdGhlIHBhZ2UsIG5ldyB0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCBldmVudHMgYXJlIGRpc3BhdGNoZWRcblx0XHRcdFx0Ly8gd2l0aCB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIHRoZSB0b3VjaCBldmVudCB0aGF0IHByZXZpb3VzbHkgdHJpZ2dlcmVkIHRoZSBjbGljayB0aGF0IHRyaWdnZXJlZCB0aGUgYWxlcnQuXG5cdFx0XHRcdC8vIFNhZGx5LCB0aGVyZSBpcyBhbiBpc3N1ZSBvbiBpT1MgNCB0aGF0IGNhdXNlcyBzb21lIG5vcm1hbCB0b3VjaCBldmVudHMgdG8gaGF2ZSB0aGUgc2FtZSBpZGVudGlmaWVyIGFzIGFuXG5cdFx0XHRcdC8vIGltbWVkaWF0ZWx5IHByZWNlZGluZyB0b3VjaCBldmVudCAoaXNzdWUgIzUyKSwgc28gdGhpcyBmaXggaXMgdW5hdmFpbGFibGUgb24gdGhhdCBwbGF0Zm9ybS5cblx0XHRcdFx0Ly8gSXNzdWUgMTIwOiB0b3VjaC5pZGVudGlmaWVyIGlzIDAgd2hlbiBDaHJvbWUgZGV2IHRvb2xzICdFbXVsYXRlIHRvdWNoIGV2ZW50cycgaXMgc2V0IHdpdGggYW4gaU9TIGRldmljZSBVQSBzdHJpbmcsXG5cdFx0XHRcdC8vIHdoaWNoIGNhdXNlcyBhbGwgdG91Y2ggZXZlbnRzIHRvIGJlIGlnbm9yZWQuIEFzIHRoaXMgYmxvY2sgb25seSBhcHBsaWVzIHRvIGlPUywgYW5kIGlPUyBpZGVudGlmaWVycyBhcmUgYWx3YXlzIGxvbmcsXG5cdFx0XHRcdC8vIHJhbmRvbSBpbnRlZ2VycywgaXQncyBzYWZlIHRvIHRvIGNvbnRpbnVlIGlmIHRoZSBpZGVudGlmaWVyIGlzIDAgaGVyZS5cblx0XHRcdFx0aWYgKHRvdWNoLmlkZW50aWZpZXIgJiYgdG91Y2guaWRlbnRpZmllciA9PT0gdGhpcy5sYXN0VG91Y2hJZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuXG5cdFx0XHRcdC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIGEgc2Nyb2xsYWJsZSBsYXllciAodXNpbmcgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoKSBhbmQ6XG5cdFx0XHRcdC8vIDEpIHRoZSB1c2VyIGRvZXMgYSBmbGluZyBzY3JvbGwgb24gdGhlIHNjcm9sbGFibGUgbGF5ZXJcblx0XHRcdFx0Ly8gMikgdGhlIHVzZXIgc3RvcHMgdGhlIGZsaW5nIHNjcm9sbCB3aXRoIGFub3RoZXIgdGFwXG5cdFx0XHRcdC8vIHRoZW4gdGhlIGV2ZW50LnRhcmdldCBvZiB0aGUgbGFzdCAndG91Y2hlbmQnIGV2ZW50IHdpbGwgYmUgdGhlIGVsZW1lbnQgdGhhdCB3YXMgdW5kZXIgdGhlIHVzZXIncyBmaW5nZXJcblx0XHRcdFx0Ly8gd2hlbiB0aGUgZmxpbmcgc2Nyb2xsIHdhcyBzdGFydGVkLCBjYXVzaW5nIEZhc3RDbGljayB0byBzZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhhdCBsYXllciAtIHVubGVzcyBhIGNoZWNrXG5cdFx0XHRcdC8vIGlzIG1hZGUgdG8gZW5zdXJlIHRoYXQgYSBwYXJlbnQgbGF5ZXIgd2FzIG5vdCBzY3JvbGxlZCBiZWZvcmUgc2VuZGluZyBhIHN5bnRoZXRpYyBjbGljayAoaXNzdWUgIzQyKS5cblx0XHRcdFx0dGhpcy51cGRhdGVTY3JvbGxQYXJlbnQodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gdHJ1ZTtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCA9IGV2ZW50LnRpbWVTdGFtcDtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IHRvdWNoLnBhZ2VYO1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSB0b3VjaC5wYWdlWTtcblxuXHRcdC8vIFByZXZlbnQgcGhhbnRvbSBjbGlja3Mgb24gZmFzdCBkb3VibGUtdGFwIChpc3N1ZSAjMzYpXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpIDwgdGhpcy50YXBEZWxheSAmJiAoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA+IC0xKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEJhc2VkIG9uIGEgdG91Y2htb3ZlIGV2ZW50IG9iamVjdCwgY2hlY2sgd2hldGhlciB0aGUgdG91Y2ggaGFzIG1vdmVkIHBhc3QgYSBib3VuZGFyeSBzaW5jZSBpdCBzdGFydGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUudG91Y2hIYXNNb3ZlZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0sIGJvdW5kYXJ5ID0gdGhpcy50b3VjaEJvdW5kYXJ5O1xuXG5cdFx0aWYgKE1hdGguYWJzKHRvdWNoLnBhZ2VYIC0gdGhpcy50b3VjaFN0YXJ0WCkgPiBib3VuZGFyeSB8fCBNYXRoLmFicyh0b3VjaC5wYWdlWSAtIHRoaXMudG91Y2hTdGFydFkpID4gYm91bmRhcnkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGxhc3QgcG9zaXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoTW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLnRyYWNraW5nQ2xpY2spIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSB0b3VjaCBoYXMgbW92ZWQsIGNhbmNlbCB0aGUgY2xpY2sgdHJhY2tpbmdcblx0XHRpZiAodGhpcy50YXJnZXRFbGVtZW50ICE9PSB0aGlzLmdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQoZXZlbnQudGFyZ2V0KSB8fCB0aGlzLnRvdWNoSGFzTW92ZWQoZXZlbnQpKSB7XG5cdFx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBmaW5kIHRoZSBsYWJlbGxlZCBjb250cm9sIGZvciB0aGUgZ2l2ZW4gbGFiZWwgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxIVE1MTGFiZWxFbGVtZW50fSBsYWJlbEVsZW1lbnRcblx0ICogQHJldHVybnMge0VsZW1lbnR8bnVsbH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZmluZENvbnRyb2wgPSBmdW5jdGlvbihsYWJlbEVsZW1lbnQpIHtcblxuXHRcdC8vIEZhc3QgcGF0aCBmb3IgbmV3ZXIgYnJvd3NlcnMgc3VwcG9ydGluZyB0aGUgSFRNTDUgY29udHJvbCBhdHRyaWJ1dGVcblx0XHRpZiAobGFiZWxFbGVtZW50LmNvbnRyb2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGxhYmVsRWxlbWVudC5jb250cm9sO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBicm93c2VycyB1bmRlciB0ZXN0IHRoYXQgc3VwcG9ydCB0b3VjaCBldmVudHMgYWxzbyBzdXBwb3J0IHRoZSBIVE1MNSBodG1sRm9yIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuaHRtbEZvcikge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGxhYmVsRWxlbWVudC5odG1sRm9yKTtcblx0XHR9XG5cblx0XHQvLyBJZiBubyBmb3IgYXR0cmlidXRlIGV4aXN0cywgYXR0ZW1wdCB0byByZXRyaWV2ZSB0aGUgZmlyc3QgbGFiZWxsYWJsZSBkZXNjZW5kYW50IGVsZW1lbnRcblx0XHQvLyB0aGUgbGlzdCBvZiB3aGljaCBpcyBkZWZpbmVkIGhlcmU6IGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGFiZWxcblx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbiwgaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pLCBrZXlnZW4sIG1ldGVyLCBvdXRwdXQsIHByb2dyZXNzLCBzZWxlY3QsIHRleHRhcmVhJyk7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggZW5kLCBkZXRlcm1pbmUgd2hldGhlciB0byBzZW5kIGEgY2xpY2sgZXZlbnQgYXQgb25jZS5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBmb3JFbGVtZW50LCB0cmFja2luZ0NsaWNrU3RhcnQsIHRhcmdldFRhZ05hbWUsIHNjcm9sbFBhcmVudCwgdG91Y2gsIHRhcmdldEVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQ7XG5cblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcblx0XHRcdHRoaXMuY2FuY2VsTmV4dENsaWNrID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQpID4gdGhpcy50YXBUaW1lb3V0KSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBSZXNldCB0byBwcmV2ZW50IHdyb25nIGNsaWNrIGNhbmNlbCBvbiBpbnB1dCAoaXNzdWUgIzE1NikuXG5cdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSBmYWxzZTtcblxuXHRcdHRoaXMubGFzdENsaWNrVGltZSA9IGV2ZW50LnRpbWVTdGFtcDtcblxuXHRcdHRyYWNraW5nQ2xpY2tTdGFydCA9IHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0O1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXHRcdC8vIE9uIHNvbWUgaU9TIGRldmljZXMsIHRoZSB0YXJnZXRFbGVtZW50IHN1cHBsaWVkIHdpdGggdGhlIGV2ZW50IGlzIGludmFsaWQgaWYgdGhlIGxheWVyXG5cdFx0Ly8gaXMgcGVyZm9ybWluZyBhIHRyYW5zaXRpb24gb3Igc2Nyb2xsLCBhbmQgaGFzIHRvIGJlIHJlLWRldGVjdGVkIG1hbnVhbGx5LiBOb3RlIHRoYXRcblx0XHQvLyBmb3IgdGhpcyB0byBmdW5jdGlvbiBjb3JyZWN0bHksIGl0IG11c3QgYmUgY2FsbGVkICphZnRlciogdGhlIGV2ZW50IHRhcmdldCBpcyBjaGVja2VkIVxuXHRcdC8vIFNlZSBpc3N1ZSAjNTc7IGFsc28gZmlsZWQgYXMgcmRhcjovLzEzMDQ4NTg5IC5cblx0XHRpZiAoZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0KSB7XG5cdFx0XHR0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuXG5cdFx0XHQvLyBJbiBjZXJ0YWluIGNhc2VzIGFyZ3VtZW50cyBvZiBlbGVtZW50RnJvbVBvaW50IGNhbiBiZSBuZWdhdGl2ZSwgc28gcHJldmVudCBzZXR0aW5nIHRhcmdldEVsZW1lbnQgdG8gbnVsbFxuXHRcdFx0dGFyZ2V0RWxlbWVudCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2gucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIHRvdWNoLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KSB8fCB0YXJnZXRFbGVtZW50O1xuXHRcdFx0dGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuZmFzdENsaWNrU2Nyb2xsUGFyZW50O1xuXHRcdH1cblxuXHRcdHRhcmdldFRhZ05hbWUgPSB0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRpZiAodGFyZ2V0VGFnTmFtZSA9PT0gJ2xhYmVsJykge1xuXHRcdFx0Zm9yRWxlbWVudCA9IHRoaXMuZmluZENvbnRyb2wodGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRpZiAoZm9yRWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGFyZ2V0RWxlbWVudCA9IGZvckVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm5lZWRzRm9jdXModGFyZ2V0RWxlbWVudCkpIHtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBJZiB0aGUgdG91Y2ggc3RhcnRlZCBhIHdoaWxlIGFnbyAoYmVzdCBndWVzcyBpcyAxMDBtcyBiYXNlZCBvbiB0ZXN0cyBmb3IgaXNzdWUgIzM2KSB0aGVuIGZvY3VzIHdpbGwgYmUgdHJpZ2dlcmVkIGFueXdheS4gUmV0dXJuIGVhcmx5IGFuZCB1bnNldCB0aGUgdGFyZ2V0IGVsZW1lbnQgcmVmZXJlbmNlIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgY2xpY2sgd2lsbCBiZSBhbGxvd2VkIHRocm91Z2guXG5cdFx0XHQvLyBDYXNlIDI6IFdpdGhvdXQgdGhpcyBleGNlcHRpb24gZm9yIGlucHV0IGVsZW1lbnRzIHRhcHBlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBjb250YWluZWQgaW4gYW4gaWZyYW1lLCB0aGVuIGFueSBpbnB1dHRlZCB0ZXh0IHdvbid0IGJlIHZpc2libGUgZXZlbiB0aG91Z2ggdGhlIHZhbHVlIGF0dHJpYnV0ZSBpcyB1cGRhdGVkIGFzIHRoZSB1c2VyIHR5cGVzIChpc3N1ZSAjMzcpLlxuXHRcdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0cmFja2luZ0NsaWNrU3RhcnQpID4gMTAwIHx8IChkZXZpY2VJc0lPUyAmJiB3aW5kb3cudG9wICE9PSB3aW5kb3cgJiYgdGFyZ2V0VGFnTmFtZSA9PT0gJ2lucHV0JykpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmZvY3VzKHRhcmdldEVsZW1lbnQpO1xuXHRcdFx0dGhpcy5zZW5kQ2xpY2sodGFyZ2V0RWxlbWVudCwgZXZlbnQpO1xuXG5cdFx0XHQvLyBTZWxlY3QgZWxlbWVudHMgbmVlZCB0aGUgZXZlbnQgdG8gZ28gdGhyb3VnaCBvbiBpT1MgNCwgb3RoZXJ3aXNlIHRoZSBzZWxlY3RvciBtZW51IHdvbid0IG9wZW4uXG5cdFx0XHQvLyBBbHNvIHRoaXMgYnJlYWtzIG9wZW5pbmcgc2VsZWN0cyB3aGVuIFZvaWNlT3ZlciBpcyBhY3RpdmUgb24gaU9TNiwgaU9TNyAoYW5kIHBvc3NpYmx5IG90aGVycylcblx0XHRcdGlmICghZGV2aWNlSXNJT1MgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvciBvbiBpT1MgKGlzc3VlICMxOCk6IGlmIGEgc3VibWl0IGVsZW1lbnQgaXMgcHJlc2VudCBpbnNpZGUgYSBmb3JtIGFuZCB0aGUgdXNlciBoaXRzIGVudGVyIGluIHRoZSBpT1Mgc2ltdWxhdG9yIG9yIGNsaWNrcyB0aGUgR28gYnV0dG9uIG9uIHRoZSBwb3AtdXAgT1Mga2V5Ym9hcmQgdGhlIGEga2luZCBvZiAnZmFrZScgY2xpY2sgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgd2l0aCB0aGUgc3VibWl0LXR5cGUgaW5wdXQgZWxlbWVudCBhcyB0aGUgdGFyZ2V0LlxuXHRcdGlmIChldmVudC50YXJnZXQudHlwZSA9PT0gJ3N1Ym1pdCcgJiYgZXZlbnQuZGV0YWlsID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRwZXJtaXR0ZWQgPSB0aGlzLm9uTW91c2UoZXZlbnQpO1xuXG5cdFx0Ly8gT25seSB1bnNldCB0YXJnZXRFbGVtZW50IGlmIHRoZSBjbGljayBpcyBub3QgcGVybWl0dGVkLiBUaGlzIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGNoZWNrIGZvciAhdGFyZ2V0RWxlbWVudCBpbiBvbk1vdXNlIGZhaWxzIGFuZCB0aGUgYnJvd3NlcidzIGNsaWNrIGRvZXNuJ3QgZ28gdGhyb3VnaC5cblx0XHRpZiAoIXBlcm1pdHRlZCkge1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBJZiBjbGlja3MgYXJlIHBlcm1pdHRlZCwgcmV0dXJuIHRydWUgZm9yIHRoZSBhY3Rpb24gdG8gZ28gdGhyb3VnaC5cblx0XHRyZXR1cm4gcGVybWl0dGVkO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbGwgRmFzdENsaWNrJ3MgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXllciA9IHRoaXMubGF5ZXI7XG5cblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgRmFzdENsaWNrIGlzIG5lZWRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqL1xuXHRGYXN0Q2xpY2subm90TmVlZGVkID0gZnVuY3Rpb24obGF5ZXIpIHtcblx0XHR2YXIgbWV0YVZpZXdwb3J0O1xuXHRcdHZhciBjaHJvbWVWZXJzaW9uO1xuXHRcdHZhciBibGFja2JlcnJ5VmVyc2lvbjtcblx0XHR2YXIgZmlyZWZveFZlcnNpb247XG5cblx0XHQvLyBEZXZpY2VzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0b3VjaCBkb24ndCBuZWVkIEZhc3RDbGlja1xuXHRcdGlmICh0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIENocm9tZSB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRjaHJvbWVWZXJzaW9uID0gKygvQ2hyb21lXFwvKFswLTldKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWywwXSlbMV07XG5cblx0XHRpZiAoY2hyb21lVmVyc2lvbikge1xuXG5cdFx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblxuXHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0KSB7XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIG9uIEFuZHJvaWQgd2l0aCB1c2VyLXNjYWxhYmxlPVwibm9cIiBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjODkpXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBDaHJvbWUgMzIgYW5kIGFib3ZlIHdpdGggd2lkdGg9ZGV2aWNlLXdpZHRoIG9yIGxlc3MgZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRcdFx0XHRpZiAoY2hyb21lVmVyc2lvbiA+IDMxICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIENocm9tZSBkZXNrdG9wIGRvZXNuJ3QgbmVlZCBGYXN0Q2xpY2sgKGlzc3VlICMxNSlcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0JsYWNrQmVycnkxMCkge1xuXHRcdFx0YmxhY2tiZXJyeVZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9WZXJzaW9uXFwvKFswLTldKilcXC4oWzAtOV0qKS8pO1xuXG5cdFx0XHQvLyBCbGFja0JlcnJ5IDEwLjMrIGRvZXMgbm90IHJlcXVpcmUgRmFzdGNsaWNrIGxpYnJhcnkuXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZnRsYWJzL2Zhc3RjbGljay9pc3N1ZXMvMjUxXG5cdFx0XHRpZiAoYmxhY2tiZXJyeVZlcnNpb25bMV0gPj0gMTAgJiYgYmxhY2tiZXJyeVZlcnNpb25bMl0gPj0gMykge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIHVzZXItc2NhbGFibGU9bm8gZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHdpZHRoPWRldmljZS13aWR0aCAob3IgbGVzcyB0aGFuIGRldmljZS13aWR0aCkgZWxpbWluYXRlcyBjbGljayBkZWxheS5cblx0XHRcdFx0XHRpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTEwIHdpdGggLW1zLXRvdWNoLWFjdGlvbjogbm9uZSBvciBtYW5pcHVsYXRpb24sIHdoaWNoIGRpc2FibGVzIGRvdWJsZS10YXAtdG8tem9vbSAoaXNzdWUgIzk3KVxuXHRcdGlmIChsYXllci5zdHlsZS5tc1RvdWNoQWN0aW9uID09PSAnbm9uZScgfHwgbGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdtYW5pcHVsYXRpb24nKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBGaXJlZm94IHZlcnNpb24gLSB6ZXJvIGZvciBvdGhlciBicm93c2Vyc1xuXHRcdGZpcmVmb3hWZXJzaW9uID0gKygvRmlyZWZveFxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGZpcmVmb3hWZXJzaW9uID49IDI3KSB7XG5cdFx0XHQvLyBGaXJlZm94IDI3KyBkb2VzIG5vdCBoYXZlIHRhcCBkZWxheSBpZiB0aGUgY29udGVudCBpcyBub3Qgem9vbWFibGUgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MjI4OTZcblxuXHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXHRcdFx0aWYgKG1ldGFWaWV3cG9ydCAmJiAobWV0YVZpZXdwb3J0LmNvbnRlbnQuaW5kZXhPZigndXNlci1zY2FsYWJsZT1ubycpICE9PSAtMSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElFMTE6IHByZWZpeGVkIC1tcy10b3VjaC1hY3Rpb24gaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgaXQncyByZWNvbW1lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG4gIHdpbmRvdy5GYXN0Q2xpY2sgPSBGYXN0Q2xpY2s7XG59KCkpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgREVGQVVMVF9WSUVXUE9SVCA9ICd3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xLG1heGltdW0tc2NhbGU9MSxtaW5pbXVtLXNjYWxlPTEsdXNlci1zY2FsYWJsZT1ubyc7XG5cbiAgdmFyIFZpZXdwb3J0ID0geyBcbiAgICBlbnN1cmVWaWV3cG9ydEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblxuICAgICAgaWYgKCF2aWV3cG9ydEVsZW1lbnQpIHtcbiAgICAgICAgdmlld3BvcnRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWV0YScpO1xuICAgICAgICB2aWV3cG9ydEVsZW1lbnQubmFtZSA9ICd2aWV3cG9ydCc7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodmlld3BvcnRFbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZpZXdwb3J0RWxlbWVudDtcbiAgICB9LFxuXG4gICAgc2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZpZXdwb3J0RWxlbWVudCA9IFZpZXdwb3J0LmVuc3VyZVZpZXdwb3J0RWxlbWVudCgpO1xuXG4gICAgICBpZiAoIXZpZXdwb3J0RWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlld3BvcnRFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudCcpKSB7XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCBERUZBVUxUX1ZJRVdQT1JUKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2luZG93LlZpZXdwb3J0ID0gVmlld3BvcnQ7XG59KSgpO1xuIiwiLy8gTG9hZCBub24tcG9seWZpbGwgbGlicmFyaWVzXG5pbXBvcnQgJy4vRmFzdENsaWNrQDEuMC42K21vZC9mYXN0Y2xpY2suanMnO1xuLy8gaW1wb3J0ICcuL21pY3JvZXZlbnQuanNANDdjYmMxNCttb2QvbWljcm9ldmVudC5qcyc7XG5pbXBvcnQgJy4vdmlld3BvcnQuanMnO1xuIiwiaW1wb3J0ICcuL29ucy9wbGF0Zm9ybSc7IC8vIFRoaXMgZmlsZSBtdXN0IGJlIGxvYWRlZCBiZWZvcmUgQ3VzdG9tIEVsZW1lbnRzIHBvbHlmaWxscy5cbmltcG9ydCAnLi9wb2x5ZmlsbHMvaW5kZXguanMnO1xuaW1wb3J0ICcuL3ZlbmRvci9pbmRleC5qcyc7XG5pbXBvcnQgJy4vb25zL21pY3JvZXZlbnQuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cChvbnMpIHtcbiAgaWYgKHdpbmRvdy5vbnMpIHtcbiAgICBvbnMuX3V0aWwud2FybignT25zZW4gVUkgaXMgbG9hZGVkIG1vcmUgdGhhbiBvbmNlLicpO1xuICB9XG5cbiAgLy8gZmFzdGNsaWNrXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgIG9ucy5mYXN0Q2xpY2sgPSBGYXN0Q2xpY2suYXR0YWNoKGRvY3VtZW50LmJvZHkpO1xuXG4gICAgY29uc3Qgc3VwcG9ydFRvdWNoQWN0aW9uID0gJ3RvdWNoLWFjdGlvbicgaW4gZG9jdW1lbnQuYm9keS5zdHlsZTtcblxuICAgIG9ucy5wbGF0Zm9ybS5fcnVuT25BY3R1YWxQbGF0Zm9ybSgoKSA9PiB7XG4gICAgICBpZiAob25zLnBsYXRmb3JtLmlzQW5kcm9pZCgpKSB7XG4gICAgICAgIC8vIEluIEFuZHJvaWQ0LjQrLCBjb3JyZWN0IHZpZXdwb3J0IHNldHRpbmdzIGNhbiByZW1vdmUgY2xpY2sgZGVsYXkuXG4gICAgICAgIC8vIFNvIGRpc2FibGUgRmFzdENsaWNrIG9uIEFuZHJvaWQuXG4gICAgICAgIG9ucy5mYXN0Q2xpY2suZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIGlmIChvbnMucGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgICBpZiAoc3VwcG9ydFRvdWNoQWN0aW9uICYmIChvbnMucGxhdGZvcm0uaXNJT1NTYWZhcmkoKSB8fCBvbnMucGxhdGZvcm0uaXNXS1dlYlZpZXcoKSkpIHtcbiAgICAgICAgICAvLyBJZiAndG91Y2gtYWN0aW9uJyBzdXBwb3J0ZWQgaW4gaU9TIFNhZmFyaSBvciBXS1dlYlZpZXcsIGRpc2FibGUgRmFzdENsaWNrLlxuICAgICAgICAgIG9ucy5mYXN0Q2xpY2suZGVzdHJveSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERvIG5vdGhpbmcuICd0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbicgaGFzIG5vIGVmZmVjdCBvbiBVSVdlYlZpZXcuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgZmFsc2UpO1xuXG4gIG9ucy5yZWFkeShmdW5jdGlvbigpIHtcbiAgICBvbnMuZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIoKTtcbiAgICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlciA9IG9ucy5faW50ZXJuYWwuZGJiRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHdpbmRvdy5kb2N1bWVudC5ib2R5LCAoKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobmF2aWdhdG9yLCAnYXBwJykpIHtcbiAgICAgICAgbmF2aWdhdG9yLmFwcC5leGl0QXBwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBjbG9zZSB0aGUgYXBwLiBJcyBcXCdjb3Jkb3ZhLmpzXFwnIGluY2x1ZGVkP1xcbkVycm9yOiBcXCd3aW5kb3cubmF2aWdhdG9yLmFwcFxcJyBpcyB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5fZ2VzdHVyZURldGVjdG9yID0gbmV3IG9ucy5HZXN0dXJlRGV0ZWN0b3IoZG9jdW1lbnQuYm9keSk7XG5cbiAgICAvLyBTaW11bGF0ZSBEZXZpY2UgQmFjayBCdXR0b24gb24gRVNDIHByZXNzXG4gICAgaWYgKCFvbnMucGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgIG9ucy5maXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gc2V0dXAgbG9hZGluZyBwbGFjZWhvbGRlclxuICAgIG9ucy5fc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzKCk7XG4gIH0pO1xuXG4gIC8vIHZpZXdwb3J0LmpzXG4gIFZpZXdwb3J0LnNldHVwKCk7XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50Q2xhc3MoKSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICdmdW5jdGlvbicpIHsgLy8gY2FzZSBvZiBTYWZhcmlcbiAgICBjb25zdCBCYXNlRWxlbWVudCA9ICgpID0+IHt9O1xuICAgIEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldHVybiBCYXNlRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUVsZW1lbnQgZXh0ZW5kcyBnZXRFbGVtZW50Q2xhc3MoKSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGVtcGxhdGVcbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERlZmluZSBhIHNlcGFyYXRlIEhUTUwgZnJhZ21lbnQgYW5kIHVzZSBhcyBhIHRlbXBsYXRlLiBUaGVzZSB0ZW1wbGF0ZXMgY2FuIGJlIGxvYWRlZCBhcyBwYWdlcyBpbiBgPG9ucy1uYXZpZ2F0b3I+YCwgYDxvbnMtdGFiYmFyPmAgYW5kIGA8b25zLXNwbGl0dGVyPmAuIFRoZXkgY2FuIGFsc28gYmUgdXNlZCB0byBnZW5lcmF0ZSBkaWFsb2dzLiBTaW5jZSBPbnNlbiBVSSAyLjQuMCwgdGhlIG5hdGl2ZSBgPHRlbXBsYXRlPmAgZWxlbWVudCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGA8b25zLXRlbXBsYXRlPmAgZm9yIGJldHRlciBwZXJmb3JtYW5jZSBhbmQgZmVhdHVyZXMuIGA8b25zLXRlbXBsYXRlPmAgaXMgc3RpbGwgc3VwcG9ydGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICogICBbL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44Go44GX44Gm5L2/55So44GZ44KL44Gf44KB44GuSFRNTOODleODqeOCsOODoeODs+ODiOOCkuWumue+qeOBl+OBvuOBmeOAguOBk+OBruimgee0oOOBp0hUTUzjgpLlrqPoqIDjgZnjgovjgajjgIFpZOWxnuaAp+OBq+aMh+WumuOBl+OBn+WQjeWJjeOCknBhZ2Xjga5VUkzjgajjgZfjgaZvbnMtbmF2aWdhdG9y44Gq44Gp44Gu44Kz44Oz44Od44O844ON44Oz44OI44GL44KJ5Y+C54Wn44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcbiAqICAgW2VuXVRoZSBgPG9ucy1uYXZpZ2F0b3I+YCBjb21wb25lbnQgZW5hYmxlcyBzdGFjayBiYXNlZCBuYXZpZ2F0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXRhYmJhclxuICogICBbZW5dVGhlIGA8b25zLXRhYmJhcj5gIGNvbXBvbmVudCBpcyB1c2VkIHRvIGFkZCB0YWIgbmF2aWdhdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRyYWdnYWJsZSBtZW51IG9yIGNvbHVtbiBiYXNlZCBsYXlvdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10ZW1wbGF0ZSBpZD1cImZvb2Jhci5odG1sXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICBQYWdlIGNvbnRlbnRcbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICpcbiAqIDxvbnMtbmF2aWdhdG9yIHBhZ2U9XCJmb29iYXIuaHRtbFwiPjwvb25zLW5hdmlnYXRvcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVtcGxhdGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdGVtcGxhdGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGVtcGxhdGUgY29udGVudC4gVGhpcyBwcm9wZXJ0eSBjYW4gbm90IGJlIHVzZWQgd2l0aCBBbmd1bGFySlMgYmluZGluZ3MuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMuaW5uZXJIVE1MO1xuXG4gICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLnBhcmVudE5vZGUpIHsgLy8gTm90ZTogdGhpcy5wYXJlbnROb2RlIGlzIG5vdCBzZXQgaW4gc29tZSBDRTAvQ0UxIHBvbHlmaWxscy5cbiAgICAgIC8vIFNob3cgd2FybmluZyB3aGVuIHRoZSBvbnMtdGVtcGxhdGUgaXMgbm90IGxvY2F0ZWQganVzdCB1bmRlciBkb2N1bWVudC5ib2R5XG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7IC8vIGlmIHRoZSBwYXJlbnQgaXMgbm90IGRvY3VtZW50LmJvZHlcbiAgICAgICAgdXRpbC53YXJuKGBvbnMtdGVtcGxhdGUgKGlkID0gJHt0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKX0pIG11c3QgYmUgbG9jYXRlZCBqdXN0IHVuZGVyIGRvY3VtZW50LmJvZHkkeyB0aGlzLnBhcmVudE5vZGUub3V0ZXJIVE1MID8gYDpcXG5cXG4ke3RoaXMucGFyZW50Tm9kZS5vdXRlckhUTUx9YCA6ICcuJyB9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdfdGVtcGxhdGVsb2FkZWQnLCB7YnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZX0pO1xuICAgIGV2ZW50LnRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcbiAgICBldmVudC50ZW1wbGF0ZUlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5UZW1wbGF0ZSA9IFRlbXBsYXRlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRlbXBsYXRlJywgVGVtcGxhdGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuLi9vbnMvb3JpZW50YXRpb24nO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaWZcbiAqIEBjYXRlZ29yeSBjb25kaXRpb25hbFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2lmXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbmRpdGlvbmFsbHkgZGlzcGxheSBjb250ZW50IGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0sIGRldmljZSBvcmllbnRhdGlvbiBvciBib3RoLlxuICpcbiAqICAgICBTb21ldGltZXMgaXQgaXMgdXNlZnVsIHRvIGNvbmRpdGlvbmFsbHkgaGlkZSBvciBzaG93IGNlcnRhaW4gY29tcG9uZW50cyBiYXNlZCBvbiBwbGF0Zm9ybS4gV2hlbiBydW5uaW5nIG9uIGlPUyB0aGUgYDxvbnMtaWY+YCBlbGVtZW50IGNhbiBiZSB1c2VkIHRvIGhpZGUgdGhlIGA8b25zLWZhYj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLWlmIG9yaWVudGF0aW9uPVwibGFuZHNjYXBlXCI+XG4gKiAgICAgTGFuZHNjYXBlIHZpZXchXG4gKiAgIDwvb25zLWlmPlxuICogICA8b25zLWlmIHBsYXRmb3JtPVwiYW5kcm9pZFwiPlxuICogICAgIFRoaXMgaXMgQW5kcm9pZC5cbiAqICAgPC9vbnMtaWY+XG4gKiAgIDxvbnMtaWYgcGxhdGZvcm09XCJpb3Mgb3RoZXJcIj5cbiAqICAgICBUaGlzIGlzIG5vdCBBbmRyb2lkLlxuICogICA8L29ucy1pZj5cbiAqIDwvb25zLXBhZ2U+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElmRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwbGF0Zm9ybVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BhY2Utc2VwYXJhdGVkIHBsYXRmb3JtIG5hbWVzLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImlvc1wiYCwgYFwiYW5kcm9pZFwiYCwgYFwid2luZG93c1wiYCBhbmQgYFwib3RoZXJcImAuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvcmllbnRhdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FaXRoZXIgYFwicG9ydHJhaXRcImAgb3IgYFwibGFuZHNjYXBlXCJgLlsvZW5dXG4gICAqICBbamFdcG9ydHJhaXTjgoLjgZfjgY/jga9sYW5kc2NhcGXjgpLmjIflrprjgZfjgb7jgZlbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmIChwbGF0Zm9ybS5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMF0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIG9yaWVudGF0aW9uLm9uKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnb3JpZW50YXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09ICdvcmllbnRhdGlvbicpIHtcbiAgICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBvcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICB9XG5cbiAgX3BsYXRmb3JtVXBkYXRlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkgPyAnJyA6ICdub25lJztcbiAgfVxuXG4gIF9pc0FsbG93ZWRQbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZ2V0QXR0cmlidXRlKCdwbGF0Zm9ybScpIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwbGF0Zm9ybScpLnNwbGl0KC9cXHMrLykuaW5kZXhPZihwbGF0Zm9ybS5nZXRNb2JpbGVPUygpKSA+PSAwO1xuICB9XG5cbiAgX29uT3JpZW50YXRpb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdvcmllbnRhdGlvbicpICYmIHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnb3JpZW50YXRpb24nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgY3VycmVudE9yaWVudGF0aW9uID0gb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnO1xuXG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAoY29uZGl0aW9uYWxPcmllbnRhdGlvbiA9PT0gY3VycmVudE9yaWVudGF0aW9uKSA/ICcnIDogJ25vbmUnO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuSWYgPSBJZkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1pZicsIElmRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMudGltaW5nID0gb3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gICAgdGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgMDtcbiAgICB0aGlzLmRlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwO1xuICB9XG5cbiAgc3RhdGljIGV4dGVuZChwcm9wZXJ0aWVzID0ge30pIHtcbiAgICBjb25zdCBleHRlbmRlZEFuaW1hdG9yID0gdGhpcztcbiAgICBjb25zdCBuZXdBbmltYXRvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgZXh0ZW5kZWRBbmltYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdXRpbC5leHRlbmQodGhpcywgcHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIG5ld0FuaW1hdG9yLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xuICAgIHJldHVybiBuZXdBbmltYXRvcjtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG4vLyBUaGlzIG9iamVjdCBzaG91bGQgbm90IGJlIGV4cG9zZWQgdG8gdXNlcnMuIFBsZWFzZSBrZWVwIHRoaXMgcHJpdmF0ZS5cbmNvbnN0IGlQaG9uZVhQYXRjaCA9IHt9O1xuXG5pUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSA9ICgpID0+IHtcbiAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ29uc2ZsYWctaXBob25leC1wb3J0cmFpdCcpICE9IG51bGwgJiYgd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG59XG5cbmlQaG9uZVhQYXRjaC5pc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSA9ICgpID0+IHtcbiAgLy8gSWYgd2lkdGggPT09IGhlaWdodCwgdHJlYXQgaXQgYXMgbGFuZHNjYXBlXG4gIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvbnNmbGFnLWlwaG9uZXgtbGFuZHNjYXBlJykgIT0gbnVsbCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+PSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2FmZSBhcmVhIGxlbmd0aHMgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNhZmUgYXJlYXMuXG4gKi9cbmlQaG9uZVhQYXRjaC5nZXRTYWZlQXJlYUxlbmd0aHMgPSAoKSA9PiB7XG4gIGxldCBzYWZlQXJlYUxlbmd0aHM7XG4gIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgc2FmZUFyZWFMZW5ndGhzID0ge1xuICAgICAgdG9wOiA0NCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAzNCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSgpKSB7XG4gICAgc2FmZUFyZWFMZW5ndGhzID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDQ0LFxuICAgICAgYm90dG9tOiAyMSxcbiAgICAgIGxlZnQ6IDQ0XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzYWZlQXJlYUxlbmd0aHMgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHNhZmVBcmVhTGVuZ3Rocztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzYWZlIGFyZWEgcmVjdCBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2FmZSBhcmVhcy5cbiAqL1xuaVBob25lWFBhdGNoLmdldFNhZmVBcmVhRE9NUmVjdCA9ICgpID0+IHtcbiAgbGV0IHNhZmVBcmVhUmVjdDtcbiAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICBzYWZlQXJlYVJlY3QgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogNDQsIC8qIDAgKyA0NCAodG9wIHNhZmUgYXJlYSkgKi9cbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IC0gNzggLyogaGVpZ2h0IC0gNDQgKHRvcCBzYWZlIGFyZWEpIC0gMzQgKGJvdHRvbSBzYWZlIGFyZWEpICovXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUoKSkge1xuICAgIHNhZmVBcmVhUmVjdCA9IHtcbiAgICAgIHg6IDQ0LCAvKiAwICsgNDQgKGxlZnQgc2FmZSBhcmVhKSAqL1xuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCAtIDg4LCAvKiB3aWR0aCAtIDQ0IChsZWZ0IHNhZmUgYXJlYSkgLSAzNCAocmlnaHQgc2FmZSBhcmVhKSAqL1xuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgLSAyMSAvKiBoZWlnaHQgLSAyMSAoYm90dG9tIHNhZmUgYXJlYSkgKi9cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNhZmVBcmVhUmVjdCA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5zYWZlQXJlYVJlY3QsXG4gICAgbGVmdDogc2FmZUFyZWFSZWN0LngsXG4gICAgdG9wOiBzYWZlQXJlYVJlY3QueSxcbiAgICByaWdodDogc2FmZUFyZWFSZWN0LnggKyBzYWZlQXJlYVJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiBzYWZlQXJlYVJlY3QueSArIHNhZmVBcmVhUmVjdC5oZWlnaHRcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaVBob25lWFBhdGNoO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5pbXBvcnQgaVBob25lWFBhdGNoIGZyb20gJy4uLy4uL29ucy9pcGhvbmV4LXBhdGNoJztcblxuZXhwb3J0IGNsYXNzIEFjdGlvblNoZWV0QW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgc2hvdyhkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbi8qKlxuICogQW5kcm9pZCBzdHlsZSBhbmltYXRvciBmb3IgQWN0aW9uIFNoZWV0LlxuICovXG5leHBvcnQgY2xhc3MgTURBY3Rpb25TaGVldEFuaW1hdG9yIGV4dGVuZHMgQWN0aW9uU2hlZXRBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3IoeyB0aW1pbmcgPSAnZWFzZScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjQgfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG5cbiAgICB0aGlzLm1hc2tUaW1pbmcgPSAnbGluZWFyJztcbiAgICB0aGlzLm1hc2tEdXJhdGlvbiA9IDAuMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm1hc2tEdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMubWFza1RpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fc2hlZXQpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgODAlLCAwKWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm1hc2tEdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMubWFza1RpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fc2hlZXQpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgODAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgSU9TQWN0aW9uU2hlZXRBbmltYXRvciBleHRlbmRzIEFjdGlvblNoZWV0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zIH0gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuXG4gICAgdGhpcy5tYXNrVGltaW5nID0gJ2xpbmVhcic7XG4gICAgdGhpcy5tYXNrRHVyYXRpb24gPSAwLjI7XG4gICAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICdjYWxjKDEwMCUgKyA0OHB4KSc7XG4gICAgfSBlbHNlIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUoKSkge1xuICAgICAgdGhpcy5saWZ0QW1vdW50ID0gJ2NhbGMoMTAwJSArIDMzcHgpJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saWZ0QW1vdW50ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQgLyAyLjAgLSAxICsgJ3B4JzsgLy8gYXZvaWQgRm9yY2VkIFN5bmNocm9ub3VzIExheW91dFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMubWFza0R1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMubWFza1RpbWluZ1xuICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX3NoZWV0KVxuICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAucXVldWUoe1xuICAgICAgICBjc3M6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMubGlmdEFtb3VudH0sIDApYFxuICAgICAgICB9LFxuICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBjc3M6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMubWFza0R1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMubWFza1RpbWluZ1xuICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX3NoZWV0KVxuICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAucXVldWUoe1xuICAgICAgICBjc3M6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH0pXG4gICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgY3NzOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmxpZnRBbW91bnR9LCAwKWBcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS1lbGVtZW50JztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi4vLi4vb25zL2Rvb3Jsb2NrJztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VEaWFsb2dFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignX3NjaGVtZSBnZXR0ZXIgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlQW5pbWF0b3JGYWN0b3J5IG1ldGhvZCBtdXN0IGJlIGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgX3RvZ2dsZVN0eWxlKHNob3VsZFNob3cpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBzaG91bGRTaG93ID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fZG9vckxvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9jYW5jZWwgPSB0aGlzLl9jYW5jZWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9zZWxmQ2FtZWxOYW1lID0gdXRpbC5jYW1lbGl6ZSh0aGlzLnRhZ05hbWUuc2xpY2UoNCkpO1xuICAgIHRoaXMuX2RlZmF1bHREQkIgPSBlID0+IHRoaXMuY2FuY2VsYWJsZSA/IHRoaXMuX2NhbmNlbCgpIDogZS5jYWxsUGFyZW50SGFuZGxlcigpO1xuICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICB9XG5cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9jYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsYWJsZSAmJiAhdGhpcy5fcnVubmluZykge1xuICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG4gICAgICB0aGlzLmhpZGUoKVxuICAgICAgICAudGhlbihcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2RpYWxvZy1jYW5jZWwnKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IHRoaXMuX3J1bm5pbmcgPSBmYWxzZVxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIF9wcmV2ZW50U2Nyb2xsKGV2ZW50KSB7XG4gICAgZXZlbnQuY2FuY2VsYWJsZSAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgc2hvdyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldFZpc2libGUodHJ1ZSwgLi4uYXJncyk7XG4gIH1cblxuICBoaWRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0VmlzaWJsZShmYWxzZSwgLi4uYXJncyk7XG4gIH1cblxuICB0b2dnbGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9zZXRWaXNpYmxlKCF0aGlzLnZpc2libGUsIC4uLmFyZ3MpO1xuICB9XG5cbiAgX3NldFZpc2libGUoc2hvdWxkU2hvdywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYWN0aW9uID0gc2hvdWxkU2hvdyA/ICdzaG93JyA6ICdoaWRlJztcblxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMgfTtcbiAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgKTtcblxuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBgcHJlJHthY3Rpb259YCwgeyAvLyBwcmVzaG93IHByZWhpZGVcbiAgICAgIFt0aGlzLl9zZWxmQ2FtZWxOYW1lXTogdGhpcyxcbiAgICAgIGNhbmNlbDogKCkgPT4gY2FuY2VsZWQgPSB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHthY3Rpb259IGV2ZW50LmApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2Rvb3JMb2NrLndhaXRVbmxvY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxvY2sgPSB0aGlzLl9kb29yTG9jay5sb2NrKCk7XG4gICAgICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgICAgIHNob3VsZFNob3cgJiYgdGhpcy5fdG9nZ2xlU3R5bGUodHJ1ZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSBzaG91bGRTaG93O1xuXG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgYW5pbWF0b3JbYWN0aW9uXSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAhc2hvdWxkU2hvdyAmJiB0aGlzLl90b2dnbGVTdHlsZShmYWxzZSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHVubG9jaygpO1xuXG4gICAgICAgICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnXycgKyBhY3Rpb24pO1xuICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0JyArIGFjdGlvbiwge1t0aGlzLl9zZWxmQ2FtZWxOYW1lXTogdGhpc30pOyAvLyBwb3N0c2hvdyBwb3N0aGlkZVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBzZXQgY2FuY2VsYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2FuY2VsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBjYW5jZWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2FuY2VsYWJsZScpO1xuICB9XG5cbiAgX3VwZGF0ZU1hc2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9tYXNrICYmIHRoaXMuZ2V0QXR0cmlidXRlKCdtYXNrLWNvbG9yJykpIHtcbiAgICAgICAgdGhpcy5fbWFzay5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9kZWZhdWx0REJCLmJpbmQodGhpcyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgICAgdGhpcy5fbWFzay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2NhbmNlbCwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9tYXNrLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3ByZXZlbnRTY3JvbGwsIGZhbHNlKTsgLy8gaU9TIGZpeFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2FuY2VsLCBmYWxzZSk7XG4gICAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3ByZXZlbnRTY3JvbGwsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdhbmltYXRpb24nLCAnbWFzay1jb2xvciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gdGhpcy5fdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWFzay1jb2xvcic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hc2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlc2hvdycsICdwb3N0c2hvdycsICdwcmVoaWRlJywgJ3Bvc3RoaWRlJywgJ2RpYWxvZy1jYW5jZWwnXTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi8uLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgeyBBY3Rpb25TaGVldEFuaW1hdG9yLCBJT1NBY3Rpb25TaGVldEFuaW1hdG9yLCBNREFjdGlvblNoZWV0QW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5hY3Rpb24tc2hlZXQnOiAnYWN0aW9uLXNoZWV0LS0qJyxcbiAgJy5hY3Rpb24tc2hlZXQtbWFzayc6ICdhY3Rpb24tc2hlZXQtbWFzay0tKicsXG4gICcuYWN0aW9uLXNoZWV0LXRpdGxlJzogJ2FjdGlvbi1zaGVldC10aXRsZS0tKidcbn07XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREFjdGlvblNoZWV0QW5pbWF0b3IgOiBJT1NBY3Rpb25TaGVldEFuaW1hdG9yLFxuICAnbm9uZSc6IEFjdGlvblNoZWV0QW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWFjdGlvbi1zaGVldFxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBY3Rpb24vYm90dG9tIHNoZWV0IHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiBjdXJyZW50IHNjcmVlbi5cbiAqXG4gKiAgICAgVGhpcyBlbGVtZW50IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIG9yIGR5bmFtaWNhbGx5IGNyZWF0ZWQgZnJvbSBhIHRlbXBsYXRlIHVzaW5nIHRoZSBgb25zLmNyZWF0ZUVsZW1lbnQodGVtcGxhdGUsIHsgYXBwZW5kOiB0cnVlIH0pYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgIFRoZSBhY3Rpb24gc2hlZXQgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIGEgbGlzdCBvZiBvcHRpb25zIGFuZCBhc2tpbmcgdGhlIHVzZXIgdG8gbWFrZSBhIGRlY2lzaW9uLiBBIGBvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbmAgaXMgcHJvdmlkZWQgZm9yIHRoaXMgcHVycG9zZSwgYWx0aG91Z2ggaXQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgY29udGVudC5cbiAqXG4gKiAgICAgSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRpc3BsYXllZCBhcyBNYXRlcmlhbCBEZXNpZ24gKGJvdHRvbSBzaGVldCkgd2hlbiBydW5uaW5nIG9uIGFuIEFuZHJvaWQgZGV2aWNlLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Ki44Kv44K344On44Oz44K344O844OI44CB44KC44GX44GP44Gv44Oc44OI44Og44K344O844OI44KS54++5Zyo44Gu44K544Kv44Oq44O844Oz5LiK44Gr6KGo56S644GX44G+44GZ44CCXG4gKlxuICogICAgIOOBk+OBruimgee0oOOBr+OAgWA8Ym9keT5g6KaB57Sg44Gr55u05o6l44Ki44K/44OD44OB44GV44KM44KL44GL44CB44KC44GX44GP44GvYG9ucy5jcmVhdGVFbGVtZW50KHRlbXBsYXRlLCB7IGFwcGVuZDogdHJ1ZSB9KWDjgahgPG9ucy10ZW1wbGF0ZT5g44K/44Kw44KS5L2/44Gj44Gm44OG44Oz44OX44Os44O844OI44GL44KJ5YuV55qE44Gr55Sf5oiQ44GV44KM44G+44GZ44CCXG4gKlxuICogICAgIOOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBr+OAgemBuOaKnuiCouOBruODquOCueODiOOCkuihqOekuuOBl+OBpuODpuODvOOCtuODvOOBq+Wwi+OBreOCi+OBruOBq+S+v+WIqeOBp+OBmeOAgmBvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbmDjga/jgIHjgZPjga7opoHntKDjga7kuK3jgavnva7jgY/jgZ/jgoHjgavmj5DkvpvjgZXjgozjgabjgYTjgb7jgZnjgYzjgIHjgZ3jgozku6XlpJbjgavjgoLku5bjga7jganjga7jgojjgYbjgaropoHntKDjgpLlkKvjgoDjgZPjgajjgYzjgafjgY3jgb7jgZnjgIJcbiAqXG4gKiAgICAgQW5kcm9pZOODh+ODkOOCpOOCueOBp+Wun+ihjOOBleOCjOOCi+OBqOOBjeOBq+OBr+OAgeiHquWLleeahOOBq+ODnuODhuODquOCouODq+ODh+OCtuOCpOODsyjjg5zjg4jjg6Djgrfjg7zjg4gp44Go44GX44Gm6KGo56S644GV44KM44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gYm90dG9tIHNoZWV0LlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjg4jjg6Djgrfjg7zjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvcmVmZXJlbmNlL2FjdGlvbi1zaGVldFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5dYDxvbnMtcG9wb3Zlcj5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcG9wb3ZlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbW9kYWxcbiAqICAgW2VuXWA8b25zLW1vZGFsPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1tb2RhbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hY3Rpb24tc2hlZXQgaWQ9XCJzaGVldFwiPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogICA8b25zLWFjdGlvbi1zaGVldC1idXR0b24+TGFiZWw8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICogPC9vbnMtYWN0aW9uLXNoZWV0PlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaGVldCcpLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3Rpb25TaGVldEVsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFjdGlvbiBzaGVldCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hY3Rpb25TaGVldFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgYWN0aW9uIHNoZWV0IGZyb20gYmVpbmcgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIGFjdGlvbiBzaGVldCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hY3Rpb25TaGVldFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBhY3Rpb24gc2hlZXQgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWN0aW9uU2hlZXRcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGFjdGlvbiBzaGVldCBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWN0aW9uIHNoZWV0IGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFjdGlvblNoZWV0XG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGl0bGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dT3B0aW9uYWwgdGl0bGUgb2YgdGhlIGFjdGlvbiBzaGVldC4gQSBuZXcgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgY29udGFpbmluZyB0aGlzIHN0cmluZy5bL2VuXVxuICAgKiAgW2phXeOCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBruOCv+OCpOODiOODq+OCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBk+OBp+aMh+WumuOBl+OBn+aWh+Wtl+WIl+OCkuWQq+OCgOaWsOOBl+OBhOimgee0oOOBjOS9nOaIkOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgYWN0aW9uIHNoZWV0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44KL44Go44CB44Ki44Kv44K344On44Oz44K344O844OI44Gu6IOM5pmv44KEQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaOqOOBmeOBk+OBqOOBp+OCouOCr+OCt+ODp+ODs+OCt+ODvOODiOOBjOmWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OA44Kk44Ki44Ot44Kw44GvZGlzYWJsZWTnirbmhYvjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIGFjdGlvbiBzaGVldC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgIG9yIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZGVmYXVsdFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJcInJnYmEoMCwgMCwgMCwgMC4yKVwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hY3Rpb24tc2hlZXQtbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9zaGVldCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hY3Rpb24tc2hlZXQnKTtcbiAgfVxuXG4gIGdldCBfdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmFjdGlvbi1zaGVldC10aXRsZScpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IEFjdGlvblNoZWV0QW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnQWN0aW9uU2hlZXRBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWFjdGlvbi1zaGVldD5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImFjdGlvbi1zaGVldC1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJhY3Rpb24tc2hlZXRcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiYWN0aW9uLXNoZWV0LXRpdGxlPjwvZGl2PlxuICAgICAqICAgICAgIC4uLlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWFjdGlvbi1zaGVldD5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fc2hlZXQpIHtcbiAgICAgIGNvbnN0IHNoZWV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzaGVldC5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBzaGVldC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHNoZWV0KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3RpdGxlICYmIHRoaXMuaGFzQXR0cmlidXRlKCd0aXRsZScpKSB7XG4gICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGl0bGUuaW5uZXJIVE1MID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgICB0aXRsZS5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQtdGl0bGUnKTtcbiAgICAgIHRoaXMuX3NoZWV0Lmluc2VydEJlZm9yZSh0aXRsZSwgdGhpcy5fc2hlZXQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2FjdGlvbi1zaGVldC1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX3NoZWV0LnN0eWxlLnpJbmRleCA9IDIwMDAxO1xuICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlVGl0bGUoKSB7XG4gICAgaWYgKHRoaXMuX3RpdGxlKSB7XG4gICAgICB0aGlzLl90aXRsZS5pbm5lckhUTUwgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBhY3Rpb24gc2hlZXQgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgYWN0aW9uIHNoZWV0LlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX0gUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50LlxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcInNsaWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcInNsaWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbnMgaXMgY2FsbGVkIGFmdGVyIHRoZSBhY3Rpb24gc2hlZXQgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44KS6ZaJ44GY44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFd6Zqg44KM44Gf6KaB57Sg44KS6Kej5rG644GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGFjdGlvbiBzaGVldCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBhY3Rpb24gc2hlZXQgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBhY3Rpb24gc2hlZXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44K344On44Oz44K344O844OI44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS6Kit5a6a44GX44G+44GZ44CC44Kt44Oj44Oz44K744Or5Y+v6IO944Gq44Ki44Kv44K344On44Oz44K344O844OI44Gv44CB6IOM5pmv44KS44K/44OD44OX44GX44Gf44KKQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaOqOOBmeOBk+OBqOOBp+mWieOBmOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAndGl0bGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVRpdGxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtBY3Rpb25TaGVldEFuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBBY3Rpb25TaGVldEFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc0FjdGlvblNoZWV0RWxlbWVudC5BY3Rpb25TaGVldEFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBBY3Rpb25TaGVldEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBBY3Rpb25TaGVldEFuaW1hdG9yO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5BY3Rpb25TaGVldCA9IEFjdGlvblNoZWV0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFjdGlvbi1zaGVldCcsIEFjdGlvblNoZWV0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdhY3Rpb24tc2hlZXQtYnV0dG9uJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdhY3Rpb24tc2hlZXQtYnV0dG9uLS0qJyxcbiAgJy5hY3Rpb24tc2hlZXQtaWNvbic6ICdhY3Rpb24tc2hlZXQtaWNvbi0tKidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWFjdGlvbi1zaGVldC1idXR0b25cbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBtb2RpZmllciBkZXN0cnVjdGl2ZVxuICogICBbZW5dU2hvd3MgYSBcImRlc3RydWN0aXZlXCIgYnV0dG9uIChvbmx5IGZvciBpT1MpLlsvZW5dXG4gKiAgIFtqYV1cImRlc3RydWN0aXZlXCLjgarjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZkoaU9T44Gn44Gu44G/5pyJ5Yq5KeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNvbXBvbmVudCB0aGF0IHJlcHJlc2VudCBlYWNoIGJ1dHRvbiBvZiB0aGUgYWN0aW9uIHNoZWV0LlsvZW5dXG4gKiAgIFtqYV3jgqLjgq/jgrfjg6fjg7Pjgrfjg7zjg4jjgavooajnpLrjgZXjgozjgovlkITjg5zjgr/jg7PjgpLooajnj77jgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWFjdGlvbi1zaGVldFxuICogICBbZW5dVGhlIGA8b25zLWFjdGlvbi1zaGVldD5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWN0aW9uLXNoZWV044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0LWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaWNvblxuICogICBbZW5dVGhlIGA8b25zLWljb24+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWljb27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2FjdGlvbi1zaGVldFxuICogQGd1aWRlIGFwcHNpemUuaHRtbCNyZW1vdmluZy1pY29uLXBhY2tzIFtlbl1SZW1vdmluZyBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAZ3VpZGUgZmFxLmh0bWwjaG93LWNhbi1pLXVzZS1jdXN0b20taWNvbi1wYWNrcyBbZW5dQWRkaW5nIGN1c3RvbSBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gYWN0aW9uIHNoZWV0IGJ1dHRvbi5bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Ki44Kv44K344On44Oz44K344O844OI55So44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWFjdGlvbi1zaGVldCBpZD1cInNoZWV0XCI+XG4gKiAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5MYWJlbDwvb25zLWFjdGlvbi1zaGVldC1idXR0b24+XG4gKiAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5MYWJlbDwvb25zLWFjdGlvbi1zaGVldC1idXR0b24+XG4gKiA8L29ucy1hY3Rpb24tc2hlZXQ+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NoZWV0Jykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjdGlvblNoZWV0QnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUNyZWF0ZXMgYW4gYG9ucy1pY29uYCBjb21wb25lbnQgd2l0aCB0aGlzIHN0cmluZy4gT25seSB2aXNpYmxlIG9uIEFuZHJvaWQuIENoZWNrIFtTZWUgYWxzb10oI3NlZWFsc28pIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uWy9lbl1cbiAgICogIFtqYV1gb25zLWljb25g44Kz44Oz44Od44O844ON44Oz44OI44KS5oKq5oCn44GX44G+44GZ44CCQW5kcm9pZOOBp+OBruOBv+ihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYWN0aW9uIHNoZWV0IGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jgrfjg6fjg7Pjgrfjg7zjg4jjg5zjgr/jg7Pjga7opovjgZ/nm67jgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX2ljb24oKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWN0aW9uLXNoZWV0LWljb24nKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICghdGhpcy5faWNvbiAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnaWNvbicpKSB7XG4gICAgICBjb25zdCBpY29uID0gdXRpbC5jcmVhdGVFbGVtZW50KGA8b25zLWljb24gaWNvbj1cIiR7dGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKX1cIj48L29ucy1pY29uPmApO1xuICAgICAgaWNvbi5jbGFzc0xpc3QuYWRkKCdhY3Rpb24tc2hlZXQtaWNvbicpO1xuICAgICAgdGhpcy5pbnNlcnRCZWZvcmUoaWNvbiwgdGhpcy5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlSWNvbigpIHtcbiAgICBpZiAodGhpcy5faWNvbikge1xuICAgICAgdGhpcy5faWNvbi5zZXRBdHRyaWJ1dGUoJ2ljb24nLCB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsICdpY29uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaWNvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZUljb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9ucy5lbGVtZW50cy5BY3Rpb25TaGVldEJ1dHRvbiA9IEFjdGlvblNoZWV0QnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFjdGlvbi1zaGVldC1idXR0b24nLCBBY3Rpb25TaGVldEJ1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgY2xhc3MgQWxlcnREaWFsb2dBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgc2hvdyhkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbi8qKlxuICogQW5kcm9pZCBzdHlsZSBhbmltYXRvciBmb3IgYWxlcnQgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgwLjksIDAuOSwgMS4wKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMCwgMS4wLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMC45LCAwLjksIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMS4wLCAxLjAsIDEuMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHsgQWxlcnREaWFsb2dBbmltYXRvciwgSU9TQWxlcnREaWFsb2dBbmltYXRvciwgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5hbGVydC1kaWFsb2cnOiAnYWxlcnQtZGlhbG9nLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctY29udGFpbmVyJzogJ2FsZXJ0LWRpYWxvZy1jb250YWluZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy10aXRsZSc6ICdhbGVydC1kaWFsb2ctdGl0bGUtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1jb250ZW50JzogJ2FsZXJ0LWRpYWxvZy1jb250ZW50LS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctZm9vdGVyJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXItLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXJvd2Zvb3Rlcic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1yb3dmb290ZXItLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbCc6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS1wcmltYWwtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1idXR0b24nOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tKicsXG4gICdvbnMtYWxlcnQtZGlhbG9nLWJ1dHRvbic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS0qJyxcbiAgJy5hbGVydC1kaWFsb2ctbWFzayc6ICdhbGVydC1kaWFsb2ctbWFzay0tKicsXG4gICcudGV4dC1pbnB1dCc6ICd0ZXh0LWlucHV0LS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ25vbmUnOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAnZmFkZSc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgOiBJT1NBbGVydERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWxlcnQgZGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY3VycmVudCBzY3JlZW4uIFVzZWZ1bCBmb3IgZGlzcGxheWluZyBxdWVzdGlvbnMsIHdhcm5pbmdzIG9yIGVycm9yIG1lc3NhZ2VzIHRvIHRoZSB1c2VyLiBUaGUgdGl0bGUsIGNvbnRlbnQgYW5kIGJ1dHRvbnMgY2FuIGJlIGVhc2lseSBjdXN0b21pemVkIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIHN0eWxlIGJhc2VkIG9uIHRoZSBwbGF0Zm9ybS5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlQWxlcnREaWFsb2codGVtcGxhdGUpYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDnj77lnKjjga7jgrnjgq/jg6rjg7zjg7Pjga7kuIrjgavooajnpLrjgZnjgovjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgafjgZnjgILjg6bjg7zjgrbjgavlr77jgZnjgovllY/jgYTjgYvjgZHjgIHorablkYrjgIHjgqjjg6njg7zjg6Hjg4Pjgrvjg7zjgrjjgpLooajnpLrjgZnjgovjga7jgavliKnnlKjjgafjgY3jgb7jgZnjgILjgr/jgqTjg4jjg6vjgoTjgrPjg7Pjg4bjg7Pjg4TjgoTjg5zjgr/jg7Pjga/nsKHljZjjgavjgqvjgrnjgr/jg57jgqTjgrrjgafjgY3jgIHlrp/ooYzjgZfjgabjgYTjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DjgavkvbXjgZvjgabjgrnjgr/jgqTjg6vjgYzoh6rli5XnmoTjgavliIfjgormm7/jgo/jgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIFF3d3h5cFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2RpYWxvZ1xuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44K544K/44Kk44OrWy9qYV1cbiAqIEBtb2RpZmllciByb3dmb290ZXJcbiAqICAgW2VuXUhvcml6b250YWxseSBhbGlnbnMgdGhlIGZvb3RlciBidXR0b25zLlsvZW5dXG4gKiAgIFtqYV3jg5Xjg4Pjgr/jg7zjga7opIfmlbDjga7jg5zjgr/jg7PjgpLmsLTlubPjgavphY3nva5bL2phXVxuICogQHNlZWFsc28gb25zLWRpYWxvZ1xuICogICBbZW5db25zLWRpYWxvZyBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWRpYWxvZ+OCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcG9wb3ZlclxuICogICBbZW5db25zLXBvcG92ZXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLm5vdGlmaWNhdGlvblxuICogICBbZW5dVXNpbmcgb25zLm5vdGlmaWNhdGlvbiB1dGlsaXR5IGZ1bmN0aW9ucy5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL44Gr44Gv44CBb25zLm5vdGlmaWNhdGlvbuOCquODluOCuOOCp+OCr+ODiOOBruODoeOCveODg+ODieOCkuS9v+OBhuOBk+OBqOOCguOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1hbGVydC1kaWFsb2cgaWQ9XCJhbGVydC1kaWFsb2dcIj5cbiAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy10aXRsZVwiPldhcm5pbmchPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctY29udGVudFwiPlxuICogICAgIEFuIGVycm9yIGhhcyBvY2N1cnJlZCFcbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctZm9vdGVyXCI+XG4gKiAgICAgPGJ1dHRvbiBpZD1cImFsZXJ0LWRpYWxvZy1idXR0b25cIiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIj5PSzwvYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbGVydC1kaWFsb2cnKS5zaG93KCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnREaWFsb2dFbGVtZW50IGV4dGVuZHMgQmFzZURpYWxvZ0VsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gc2hvd2luZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7ooajnpLrjgpLmraLjgoHjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFsZXJ0IGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdG8gc3RvcCB0aGUgZGlhbG9nIGZyb20gaGlkaW5nLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCiOOBhuOBqOOBmeOCi+OBruOCkuatouOCgeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhbGVydCBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgZGlhbG9nLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44Gu6KaL44Gf55uu44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2FuY2VsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OCkuioreWumuOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruiDjOaZr+OCkuOCv+ODg+ODl+OBl+OBn+OCikFuZHJvaWTjg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7PjgpLmirzjgZnjgajjg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGRpYWxvZyBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBr2Rpc2FibGVk54q25oWL44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBkaWFsb2cuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCBvciBgXCJkZWZhdWx0XCJgLlsvZW5dXG4gICAqICBbamFd44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44Gn44GvXCJub25lXCLjgYtcImRlZmF1bHRcIuOBjOaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAguS+i++8mntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCByZ2JhKDAsIDAsIDAsIDAuMilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBcInJnYmEoMCwgMCwgMCwgMC4yKVwiLlsvZW5dXG4gICAqICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CCXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBjOODh+ODleOCqeODq+ODiOWApOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICovXG4gIGdldCBfbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2ctbWFzaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5hbGVydC1kaWFsb2cnKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX3RpdGxlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy10aXRsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0sICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBBbGVydERpYWxvZ0FuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ0FsZXJ0RGlhbG9nQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAxO1xuXG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgcmVzdWx0IGFmdGVyIGNvbXBpbGU6XG4gICAgICpcbiAgICAgKiA8b25zLWFsZXJ0LWRpYWxvZyBzdHlsZT1cIm5vbmVcIj5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctbWFza1wiPjwvZGl2PlxuICAgICAqICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZ1wiPlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgPC9kaXY+XG4gICAgICogPC9vbnMtYWxlcnQtZGlhbG9nPlxuICAgICAqL1xuXG4gICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGlmICghdGhpcy5fbWFzayAmJiAhdGhpcy5fZGlhbG9nKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1hc2suY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLW1hc2snKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2cnKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGRpYWxvZywgbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLl9kaWFsb2csICcuYWxlcnQtZGlhbG9nLWNvbnRhaW5lcicpKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdhbGVydC1kaWFsb2ctY29udGFpbmVyJyk7XG4gICAgICB0aGlzLl9kaWFsb2cuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWFsb2cuY2hpbGRyZW5bMF0uYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICB0aGlzLl9kaWFsb2cuc3R5bGUuekluZGV4ID0gMjAwMDE7XG4gICAgdGhpcy5fbWFzay5zdHlsZS56SW5kZXggPSAyMDAwMDtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIEEgY2FuY2VsYWJsZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogICBbamFd44Gd44Gu44OA44Kk44Ki44Ot44Kw44GM44Kt44Oj44Oz44K744Or5Y+v6IO944GL44Gp44GG44GL44KS6KGo44GX44G+44GZ44CC44Kt44Oj44Oz44K744Or5Y+v6IO944Gq44OA44Kk44Ki44Ot44Kw44Gv44CB6IOM5pmv44KS44K/44OD44OX44GZ44KL44GLQW5kcm9pZOODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OCkuaKvOOBmeOBk+OBqOOBp+mWieOBmOOCi+OBk+OBqOOBjOWHuuadpeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjga7jga/jgIFcImZhZGVcIiwgXCJub25lXCLjga7jgYTjgZrjgozjgYvjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXUEgYFByb21pc2VgIG9iamVjdCB0aGF0IHJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3ooajnpLrjgZXjgozjgovopoHntKDjgpLop6PmsbrjgZnjgotgUHJvbWlzZWDjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9PC9jb2RlPiBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciB0aGUgZGlhbG9nIGhhcyBiZWVuIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovjgrPjg7zjg6vjg5Djg4Pjgq/jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgYWxlcnQgZGlhbG9nLlsvZW5dXG4gICAqICAgW2phXeODgOOCpOOCouODreOCsOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXemaoOOCjOOBn+imgee0oOOCkuino+axuuOBmeOCi2BQcm9taXNlYOOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RGlhbG9nQW5pbWF0b3J9IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIEFsZXJ0RGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zQWxlcnREaWFsb2dFbGVtZW50LkFsZXJ0RGlhbG9nQW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEFsZXJ0RGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIEFsZXJ0RGlhbG9nQW5pbWF0b3I7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLkFsZXJ0RGlhbG9nID0gQWxlcnREaWFsb2dFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYWxlcnQtZGlhbG9nJywgQWxlcnREaWFsb2dFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdhbGVydC1kaWFsb2ctYnV0dG9uJztcblxuY29uc3Qgc2NoZW1lID0geycnOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2ctYnV0dG9uXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBhbGVydC1kaWFsb2cgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBjb21wb25lbnQgZGlzcGxheXMgYSBhbGVydCBkaWFsb2cuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqICA8b25zLWFsZXJ0LWRpYWxvZz5cbiAqICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctdGl0bGVcIj5XYXJuaW5nITwvZGl2PlxuICogICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gKiAgICAgIEFuIGVycm9yIGhhcyBvY2N1cnJlZCFcbiAqICAgIDwvZGl2PlxuICogICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1mb290ZXJcIj5cbiAqICAgICAgPGFsZXJ0LWRpYWxvZy1idXR0b24gb25jbGljaz1cImFwcC5jbG9zZSgpXCI+Q2FuY2VsPC9hbGVydC1kaWFsb2ctYnV0dG9uPlxuICogICAgICA8YWxlcnQtZGlhbG9nLWJ1dHRvbiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIiBvbmNsaWNrPVwiYXBwLmNsb3NlKClcIj5PSzwvYWxlcnQtZGlhbG9nLWJ1dHRvbj5cbiAqICAgIDwvZGl2PlxuICogIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnREaWFsb2dCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMsIHVuZGVmaW5lZCwgeydtb2RpZmllcic6ICdsaWdodC1ncmF5J30pO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9ucy5lbGVtZW50cy5BbGVydERpYWxvZ0J1dHRvbiA9IEFsZXJ0RGlhbG9nQnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nLCBBbGVydERpYWxvZ0J1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgaW9zQmFja0J1dHRvbkljb24gZnJvbSAnLi4vLi4vaW1hZ2VzL2lvcy1iYWNrLWJ1dHRvbi1pY29uLnN2Zyc7XG5pbXBvcnQgbWRCYWNrQnV0dG9uSWNvbiBmcm9tICcuLi8uLi9pbWFnZXMvbWQtYmFjay1idXR0b24taWNvbi5zdmcnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2JhY2stYnV0dG9uJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ2JhY2stYnV0dG9uLS0qJyxcbiAgJy5iYWNrLWJ1dHRvbl9faWNvbic6ICdiYWNrLWJ1dHRvbi0tKl9faWNvbicsXG4gICcuYmFjay1idXR0b25fX2xhYmVsJzogJ2JhY2stYnV0dG9uLS0qX19sYWJlbCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJhY2stYnV0dG9uXG4gKiBAY2F0ZWdvcnkgbmF2aWdhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBCYWNrIGJ1dHRvbiBjb21wb25lbnQgZm9yIGA8b25zLXRvb2xiYXI+YC4gUHV0IGl0IGluIHRoZSBsZWZ0IHBhcnQgb2YgdGhlIGA8b25zLXRvb2xiYXI+YC5cbiAqXG4gKiAgICAgSXQgd2lsbCBmaW5kIHRoZSBwYXJlbnQgYDxvbnMtbmF2aWdhdG9yPmAgZWxlbWVudCBhbmQgcG9wIGEgcGFnZSB3aGVuIGNsaWNrZWQuIFRoaXMgYmVoYXZpb3IgY2FuIGJlIG92ZXJyaWRlbiBieSBzcGVjaWZ5aW5nIHRoZSBgb25DbGlja2AgcHJvcGVydHkuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gYUhtR0xcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9uYXZpZ2F0b3JcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5db25zLXRvb2xiYXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcbiAqICAgW2VuXW9ucy1uYXZpZ2F0b3IgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1uYXZpZ2F0b3LjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdG9vbGJhcj5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8ZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYWNrQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJhY2sgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44OQ44OD44Kv44Oc44K/44Oz44Gu6KaL44Gf55uu44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0ge307XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZUljb24oaWNvbiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgIGljb24uaW5uZXJIVE1MID0gYXV0b1N0eWxlLmdldFBsYXRmb3JtKHRoaXMpID09PSAnYW5kcm9pZCcgfHwgdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKSA/IG1kQmFja0J1dHRvbkljb24gOiBpb3NCYWNrQnV0dG9uSWNvbjtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2stYnV0dG9uX19sYWJlbCcpKSB7XG4gICAgICBjb25zdCBsYWJlbCA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19sYWJlbCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgY29uc3QgaWNvbiA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19pY29uJyk7XG4gICAgICB0aGlzLl91cGRhdGVJY29uKGljb24pO1xuXG4gICAgICB0aGlzLmluc2VydEJlZm9yZShpY29uLCB0aGlzLmNoaWxkcmVuWzBdKTtcbiAgICB9XG5cbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzLCB1bmRlZmluZWQsIHtjZW50ZXI6ICcnLCAnc2l6ZSc6ICdjb250YWluJywgJ2JhY2tncm91bmQnOiAndHJhbnNwYXJlbnQnfSk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wdGlvbnMgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIgYW5kIFwibm9uZVwiLlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgXCItaW9zXCIgb3IgXCItbWRcIlxuICAgKiAgICAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBcImxpZnQtaW9zXCIsIFwibGlmdC1tZFwiLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIFwic2xpZGUtaW9zXCIgYW5kIFwiZmFkZS1tZFwiLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuY2FsbGJhY2tcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25DbGlja1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhY2sgYnV0dG9uIGJlaGF2aW9yLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBfb25DbGljaygpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrKSB7XG4gICAgICB0aGlzLm9uQ2xpY2suYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbmF2aWdhdG9yID0gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtbmF2aWdhdG9yJyk7XG4gICAgICBpZiAobmF2aWdhdG9yKSB7XG4gICAgICAgIG5hdmlnYXRvci5wb3BQYWdlKHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtb2RpZmllcic6IHtcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkgJiYgdGhpcy5fdXBkYXRlSWNvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLkJhY2tCdXR0b24gPSBCYWNrQnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWJhY2stYnV0dG9uJywgQmFja0J1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2JvdHRvbS1iYXInO1xuY29uc3Qgc2NoZW1lID0geycnOiAnYm90dG9tLWJhci0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1ib3R0b20tdG9vbGJhclxuICogQGNhdGVnb3J5IHBhZ2VcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVG9vbGJhciBjb21wb25lbnQgdGhhdCBpcyBwb3NpdGlvbmVkIGF0IHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuIFNpbmNlIGJvdHRvbSB0b29sYmFycyBhcmUgdmVyeSB2ZXJzYXRpbGUgZWxlbWVudHMsIGBvbnMtYm90dG9tLXRvb2xiYXJgIGRvZXMgbm90IHByb3ZpZGUgYW55IHNwZWNpZmljIGxheW91dCBzeW50YXggZm9yIGl0cyBjaGlsZHJlbi4gTW9kaWZpZXJzIG9yIGN1c3RvbSBDU1MgbXVzdCBiZSB1c2VkLlsvZW5dXG4gKiAgIFtqYV3jg5rjg7zjgrjkuIvpg6jjgavphY3nva7jgZXjgozjgovjg4Tjg7zjg6vjg5Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgIFtlbl1NYWtlIHRoZSB0b29sYmFyIHRyYW5zcGFyZW50LlsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7og4zmma/jgpLpgI/mmI7jgavjgZfjgabooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGFsaWduZWRcbiAqICAgW2VuXVZlcnRpY2FsbHkgYWxpZ25zIGl0cyBjaGlsZHJlbiBhbmQgYXBwbGllcyBmbGV4Ym94IGZvciBibG9jayBlbGVtZW50cy4gYGp1c3RpZnktY29udGVudGAgQ1NTIHJ1bGUgY2FuIGJlIHVzZWQgdG8gY2hhbmdlIGhvcml6b250YWwgYWxpZ24uWy9lbl1cbiAqICAgW2phXeODhOODvOODq+ODkOODvOOBruiDjOaZr+OCkumAj+aYjuOBq+OBl+OBpuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhciBbZW5db25zLXRvb2xiYXIgY29tcG9uZW50Wy9lbl1bamFdb25zLXRvb2xiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtYm90dG9tLXRvb2xiYXI+XG4gKiAgIENvbnRlbnRcbiAqIDwvb25zLWJvdHRvbS10b29sYmFyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb3R0b21Ub29sYmFyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0b29sYmFyLlsvZW5dXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOBruimi+OBn+ebruOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHV0aWwubWF0Y2godGhpcy5wYXJlbnROb2RlLCAnb25zLXBhZ2UnKSkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ3BhZ2Utd2l0aC1ib3R0b20tdG9vbGJhcicpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG59XG5cbm9ucy5lbGVtZW50cy5Cb3R0b21Ub29sYmFyID0gQm90dG9tVG9vbGJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1ib3R0b20tdG9vbGJhcicsIEJvdHRvbVRvb2xiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3Qgc2NoZW1lID0geycnOiAnYnV0dG9uLS0qJ307XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnYnV0dG9uJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYnV0dG9uXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG91dGxpbmVcbiAqICAgW2VuXUJ1dHRvbiB3aXRoIG91dGxpbmUgYW5kIHRyYW5zcGFyZW50IGJhY2tncm91bmRbL2VuXVxuICogICBbamFd44Ki44Km44OI44Op44Kk44Oz44KS5oyB44Gj44Gf44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsaWdodFxuICogICBbZW5dQnV0dG9uIHRoYXQgZG9lc24ndCBzdGFuZCBvdXQuWy9lbl1cbiAqICAgW2phXeebrueri+OBn+OBquOBhOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgcXVpZXRcbiAqICAgW2VuXUJ1dHRvbiB3aXRoIG5vIG91dGxpbmUgYW5kIG9yIGJhY2tncm91bmQuLlsvZW5dXG4gKiAgIFtqYV3mnqDnt5rjgoTog4zmma/jgYznhKHjgYTmloflrZfjgaDjgZHjga7jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGN0YVxuICogICBbZW5dQnV0dG9uIHRoYXQgcmVhbGx5IHN0YW5kcyBvdXQuWy9lbl1cbiAqICAgW2phXeebrueri+OBpOODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2VcbiAqICAgW2VuXUxhcmdlIGJ1dHRvbiB0aGF0IGNvdmVycyB0aGUgd2lkdGggb2YgdGhlIHNjcmVlbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KL5aSn44GN44Gq44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZS0tcXVpZXRcbiAqICAgW2VuXUxhcmdlIHF1aWV0IGJ1dHRvbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KLcXVpZXTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlLS1jdGFcbiAqICAgW2VuXUxhcmdlIGNhbGwgdG8gYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICogICBbamFd5qiq44GE44Gj44Gx44GE44Gr5bqD44GM44KLY3Rh44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIGJ1dHRvblsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjgr/jg7NbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsLS1mbGF0XG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gZmxhdCBidXR0b25bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44OV44Op44OD44OI44Oc44K/44OzWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQnV0dG9uIGNvbXBvbmVudC4gSWYgeW91IHdhbnQgdG8gcGxhY2UgYSBidXR0b24gaW4gYSB0b29sYmFyLCB1c2UgYDxvbnMtdG9vbGJhci1idXR0b24+YCBvciBgPG9ucy1iYWNrLWJ1dHRvbj5gIGluc3RlYWQuXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIGJ1dHRvbiB3aXRoIGEgcmlwcGxlIGVmZmVjdCBvbiBBbmRyb2lkLlxuICogICBbL2VuXVxuICogICBbamFd44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44CC44OE44O844Or44OQ44O844Gr44Oc44K/44Oz44KS6Kit572u44GZ44KL5aC05ZCI44Gv44CBb25zLXRvb2xiYXItYnV0dG9u44KC44GX44GP44Gvb25zLWJhY2stYnV0dG9u44Kz44Oz44Od44O844ON44Oz44OI44KS5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGhMYXl4XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYnV0dG9uXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtYnV0dG9uIG1vZGlmaWVyPVwibGFyZ2UtLWN0YVwiPlxuICogICBUYXAgTWVcbiAqIDwvb25zLWJ1dHRvbj5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogIFtqYV3jg5zjgr/jg7Pjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByaXBwbGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgdGhlIGJ1dHRvbiB3aWxsIGhhdmUgYSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLkJ1dHRvbiA9IEJ1dHRvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1idXR0b24nLCBCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2NhcmQnO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ2NhcmQtLSonLFxuICAnLmNhcmRfX3RpdGxlJzogJ2NhcmQtLSpfX3RpdGxlJyxcbiAgJy5jYXJkX19jb250ZW50JzogJ2NhcmQtLSpfX2NvbnRlbnQnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jYXJkXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXUEgY2FyZCB3aXRoIG1hdGVyaWFsIGRlc2lnbi5bL2VuXVxuICogICBbamFd44Oq44K544OI44Gu5LiK5LiL44Gu44Oc44O844OA44O844GM54Sh44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICBDb21wb25lbnQgdG8gY3JlYXRlIGEgY2FyZCB0aGF0IGRpc3BsYXlzIHNvbWUgaW5mb3JtYXRpb24uXG4gKlxuICogICAgVGhlIGNhcmQgbWF5IGJlIGNvbXBvc2VkIGJ5IGRpdnMgd2l0aCBzcGVjaWFsbHkgcHJlcGFyZWQgY2xhc3NlcyBgdGl0bGVgIGFuZC9vciBgY29udGVudGAuIFlvdSBjYW4gYWxzbyBhZGQgeW91ciBvd24gY29udGVudCBhcyB5b3UgcGxlYXNlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2NhcmRcbiAqIEBleGFtcGxlXG4gKiA8b25zLWNhcmQ+XG4gKiAgIDxwPlNvbWUgY29udGVudDwvcD5cbiAqIDwvb25zLWNhcmQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcmRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY2FyZC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGxldCB0aXRsZSwgY29udGVudDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCd0aXRsZScpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2NhcmRfX3RpdGxlJyk7XG4gICAgICAgIHRpdGxlID0gZWw7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NvbnRlbnQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdjYXJkX19jb250ZW50Jyk7XG4gICAgICAgIGNvbnRlbnQgPSBlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9ucy5lbGVtZW50cy5DYXJkID0gQ2FyZEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jYXJkJywgQ2FyZEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdjYXJvdXNlbC1pdGVtLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcm91c2VsLWl0ZW1cbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBpdGVtIGNvbXBvbmVudC4gVXNlZCBhcyBhIGNoaWxkIG9mIHRoZSBgPG9ucy1jYXJvdXNlbD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geGJiek9RXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2Fyb3VzZWxcbiAqIEBzZWVhbHNvIG9ucy1jYXJvdXNlbFxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWw+YCBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXTxvbnMtY2Fyb3VzZWw+44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWNhcm91c2VsIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMjAwcHhcIj5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogPC9vbnMtY2Fyb3VzZWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcm91c2VsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuQ2Fyb3VzZWxJdGVtID0gQ2Fyb3VzZWxJdGVtRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWNhcm91c2VsLWl0ZW0nLCBDYXJvdXNlbEl0ZW1FbGVtZW50KTtcbiIsImltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vYW5pbWl0JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IGRpcmVjdGlvbk1hcCA9IHtcbiAgdmVydGljYWw6IHtcbiAgICBheGlzOiAnWScsXG4gICAgc2l6ZTogJ0hlaWdodCcsXG4gICAgZGlyOiBbJ3VwJywgJ2Rvd24nXSxcbiAgICB0M2Q6IFsnMHB4LCAnLCAncHgsIDBweCddXG4gIH0sXG4gIGhvcml6b250YWw6IHtcbiAgICBheGlzOiAnWCcsXG4gICAgc2l6ZTogJ1dpZHRoJyxcbiAgICBkaXI6IFsnbGVmdCcsICdyaWdodCddLFxuICAgIHQzZDogWycnLCAncHgsIDBweCwgMHB4J11cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3dpcGVyIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgLy8gUGFyYW1ldGVyc1xuICAgIGNvbnN0IEZBTFNFID0gKCgpID0+IGZhbHNlKTtcbiAgICBgZ2V0SW5pdGlhbEluZGV4IGdldEJ1YmJsZVdpZHRoIGlzVmVydGljYWwgaXNPdmVyU2Nyb2xsYWJsZSBpc0NlbnRlcmVkXG4gICAgaXNBdXRvU2Nyb2xsYWJsZSByZWZyZXNoSG9vayBwcmVDaGFuZ2VIb29rIHBvc3RDaGFuZ2VIb29rIG92ZXJTY3JvbGxIb29rYFxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC5mb3JFYWNoKGtleSA9PiB0aGlzW2tleV0gPSBwYXJhbXNba2V5XSB8fCBGQUxTRSk7XG5cbiAgICB0aGlzLmdldEVsZW1lbnQgPSBwYXJhbXMuZ2V0RWxlbWVudDsgLy8gUmVxdWlyZWRcbiAgICB0aGlzLnNjcm9sbEhvb2sgPSBwYXJhbXMuc2Nyb2xsSG9vazsgLy8gT3B0aW9uYWxcbiAgICB0aGlzLml0ZW1TaXplID0gcGFyYW1zLml0ZW1TaXplIHx8ICcxMDAlJztcblxuICAgIHRoaXMuZ2V0QXV0b1Njcm9sbFJhdGlvID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIGxldCByYXRpbyA9IHBhcmFtcy5nZXRBdXRvU2Nyb2xsUmF0aW8gJiYgcGFyYW1zLmdldEF1dG9TY3JvbGxSYXRpbyguLi5hcmdzKTtcbiAgICAgIHJhdGlvID0gdHlwZW9mIHJhdGlvID09PSAnbnVtYmVyJyAmJiByYXRpbyA9PT0gcmF0aW8gPyByYXRpbyA6IC41O1xuICAgICAgaWYgKHJhdGlvIDwgMC4wIHx8IHJhdGlvID4gMS4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhdXRvLXNjcm9sbC1yYXRpbyAnICsgcmF0aW8gKyAnLiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgMScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhdGlvO1xuICAgIH07XG5cbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBvbmx5IG9uIGRlc2t0b3BcbiAgICB0aGlzLnNob3VsZEJsb2NrID0gcGxhdGZvcm0uX3J1bk9uQWN0dWFsUGxhdGZvcm0oKCkgPT4gcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSkgPT09ICdvdGhlcic7XG5cbiAgICAvLyBCaW5kIGhhbmRsZXJzXG4gICAgdGhpcy5vbkRyYWdTdGFydCA9IHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uRHJhZyA9IHRoaXMub25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkRyYWdFbmQgPSB0aGlzLm9uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25SZXNpemUgPSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XG4gIH1cblxuICBpbml0KHsgc3dpcGVhYmxlLCBhdXRvUmVmcmVzaCB9ID0ge30pIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLnRhcmdldCA9IHRoaXMuZ2V0RWxlbWVudCgpLmNoaWxkcmVuWzBdO1xuICAgIHRoaXMuYmxvY2tlciA9IHRoaXMuZ2V0RWxlbWVudCgpLmNoaWxkcmVuWzFdO1xuICAgIGlmICghdGhpcy50YXJnZXQgfHwgIXRoaXMuYmxvY2tlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBcInRhcmdldFwiIGFuZCBcImJsb2NrZXJcIiBlbGVtZW50cyB0byBleGlzdCBiZWZvcmUgaW5pdGlhbGl6aW5nIFN3aXBlci4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2hvdWxkQmxvY2spIHtcbiAgICAgIHRoaXMuYmxvY2tlci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIC8vIEFkZCBjbGFzc2VzXG4gICAgdGhpcy5nZXRFbGVtZW50KCkuY2xhc3NMaXN0LmFkZCgnb25zLXN3aXBlcicpO1xuICAgIHRoaXMudGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ29ucy1zd2lwZXItdGFyZ2V0Jyk7XG4gICAgdGhpcy5ibG9ja2VyLmNsYXNzTGlzdC5hZGQoJ29ucy1zd2lwZXItYmxvY2tlcicpO1xuXG4gICAgLy8gU2V0dXAgbGlzdGVuZXJzXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLmdldEVsZW1lbnQoKSwgeyBkcmFnTWluRGlzdGFuY2U6IDEsIGRyYWdMb2NrVG9BeGlzOiB0cnVlIH0pO1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gICAgdGhpcy51cGRhdGVTd2lwZWFibGUoc3dpcGVhYmxlKTtcbiAgICB0aGlzLnVwZGF0ZUF1dG9SZWZyZXNoKGF1dG9SZWZyZXNoKTtcblxuICAgIC8vIFNldHVwIGluaXRpYWwgbGF5b3V0XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fb2Zmc2V0ID0gdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQoKTtcbiAgICB0aGlzLl9zZXR1cEluaXRpYWxJbmRleCgpO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmluaXRpYWxpemVkICYmIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCkpO1xuXG4gICAgLy8gRml4IHJlbmRlcmluZyBnbGl0Y2ggb24gQW5kcm9pZCA0LjFcbiAgICBpZiAodGhpcy5vZmZzZXRIZWlnaHQgPT09IDApIHtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVTd2lwZWFibGUoZmFsc2UpO1xuICAgIHRoaXMudXBkYXRlQXV0b1JlZnJlc2goZmFsc2UpO1xuXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yICYmIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLmJsb2NrZXIgPSB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcblxuICAgIHRoaXMuc2V0dXBSZXNpemUoZmFsc2UpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3Njcm9sbCAvIHRoaXMudGFyZ2V0U2l6ZTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoaSk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICBnZXQgaXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldC5jaGlsZHJlbi5sZW5ndGg7XG4gIH1cblxuICBnZXQgaXRlbU51bVNpemUoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9pdGVtTnVtU2l6ZSAhPT0gJ251bWJlcicgfHwgdGhpcy5faXRlbU51bVNpemUgIT09IHRoaXMuX2l0ZW1OdW1TaXplKSB7XG4gICAgICB0aGlzLl9pdGVtTnVtU2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZUl0ZW1TaXplKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pdGVtTnVtU2l6ZTtcbiAgfVxuXG4gIGdldCBtYXhTY3JvbGwoKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5pdGVtQ291bnQgKiB0aGlzLml0ZW1OdW1TaXplIC0gdGhpcy50YXJnZXRTaXplO1xuICAgIHJldHVybiBNYXRoLmNlaWwobWF4IDwgMCA/IDAgOiBtYXgpOyAvLyBOZWVkIHRvIHJldHVybiBhbiBpbnRlZ2VyIHZhbHVlLlxuICB9XG5cbiAgX2NhbGN1bGF0ZUl0ZW1TaXplKCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLml0ZW1TaXplLm1hdGNoKC9eKFxcZCspKHB4fCUpLyk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdGF0ZTogc3dpcGVyJ3Mgc2l6ZSB1bml0IG11c3QgYmUgJyUnIG9yICdweCdgKTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcbiAgICByZXR1cm4gbWF0Y2hlc1syXSA9PT0gJyUnID8gTWF0aC5yb3VuZCh2YWx1ZSAvIDEwMCAqIHRoaXMudGFyZ2V0U2l6ZSkgOiB2YWx1ZTtcbiAgfVxuXG4gIF9zZXR1cEluaXRpYWxJbmRleCgpIHtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IE1hdGgubWF4KE1hdGgubWluKE51bWJlcih0aGlzLmdldEluaXRpYWxJbmRleCgpKSwgdGhpcy5pdGVtQ291bnQpLCAwKTtcbiAgICB0aGlzLl9zY3JvbGwgPSB0aGlzLl9vZmZzZXQgKyB0aGlzLml0ZW1OdW1TaXplICogdGhpcy5fbGFzdEFjdGl2ZUluZGV4O1xuICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3Njcm9sbCk7XG4gIH1cblxuICBzZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5pdGVtQ291bnQgLSAxKSk7XG4gICAgY29uc3Qgc2Nyb2xsID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5tYXhTY3JvbGwsIHRoaXMuX29mZnNldCArIHRoaXMuaXRlbU51bVNpemUgKiBpbmRleCkpO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzVUlXZWJWaWV3KCkpIHtcbiAgICAgIC8qIERpcnR5IGZpeCBmb3IgIzIyMzEoaHR0cHM6Ly9naXRodWIuY29tL09uc2VuVUkvT25zZW5VSS9pc3N1ZXMvMjIzMSkuIGJlZ2luICovXG4gICAgICBjb25zdCBjb25jYXQgPSBhcnJheU9mQXJyYXkgPT4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyYXlPZkFycmF5KTtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gY29uY2F0KFxuICAgICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLnRhcmdldC5jaGlsZHJlbikubWFwKHBhZ2UgPT4ge1xuICAgICAgICAgIHJldHVybiB1dGlsLmFycmF5RnJvbShwYWdlLmNoaWxkcmVuKVxuICAgICAgICAgICAgLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ3BhZ2VfX2NvbnRlbnQnKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBjb250ZW50cy5mb3JFYWNoKGNvbnRlbnQgPT4ge1xuICAgICAgICAgICAgbWFwLnNldChjb250ZW50LCBjb250ZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSk7XG4gICAgICAgICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3BhZ2VfX2NvbnRlbnQtLXN1cHByZXNzLWxheWVyLWNyZWF0aW9uJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVzb2x2ZSk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHRoaXMuX2NoYW5nZVRvKHNjcm9sbCwgb3B0aW9ucykpXG4gICAgICAgIC50aGVuKCgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGNvbnRlbnRzLmZvckVhY2goY29udGVudCA9PiB7XG4gICAgICAgICAgICBjb250ZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBtYXAuZ2V0KGNvbnRlbnQpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVzb2x2ZSk7XG4gICAgICAgIH0pKVxuICAgICAgKTtcbiAgICAgIC8qIGVuZCAqL1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2hhbmdlVG8oc2Nyb2xsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBnZXRBY3RpdmVJbmRleChzY3JvbGwgPSB0aGlzLl9zY3JvbGwpIHtcbiAgICBzY3JvbGwgLT0gdGhpcy5fb2Zmc2V0O1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5pdGVtQ291bnQsXG4gICAgICBzaXplID0gdGhpcy5pdGVtTnVtU2l6ZTtcblxuICAgIGlmIChzY3JvbGwgPD0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBpZiAoc2l6ZSAqIGkgPD0gc2Nyb2xsICYmIHNpemUgKiAoaSArIDEpID4gc2Nyb2xsKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3VudCAtIDE7XG4gIH1cblxuICBzZXR1cFJlc2l6ZShhZGQpIHtcbiAgICB3aW5kb3dbKGFkZCA/ICdhZGQnIDogJ3JlbW92ZScpICsgJ0V2ZW50TGlzdGVuZXInXSgncmVzaXplJywgdGhpcy5vblJlc2l6ZSwgdHJ1ZSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc2V0dXBSZXNpemUodHJ1ZSk7XG4gICAgdGhpcy5vblJlc2l6ZSgpO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnNldHVwUmVzaXplKGZhbHNlKTtcbiAgfVxuXG4gIHVwZGF0ZVN3aXBlYWJsZShzaG91bGRVcGRhdGUpIHtcbiAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBzaG91bGRVcGRhdGUgPyAnb24nIDogJ29mZic7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZycsIHRoaXMub25EcmFnKTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnc3RhcnQnLCB0aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnZW5kJywgdGhpcy5vbkRyYWdFbmQpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUF1dG9SZWZyZXNoKHNob3VsZFdhdGNoKSB7XG4gICAgaWYgKHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIHNob3VsZFdhdGNoXG4gICAgICAgID8gdGhpcy5fbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMudGFyZ2V0LCB7IGNoaWxkTGlzdDogdHJ1ZSB9KVxuICAgICAgICA6IHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUl0ZW1TaXplKG5ld1NpemUpIHtcbiAgICB0aGlzLml0ZW1TaXplID0gbmV3U2l6ZSB8fCAnMTAwJSc7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICB0b2dnbGVCbG9ja2VyKGJsb2NrKSB7XG4gICAgdGhpcy5ibG9ja2VyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBibG9jayA/ICdhdXRvJyA6ICdub25lJztcbiAgfVxuXG4gIF9jYW5Db25zdW1lR2VzdHVyZShnZXN0dXJlKSB7XG4gICAgY29uc3QgZCA9IGdlc3R1cmUuZGlyZWN0aW9uO1xuICAgIGNvbnN0IGlzRmlyc3QgPSB0aGlzLl9zY3JvbGwgPT09IDAgJiYgIXRoaXMuaXNPdmVyU2Nyb2xsYWJsZSgpO1xuICAgIGNvbnN0IGlzTGFzdCA9IHRoaXMuX3Njcm9sbCA9PT0gdGhpcy5tYXhTY3JvbGwgJiYgIXRoaXMuaXNPdmVyU2Nyb2xsYWJsZSgpO1xuXG4gICAgcmV0dXJuIHRoaXMuaXNWZXJ0aWNhbCgpXG4gICAgICA/ICgoZCA9PT0gJ2Rvd24nICYmICFpc0ZpcnN0KSB8fCAoZCA9PT0gJ3VwJyAmJiAhaXNMYXN0KSlcbiAgICAgIDogKChkID09PSAncmlnaHQnICYmICFpc0ZpcnN0KSB8fCAoZCA9PT0gJ2xlZnQnICYmICFpc0xhc3QpKTtcbiAgfVxuXG4gIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5faWdub3JlRHJhZyA9IGV2ZW50LmNvbnN1bWVkIHx8ICF1dGlsLmlzVmFsaWRHZXN0dXJlKGV2ZW50KTtcblxuICAgIGlmICghdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgY29uc3QgY29uc3VtZSA9IGV2ZW50LmNvbnN1bWU7XG4gICAgICBldmVudC5jb25zdW1lID0gKCkgPT4geyBjb25zdW1lICYmIGNvbnN1bWUoKTsgdGhpcy5faWdub3JlRHJhZyA9IHRydWU7IH07XG5cbiAgICAgIGlmICh0aGlzLl9jYW5Db25zdW1lR2VzdHVyZShldmVudC5nZXN0dXJlKSkge1xuICAgICAgICBjb25zdCBzdGFydFggPSBldmVudC5nZXN0dXJlLmNlbnRlciAmJiBldmVudC5nZXN0dXJlLmNlbnRlci5jbGllbnRYIHx8IDAsXG4gICAgICAgICAgZGlzdEZyb21FZGdlID0gdGhpcy5nZXRCdWJibGVXaWR0aCgpIHx8IDAsXG4gICAgICAgICAgc3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdW1lICYmIGNvbnN1bWUoKTtcbiAgICAgICAgICAgIGV2ZW50LmNvbnN1bWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlOyAvLyBBdm9pZCBzdGFydGluZyBkcmFnIGZyb20gb3V0c2lkZVxuICAgICAgICAgICAgdGhpcy5zaG91bGRCbG9jayAmJiB0aGlzLnRvZ2dsZUJsb2NrZXIodHJ1ZSk7XG4gICAgICAgICAgICB1dGlsLnByZXZlbnRTY3JvbGwodGhpcy5fZ2VzdHVyZURldGVjdG9yKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIExldCBwYXJlbnQgZWxlbWVudHMgY29uc3VtZSB0aGUgZ2VzdHVyZSBvciBjb25zdW1lIGl0IHJpZ2h0IGF3YXlcbiAgICAgICAgc3RhcnRYIDwgZGlzdEZyb21FZGdlIHx8IHN0YXJ0WCA+ICh0aGlzLnRhcmdldFNpemUgLSBkaXN0RnJvbUVkZ2UpXG4gICAgICAgICAgPyBzZXRJbW1lZGlhdGUoKCkgPT4gIXRoaXMuX2lnbm9yZURyYWcgJiYgc3RhcnQoKSlcbiAgICAgICAgICA6IHN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuX2lnbm9yZURyYWcgfHwgIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250aW51ZWQgPSB0cnVlOyAvLyBGaXggZm9yIHJhbmRvbSAnZHJhZ2VuZCcgd2l0aG91dCAnZHJhZydcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3Njcm9sbCAtIHRoaXMuX2dldERlbHRhKGV2ZW50KSwgeyB0aHJvdHRsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIG9uRHJhZ0VuZChldmVudCkge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWV2ZW50Lmdlc3R1cmUgfHwgdGhpcy5faWdub3JlRHJhZyB8fCAhdGhpcy5fY29udGludWVkKSB7XG4gICAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTsgLy8gb25EcmFnRW5kIG1pZ2h0IGZpcmUgYmVmb3JlIG9uRHJhZ1N0YXJ0J3Mgc2V0SW1tZWRpYXRlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGludWVkID0gZmFsc2U7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSB0aGlzLl9nZXREZWx0YShldmVudCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNjcm9sbCA9IHRoaXMuX25vcm1hbGl6ZVNjcm9sbChzY3JvbGwpO1xuICAgIHNjcm9sbCA9PT0gbm9ybWFsaXplZFNjcm9sbCA/IHRoaXMuX3N0YXJ0TW9tZW50dW1TY3JvbGwoc2Nyb2xsLCBldmVudCkgOiB0aGlzLl9raWxsT3ZlclNjcm9sbChub3JtYWxpemVkU2Nyb2xsKTtcbiAgICB0aGlzLnNob3VsZEJsb2NrICYmIHRoaXMudG9nZ2xlQmxvY2tlcihmYWxzZSk7XG4gIH1cblxuICBfc3RhcnRNb21lbnR1bVNjcm9sbChzY3JvbGwsIGV2ZW50KSB7XG4gICAgY29uc3QgdmVsb2NpdHkgPSB0aGlzLl9nZXRWZWxvY2l0eShldmVudCksXG4gICAgICBtYXRjaGVzRGlyZWN0aW9uID0gZXZlbnQuZ2VzdHVyZS5pbnRlcmltRGlyZWN0aW9uID09PSB0aGlzLmRNLmRpclt0aGlzLl9nZXREZWx0YShldmVudCkgPCAwID8gMCA6IDFdO1xuXG4gICAgY29uc3QgbmV4dFNjcm9sbCA9IHRoaXMuX2dldEF1dG9TY3JvbGwoc2Nyb2xsLCB2ZWxvY2l0eSwgbWF0Y2hlc0RpcmVjdGlvbik7XG4gICAgbGV0IGR1cmF0aW9uID0gTWF0aC5hYnMobmV4dFNjcm9sbCAtIHNjcm9sbCkgLyAodmVsb2NpdHkgKyAwLjAxKSAvIDEwMDA7XG4gICAgZHVyYXRpb24gPSBNYXRoLm1pbiguMjUsIE1hdGgubWF4KC4xLCBkdXJhdGlvbikpO1xuXG4gICAgdGhpcy5fY2hhbmdlVG8obmV4dFNjcm9sbCwgeyBzd2lwZTogdHJ1ZSwgYW5pbWF0aW9uT3B0aW9uczogeyBkdXJhdGlvbiwgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC40LCAuNywgLjUsIDEpJyB9IH0pO1xuICB9XG5cbiAgX2tpbGxPdmVyU2Nyb2xsKHNjcm9sbCkge1xuICAgIHRoaXMuX3Njcm9sbCA9IHNjcm9sbDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRNLmRpcltOdW1iZXIoc2Nyb2xsID4gMCldO1xuICAgIGNvbnN0IGtpbGxPdmVyU2Nyb2xsID0gKCkgPT4gdGhpcy5fY2hhbmdlVG8oc2Nyb2xsLCB7IGFuaW1hdGlvbk9wdGlvbnM6IHsgZHVyYXRpb246IC40LCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknIH0gfSk7XG4gICAgdGhpcy5vdmVyU2Nyb2xsSG9vayh7IGRpcmVjdGlvbiwga2lsbE92ZXJTY3JvbGwgfSkgfHwga2lsbE92ZXJTY3JvbGwoKTtcbiAgfVxuXG4gIF9jaGFuZ2VUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGUgPSB7IGFjdGl2ZUluZGV4OiB0aGlzLmdldEFjdGl2ZUluZGV4KHNjcm9sbCksIGxhc3RBY3RpdmVJbmRleDogdGhpcy5fbGFzdEFjdGl2ZUluZGV4LCBzd2lwZTogb3B0aW9ucy5zd2lwZSB8fCBmYWxzZSB9O1xuICAgIGNvbnN0IGNoYW5nZSA9IGUuYWN0aXZlSW5kZXggIT09IGUubGFzdEFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IGNhbmNlbGVkID0gY2hhbmdlID8gdGhpcy5wcmVDaGFuZ2VIb29rKGUpIDogZmFsc2U7XG5cbiAgICB0aGlzLl9zY3JvbGwgPSBjYW5jZWxlZCA/IHRoaXMuX29mZnNldCArIGUubGFzdEFjdGl2ZUluZGV4ICogdGhpcy5pdGVtTnVtU2l6ZSA6IHNjcm9sbDtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBjYW5jZWxlZCA/IGUubGFzdEFjdGl2ZUluZGV4IDogZS5hY3RpdmVJbmRleDtcblxuICAgIHJldHVybiB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHNjcm9sbCA9PT0gdGhpcy5fc2Nyb2xsICYmICFjYW5jZWxlZCkge1xuICAgICAgICBjaGFuZ2UgJiYgdGhpcy5wb3N0Q2hhbmdlSG9vayhlKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5yZWplY3QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3Njcm9sbFRvKHNjcm9sbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMudGhyb3R0bGUpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gMC4zNTtcbiAgICAgIGlmIChzY3JvbGwgPCAwKSB7XG4gICAgICAgIHNjcm9sbCA9IHRoaXMuaXNPdmVyU2Nyb2xsYWJsZSgpID8gTWF0aC5yb3VuZChzY3JvbGwgKiByYXRpbykgOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF4U2Nyb2xsID0gdGhpcy5tYXhTY3JvbGw7XG4gICAgICAgIGlmIChtYXhTY3JvbGwgPCBzY3JvbGwpIHtcbiAgICAgICAgICBzY3JvbGwgPSB0aGlzLmlzT3ZlclNjcm9sbGFibGUoKSA/IG1heFNjcm9sbCArIE1hdGgucm91bmQoKHNjcm9sbCAtIG1heFNjcm9sbCkgKiByYXRpbykgOiBtYXhTY3JvbGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcHQgPSBvcHRpb25zLmFuaW1hdGlvbiAgPT09ICdub25lJyA/IHt9IDogb3B0aW9ucy5hbmltYXRpb25PcHRpb25zO1xuICAgIHRoaXMuc2Nyb2xsSG9vayAmJiB0aGlzLml0ZW1OdW1TaXplID4gMCAmJiB0aGlzLnNjcm9sbEhvb2soKHNjcm9sbCAvIHRoaXMuaXRlbU51bVNpemUpLnRvRml4ZWQoMiksIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PlxuICAgICAgYW5pbWl0KHRoaXMudGFyZ2V0KVxuICAgICAgICAucXVldWUoeyB0cmFuc2Zvcm06IHRoaXMuX2dldFRyYW5zZm9ybShzY3JvbGwpIH0sIG9wdClcbiAgICAgICAgLnBsYXkocmVzb2x2ZSlcbiAgICApO1xuICB9XG5cbiAgX2dldEF1dG9TY3JvbGwoc2Nyb2xsLCB2ZWxvY2l0eSwgbWF0Y2hlc0RpcmVjdGlvbikge1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4U2Nyb2xsLFxuICAgICAgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0LFxuICAgICAgc2l6ZSA9IHRoaXMuaXRlbU51bVNpemU7XG5cbiAgICBpZiAoIXRoaXMuaXNBdXRvU2Nyb2xsYWJsZSgpKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCBzY3JvbGwpKTtcbiAgICB9XG5cbiAgICBsZXQgYXJyID0gW107XG4gICAgZm9yIChsZXQgcyA9IG9mZnNldDsgcyA8IG1heDsgcyArPSBzaXplKSB7XG4gICAgICBhcnIucHVzaChzKTtcbiAgICB9XG4gICAgYXJyLnB1c2gobWF4KTtcblxuICAgIGFyciA9IGFyclxuICAgICAgLnNvcnQoKGxlZnQsIHJpZ2h0KSA9PiBNYXRoLmFicyhsZWZ0IC0gc2Nyb2xsKSAtIE1hdGguYWJzKHJpZ2h0IC0gc2Nyb2xsKSlcbiAgICAgIC5maWx0ZXIoKGl0ZW0sIHBvcykgPT4gIXBvcyB8fCBpdGVtICE9PSBhcnJbcG9zIC0gMV0pO1xuXG4gICAgbGV0IHJlc3VsdCA9IGFyclswXTtcbiAgICBjb25zdCBsYXN0U2Nyb2xsID0gdGhpcy5fbGFzdEFjdGl2ZUluZGV4ICogc2l6ZSArIG9mZnNldDtcbiAgICBjb25zdCBzY3JvbGxSYXRpbyA9IE1hdGguYWJzKHNjcm9sbCAtIGxhc3RTY3JvbGwpIC8gc2l6ZTtcblxuICAgIGlmIChzY3JvbGxSYXRpbyA8PSB0aGlzLmdldEF1dG9TY3JvbGxSYXRpbyhtYXRjaGVzRGlyZWN0aW9uLCB2ZWxvY2l0eSwgc2l6ZSkpIHtcbiAgICAgIHJlc3VsdCA9IGxhc3RTY3JvbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzY3JvbGxSYXRpbyA8IDEuMCAmJiBhcnJbMF0gPT09IGxhc3RTY3JvbGwgJiYgYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmVzdWx0ID0gYXJyWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCByZXN1bHQpKTtcbiAgfVxuXG4gIF9yZXNldCgpIHtcbiAgICB0aGlzLl90YXJnZXRTaXplID0gdGhpcy5faXRlbU51bVNpemUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBfbm9ybWFsaXplU2Nyb2xsKHNjcm9sbCkge1xuICAgIHJldHVybiBNYXRoLm1heCggTWF0aC5taW4oc2Nyb2xsLCB0aGlzLm1heFNjcm9sbCksIDApXG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KCk7XG5cbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9ub3JtYWxpemVTY3JvbGwodGhpcy5fc2Nyb2xsKTtcbiAgICBzY3JvbGwgIT09IHRoaXMuX3Njcm9sbCA/IHRoaXMuX2tpbGxPdmVyU2Nyb2xsKHNjcm9sbCkgOiB0aGlzLl9jaGFuZ2VUbyhzY3JvbGwpO1xuXG4gICAgdGhpcy5yZWZyZXNoSG9vaygpO1xuICB9XG5cbiAgZ2V0IHRhcmdldFNpemUoKSB7XG4gICAgaWYgKCF0aGlzLl90YXJnZXRTaXplKSB7XG4gICAgICB0aGlzLl90YXJnZXRTaXplID0gdGhpcy50YXJnZXRbYG9mZnNldCR7dGhpcy5kTS5zaXplfWBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0U2l6ZTtcbiAgfVxuXG4gIF9nZXREZWx0YShldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlW2BkZWx0YSR7dGhpcy5kTS5heGlzfWBdO1xuICB9XG5cbiAgX2dldFZlbG9jaXR5KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmVbYHZlbG9jaXR5JHt0aGlzLmRNLmF4aXN9YF07XG4gIH1cblxuICBfZ2V0VHJhbnNmb3JtKHNjcm9sbCkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRNLnQzZFswXX0key1zY3JvbGx9JHt0aGlzLmRNLnQzZFsxXX0pYDtcbiAgfVxuXG4gIF91cGRhdGVMYXlvdXQoKSB7XG4gICAgdGhpcy5kTSA9IGRpcmVjdGlvbk1hcFt0aGlzLmlzVmVydGljYWwoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCddO1xuICAgIHRoaXMudGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ29ucy1zd2lwZXItdGFyZ2V0LS12ZXJ0aWNhbCcsIHRoaXMuaXNWZXJ0aWNhbCgpKTtcblxuICAgIGZvciAobGV0IGMgPSB0aGlzLnRhcmdldC5jaGlsZHJlblswXTsgYzsgYyA9IGMubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICBjLnN0eWxlW3RoaXMuZE0uc2l6ZS50b0xvd2VyQ2FzZSgpXSA9IHRoaXMuaXRlbVNpemU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDZW50ZXJlZCgpKSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSAodGhpcy50YXJnZXRTaXplIC0gdGhpcy5pdGVtTnVtU2l6ZSkgLyAtMiB8fCAwO1xuICAgIH1cbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBTd2lwZXIgZnJvbSAnLi4vb25zL2ludGVybmFsL3N3aXBlcic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcm91c2VsXG4gKiBAY2F0ZWdvcnkgY2Fyb3VzZWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ2Fyb3VzZWwgY29tcG9uZW50LiBBIGNhcm91c2VsIGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgc2V2ZXJhbCBpdGVtcyBpbiB0aGUgc2FtZSBzcGFjZS5cbiAqXG4gKiAgICAgVGhlIGNvbXBvbmVudCBzdXBwb3J0cyBkaXNwbGF5aW5nIGNvbnRlbnQgYm90aCBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkuIFRoZSB1c2VyIGNhbiBzY3JvbGwgdGhyb3VnaCB0aGUgaXRlbXMgYnkgZHJhZ2dpbmcgYW5kIGl0IGNhbiBhbHNvIGJlIGNvbnRyb2xsZXIgcHJvZ3JhbW1hdGljYWxseS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4YmJ6T1FcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9jYXJvdXNlbFxuICogQHNlZWFsc28gb25zLWNhcm91c2VsLWl0ZW1cbiAqICAgW2VuXWA8b25zLWNhcm91c2VsLWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWNhcm91c2VsLWl0ZW3jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2Fyb3VzZWwgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAyMDBweFwiPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiA8L29ucy1jYXJvdXNlbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2Fyb3VzZWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgY3VycmVudCBjYXJvdXNlbCBpdGVtIGhhcyBjaGFuZ2VkLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuOBl+OBpuOBhOOCi+OCq+ODq+ODvOOCu+ODq+OBruimgee0oOOBjOWkieOCj+OBo+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5hY3RpdmVJbmRleFxuICAgKiAgIFtlbl1DdXJyZW50IGFjdGl2ZSBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovopoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQubGFzdEFjdGl2ZUluZGV4XG4gICAqICAgW2VuXVByZXZpb3VzIGFjdGl2ZSBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3ku6XliY3jgqLjgq/jg4bjgqPjg5bjgaDjgaPjgZ/opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHJlZnJlc2hcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxuICAgKiAgIFtlbl1DYXJvdXNlbCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44GfQ2Fyb3VzZWzjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IG92ZXJzY3JvbGxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIG92ZXJzY3JvbGxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzjgqrjg7zjg5Djg7zjgrnjgq/jg63jg7zjg6vjgZfjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jYXJvdXNlbFxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBjYXJvdXNlbCBoYXMgYmVlbiByZWZyZXNoZWQuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or44GM5pu05paw44GV44KM44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudC5kaXJlY3Rpb25cbiAgICogICBbZW5dQ2FuIGJlIG9uZSBvZiBlaXRoZXIgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgb3IgXCJyaWdodFwiLlsvZW5dXG4gICAqICAgW2phXeOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBleOCjOOBn+aWueWQkeOBjOW+l+OCieOCjOOBvuOBmeOAglwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiLCBcInJpZ2h0XCLjga7jgYTjgZrjgozjgYvjga7mlrnlkJHjgYzmuKHjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC53YWl0VG9SZXR1cm5cbiAgICogICBbZW5dVGFrZXMgYSA8Y29kZT5Qcm9taXNlPC9jb2RlPiBvYmplY3QgYXMgYW4gYXJndW1lbnQuIFRoZSBjYXJvdXNlbCB3aWxsIG5vdCBzY3JvbGwgYmFjayB1bnRpbCB0aGUgcHJvbWlzZSBoYXMgYmVlbiByZXNvbHZlZCBvciByZWplY3RlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjga9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS5byV5pWw44Go44GX44Gm5Y+X44GR5Y+W44KK44G+44GZ44CC5rih44GX44GfUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOBjHJlc29sdmXjgZXjgozjgovjgYtyZWplY3TjgZXjgozjgovjgb7jgafjgIHjgqvjg6vjg7zjgrvjg6vjga/jgrnjgq/jg63jg7zjg6vjg5Djg4Pjgq/jgZfjgb7jgZvjgpPjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBkaXJlY3Rpb24gb2YgdGhlIGNhcm91c2VsLiBDYW4gYmUgZWl0aGVyIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi4gRGVmYXVsdCBpcyBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjga7mlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJcImhvcml6b250YWxcIuOBi1widmVydGljYWxcIuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GM44OH44OV44Kp44Or44OI5YCk44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZnVsbHNjcmVlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGNvdmVyIHRoZSB3aG9sZSBzY3JlZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CBYWJzb2x1dGXjg53jgrjjgrfjg6fjg7PjgpLkvb/jgaPjgabjgqvjg6vjg7zjgrvjg6vjgYzoh6rli5XnmoTjgavnlLvpnaLjgYTjgaPjgbHjgYTjgavluoPjgYzjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvdmVyc2Nyb2xsYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGJlIHNjcm9sbGFibGUgb3ZlciB0aGUgZWRnZS4gSXQgd2lsbCBib3VuY2UgYmFjayB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCv+ODg+ODgeOChOODieODqeODg+OCsOOBp+err+OBvuOBp+OCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+OAgeODkOOCpuODs+ODieOBmeOCi+OCiOOBhuOBquWKueaenOOBjOW9k+OBn+OCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNlbnRlcmVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHRoZW4gdGhlIHNlbGVjdGVkIGl0ZW0gd2lsbCBiZSBpbiB0aGUgY2VudGVyIG9mIHRoZSBjYXJvdXNlbCBpbnN0ZWFkIG9mIHRoZSBiZWdpbm5pbmcuIFVzZWZ1bCBvbmx5IHdoZW4gdGhlIGl0ZW1zIGFyZSBzbWFsbGVyIHRoYW4gdGhlIGNhcm91c2VsLiBbL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHpgbjjgpPjgafjgYTjgotvbnMtY2Fyb3VzZWwtaXRlbeOBr+OCq+ODq+ODvOOCu+ODq+OBruecn+OCk+S4reOBuOihjOOBjeOBvuOBmeOAgumgheebruOBjOOCq+ODq+ODvOOCu+ODq+OCiOOCiuOCguWwj+OBleOBhOWgtOWQiOOBq+OBruOBv+OAgeOBk+OCjOOBr+S+v+WIqeOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0td2lkdGhcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIHdpZHRoLiBPbmx5IHdvcmtzIHdoZW4gdGhlIGRpcmVjdGlvbiBpcyBzZXQgdG8gXCJob3Jpem9udGFsXCIuWy9lbl1cbiAgICogICAgW2phXW9ucy1jYXJvdXNlbC1pdGVt44Gu5bmF44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu5bGe5oCn44Gv44CBZGlyZWN0aW9u5bGe5oCn44GrXCJob3Jpem9udGFsXCLjgpLmjIflrprjgZfjgZ/mmYLjga7jgb/mnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpdGVtLWhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5db25zLWNhcm91c2VsLWl0ZW0ncyBoZWlnaHQuIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcInZlcnRpY2FsXCIuWy9lbl1cbiAgICogICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7pq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcInZlcnRpY2FsXCLjgpLmjIflrprjgZfjgZ/mmYLjga7jgb/mnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2Nyb2xsZWQgdG8gdGhlIGNsb3Nlc3QgaXRlbSBib3JkZXIgd2hlbiByZWxlYXNlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHkuIDnlarov5HjgYRjYXJvdXNlbC1pdGVt44Gu5aKD55WM44G+44Gn6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0by1zY3JvbGwtcmF0aW9cbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgIFtlbl1BIG51bWJlciBiZXR3ZWVuIDAuMCBhbmQgMS4wIHRoYXQgc3BlY2lmaWVzIGhvdyBtdWNoIHRoZSB1c2VyIG11c3QgZHJhZyB0aGUgY2Fyb3VzZWwgaW4gb3JkZXIgZm9yIGl0IHRvIGF1dG8gc2Nyb2xsIHRvIHRoZSBuZXh0IGl0ZW0uWy9lbl1cbiAgICogICAgW2phXTAuMOOBi+OCiTEuMOOBvuOBp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAguOCq+ODq+ODvOOCu+ODq+OBruimgee0oOOCkuOBqeOCjOOBkOOCieOBhOOBruWJsuWQiOOBvuOBp+ODieODqeODg+OCsOOBmeOCi+OBqOasoeOBruimgee0oOOBq+iHquWLleeahOOBq+OCueOCr+ODreODvOODq+OBmeOCi+OBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCBjYW4gYmUgc2Nyb2xsZWQgYnkgZHJhZyBvciBzd2lwZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgqvjg6vjg7zjgrvjg6vjgpLjgrnjg6/jgqTjg5fjgoTjg4njg6njg4PjgrDjgafnp7vli5XjgafjgY3jgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBjYXJvdXNlbCBpcyBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIFkcmFn44KEdG91Y2jjgoRzd2lwZeOCkuWPl+OBkeS7mOOBkeOBquOBj+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluaXRpYWwtaW5kZXhcbiAgICogQGluaXRvbmx5XG4gICAqIEBkZWZhdWx0IDBcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBvbnMtY2Fyb3VzZWwtaXRlbSB0byBzaG93IGluaXRpYWxseS4gRGVmYXVsdCBpcyAwLlsvZW5dXG4gICAqICAgW2phXeacgOWIneOBq+ihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSMOWni+OBvuOCiuOBruOCpOODs+ODh+ODg+OCr+OCueOBp+aMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOWApOOBryAwIOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hlbiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYXV0b21hdGljYWxseSByZWZyZXNoIHdoZW4gdGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBjaGFuZ2UuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB5a2Q6KaB57Sg44Gu5pWw44GM5aSJ44KP44KL44Go44Kr44Or44O844K744Or44Gv6Ieq5YuV55qE44Gr5pu05paw44GV44KM44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuY2hpbGRyZW5bMF0gJiYgdGhpcy5jaGlsZHJlblswXS50YWdOYW1lICE9PSAnT05TLUNBUk9VU0VMLUlURU0nICYmIHRoaXMuY2hpbGRyZW5bMF0gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaWYgKCF0YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGFyZ2V0KTtcbiAgICB9XG5cbiAgICAhdGhpcy5jaGlsZHJlblsxXSAmJiB0aGlzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQgPSB0aGlzLmFwcGVuZENoaWxkLmJpbmQodGFyZ2V0KTtcbiAgICB0aGlzLmluc2VydEJlZm9yZSA9IHRoaXMuaW5zZXJ0QmVmb3JlLmJpbmQodGFyZ2V0KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5fc3dpcGVyKSB7XG4gICAgICB0aGlzLl9zd2lwZXIgPSBuZXcgU3dpcGVyKHtcbiAgICAgICAgZ2V0RWxlbWVudDogKCkgPT4gdGhpcyxcbiAgICAgICAgZ2V0SW5pdGlhbEluZGV4OiAoKSA9PiB0aGlzLmdldEF0dHJpYnV0ZSgnaW5pdGlhbC1pbmRleCcpLFxuICAgICAgICBnZXRBdXRvU2Nyb2xsUmF0aW86ICgpID0+IHRoaXMuYXV0b1Njcm9sbFJhdGlvLFxuICAgICAgICBpc1ZlcnRpY2FsOiAoKSA9PiB0aGlzLnZlcnRpY2FsLFxuICAgICAgICBpc092ZXJTY3JvbGxhYmxlOiAoKSA9PiB0aGlzLm92ZXJzY3JvbGxhYmxlLFxuICAgICAgICBpc0NlbnRlcmVkOiAoKSA9PiB0aGlzLmNlbnRlcmVkLFxuICAgICAgICBpc0F1dG9TY3JvbGxhYmxlOiAoKSA9PiB0aGlzLmF1dG9TY3JvbGwsXG4gICAgICAgIGl0ZW1TaXplOiB0aGlzLml0ZW1TaXplLFxuICAgICAgICBvdmVyU2Nyb2xsSG9vazogdGhpcy5fb25PdmVyU2Nyb2xsLmJpbmQodGhpcyksXG4gICAgICAgIHByZUNoYW5nZUhvb2s6IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcywgJ3ByZWNoYW5nZScpLFxuICAgICAgICBwb3N0Q2hhbmdlSG9vazogdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzLCAncG9zdGNoYW5nZScpLFxuICAgICAgICByZWZyZXNoSG9vazogdGhpcy5fb25SZWZyZXNoLmJpbmQodGhpcyksXG4gICAgICAgIHNjcm9sbEhvb2s6IHRoaXMuX29uU3dpcGVcbiAgICAgIH0pO1xuXG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fc3dpcGVyLmluaXQoe1xuICAgICAgICBzd2lwZWFibGU6IHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSxcbiAgICAgICAgYXV0b1JlZnJlc2g6IHRoaXMuaGFzQXR0cmlidXRlKCdhdXRvLXJlZnJlc2gnKVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9zd2lwZXIgJiYgdGhpcy5fc3dpcGVyLmluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9zd2lwZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fc3dpcGVyID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydzd2lwZWFibGUnLCAnYXV0by1yZWZyZXNoJywgJ2RpcmVjdGlvbicsICdpdGVtLWhlaWdodCcsICdpdGVtLXdpZHRoJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmICghdGhpcy5fc3dpcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdzd2lwZWFibGUnOlxuICAgICAgICB0aGlzLl9zd2lwZXIudXBkYXRlU3dpcGVhYmxlKHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYXV0by1yZWZyZXNoJzpcbiAgICAgICAgdGhpcy5fc3dpcGVyLnVwZGF0ZUF1dG9SZWZyZXNoKHRoaXMuaGFzQXR0cmlidXRlKCdhdXRvLXJlZnJlc2gnKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaXRlbS1oZWlnaHQnOlxuICAgICAgICB0aGlzLnZlcnRpY2FsICYmIHRoaXMuX3N3aXBlci51cGRhdGVJdGVtU2l6ZSh0aGlzLml0ZW1TaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpdGVtLXdpZHRoJzpcbiAgICAgICAgdGhpcy52ZXJ0aWNhbCB8fCB0aGlzLl9zd2lwZXIudXBkYXRlSXRlbVNpemUodGhpcy5pdGVtU2l6ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgdGhpcy5fc3dpcGVyLnJlZnJlc2goKTtcbiAgICB9XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICB0aGlzLl9zd2lwZXIuc2hvdygpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy5fc3dpcGVyLmhpZGUoKTtcbiAgfVxuXG4gIF9vbk92ZXJTY3JvbGwoeyBkaXJlY3Rpb24sIGtpbGxPdmVyU2Nyb2xsIH0pIHtcbiAgICBsZXQgd2FpdEZvckFjdGlvbiA9IGZhbHNlO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnb3ZlcnNjcm9sbCcsIHtcbiAgICAgIGNhcm91c2VsOiB0aGlzLFxuICAgICAgYWN0aXZlSW5kZXg6IHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHdhaXRUb1JldHVybjogcHJvbWlzZSA9PiB7XG4gICAgICAgIHdhaXRGb3JBY3Rpb24gPSB0cnVlO1xuICAgICAgICBwcm9taXNlLnRoZW4oa2lsbE92ZXJTY3JvbGwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHdhaXRGb3JBY3Rpb247XG4gIH1cblxuICBfb25DaGFuZ2UoZXZlbnROYW1lLCB7IGFjdGl2ZUluZGV4LCBsYXN0QWN0aXZlSW5kZXggfSkge1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBldmVudE5hbWUsIHsgY2Fyb3VzZWw6IHRoaXMsIGFjdGl2ZUluZGV4LCBsYXN0QWN0aXZlSW5kZXggfSk7XG4gIH1cblxuICBfb25SZWZyZXNoKCkge1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncmVmcmVzaCcsIHsgY2Fyb3VzZWw6IHRoaXMgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVJbmRleFxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZUluZGV4KGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UaGUgaW5kZXggdGhhdCB0aGUgY2Fyb3VzZWwgc2hvdWxkIGJlIHNldCB0by5bL2VuXVxuICAgKiAgIFtqYV1jYXJvdXNlbOimgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nIGZ1bmN0aW9uIG9mIHRoZSBhbmltYXRpb24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGluZGV4IG9mIHRoZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAgdG8gc2hvdy5bL2VuXVxuICAgKiAgIFtqYV3ooajnpLrjgZnjgotvbnMtY2Fyb3VzZWwtaXRlbeOCkmluZGV444Gn5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZUluZGV4KGluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyAhPSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBZb3Ugc3VwcGxpZWQgJyArIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpO1xuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgeyBkdXJhdGlvbjogLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguNCwgLjcsIC41LCAxKScgfSxcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpID8gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIDoge31cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5zZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544GM6L+U44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GV44KM44Gm44GE44KLb25zLWNhcm91c2VsLWl0ZW3opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5nZXRBY3RpdmVJbmRleCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmV4dFxuICAgKiBAc2lnbmF0dXJlIG5leHQoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG5leHQgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeasoeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG5leHQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSArIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHJldlxuICAgKiBAc2lnbmF0dXJlIHByZXYoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHByZXZpb3VzIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3liY3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBwcmV2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgLSAxLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGZpcnN0XG4gICAqIEBzaWduYXR1cmUgZmlyc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgaXMgc2V0IHRvIGBcIm5vbmVcImAsIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IGZpcnN0IGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3mnIDliJ3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBmaXJzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgoMCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsYXN0XG4gICAqIEBzaWduYXR1cmUgbGFzdCgpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBsYXN0IG9ucy1jYXJvdXNlbCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeacgOW+jOOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGxhc3Qob3B0aW9ucykge1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoTWF0aC5tYXgodGhpcy5pdGVtQ291bnQgLSAxLCAwKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1VcGRhdGUgdGhlIGxheW91dCBvZiB0aGUgY2Fyb3VzZWwuIFVzZWQgd2hlbiBhZGRpbmcgYDxvbnMtY2Fyb3VzZWwtaXRlbXM+YCBkeW5hbWljYWxseSBvciB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB0aGUgc2l6ZS5bL2VuXVxuICAgKiAgIFtqYV3jg6zjgqTjgqLjgqbjg4jjgoTlhoXpg6jjga7nirbmhYvjgpLmnIDmlrDjga7jgoLjga7jgavmm7TmlrDjgZfjgb7jgZnjgIJvbnMtY2Fyb3VzZWwtaXRlbeOCkuWLleeahOOBq+Wil+OChOOBl+OBn+OCiuOAgW9ucy1jYXJvdXNlbOOBruWkp+OBjeOBleOCkuWLleeahOOBq+WkieOBiOOCi+mam+OBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX3N3aXBlci5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGl0ZW1Db3VudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBudW1iZXIgb2YgY2Fyb3VzZWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or6KaB57Sg44Gu5pWw44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBpdGVtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5pdGVtQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgdGhlIGNhcm91c2VsIGlzIHN3aXBlYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1zd2lwZWFibGXjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKTtcbiAgfVxuXG4gIHNldCBzd2lwZWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25Td2lwZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBzbGlkZXMgdGhlIGNhcm91c2VsLiBJdCBnZXRzIGEgZGVjaW1hbCBpbmRleCBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25Td2lwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25Td2lwZTtcbiAgfVxuXG4gIHNldCBvblN3aXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ29uU3dpcGUnIG11c3QgYmUgYSBmdW5jdGlvbi5gKVxuICAgIH1cbiAgICB0aGlzLl9vblN3aXBlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl10cnVlIGlmIGF1dG8gc2Nyb2xsIGlzIGVuYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Kq44O844OI44K544Kv44Ot44O844Or44GM5pyJ5Yq544Gn44GC44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgYXV0b1Njcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsJyk7XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnYXV0by1zY3JvbGwnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgdmVydGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSA9PT0gJ3ZlcnRpY2FsJztcbiAgfVxuXG4gIGdldCBpdGVtU2l6ZSgpIHtcbiAgICBjb25zdCBpdGVtU2l6ZUF0dHIgPSAodGhpcy5nZXRBdHRyaWJ1dGUoYGl0ZW0tJHt0aGlzLnZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnfWApIHx8ICcnKS50cmltKCk7XG4gICAgcmV0dXJuIGl0ZW1TaXplQXR0ci5tYXRjaCgvXlxcZCsocHh8JSkkLykgPyBpdGVtU2l6ZUF0dHIgOiAnMTAwJSc7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGF1dG9TY3JvbGxSYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgYXV0byBzY3JvbGwgcmF0aW8uIFsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruOCquODvOODiOOCueOCr+ODreODvOODq+OBrnJhdGlv5YCk44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsUmF0aW8oKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJykpO1xuICB9XG5cbiAgc2V0IGF1dG9TY3JvbGxSYXRpbyhyYXRpbykge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhdXRvLXNjcm9sbC1yYXRpbycsIHJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvdmVyc2Nyb2xsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIG92ZXJzY3JvbGxhYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1vdmVyc2Nyb2xs44Gn44GN44KM44GwdHJ1ZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgb3ZlcnNjcm9sbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdvdmVyc2Nyb2xsYWJsZScpO1xuICB9XG5cbiAgc2V0IG92ZXJzY3JvbGxhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdvdmVyc2Nyb2xsYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2VudGVyZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBjZW50ZXJlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdY2VudGVyZWTnirbmhYvjgavjgarjgaPjgabjgYTjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBjZW50ZXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2NlbnRlcmVkJyk7XG4gIH1cblxuICBzZXQgY2VudGVyZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NlbnRlcmVkJywgdmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncG9zdGNoYW5nZScsICdyZWZyZXNoJywgJ292ZXJzY3JvbGwnXTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuQ2Fyb3VzZWwgPSBDYXJvdXNlbEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1jYXJvdXNlbCcsIENhcm91c2VsRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jb2xcbiAqIEBjYXRlZ29yeSBncmlkXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSBjb2x1bW4gaW4gdGhlIGdyaWQgc3lzdGVtLiBVc2Ugd2l0aCBgPG9ucy1yb3c+YCB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm5YiX44KS5a6a576p44GX44G+44GZ44CCb25zLXJvd+OBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBruODrOOCpOOCouOCpuODiOOBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sdW1uLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgYWxpZ25tZW50LlsvZW5dXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbHVtbuOCkue1hOOBv+WQiOOCj+OBm+OBn+WgtOWQiOOBq+aPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBHZ3VqQyB7d2lkZX1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwgW2VuXUxheW91dGluZyBndWlkZVsvZW5dW2phXeODrOOCpOOCouOCpuODiOapn+iDvVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcm93XG4gKiAgIFtlbl1UaGUgYDxvbnMtcm93PmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgb2YgYDxvbnMtY29sPmAuWy9lbl1cbiAqICAgW2phXW9ucy1yb3fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIFwidG9wXCIsIFwiY2VudGVyXCIsIGFuZCBcImJvdHRvbVwiLlsvZW5dXG4gKiAgIFtqYV3nuKbjga7phY3nva7jgpLmjIflrprjgZnjgovjgIJcInRvcFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIGNzcyB3aWR0aCB2YWx1ZXMgKFwiMTAlXCIsIFwiNTBweFwiKS5bL2VuXVxuICogICBbamFd44Kr44Op44Og44Gu5qiq5bmF44KS5oyH5a6a44GZ44KL44CC44OR44O844K744Oz44OI44KC44GX44GP44Gv44OU44Kv44K744Or44Gn5oyH5a6a44GX44G+44GZ77yIMTAl44KENTBweO+8ieOAglsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWyd3aWR0aCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3dpZHRoJykge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgc3R5bGVyLmNsZWFyKHRoaXMsICdmbGV4IG1heFdpZHRoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gd2lkdGgudHJpbSgpLm1hdGNoKC9eXFxkKyQvKSA/IHdpZHRoICsgJyUnIDogd2lkdGg7XG5cbiAgICAgIHN0eWxlcih0aGlzLCB7XG4gICAgICAgIGZsZXg6ICcwIDAgJyArIHdpZHRoLFxuICAgICAgICBtYXhXaWR0aDogd2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuQ29sID0gQ29sRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWNvbCcsIENvbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBjbGFzcyBEaWFsb2dBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBzaG93KGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgaGlkZShkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbmRyb2lkIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmRyb2lkRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2cpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC02MCUsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0RpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnZWFzZS1pbi1vdXQnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG5cbiAgICB0aGlzLmJvZHlIZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDsgLy8gYXZvaWQgRm9yY2VkIFN5bmNocm9ub3VzIExheW91dFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAke3RoaXMuYm9keUhlaWdodCAvIDIuMCAtIDF9cHgsIDApYFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAke3RoaXMuYm9keUhlaWdodCAvIDIuMCAtIDF9cHgsIDApYFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcblxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgU2xpZGVEaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMuYm9keUhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNTAlLCAtNTAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC01MCUsIC01MCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi8uLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgeyBEaWFsb2dBbmltYXRvciwgSU9TRGlhbG9nQW5pbWF0b3IsIEFuZHJvaWREaWFsb2dBbmltYXRvciwgU2xpZGVEaWFsb2dBbmltYXRvciB9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZURpYWxvZ0VsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWRpYWxvZyc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmRpYWxvZyc6ICdkaWFsb2ctLSonLFxuICAnLmRpYWxvZy1jb250YWluZXInOiAnZGlhbG9nLWNvbnRhaW5lci0tKicsXG4gICcuZGlhbG9nLW1hc2snOiAnZGlhbG9nLW1hc2stLSonXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gQW5kcm9pZERpYWxvZ0FuaW1hdG9yIDogSU9TRGlhbG9nQW5pbWF0b3IsXG4gICdzbGlkZSc6IFNsaWRlRGlhbG9nQW5pbWF0b3IsXG4gICdub25lJzogRGlhbG9nQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWRpYWxvZ1xuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaWFsb2cgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIGN1cnJlbnQgc2NyZWVuLiBBcyBvcHBvc2VkIHRvIHRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBlbGVtZW50LCB0aGlzIGNvbXBvbmVudCBjYW4gY29udGFpbiBhbnkga2luZCBvZiBjb250ZW50LlxuICpcbiAqICAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVEaWFsb2codGVtcGxhdGUpYCB1dGlsaXR5IGZ1bmN0aW9uIGFuZCB0aGUgYDxvbnMtdGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgIFRoZSBkaWFsb2cgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIG1lbnVzLCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIHRvIGFzayB0aGUgdXNlciB0byBtYWtlIGEgZGVjaXNpb24uXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkaXNwbGF5ZWQgYXMgTWF0ZXJpYWwgRGVzaWduIHdoZW4gcnVubmluZyBvbiBhbiBBbmRyb2lkIGRldmljZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4genh4YUdhXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXWA8b25zLWFsZXJ0LWRpYWxvZz5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1gPG9ucy1wb3BvdmVyPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wb3BvdmVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1tb2RhbFxuICogICBbZW5dYDxvbnMtbW9kYWw+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW1vZGFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWRpYWxvZyBpZD1cImRpYWxvZ1wiPlxuICogICA8cD5UaGlzIGlzIGEgZGlhbG9nITwvcD5cbiAqIDwvb25zLWRpYWxvZz5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlhbG9nJykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJkZWZhdWx0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2cnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdEaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWRpYWxvZz5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJkaWFsb2dcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWRpYWxvZz5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdkaWFsb2cnKTtcblxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGlhbG9nLWNvbnRhaW5lcicpO1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zRGlhbG9nRWxlbWVudC5EaWFsb2dBbmltYXRvcicpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIERpYWxvZ0FuaW1hdG9yO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5EaWFsb2cgPSBEaWFsb2dFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZGlhbG9nJywgRGlhbG9nRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2ZhYic7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdmYWItLSonLFxuICAnLmZhYl9faWNvbic6ICdmYWItLSpfX2ljb24nXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1mYWJcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBGbG9hdGluZyBhY3Rpb24gYnV0dG9uIGlzIGEgY2lyY3VsYXIgYnV0dG9uIGRlZmluZWQgaW4gdGhlIFtNYXRlcmlhbCBEZXNpZ24gc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL2J1dHRvbnMtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5odG1sKS4gVGhleSBhcmUgb2Z0ZW4gdXNlZCB0byBwcm9tb3RlIHRoZSBwcmltYXJ5IGFjdGlvbiBvZiB0aGUgYXBwLlxuICpcbiAqICAgICBJdCBjYW4gYmUgZGlzcGxheWVkIGVpdGhlciBhcyBhbiBpbmxpbmUgZWxlbWVudCBvciBpbiBvbmUgb2YgdGhlIGNvcm5lcnMuIE5vcm1hbGx5IGl0IHdpbGwgYmUgcG9zaXRpb25lZCBpbiB0aGUgbG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoZSBzY3JlZW4uXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2ZhYlxuICogQG1vZGlmaWVyIG1pbmlcbiAqICAgW2VuXU1ha2VzIHRoZSBgb25zLWZhYmAgc21hbGxlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2phXVxuICogQHNlZWFsc28gb25zLXNwZWVkLWRpYWxcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsPmAgY29tcG9uZW50IGlzIGEgRmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiB0aGF0IGRpc3BsYXlzIGEgbWVudSB3aGVuIHRhcHBlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFiRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBwb3NpdGlvbiBvZiB0aGUgYnV0dG9uLiBTaG91bGQgYmUgYSBzdHJpbmcgbGlrZSBgXCJib3R0b20gcmlnaHRcImAgb3IgYFwidG9wIGxlZnRcImAuIElmIHRoaXMgYXR0cmlidXRlIGlzIG5vdCBkZWZpbmVkIGl0IHdpbGwgYmUgZGlzcGxheWVkIGFzIGFuIGlubGluZSBlbGVtZW50LlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBzdGF0ZW1lbnRzIGNhbiBiZSBleGVjdXRlZCBiZWZvcmUgY29udGVudFJlYWR5XG4gICAgLy8gc2luY2UgdGhlc2UgZG8gbm90IGFjY2VzcyB0aGUgY2hpbGRyZW5cbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuZmFiX19pY29uJykpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ2ZhYl9faWNvbicpO1xuXG4gICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGlmICghZWxlbWVudC50YWdOYW1lIHx8IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnb25zLXJpcHBsZScpIHtcbiAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuc2hvdygpKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdwb3NpdGlvbicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdGhpcy5zaG93KCk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5oaWRlKCkpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzKTtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXG4gICAgICAnZmFiLS1ib3R0b21fX3JpZ2h0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcbiAgICAgICdmYWItLXRvcF9fY2VudGVyJyxcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgY2FzZSAndG9wIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIHJpZ2h0JzpcbiAgICAgIGNhc2UgJ3JpZ2h0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX3JpZ2h0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tIGxlZnQnOlxuICAgICAgY2FzZSAnbGVmdCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19sZWZ0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIHRvcCc6XG4gICAgICBjYXNlICd0b3AgY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyIGJvdHRvbSc6XG4gICAgICBjYXNlICdib3R0b20gY2VudGVyJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy50b2dnbGUodHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUhpZGUgdGhlIGZsb2F0aW5nIGFjdGlvbiBidXR0b24uWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZShhY3Rpb24gPSAhdGhpcy52aXNpYmxlKSB7XG4gICAgY29uc3QgaXNCb3R0b20gPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykgfHwgJycpLmluZGV4T2YoJ2JvdHRvbScpID49IDA7XG4gICAgY29uc3QgdHJhbnNsYXRlID0gaXNCb3R0b20gPyBgdHJhbnNsYXRlM2QoMHB4LCAtJHt1dGlsLmdsb2JhbHMuZmFiT2Zmc2V0IHx8IDB9cHgsIDBweClgIDogJyc7XG5cbiAgICBzdHlsZXIodGhpcywgeyB0cmFuc2Zvcm06IGAke3RyYW5zbGF0ZX0gc2NhbGUoJHtOdW1iZXIoYWN0aW9uKX0pYCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGUudHJhbnNmb3JtLmluZGV4T2YoJ3NjYWxlKDApJykgPT09IC0xICYmIHRoaXMuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5GYWIgPSBGYWJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZmFiJywgRmFiRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZ2VzdHVyZS1kZXRlY3RvclxuICogQGNhdGVnb3J5IGdlc3R1cmVcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29tcG9uZW50IHRvIGRldGVjdCBmaW5nZXIgZ2VzdHVyZXMgd2l0aGluIHRoZSB3cmFwcGVkIGVsZW1lbnQuIEZvbGxvd2luZyBnZXN0dXJlcyBhcmUgc3VwcG9ydGVkOlxuICogICAgIC0gRHJhZyBnZXN0dXJlczogYGRyYWdgLCBgZHJhZ2xlZnRgLCBgZHJhZ3JpZ2h0YCwgYGRyYWd1cGAsIGBkcmFnZG93bmBcbiAqICAgICAtIEhvbGQgZ2VzdHVyZXM6IGBob2xkYCwgYHJlbGVhc2VgXG4gKiAgICAgLSBTd2lwZSBnZXN0dXJlczogYHN3aXBlYCwgYHN3aXBlbGVmdGAsIGBzd2lwZXJpZ2h0YCwgYHN3aXBldXBgLCBgc3dpcGVkb3duYFxuICogICAgIC0gVGFwIGdlc3R1cmVzOiBgdGFwYCwgYGRvdWJsZXRhcGBcbiAqICAgICAtIFBpbmNoIGdlc3R1cmVzOiBgcGluY2hgLCBgcGluY2hpbmAsIGBwaW5jaG91dGBcbiAqICAgICAtIE90aGVyIGdlc3R1cmVzOiBgdG91Y2hgLCBgdHJhbnNmb3JtYCwgYHJvdGF0ZWBcbiAqICAgWy9lbl1cbiAqICAgW2phXeimgee0oOWGheOBruOCuOOCp+OCueODgeODo+ODvOaTjeS9nOOCkuaknOefpeOBl+OBvuOBmeOAguips+OBl+OBj+OBr+OCrOOCpOODieOCkuWPgueFp+OBl+OBpuOBj+OBoOOBleOBhOOAglsvamFdXG4gKiBAZ3VpZGUgZmVhdHVyZXMuaHRtbCNnZXN0dXJlLWRldGVjdGlvblxuICogICBbZW5dRGV0ZWN0aW5nIGZpbmdlciBnZXN0dXJlc1svZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6Pjg7zmk43kvZzjga7mpJznn6VbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtZ2VzdHVyZS1kZXRlY3Rvcj5cbiAqICAgPGRpdiBpZD1cImRldGVjdC1hcmVhXCIgc3R5bGU9XCJ3aWR0aDogMTAwcHg7IGhlaWdodDogMTAwcHg7XCI+XG4gKiAgICAgU3dpcGUgSGVyZVxuICogICA8L2Rpdj5cbiAqIDwvb25zLWdlc3R1cmUtZGV0ZWN0b3I+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc3dpcGVsZWZ0JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAqICAgICBpZiAoZXZlbnQudGFyZ2V0Lm1hdGNoZXMoJyNkZXRlY3QtYXJlYScpKSB7XG4gKiAgICAgICBjb25zb2xlLmxvZygnU3dpcGUgbGVmdCBpcyBkZXRlY3RlZC4nKTtcbiAqICAgICB9XG4gKiAgIH0pO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdlc3R1cmVEZXRlY3RvckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMpO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5HZXN0dXJlRGV0ZWN0b3IgPSBHZXN0dXJlRGV0ZWN0b3JFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZ2VzdHVyZS1kZXRlY3RvcicsIEdlc3R1cmVEZXRlY3RvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxubGV0IGF1dG9QcmVmaXggPSAnZmEnOyAvLyBGSVhNRTogVG8gYmUgcmVtb3ZlZCBpbiB2M1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1pY29uXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXlzIGFuIGljb24uIFRoZSBmb2xsb3dpbmcgaWNvbiBzdWl0ZXMgYXJlIGF2YWlsYWJsZTpcbiAqXG4gKiAgICAgKiBbRm9udCBBd2Vzb21lXShodHRwczovL2ZvcnRhd2Vzb21lLmdpdGh1Yi5pby9Gb250LUF3ZXNvbWUvKVxuICogICAgICogW0lvbmljb25zXShodHRwOi8vaW9uaWNvbnMuY29tLylcbiAqICAgICAqIFtNYXRlcmlhbCBEZXNpZ24gSWNvbmljIEZvbnRdKGh0dHA6Ly96YXZvbG9rbG9tLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbmljLWZvbnQvKVxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhBaHZnXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvaWNvblxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdWy9qYV1cbiAqIEBndWlkZSBhcHBzaXplLmh0bWwjcmVtb3ZpbmctaWNvbi1wYWNrcyBbZW5dUmVtb3ZpbmcgaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQGd1aWRlIGZhcS5odG1sI2hvdy1jYW4taS11c2UtY3VzdG9tLWljb24tcGFja3MgW2VuXUFkZGluZyBjdXN0b20gaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtaWNvblxuICogICBpY29uPVwibWQtY2FyXCJcbiAqICAgc2l6ZT1cIjIwcHhcIlxuICogICBzdHlsZT1cImNvbG9yOiByZWRcIj5cbiAqIDwvb25zLWljb24+XG4gKlxuICogPG9ucy1idXR0b24+XG4gKiAgIDxvbnMtaWNvbiBpY29uPVwibWQtY2FyXCI+PC9vbnMtaWNvbj5cbiAqICAgQ2FyXG4gKiA8L29ucy1idXR0b24+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIGljb24gbmFtZS4gYFwibWQtXCJgIHByZWZpeCBmb3IgTWF0ZXJpYWwgSWNvbnMsIGBcImZhLVwiYCBmb3IgRm9udCBBd2Vzb21lIGFuZCBgXCJpb24tXCJgIHByZWZpeCBmb3IgSW9uaWNvbnMuXG4gICAqXG4gICAqICAgICBTZWUgYWxsIGF2YWlsYWJsZSBpY29ucyBvbiB0aGUgZWxlbWVudCBkZXNjcmlwdGlvbiAoYXQgdGhlIHRvcCkuXG4gICAqXG4gICAqICAgICBJY29ucyBjYW4gYWxzbyBiZSBzdHlsZWQgYmFzZWQgb24gbW9kaWZpZXIgcHJlc2VuY2UuIEFkZCBjb21tYS1zZXBhcmF0ZWQgaWNvbnMgd2l0aCBgXCJtb2RpZmllck5hbWU6XCJgIHByZWZpeC5cbiAgICpcbiAgICogICAgIFRoZSBjb2RlIGA8b25zLWljb24gaWNvbj1cImlvbi1lZGl0LCBtYXRlcmlhbDptZC1lZGl0XCI+PC9vbnMtaWNvbj5gIHdpbGwgZGlzcGxheSBgXCJtZC1lZGl0XCJgIGZvciBNYXRlcmlhbCBEZXNpZ24gYW5kIGBcImlvbi1lZGl0XCJgIGFzIHRoZSBkZWZhdWx0IGljb24uXG4gICAqXG4gICAqICAgICBgZmEtYCBwcmVmaXggaXMgYWRkZWQgYXV0b21hdGljYWxseSBpZiBub25lIGlzIHByb3ZpZGVkLiBDaGVjayBbU2VlIGFsc29dKCNzZWVhbHNvKSBzZWN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNpemVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIHNpemVzIG9mIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIGxnLCAyeCwgM3gsIDR4LCA1eCwgb3IgaW4gdGhlIHNpemUgaW4gcGl4ZWxzLlxuICAgKiAgICAgSWNvbnMgY2FuIGFsc28gYmUgc3R5bGVkIGJhc2VkIG9uIG1vZGlmaWVyIHByZXNlbmNlLiBBZGQgY29tbWEtc2VwYXJhdGVkIGljb25zIHdpdGggYFwibW9kaWZpZXJOYW1lOlwiYCBwcmVmaXguXG4gICAqXG4gICAqICAgICBUaGUgY29kZTpcbiAgICpcbiAgICogICAgIGBgYFxuICAgKiAgICAgPG9ucy1pY29uXG4gICAqICAgICAgIGljb249XCJpb24tZWRpdFwiXG4gICAqICAgICAgIHNpemU9XCIzMnB4LCBtYXRlcmlhbDoyNHB4XCI+XG4gICAqICAgICA8L29ucy1pY29uPlxuICAgKiAgICAgYGBgXG4gICAqXG4gICAqICAgICB3aWxsIHJlbmRlciBhcyBhIGAyNHB4YCBpY29uIGlmIHRoZSBgXCJtYXRlcmlhbFwiYCBtb2RpZmllciBpcyBwcmVzZW50IGFuZCBgMzJweGAgb3RoZXJ3aXNlLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJvdGF0ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTnVtYmVyIG9mIGRlZ3JlZXMgdG8gcm90YXRlIHRoZSBpY29uLiBWYWxpZCB2YWx1ZXMgYXJlIDkwLCAxODAgYW5kIDI3MC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZfjgabooajnpLrjgZfjgb7jgZnjgII5MCwgMTgwLCAyNzDjgYvjgonmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC13aWR0aFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dV2hlbiB1c2VkIGluIGEgbGlzdCwgeW91IHdhbnQgdGhlIGljb25zIHRvIGhhdmUgdGhlIHNhbWUgd2lkdGggc28gdGhhdCB0aGV5IGFsaWduIHZlcnRpY2FsbHkgYnkgZGVmaW5pbmcgdGhpcyBhdHRyaWJ1dGUuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzcGluXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoZXRoZXIgdGhlIGljb24gc2hvdWxkIGJlIHNwaW5uaW5nLlsvZW5dXG4gICAqICAgW2phXeOCouOCpOOCs+ODs+OCkuWbnui7ouOBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jb21waWxlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydpY29uJywgJ3NpemUnLCAnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgdGhpcy5fY2xlYW5DbGFzc0F0dHJpYnV0ZShuYW1lID09PSAnaWNvbicgPyBsYXN0IDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKSwgbmFtZSA9PT0gJ21vZGlmaWVyJyA/IGxhc3QgOiB1bmRlZmluZWQpO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gIH1cblxuICBfdXBkYXRlKCkge1xuICAgIGNvbnN0IHtjbGFzc0xpc3QsIHN0eWxlfSA9IHRoaXMuX2J1aWxkQ2xhc3NBbmRTdHlsZSh0aGlzLl9wYXJzZUF0dHIoJ2ljb24nKSwgdGhpcy5fcGFyc2VBdHRyKCdzaXplJykpO1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMuc3R5bGUsIHN0eWxlKTtcblxuICAgIGNsYXNzTGlzdC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSk7XG4gIH1cblxuICBfcGFyc2VBdHRyKGF0dHJOYW1lLCBtb2RpZmllciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnKSB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKSB8fCBhdHRyTmFtZSB8fCAnJ1xuICAgIGNvbnN0IHBhcnRzID0gYXR0ci5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgY29uc3QgZGVmID0gcGFydHNbMF07XG4gICAgbGV0IG1kID0gcGFydHNbMV07XG4gICAgbWQgPSAobWQgfHwgJycpLnNwbGl0KC9cXHMqOlxccyovKTtcblxuICAgIHJldHVybiAobW9kaWZpZXIgJiYgKFJlZ0V4cChgKF58XFxcXHMrKSR7bWRbMF19KCR8XFxcXHMrKWAsICdpJykudGVzdChtb2RpZmllcikpID8gbWRbMV0gOiBkZWYpIHx8ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB1bm5lZWRlZCBjbGFzcyB2YWx1ZS5cbiAgICovXG4gIF9jbGVhbkNsYXNzQXR0cmlidXRlKGxhc3RJY29uLCBsYXN0TW9kaWZpZXIpIHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgcHJlZml4IH0gPSB0aGlzLl9wcmVmaXhJY29uKHRoaXMuX3BhcnNlQXR0cihsYXN0SWNvbiwgbGFzdE1vZGlmaWVyKSk7XG4gICAgY29uc3QgY3VzdG9tUHJlZml4UkUgPSBjbGFzc05hbWUgIT09IHByZWZpeCA/IGB8JHtwcmVmaXh9JHwke3ByZWZpeH0tYCA6IGB8JHtjbGFzc05hbWV9JGAgfHwgJyc7XG4gICAgY29uc3QgcmUgPSBuZXcgUmVnRXhwKGBeKGZhJHxmYS18aW9uLXx6bWRpJHx6bWRpLXxvbnMtaWNvbi0tJHtjdXN0b21QcmVmaXhSRX0pYCk7XG5cbiAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNsYXNzTGlzdClcbiAgICAgIC5maWx0ZXIoY2xhc3NOYW1lID0+IHJlLnRlc3QoY2xhc3NOYW1lKSlcbiAgICAgIC5mb3JFYWNoKGNsYXNzTmFtZSA9PiB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSk7XG4gIH1cblxuICBfcHJlZml4SWNvbihpY29uTmFtZSkge1xuICAgIGNvbnN0IGNsYXNzTmFtZSA9IGF1dG9QcmVmaXggKyAoYXV0b1ByZWZpeCA/ICctJyA6ICcnKSArIGljb25OYW1lO1xuICAgIHJldHVybiB7IGNsYXNzTmFtZSwgcHJlZml4OiBjbGFzc05hbWUuc3BsaXQoJy0nKVswXSB9O1xuICB9XG5cbiAgX2J1aWxkQ2xhc3NBbmRTdHlsZShpY29uTmFtZSwgc2l6ZSkge1xuICAgIGNvbnN0IGNsYXNzTGlzdCA9IFsnb25zLWljb24nXTtcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xuXG4gICAgLy8gSWNvblxuICAgIGlmIChpY29uTmFtZS5pbmRleE9mKCdpb24tJykgPT09IDApIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKGljb25OYW1lKTtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdvbnMtaWNvbi0taW9uJyk7XG4gICAgfSBlbHNlIGlmIChpY29uTmFtZS5pbmRleE9mKCdmYS0nKSA9PT0gMCkge1xuICAgICAgY2xhc3NMaXN0LnB1c2goaWNvbk5hbWUpO1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ2ZhJyk7XG4gICAgfSBlbHNlIGlmKGljb25OYW1lLmluZGV4T2YoJ21kLScpID09PSAwKSAge1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ3ptZGknKTtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCd6bWRpLScgKyBpY29uTmFtZS5zcGxpdCgvLSguKyk/LylbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGNsYXNzTmFtZSwgcHJlZml4IH0gPSB0aGlzLl9wcmVmaXhJY29uKGljb25OYW1lKTtcbiAgICAgIHByZWZpeCAmJiBjbGFzc0xpc3QucHVzaChwcmVmaXgpO1xuICAgICAgY2xhc3NOYW1lICYmIGNsYXNzTGlzdC5wdXNoKGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gU2l6ZVxuICAgIGlmIChzaXplLm1hdGNoKC9eWzEtNV14fGxnJC8pKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnb25zLWljb24tLScgKyBzaXplKTtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ2ZvbnQtc2l6ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5mb250U2l6ZSA9IHNpemU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzTGlzdDogY2xhc3NMaXN0LFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBzZXRBdXRvUHJlZml4KHByZWZpeCkge1xuICAgIGF1dG9QcmVmaXggPSBwcmVmaXggPyAodHlwZW9mIHByZWZpeCA9PT0gJ3N0cmluZycgJiYgcHJlZml4IHx8ICdmYScpIDogJyc7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLkljb24gPSBJY29uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWljb24nLCBJY29uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5cbmV4cG9ydCBjbGFzcyBMYXp5UmVwZWF0RGVsZWdhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHVzZXJEZWxlZ2F0ZSwgdGVtcGxhdGVFbGVtZW50ID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdXNlckRlbGVnYXRlICE9PSAnb2JqZWN0JyB8fCB1c2VyRGVsZWdhdGUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgIH1cbiAgICB0aGlzLl91c2VyRGVsZWdhdGUgPSB1c2VyRGVsZWdhdGU7XG5cbiAgICBpZiAoISh0ZW1wbGF0ZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSAmJiB0ZW1wbGF0ZUVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdcInRlbXBsYXRlRWxlbWVudFwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQgb3IgbnVsbC4nKTtcbiAgICB9XG4gICAgdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gdGVtcGxhdGVFbGVtZW50O1xuICB9XG5cbiAgZ2V0IGl0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJEZWxlZ2F0ZS5pdGVtSGVpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBoYXNSZW5kZXJGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLl9yZW5kZXIgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgX3JlbmRlcigpIHtcbiAgICB0aGlzLl91c2VyRGVsZWdhdGUuX3JlbmRlci5hcHBseSh0aGlzLl91c2VyRGVsZWdhdGUsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQSBmdW5jdGlvbiB0aGF0IHRha2UgaXRlbSBvYmplY3QgYXMgcGFyYW1ldGVyLlxuICAgKi9cbiAgbG9hZEl0ZW1FbGVtZW50KGluZGV4LCBkb25lKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgZG9uZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY3JlYXRlSXRlbUNvbnRlbnQoaW5kZXgsIHRoaXMuX3RlbXBsYXRlRWxlbWVudCk7XG4gICAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NyZWF0ZUl0ZW1Db250ZW50KCkgbXVzdCByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgRWxlbWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgZG9uZSh7ZWxlbWVudH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjb3VudEl0ZW1zKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fdXNlckRlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgICBpZiAodHlwZW9mIGNvdW50ICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdW50SXRlbXMoKSBtdXN0IHJldHVybiBhIG51bWJlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGl0ZW0uZWxlbWVudFxuICAgKi9cbiAgdXBkYXRlSXRlbShpbmRleCwgaXRlbSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLnVwZGF0ZUl0ZW1Db250ZW50KGluZGV4LCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7TnVtYmVyfVxuICAgKi9cbiAgY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodChpbmRleCk7XG5cbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcignY2FsY3VsYXRlSXRlbUhlaWdodCgpIG11c3QgcmV0dXJuIGEgbnVtYmVyLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbVxuICAgKi9cbiAgZGVzdHJveUl0ZW0oaW5kZXgsIGl0ZW0pIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZSA9IHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGUgY29yZSBmdW5jdGlvbnMgZm9yIG9ucy1sYXp5LXJlcGVhdC5cbiAqL1xuZXhwb3J0IGNsYXNzIExhenlSZXBlYXRQcm92aWRlciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gd3JhcHBlckVsZW1lbnRcbiAgICogQHBhcmFtIHtMYXp5UmVwZWF0RGVsZWdhdGV9IGRlbGVnYXRlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3cmFwcGVyRWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICBpZiAoIShkZWxlZ2F0ZSBpbnN0YW5jZW9mIExhenlSZXBlYXREZWxlZ2F0ZSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdcImRlbGVnYXRlXCIgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgTGF6eVJlcGVhdERlbGVnYXRlLicpO1xuICAgIH1cblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gd3JhcHBlckVsZW1lbnQ7XG4gICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB0aGlzLl9pbnNlcnRJbmRleCA9ICh0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblswXSAmJiB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblswXS50YWdOYW1lID09PSAnT05TLUxBWlktUkVQRUFUJykgPyAxIDogMDtcblxuICAgIGlmICh3cmFwcGVyRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdCcpIHtcbiAgICAgIHdyYXBwZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhenktbGlzdCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VDb250ZW50ID0gdGhpcy5fZmluZFBhZ2VDb250ZW50RWxlbWVudCh3cmFwcGVyRWxlbWVudCk7XG5cbiAgICBpZiAoIXRoaXMuX3BhZ2VDb250ZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ucy1sYXp5LXJlcGVhdCBtdXN0IGJlIGEgZGVzY2VuZGFudCBvZiBhbiA8b25zLXBhZ2U+IG9yIGFuIGVsZW1lbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gdGhpcy5fcGFnZUNvbnRlbnQuc2Nyb2xsVG9wO1xuICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgdGhpcy5fdG9wUG9zaXRpb25zID0gWzBdO1xuICAgIHRoaXMuX3JlbmRlcmVkSXRlbXMgPSB7fTtcblxuICAgIGlmICghdGhpcy5fZGVsZWdhdGUuaXRlbUhlaWdodCAmJiAhdGhpcy5fZGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodCgwKSkge1xuICAgICAgdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fb25DaGFuZ2UoKTtcbiAgfVxuXG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS5wYWRkaW5nVG9wLCAxMCk7XG4gIH1cblxuICBzZXQgcGFkZGluZyhuZXdWYWx1ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLnBhZGRpbmdUb3AgPSBuZXdWYWx1ZSArICdweCc7XG4gIH1cblxuICBfZmluZFBhZ2VDb250ZW50RWxlbWVudCh3cmFwcGVyRWxlbWVudCkge1xuICAgIGNvbnN0IHBhZ2VDb250ZW50ID0gdXRpbC5maW5kUGFyZW50KHdyYXBwZXJFbGVtZW50LCAnLnBhZ2VfX2NvbnRlbnQnKTtcblxuICAgIGlmIChwYWdlQ29udGVudCkge1xuICAgICAgcmV0dXJuIHBhZ2VDb250ZW50O1xuICAgIH1cblxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQod3JhcHBlckVsZW1lbnQsICdvbnMtcGFnZScpO1xuICAgIGlmIChwYWdlKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdXRpbC5maW5kQ2hpbGQocGFnZSwgJy5jb250ZW50Jyk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9jaGVja0l0ZW1IZWlnaHQoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQoMCwgaXRlbSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3Vua25vd25JdGVtSGVpZ2h0KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW0uZWxlbWVudCk7XG5cbiAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lJdGVtKDAsIGl0ZW0pO1xuICAgICAgICBpdGVtLmVsZW1lbnQgJiYgaXRlbS5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQ7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgaWYgKHRoaXMuX2l0ZW1IZWlnaHQgPiAwKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyByZXRyeSB0byBtZWFzdXJlIG9mZnNldCBoZWlnaHRcbiAgICAgIC8vIGRpcnR5IGZpeCBmb3IgYW5ndWxhcjIgZGlyZWN0aXZlXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICBpdGVtLmVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1IZWlnaHQgPT0gMCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlOiB0aGlzLl9pdGVtSGVpZ2h0IG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBzdGF0aWNJdGVtSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5pdGVtSGVpZ2h0IHx8IHRoaXMuX2l0ZW1IZWlnaHQ7XG4gIH1cbiAgX2NvdW50SXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmNvdW50SXRlbXMoKTtcbiAgfVxuXG4gIF9nZXRJdGVtSGVpZ2h0KGkpIHtcbiAgICAvLyBJdGVtIGlzIHJlbmRlcmVkXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkSXRlbXMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmICghdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5oZWlnaHQgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2ldLmVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkSXRlbXNbaV0uaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIEl0ZW0gaXMgbm90IHJlbmRlcmVkLCBzY3JvbGwgdXBcbiAgICBpZiAodGhpcy5fdG9wUG9zaXRpb25zW2kgKyAxXSAmJiB0aGlzLl90b3BQb3NpdGlvbnNbaV0pIHtcbiAgICAgIHJldHVybiB0aGlzLl90b3BQb3NpdGlvbnNbaSArIDFdIC0gdGhpcy5fdG9wUG9zaXRpb25zW2ldO1xuICAgIH1cbiAgICAvLyBJdGVtIGlzIG5vdCByZW5kZXJlZCwgc2Nyb2xsIGRvd25cbiAgICByZXR1cm4gdGhpcy5zdGF0aWNJdGVtSGVpZ2h0IHx8IHRoaXMuX2RlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoaSk7XG4gIH1cblxuICBfY2FsY3VsYXRlUmVuZGVyZWRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLnJlZHVjZSgoYSwgYikgPT4gYSArIHRoaXMuX2dldEl0ZW1IZWlnaHQoKyhiKSksIDApXG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5fcmVuZGVyKCk7XG4gIH1cblxuICBfbGFzdEl0ZW1SZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoLi4uT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykpO1xuICB9XG5cbiAgX2ZpcnN0SXRlbVJlbmRlcmVkKCkge1xuICAgIHJldHVybiBNYXRoLm1pbiguLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IGZvcmNlUmVuZGVyID0geyBmb3JjZVNjcm9sbERvd246IHRydWUgfTtcbiAgICBjb25zdCBsYXN0SXRlbUluZGV4ID0gTWF0aC5taW4odGhpcy5fbGFzdEl0ZW1SZW5kZXJlZCgpLCB0aGlzLl9jb3VudEl0ZW1zKCkgLSAxKTtcbiAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMuX2ZpcnN0SXRlbVJlbmRlcmVkKCk7XG5cbiAgICBpZiAodXRpbC5pc0ludGVnZXIobGFzdEl0ZW1JbmRleCkpIHtcbiAgICAgIGZvcmNlUmVuZGVyLmZvcmNlTGFzdEluZGV4ID0gbGFzdEl0ZW1JbmRleFxuICAgIH1cblxuICAgIGlmICh1dGlsLmlzSW50ZWdlcihmaXJzdEl0ZW1JbmRleCkpIHtcbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuX3RvcFBvc2l0aW9uc1tmaXJzdEl0ZW1JbmRleF0gKyB0aGlzLl9jYWxjdWxhdGVSZW5kZXJlZEhlaWdodCgpICsgJ3B4JztcbiAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMuX3RvcFBvc2l0aW9uc1tmaXJzdEl0ZW1JbmRleF07XG4gICAgICBmb3JjZVJlbmRlci5mb3JjZUZpcnN0SW5kZXggPSBmaXJzdEl0ZW1JbmRleDtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgIHRoaXMuX3JlbmRlcihmb3JjZVJlbmRlcik7XG4gICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJ2luaGVyaXQnO1xuICB9XG5cbiAgX3JlbmRlcih7Zm9yY2VTY3JvbGxEb3duID0gZmFsc2UsIGZvcmNlRmlyc3RJbmRleCwgZm9yY2VMYXN0SW5kZXh9ID0ge30pIHtcbiAgICBpZiAodGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGVja0l0ZW1IZWlnaHQodGhpcy5fcmVuZGVyLmJpbmQodGhpcywgYXJndW1lbnRzWzBdKSk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNTY3JvbGxVcCA9ICFmb3JjZVNjcm9sbERvd24gJiYgdGhpcy5sYXN0U2Nyb2xsVG9wID4gdGhpcy5fcGFnZUNvbnRlbnQuc2Nyb2xsVG9wO1xuICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHRoaXMuX3BhZ2VDb250ZW50LnNjcm9sbFRvcDtcbiAgICBjb25zdCBrZWVwID0ge307XG5cbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl93cmFwcGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgY29uc3QgbGltaXQgPSA0ICogd2luZG93LmlubmVySGVpZ2h0IC0gb2Zmc2V0O1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fY291bnRJdGVtcygpO1xuXG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IGZvcmNlRmlyc3RJbmRleCB8fCBNYXRoLm1heCgwLCB0aGlzLl9jYWxjdWxhdGVTdGFydEluZGV4KG9mZnNldCkgLSAzMCk7IC8vIFJlY2FsY3VsYXRlIGZvciAwIG9yIHVuZGVmaW5lZFxuICAgIGxldCBpID0gc3RhcnQ7XG5cbiAgICBmb3IobGV0IHRvcCA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpXTsgaSA8IGNvdW50ICYmIHRvcCA8IGxpbWl0OyBpKyspIHtcbiAgICAgIGlmIChpID49IHRoaXMuX3RvcFBvc2l0aW9ucy5sZW5ndGgpIHsgLy8gcGVyZiBvcHRpbWl6YXRpb25cbiAgICAgICAgdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCArPSAxMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RvcFBvc2l0aW9uc1tpXSA9IHRvcDtcbiAgICAgIHRvcCArPSB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWxlZ2F0ZS5oYXNSZW5kZXJGdW5jdGlvbiAmJiB0aGlzLl9kZWxlZ2F0ZS5oYXNSZW5kZXJGdW5jdGlvbigpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuX3JlbmRlcihzdGFydCwgaSwgKCkgPT4ge1xuICAgICAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLl90b3BQb3NpdGlvbnNbc3RhcnRdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2Nyb2xsVXApIHtcbiAgICAgIGZvciAobGV0IGogPSBpIC0gMTsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICAgIGtlZXBbal0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJFbGVtZW50KGosIGlzU2Nyb2xsVXApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBmb3JjZUxhc3RJbmRleCB8fCBNYXRoLm1heChpIC0gMSwgLi4uT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykpOyAvLyBSZWNhbGN1bGF0ZSBmb3IgMCBvciB1bmRlZmluZWRcbiAgICAgIGZvciAobGV0IGogPSBzdGFydDsgaiA8PSBsYXN0SW5kZXg7IGorKykge1xuICAgICAgICBrZWVwW2pdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyRWxlbWVudChqLCBpc1Njcm9sbFVwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKS5mb3JFYWNoKGtleSA9PiBrZWVwW2tleV0gfHwgdGhpcy5fcmVtb3ZlRWxlbWVudChrZXksIGlzU2Nyb2xsVXApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1Njcm9sbFVwXG4gICAqL1xuICBfcmVuZGVyRWxlbWVudChpbmRleCwgaXNTY3JvbGxVcCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdGhpcy5fZGVsZWdhdGUudXBkYXRlSXRlbShpbmRleCwgaXRlbSk7IC8vIHVwZGF0ZSBpZiBpdCBleGlzdHNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWxlZ2F0ZS5sb2FkSXRlbUVsZW1lbnQoaW5kZXgsIGl0ZW0gPT4ge1xuICAgICAgaWYgKGlzU2Nyb2xsVXApIHtcbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuaW5zZXJ0QmVmb3JlKGl0ZW0uZWxlbWVudCwgdGhpcy5fd3JhcHBlckVsZW1lbnQuY2hpbGRyZW5bdGhpcy5faW5zZXJ0SW5kZXhdKVxuICAgICAgICB0aGlzLnBhZGRpbmcgPSB0aGlzLl90b3BQb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICBpdGVtLmhlaWdodCA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpbmRleCArIDFdIC0gdGhpcy5fdG9wUG9zaXRpb25zW2luZGV4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW0uZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdID0gaXRlbTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc1Njcm9sbFVwXG4gICAqL1xuICBfcmVtb3ZlRWxlbWVudChpbmRleCwgaXNTY3JvbGxVcCA9IHRydWUpIHtcbiAgICBpbmRleCA9ICsoaW5kZXgpO1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95SXRlbShpbmRleCwgaXRlbSk7XG5cbiAgICBpZiAoaXNTY3JvbGxVcCkge1xuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2luZGV4ICsgMV0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMucGFkZGluZyArIHRoaXMuX2dldEl0ZW1IZWlnaHQoaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChpdGVtLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgaXRlbS5lbGVtZW50LnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF07XG4gIH1cblxuICBfcmVtb3ZlQWxsRWxlbWVudHMoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykuZm9yRWFjaChrZXkgPT4gdGhpcy5fcmVtb3ZlRWxlbWVudChrZXkpKTtcbiAgfVxuXG4gIF9yZWNhbGN1bGF0ZVRvcFBvc2l0aW9ucyhzdGFydCwgZW5kKSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaSArIDFdID0gdGhpcy5fdG9wUG9zaXRpb25zW2ldICsgdGhpcy5fZ2V0SXRlbUhlaWdodChpKTtcbiAgICB9XG4gIH1cblxuICBfY2FsY3VsYXRlU3RhcnRJbmRleChjdXJyZW50KSB7XG4gICAgY29uc3QgZmlyc3RJdGVtSW5kZXggPSB0aGlzLl9maXJzdEl0ZW1SZW5kZXJlZCgpO1xuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggPSB0aGlzLl9sYXN0SXRlbVJlbmRlcmVkKCk7XG5cbiAgICAvLyBGaXggZm9yIFNhZmFyaSBzY3JvbGwgYW5kIEFuZ3VsYXIgMlxuICAgIHRoaXMuX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKGZpcnN0SXRlbUluZGV4LCBsYXN0SXRlbUluZGV4KTtcblxuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IHRoaXMuX2NvdW50SXRlbXMoKSAtIDE7XG5cbiAgICAvLyBCaW5hcnkgc2VhcmNoIGZvciBpbmRleCBhdCB0b3Agb2Ygc2NyZWVuIHNvIHdlIGNhbiBzcGVlZCB1cCByZW5kZXJpbmcuXG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgbWlkZGxlID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnQgKyB0aGlzLl90b3BQb3NpdGlvbnNbbWlkZGxlXTtcblxuICAgICAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSA8PSAwICYmIHZhbHVlICsgdGhpcy5fZ2V0SXRlbUhlaWdodChtaWRkbGUpID4gMCkge1xuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfSBlbHNlIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPj0gMCkge1xuICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBtaWRkbGUgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9kZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgd2FpdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIF9kb3VibGVGaXJlT25Ub3VjaGVuZCgpIHtcbiAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB0aGlzLl9kZWJvdW5jZSh0aGlzLl9yZW5kZXIuYmluZCh0aGlzKSwgMTAwKTtcbiAgfVxuXG4gIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICB1dGlsLmJpbmRMaXN0ZW5lcnModGhpcywgWydfb25DaGFuZ2UnLCAnX2RvdWJsZUZpcmVPblRvdWNoZW5kJ10pO1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzSU9TKCkpIHtcbiAgICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9kZWJvdW5jZSh0aGlzLl9ib3VuZE9uQ2hhbmdlLCAzMCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fcGFnZUNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgdHJ1ZSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fYm91bmREb3VibGVGaXJlT25Ub3VjaGVuZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIHRydWUpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9yZW1vdmVBbGxFbGVtZW50cygpO1xuICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9wYXJlbnRFbGVtZW50ID0gdGhpcy5fZGVsZWdhdGUgPSB0aGlzLl9yZW5kZXJlZEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICB9XG59XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCB7IExhenlSZXBlYXREZWxlZ2F0ZSwgTGF6eVJlcGVhdFByb3ZpZGVyIH0gZnJvbSAnLi4vb25zL2ludGVybmFsL2xhenktcmVwZWF0JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGF6eS1yZXBlYXRcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFVzaW5nIHRoaXMgY29tcG9uZW50IGEgbGlzdCB3aXRoIG1pbGxpb25zIG9mIGl0ZW1zIGNhbiBiZSByZW5kZXJlZCB3aXRob3V0IGEgZHJvcCBpbiBwZXJmb3JtYW5jZS5cbiAqICAgICBJdCBkb2VzIHRoYXQgYnkgXCJsYXppbHlcIiBsb2FkaW5nIGVsZW1lbnRzIGludG8gdGhlIERPTSB3aGVuIHRoZXkgY29tZSBpbnRvIHZpZXcgYW5kXG4gKiAgICAgcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgRE9NIHdoZW4gdGhleSBhcmUgbm90IHZpc2libGUuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXjgafmj4/nlLvjgZXjgozjgovjgqLjgqTjg4bjg6Djga5ET03opoHntKDjga7oqq3jgb/ovrzjgb/jga/jgIHnlLvpnaLjgavopovjgYjjgZ3jgYbjgavjgarjgaPjgZ/mmYLjgb7jgafoh6rli5XnmoTjgavpgYXlu7bjgZXjgozjgIFcbiAqICAgICDnlLvpnaLjgYvjgonopovjgYjjgarjgY/jgarjgaPjgZ/loLTlkIjjgavjga/jgZ3jga7opoHntKDjga/li5XnmoTjgavjgqLjg7Pjg63jg7zjg4njgZXjgozjgb7jgZnjgIJcbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/jgYbjgZPjgajjgafjgIHjg5Hjg5Xjgqnjg7zjg57jg7PjgrnjgpLliqPljJbjgZXjgZvjgovjgZPjgajnhKHjgZfjgavlt6jlpKfjgarmlbDjga7opoHntKDjgpLmj4/nlLvjgafjgY3jgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIFF3ckdCbVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xhenktcmVwZWF0XG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gcmVuZGVyIGEgbGlzdC5bL2VuXVxuICogICBbamFdYDxvbnMtbGlzdD5g6KaB57Sg44Gv44Oq44K544OI44KS5o+P55S744GZ44KL44Gu44Gr5L2/44KP44KM44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBsYXp5UmVwZWF0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpc3QnKTtcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xuICogICAgICBjcmVhdGVJdGVtQ29udGVudDogZnVuY3Rpb24oaSwgdGVtcGxhdGUpIHtcbiAqICAgICAgICB2YXIgZG9tID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xuICpcbiAqICAgICAgICByZXR1cm4gZG9tO1xuICogICAgICB9LFxuICogICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gMTAwMDAwMDA7XG4gKiAgICAgIH0sXG4gKiAgICAgIGRlc3Ryb3lJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICogICAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95ZWQgaXRlbSB3aXRoIGluZGV4OiAnICsgaW5kZXgpO1xuICogICAgICB9XG4gKiAgICAgfTtcbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLWxpc3QgaWQ9XCJsaXN0XCI+XG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+PC9vbnMtbGlzdC1pdGVtPlxuICogICA8L29ucy1sYXp5LXJlcGVhdD5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlSZXBlYXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIC8vIG5vdCB2ZXJ5IGdvb2QgaWRlYSBhbmQgYWxzbyBub3QgZG9jdW1lbnRlZFxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGVsZWdhdGUnKSkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHdpbmRvd1t0aGlzLmdldEF0dHJpYnV0ZSgnZGVsZWdhdGUnKV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGEgZGVsZWdhdGUgb2JqZWN0IHRvIGxvYWQgYW5kIHVubG9hZCBpdGVtIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFd6KaB57Sg44Gu44Ot44O844OJ44CB44Ki44Oz44Ot44O844OJ44Gq44Gp44Gu5Yem55CG44KS5aeU6K2y44GZ44KL44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBIVE1MRWxlbWVudGAuXG4gICAqXG4gICAqICAgICBUbyBoZWxwIHJlbmRlcmluZyB0aGUgZWxlbWVudCwgdGhlIGN1cnJlbnQgaW5kZXggYW5kIGEgdGVtcGxhdGUgaXMgc3VwcGxpZWQgYXMgYXJndW1lbnRzLiBUaGUgdGVtcGxhdGUgaXMgdGhlIGluaXRpYWwgY29udGVudCBvZiB0aGUgYDxvbnMtbGF6eS1yZXBlYXQ+YCBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44GvYEhUTUxFbGVtZW50YOOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAglxuICAgKiAgICAg6KaB57Sg44KS55Sf5oiQ44GX44KE44GZ44GP44GZ44KL44Gf44KB44Gr44CB54++5Zyo44Gu44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K544Go44OG44Oz44OX44Os44O844OI44GM5byV5pWw44Gr5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7jg4bjg7Pjg5fjg6zjg7zjg4jjga/jgIFgPG9ucy1sYXp5LXJlcGVhdD5g6KaB57Sg44Gu44Kz44Oz44OG44Oz44OE44GM5rih44GV44KM44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jb3VudEl0ZW1zXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jlhoXjga7jgqLjgqTjg4bjg6DmlbDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTaG91bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgYW4gaXRlbS4gVGhlIGluZGV4IGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgVGhpcyBpcyBpbXBvcnRhbnQgd2hlbiByZW5kZXJpbmcgbGlzdHMgd2hlcmUgdGhlIGl0ZW1zIGhhdmUgZGlmZmVyZW50IGhlaWdodC5cbiAgICpcbiAgICogICAgIFRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXNuJ3QgcHJlc2VudCB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBpdGVtIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB1c2VkIGZvciBhbGwgb3RoZXIgaXRlbXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7pq5jjgZUo44OU44Kv44K744OrKeOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAguOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueWApOOBr+W8leaVsOOBp+a4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44Gd44KM44Ge44KM44Gu44Ki44Kk44Og44GM6YGV44Gj44Gf6auY44GV44KS5oyB44Gk44Oq44K544OI44KS44Os44Oz44OA44Oq44Oz44Kw44GZ44KL6Zqb44Gr6YeN6KaB44Gn44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgqrjg5fjgrfjg6fjg4rjg6vjgafjgZnjgILjgoLjgZfjgZPjga7plqLmlbDjgYznhKHjgYTloLTlkIjjgavjga/jgIFcbiAgICogICAgIOacgOWIneOBruOCouOCpOODhuODoOOBrumrmOOBleOBjOS7luOBruOBmeOBueOBpuOBruOCouOCpOODhuODoOOBrumrmOOBleOBqOOBl+OBpuWIqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuZGVzdHJveUl0ZW1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS4gVGhlIGluZGV4IGFuZCBET00gZWxlbWVudCBpcyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gICAqXG4gICAqICAgICBUaGUgZnVuY3Rpb24gaXMgb3B0aW9uYWwgYnV0IG1heSBiZSBpbXBvcnRhbnQgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44GC44KL44Ki44Kk44OG44Og44GMRE9N44OE44Oq44O844GL44KJ6Zmk44GL44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44G+44GZ44CCXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgahET03opoHntKDjgYzlvJXmlbDjgajjgZfjgabmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OCquODl+OCt+ODp+ODiuODq+OBp+OBmeOBjOOAgeWQhOOCouOCpOODhuODoOOBruW+jOWHpueQhuOBjOW/heimgeOBquWgtOWQiOOBq+OBr+ODoeODouODquODvOODquODvOOCr+OCkumBv+OBkeOCi+OBn+OCgeOBq+mHjeimgeOBp+OBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIHNldCBkZWxlZ2F0ZSh1c2VyRGVsZWdhdGUpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLmRlc3Ryb3koKTtcblxuICAgIGlmICghdGhpcy5fdGVtcGxhdGVFbGVtZW50ICYmIHRoaXMuY2hpbGRyZW5bMF0pIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZWdhdGUgPSBuZXcgTGF6eVJlcGVhdERlbGVnYXRlKHVzZXJEZWxlZ2F0ZSwgdGhpcy5fdGVtcGxhdGVFbGVtZW50IHx8IG51bGwpO1xuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciA9IG5ldyBMYXp5UmVwZWF0UHJvdmlkZXIodGhpcy5wYXJlbnRFbGVtZW50LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICBnZXQgZGVsZWdhdGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHByb3BlcnR5IGNhbiBvbmx5IGJlIHVzZWQgdG8gc2V0IHRoZSBkZWxlZ2F0ZSBvYmplY3QuJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZWZyZXNoIHRoZSBsaXN0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZGF0YSBoYXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjgpLmm7TmlrDjgZfjgb7jgZnjgILjgoLjgZfjg4fjg7zjgr/jgYzlpInjgo/jgaPjgZ/loLTlkIjjgavjga/jgZPjga7jg6Hjgr3jg4Pjg4njgpLkvb/jgaPjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLnJlZnJlc2goKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG59XG5cbmludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcbmludGVybmFsLkxhenlSZXBlYXRQcm92aWRlciA9IExhenlSZXBlYXRQcm92aWRlcjtcblxub25zLmVsZW1lbnRzLkxhenlSZXBlYXQgPSBMYXp5UmVwZWF0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxhenktcmVwZWF0JywgTGF6eVJlcGVhdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3QtaGVhZGVyJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtaGVhZGVyLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtaGVhZGVyXG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1IZWFkZXIgZWxlbWVudCBmb3IgbGlzdCBpdGVtcy4gTXVzdCBiZSBwdXQgaW5zaWRlIHRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jopoHntKDjgavkvb/nlKjjgZnjgovjg5jjg4Pjg4Djg7znlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgIJvbnMtbGlzdOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3TjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxuICogICBbZW5dVGhlIGA8b25zLWxpc3QtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1EaXNwbGF5IGEgTWF0ZXJpYWwgRGVzaWduIGxpc3QgaGVhZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWhlYWRlcj5IZWFkZXIgVGV4dDwvb25zLWxpc3QtaGVhZGVyPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEhlYWRlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0IGhlYWRlci5bL2VuXVxuICAgKiAgIFtqYV3jg5jjg4Pjg4Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuTGlzdEhlYWRlciA9IExpc3RIZWFkZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdC1oZWFkZXInLCBMaXN0SGVhZGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnbGlzdC10aXRsZSc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LXRpdGxlLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWxpc3QtdGl0bGVcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSBsaXN0IHRpdGxlLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7jgr/jgqTjg4jjg6vjgpLooajnj77jgZfjgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdC10aXRsZT5MaXN0IFRpdGxlPC9vbnMtbGlzdC10aXRsZT5cbiAqIDxvbnMtbGlzdD5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gbGlzdCB0aXRsZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0VGl0bGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jb21waWxlKCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbm9ucy5lbGVtZW50cy5MaXN0VGl0bGUgPSBMaXN0VGl0bGVFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdC10aXRsZScsIExpc3RUaXRsZUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3QtaXRlbSc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcubGlzdC1pdGVtJzogJ2xpc3QtaXRlbS0tKicsXG4gICcubGlzdC1pdGVtX19sZWZ0JzogJ2xpc3QtaXRlbS0tKl9fbGVmdCcsXG4gICcubGlzdC1pdGVtX19jZW50ZXInOiAnbGlzdC1pdGVtLS0qX19jZW50ZXInLFxuICAnLmxpc3QtaXRlbV9fcmlnaHQnOiAnbGlzdC1pdGVtLS0qX19yaWdodCcsXG4gICcubGlzdC1pdGVtX19sYWJlbCc6ICdsaXN0LWl0ZW0tLSpfX2xhYmVsJyxcbiAgJy5saXN0LWl0ZW1fX3RpdGxlJzogJ2xpc3QtaXRlbS0tKl9fdGl0bGUnLFxuICAnLmxpc3QtaXRlbV9fc3VidGl0bGUnOiAnbGlzdC1pdGVtLS0qX19zdWJ0aXRsZScsXG4gICcubGlzdC1pdGVtX190aHVtYm5haWwnOiAnbGlzdC1pdGVtLS0qX190aHVtYm5haWwnLFxuICAnLmxpc3QtaXRlbV9faWNvbic6ICdsaXN0LWl0ZW0tLSpfX2ljb24nXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0LWl0ZW1cbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAbW9kaWZpZXIgdGFwcGFibGVcbiAqICAgW2VuXU1ha2UgdGhlIGxpc3QgaXRlbSBjaGFuZ2UgYXBwZWFyYW5jZSB3aGVuIGl0J3MgdGFwcGVkLiBPbiBpT1MgaXQgaXMgYmV0dGVyIHRvIHVzZSB0aGUgXCJ0YXBwYWJsZVwiIGFuZCBcInRhcC1iYWNrZ3JvdW5kLWNvbG9yXCIgYXR0cmlidXRlIGZvciBiZXR0ZXIgYmVoYXZpb3Igd2hlbiBzY3JvbGxpbmcuWy9lbl1cbiAqICAgW2phXeOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBl+OBn+aZguOBq+WKueaenOOBjOihqOekuuOBleOCjOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgY2hldnJvblxuICogICBbZW5dRGlzcGxheSBhIGNoZXZyb24gYXQgdGhlIHJpZ2h0IGVuZCBvZiB0aGUgbGlzdCBpdGVtIGFuZCBtYWtlIGl0IGNoYW5nZSBhcHBlYXJhbmNlIHdoZW4gdGFwcGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIGxvbmdkaXZpZGVyXG4gKiAgIFtlbl1EaXNwbGF5cyBhIGxvbmcgaG9yaXpvbnRhbCBkaXZpZGVyIGJldHdlZW4gaXRlbXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9kaXZpZGVyXG4gKiAgIFtlbl1SZW1vdmVzIHRoZSBkaXZpZGVyIGJldHdlZW4gbGlzdCBpdGVtcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGl0ZW0uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgZWFjaCBpdGVtIGluIGEgbGlzdC4gVGhlIGxpc3QgaXRlbSBpcyBjb21wb3NlZCBvZiB0aHJlZSBwYXJ0cyB0aGF0IGFyZSByZXByZXNlbnRlZCB3aXRoIHRoZSBgbGVmdGAsIGBjZW50ZXJgIGFuZCBgcmlnaHRgIGNsYXNzZXMuIFRoZXNlIGNsYXNzZXMgY2FuIGJlIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNvbnRlbnQgb2YgdGhlIGxpc3QgaXRlbXMgaXMgcHJvcGVybHkgYWxpZ25lZC5cbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPkxlZnQ8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5DZW50ZXI8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlJpZ2h0PC9kaXY+XG4gKiAgICAgPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIGBgYFxuICpcbiAqICAgICBUaGVyZSBpcyBhbHNvIGEgbnVtYmVyIG9mIGNsYXNzZXMgKHByZWZpeGVkIHdpdGggYGxpc3QtaXRlbV9fKmApIHRoYXQgaGVscCB3aGVuIHB1dHRpbmcgdGhpbmdzIGxpa2UgaWNvbnMgYW5kIHRodW1ibmFpbHMgaW50byB0aGUgbGlzdCBpdGVtcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5db25zLWxpc3QgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWhlYWRlclxuICogICBbZW5db25zLWxpc3QtaGVhZGVyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1oZWFkZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGNvZGVwZW4geXhjQ3RcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9saXN0XG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0LWl0ZW0+XG4gKiAgIDxkaXYgY2xhc3M9XCJsZWZ0XCI+XG4gKiAgICAgPG9ucy1pY29uIGljb249XCJtZC1mYWNlXCIgY2xhc3M9XCJsaXN0LWl0ZW1fX2ljb25cIj48L29ucy1pY29uPlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgIDxkaXYgY2xhc3M9XCJsaXN0LWl0ZW1fX3RpdGxlXCI+VGl0bGU8L2Rpdj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGlzdC1pdGVtX19zdWJ0aXRsZVwiPlN1YnRpdGxlPC9kaXY+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwicmlnaHRcIj5cbiAqICAgICA8b25zLXN3aXRjaD48L29ucy1zd2l0Y2g+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtbGlzdC1pdGVtPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0SXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBsaXN0IGl0ZW0uWy9lbl1cbiAgICogICBbamFd5ZCE6KaB57Sg44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbG9jay1vbi1kcmFnXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QcmV2ZW50IHZlcnRpY2FsIHNjcm9sbGluZyB3aGVuIHRoZSB1c2VyIGRyYWdzIGhvcml6b250YWxseS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg6bjg7zjgrbjg7zjgYzjgZPjga7opoHntKDjgpLmqKrmlrnlkJHjgavjg4njg6njg4PjgrDjgZfjgabjgYTjgovmmYLjgavjgIHnuKbmlrnlkJHjga7jgrnjgq/jg63jg7zjg6vjgYzotbfjgY3jgarjgYTjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0YXBwYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU1ha2VzIHRoZSBlbGVtZW50IHJlYWN0IHRvIHRhcHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGFwLWJhY2tncm91bmQtY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dIENoYW5nZXMgdGhlIGJhY2tncm91bmQgY29sb3Igd2hlbiB0YXBwZWQuIEZvciB0aGlzIHRvIHdvcmssIHRoZSBhdHRyaWJ1dGUgXCJ0YXBwYWJsZVwiIG5lZWRzIHRvIGJlIHNldC4gVGhlIGRlZmF1bHQgY29sb3IgaXMgXCIjZDlkOWQ5XCIuIEl0IHdpbGwgZGlzcGxheSBhcyBhIHJpcHBsZSBlZmZlY3Qgb24gQW5kcm9pZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgbGV0IGxlZnQsIGNlbnRlciwgcmlnaHQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnbGVmdCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fbGVmdCcpO1xuICAgICAgICBsZWZ0ID0gZWw7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2NlbnRlcicpKSB7XG4gICAgICAgIGNlbnRlciA9IGVsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdyaWdodCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fcmlnaHQnKTtcbiAgICAgICAgcmlnaHQgPSBlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNlbnRlcikge1xuICAgICAgY2VudGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGlmICghbGVmdCAmJiAhcmlnaHQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgIGNlbnRlci5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgaWYgKGVsICE9PSBsZWZ0ICYmIGVsICE9PSByaWdodCkge1xuICAgICAgICAgICAgY2VudGVyLmluc2VydEJlZm9yZShlbCwgY2VudGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmluc2VydEJlZm9yZShjZW50ZXIsIHJpZ2h0IHx8IG51bGwpO1xuICAgIH1cblxuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdjZW50ZXInKTtcbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgnbGlzdC1pdGVtX19jZW50ZXInKTtcblxuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnLCAncmlwcGxlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKHRydWUpO1xuICAgIHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yID0gdGhpcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKGZhbHNlKTtcbiAgfVxuXG4gIF9zZXR1cExpc3RlbmVycyhhZGQpIHtcbiAgICBjb25zdCBhY3Rpb24gPSAoYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lcic7XG4gICAgdGhpc1thY3Rpb25dKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICB0aGlzW2FjdGlvbl0oJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblRvdWNoKTtcbiAgICB0aGlzW2FjdGlvbl0oJ21vdXNlZG93bicsIHRoaXMuX29uVG91Y2gpO1xuICAgIHRoaXNbYWN0aW9uXSgndG91Y2hlbmQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXNbYWN0aW9uXSgndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ3RvdWNoY2FuY2VsJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ21vdXNldXAnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXNbYWN0aW9uXSgnbW91c2VvdXQnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIHRoaXNbYWN0aW9uXSgndG91Y2hsZWF2ZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnKGV2ZW50KSB7XG4gICAgY29uc3QgZ2VzdHVyZSA9IGV2ZW50Lmdlc3R1cmU7XG4gICAgLy8gUHJldmVudCB2ZXJ0aWNhbCBzY3JvbGxpbmcgaWYgdGhlIHVzZXJzIHBhbnMgbGVmdCBvciByaWdodC5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2xvY2stb24tZHJhZycpICYmIFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZ2VzdHVyZS5kaXJlY3Rpb24pID4gLTEpIHtcbiAgICAgIGdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBfb25Ub3VjaCgpIHtcbiAgICBpZiAodGhpcy50YXBwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRhcHBlZCA9IHRydWU7XG4gICAgY29uc3QgdG91Y2hTdHlsZSA9IHsgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQtY29sb3IgMC4wcyBsaW5lYXIgMC4wMnMsIGJveC1zaGFkb3cgMC4wcyBsaW5lYXIgMC4wMnMnIH07XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJykpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgfVxuXG4gICAgICB0b3VjaFN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0YXAtYmFja2dyb3VuZC1jb2xvcicpIHx8ICcjZDlkOWQ5JztcbiAgICAgIHRvdWNoU3R5bGUuYm94U2hhZG93ID0gYDBweCAtMXB4IDBweCAwcHggJHt0b3VjaFN0eWxlLmJhY2tncm91bmRDb2xvcn1gO1xuICAgIH1cblxuICAgIHN0eWxlcih0aGlzLCB0b3VjaFN0eWxlKTtcbiAgfVxuXG4gIF9vblJlbGVhc2UoKSB7XG4gICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIHx8ICcnO1xuICAgIHN0eWxlci5jbGVhcih0aGlzLCAndHJhbnNpdGlvbiBib3hTaGFkb3cnKTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuTGlzdEl0ZW0gPSBMaXN0SXRlbUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1saXN0LWl0ZW0nLCBMaXN0SXRlbUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3QnO1xuY29uc3Qgc2NoZW1lID0geycnOiAnbGlzdC0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0XG4gKiBAY2F0ZWdvcnkgbGlzdFxuICogQG1vZGlmaWVyIGluc2V0XG4gKiAgIFtlbl1JbnNldCBsaXN0IHRoYXQgZG9lc24ndCBjb3ZlciB0aGUgd2hvbGUgd2lkdGggb2YgdGhlIHBhcmVudC5bL2VuXVxuICogICBbamFd6Kaq6KaB57Sg44Gu55S76Z2i44GE44Gj44Gx44GE44Gr5bqD44GM44KJ44Gq44GE44Oq44K544OI44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBub2JvcmRlclxuICogICBbZW5dQSBsaXN0IHdpdGggbm8gYm9yZGVycyBhdCB0aGUgdG9wIGFuZCBib3R0b20uWy9lbl1cbiAqICAgW2phXeODquOCueODiOOBruS4iuS4i+OBruODnOODvOODgOODvOOBjOeEoeOBhOODquOCueODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNvbXBvbmVudCB0byBkZWZpbmUgYSBsaXN0LCBhbmQgdGhlIGNvbnRhaW5lciBmb3Igb25zLWxpc3QtaXRlbShzKS5bL2VuXVxuICogICBbamFd44Oq44K544OI44KS6KGo54++44GZ44KL44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44CCb25zLWxpc3QtaXRlbeOBruOCs+ODs+ODhuODiuOBqOOBl+OBpuS9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1pdGVtXG4gKiAgIFtlbl1vbnMtbGlzdC1pdGVtIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWhlYWRlclxuICogICBbZW5db25zLWxpc3QtaGVhZGVyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdC1oZWFkZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWxhenktcmVwZWF0XG4gKiAgIFtlbl1vbnMtbGF6eS1yZXBlYXQgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1sYXp5LXJlcGVhdOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3Q+XG4gKiAgIDxvbnMtbGlzdC1oZWFkZXI+SGVhZGVyIFRleHQ8L29ucy1saXN0LWhlYWRlcj5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuTGlzdCA9IExpc3RFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdCcsIExpc3RFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvY2FwaXRhbGl6ZScsXG4gICdhdXRvY29tcGxldGUnLFxuICAnYXV0b2NvcnJlY3QnLFxuICAnYXV0b2ZvY3VzJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2lucHV0bW9kZScsXG4gICdtYXgnLFxuICAnbWF4bGVuZ3RoJyxcbiAgJ21pbicsXG4gICdtaW5sZW5ndGgnLFxuICAnbmFtZScsXG4gICdwYXR0ZXJuJyxcbiAgJ3BsYWNlaG9sZGVyJyxcbiAgJ3JlYWRvbmx5JyxcbiAgJ3JlcXVpcmVkJyxcbiAgJ3NpemUnLFxuICAnc3RlcCcsXG4gICd2YWxpZGF0b3InLFxuICAndmFsdWUnXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlSW5wdXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIF91cGRhdGUoKSB7fSAvLyBPcHRpb25hbGx5IGltcGxlbWVudGVkXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdfc2NoZW1lIGdldHRlciBtdXN0IGJlIGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ190ZW1wbGF0ZSBnZXR0ZXIgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndHlwZSBnZXR0ZXIgbXVzdCBiZSBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQgPSB0aGlzLl9kZWxlZ2F0ZUV2ZW50LmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lICYmIHRoaXMuY2xhc3NMaXN0LmFkZCh0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodXRpbC5jcmVhdGVGcmFnbWVudCh0aGlzLl90ZW1wbGF0ZSkpO1xuXG4gICAgdGhpcy5fc2V0SW5wdXRJZCgpO1xuICAgIHRoaXMuX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpIHtcbiAgICBJTlBVVF9BVFRSSUJVVEVTLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgX2RlbGVnYXRlRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCBlID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50LnR5cGUsIHtcbiAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgfVxuXG4gIF9zZXRJbnB1dElkKCkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaW5wdXQtaWQnKSkge1xuICAgICAgdGhpcy5faW5wdXQuaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaW5wdXQtaWQnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZ2V0IF9pbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dCA9PT0gbnVsbFxuICAgICAgPyB0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKVxuICAgICAgOiB0aGlzLl9pbnB1dC52YWx1ZTtcbiAgfVxuXG4gIHNldCB2YWx1ZSh2YWwpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgdmFsID0gdmFsLnRvSVNPU3RyaW5nKCkuc3Vic3RyaW5nKDAsIDEwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gdmFsO1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgICB0aGlzLl9pbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmREZWxlZ2F0ZUV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2lucHV0LWlkJywgJ2NsYXNzJywgLi4uSU5QVVRfQVRUUklCVVRFU107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHRoaXMuX3NjaGVtZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0LWlkJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3NldElucHV0SWQoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lLCB0aGlzLl9zY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoSU5QVVRfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IEJhc2VJbnB1dEVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtaW5wdXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy50ZXh0LWlucHV0JzogJ3RleHQtaW5wdXQtLSonLFxuICAnLnRleHQtaW5wdXRfX2xhYmVsJzogJ3RleHQtaW5wdXQtLSpfX2xhYmVsJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaW5wdXRcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB1bmRlcmJhclxuICogIFtlbl1EaXNwbGF5cyBhIGhvcml6b250YWwgbGluZSB1bmRlcm5lYXRoIGEgdGV4dCBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgW2VuXURpc3BsYXlzIGEgdHJhbnNwYXJlbnQgaW5wdXQuIFdvcmtzIGZvciBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEFuIGlucHV0IGVsZW1lbnQuIFRoZSBgdHlwZWAgYXR0cmlidXRlIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgaW5wdXQgdHlwZS4gQWxsIHRleHQgaW5wdXQgdHlwZXMgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQgb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0PmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pbnB1dFxuICogQHNlZWFsc28gb25zLWNoZWNrYm94XG4gKiAgIFtlbl1UaGUgYDxvbnMtY2hlY2tib3g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGNoZWNrYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhZGlvXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWxlY3RcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlbGVjdCBib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWlucHV0IHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIiBmbG9hdD48L29ucy1pbnB1dD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRFbGVtZW50IGV4dGVuZHMgQmFzZUlucHV0RWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JvdW5kT25JbnB1dCA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25Gb2N1c2luID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKiBJbmhlcml0ZWQgcHJvcHMgKi9cblxuICBfdXBkYXRlKCkge1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsKCk7XG4gICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxpbnB1dCB0eXBlPVwiJHt0aGlzLnR5cGV9XCIgY2xhc3M9XCJ0ZXh0LWlucHV0XCI+XG4gICAgICA8c3BhbiBjbGFzcz1cInRleHQtaW5wdXRfX2xhYmVsXCI+PC9zcGFuPlxuICAgIGA7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICByZXR1cm4gKFsnY2hlY2tib3gnLCAncmFkaW8nXS5pbmRleE9mKHR5cGUpIDwgMCkgJiYgdHlwZSB8fCAndGV4dCc7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBfdXBkYXRlTGFiZWwoKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSB8fCAnJztcblxuICAgIGlmICh0eXBlb2YgdGhpcy5faGVscGVyLnRleHRDb250ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faGVscGVyLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hlbHBlci5pbm5lclRleHQgPSBsYWJlbDtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTGFiZWxDbGFzcygpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWlucHV0LS1tYXRlcmlhbF9fbGFiZWwtLWFjdGl2ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dC0tbWF0ZXJpYWxfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX2hlbHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fYm91bmRPbklucHV0KTtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9ib3VuZE9uRm9jdXNpbik7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICBpZiAoWydjaGVja2JveCcsICdyYWRpbyddLmluZGV4T2YodHlwZSkgPj0gMCkge1xuICAgICAgdXRpbC53YXJuKGBXYXJuOiA8b25zLWlucHV0IHR5cGU9XCIke3R5cGV9XCI+IGlzIGRlcHJlY2F0ZWQgc2luY2UgdjIuNC4wLiBVc2UgPG9ucy0ke3R5cGV9PiBpbnN0ZWFkLmApXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYm91bmRPbkZvY3VzaW4pO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICd0eXBlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhY2Vob2xkZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBsYWNlaG9sZGVyIHRleHQuIEluIE1hdGVyaWFsIERlc2lnbiwgdGhpcyBwbGFjZWhvbGRlciB3aWxsIGJlIGEgZmxvYXRpbmcgbGFiZWwuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZmxvYXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgcHJlc2VudCwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgYW5pbWF0ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5pmC44CB44Op44OZ44Or44Gv44Ki44OL44Oh44O844K344On44Oz44GZ44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdHlwZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1cbiAgICogICAgU3BlY2lmeSB0aGUgaW5wdXQgdHlwZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgXCJ0eXBlXCIgYXR0cmlidXRlIGZvciBub3JtYWwgaW5wdXRzLiBJdCBleHBlY3RzIHN0cmljdCB0ZXh0IHR5cGVzIHN1Y2ggYXMgYHRleHRgLCBgcGFzc3dvcmRgLCBldGMuIEZvciBjaGVja2JveCwgcmFkaW8gYnV0dG9uLCBzZWxlY3Qgb3IgcmFuZ2UsIHBsZWFzZSBoYXZlIGEgbG9vayBhdCB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cy5cbiAgICpcbiAgICogICAgUGxlYXNlIHRha2UgYSBsb29rIGF0IFtNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNhdHRyLXR5cGUpIGZvciBhbiBleGhhdXN0aXZlIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzLiBEZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtIGFuZCBicm93c2VyIHZlcnNpb24gc29tZSBvZiB0aGVzZSBtaWdodCBub3Qgd29yay5cbiAgICogIFsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgXCJpZFwiIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBpbnB1dCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG59XG5cbm9ucy5lbGVtZW50cy5JbnB1dCA9IElucHV0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWlucHV0JywgSW5wdXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgQmFzZUlucHV0RWxlbWVudCBmcm9tICcuL2Jhc2UtaW5wdXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VDaGVja2JveEVsZW1lbnQgZXh0ZW5kcyBCYXNlSW5wdXRFbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdjaGVja2VkJywgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBJbmhlcml0ZWQgcHJvcHMgKi9cblxuICBnZXQgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8aW5wdXQgdHlwZT1cIiR7dGhpcy50eXBlfVwiIGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9faW5wdXRcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9fY2hlY2ttYXJrXCI+PC9zcGFuPlxuICAgIGA7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBnZXQgX2hlbHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gIH1cblxuICBnZXQgY2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQuY2hlY2tlZDtcbiAgfVxuXG4gIHNldCBjaGVja2VkKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5jaGVja2VkID0gdmFsO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICdjaGVja2VkJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCBCYXNlQ2hlY2tib3hFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWNoZWNrYm94JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmNoZWNrYm94JzogJ2NoZWNrYm94LS0qJyxcbiAgJy5jaGVja2JveF9faW5wdXQnOiAnY2hlY2tib3gtLSpfX2lucHV0JyxcbiAgJy5jaGVja2JveF9fY2hlY2ttYXJrJzogJ2NoZWNrYm94LS0qX19jaGVja21hcmsnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jaGVja2JveFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBjaGVja2JveC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG5vYm9yZGVyXG4gKiAgW2VuXWlPUyBib3JkZXJsZXNzIGNoZWNrYm94LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNoZWNrYm94IGVsZW1lbnQuIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiBjaGVja2JveCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKlxuICogICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCI+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLWNoZWNrYm94PmAgZWxlbWVudC5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2lucHV0XG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYWRpb1xuICogICBbZW5dVGhlIGA8b25zLXJhZGlvPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYWRpbyBidXR0b24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWFyY2gtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWFyY2gtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlYXJjaCBpbnB1dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jaGVja2JveCBjaGVja2VkPjwvb25zLWNoZWNrYm94PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGVja2JveEVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAnY2hlY2tib3gnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdjaGVja2JveCc7XG4gIH1cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY2hlY2tib3guWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjaGVja2VkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2hlY2tib3ggaXMgY2hlY2tlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbn1cblxub25zLmVsZW1lbnRzLkNoZWNrYm94ID0gQ2hlY2tib3hFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2hlY2tib3gnLCBDaGVja2JveEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCBCYXNlQ2hlY2tib3hFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWNoZWNrYm94JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnJhZGlvLWJ1dHRvbic6ICdyYWRpby1idXR0b24tLSonLFxuICAnLnJhZGlvLWJ1dHRvbl9faW5wdXQnOiAncmFkaW8tYnV0dG9uLS0qX19pbnB1dCcsXG4gICcucmFkaW8tYnV0dG9uX19jaGVja21hcmsnOiAncmFkaW8tYnV0dG9uLS0qX19jaGVja21hcmsnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yYWRpb1xuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiByYWRpbyBidXR0b24uWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgcmFkaW8gYnV0dG9uIGVsZW1lbnQuIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiByYWRpbyBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0IHR5cGU9XCJyYWRpb1wiPmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1yYWRpbz5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pbnB1dFxuICogQHNlZWFsc28gb25zLXNlbGVjdFxuICogICBbZW5dVGhlIGA8b25zLXNlbGVjdD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgc2VsZWN0IGJveC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jaGVja2JveFxuICogICBbZW5dVGhlIGA8b25zLWNoZWNrYm94PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBjaGVja2JveC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zd2l0Y2hcbiAqICAgW2VuXVRoZSBgPG9ucy1zd2l0Y2g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGRyYWdnYWJsZSB0b2dnbGUgc3dpdGNoLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VhcmNoLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VhcmNoLWlucHV0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWFyY2ggaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yYWRpbyBjaGVja2VkPjwvb25zLXJhZGlvPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpb0VsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAncmFkaW8tYnV0dG9uJztcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAncmFkaW8nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgXCJpZFwiIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSByYWRpbyBidXR0b24gaXMgY2hlY2tlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHJhZGlvIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG59XG5cbm9ucy5lbGVtZW50cy5SYWRpbyA9IFJhZGlvRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJhZGlvJywgUmFkaW9FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgQmFzZUlucHV0RWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1pbnB1dCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5zZWFyY2gtaW5wdXQnOiAnc2VhcmNoLWlucHV0LS0qJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc2VhcmNoLWlucHV0XG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgW2VuXURpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIHNlYXJjaCBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBzZWFyY2ggaW5wdXQgZWxlbWVudC4gVGhlIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVuZGVyIGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlYXJjaCBpbnB1dCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKlxuICogICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8aW5wdXQ+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLXNlYXJjaC1pbnB1dD5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pbnB1dFxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXN3aXRjaFxuICogICBbZW5dVGhlIGA8b25zLXN3aXRjaD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgZHJhZ2dhYmxlIHRvZ2dsZSBzd2l0Y2guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VsZWN0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VsZWN0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWxlY3QgYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWNoZWNrYm94XG4gKiAgIFtlbl1UaGUgYDxvbnMtY2hlY2tib3g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGNoZWNrYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhZGlvXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc2VhcmNoLWlucHV0IHBsYWNlaG9sZGVyPVwiU2VhcmNoXCI+PC9vbnMtc2VhcmNoLWlucHV0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWFyY2hJbnB1dEVsZW1lbnQgZXh0ZW5kcyBCYXNlSW5wdXRFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cInNlYXJjaC1pbnB1dFwiPlxuICAgIGA7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ3NlYXJjaCc7XG4gIH1cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBcImlkXCIgYXR0cmlidXRlIG9mIHRoZSBpbm5lciBgPGlucHV0PmAgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBgPGxhYmVsIGZvcj1cIi4uLlwiPmAgZWxlbWVudHMuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGlucHV0IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbn1cblxub25zLmVsZW1lbnRzLlNlYXJjaElucHV0ID0gU2VhcmNoSW5wdXRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc2VhcmNoLWlucHV0JywgU2VhcmNoSW5wdXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbEFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IE1vZGFsQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVNb2RhbEFuaW1hdG9yIGV4dGVuZHMgTW9kYWxBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICB9KVxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIG1vZGFsLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZnRNb2RhbEFuaW1hdG9yIGV4dGVuZHMgTW9kYWxBbmltYXRvclxue1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciggLjEsIC43LCAuMSwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC40fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KG1vZGFsKVxuICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAucXVldWUoe1xuICAgICAgICBjc3M6IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIGNzczoge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgIH0pXG4gICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgIC5xdWV1ZShmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgIGFuaW1pdChtb2RhbClcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgY3NzOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknXG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIGNzczoge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xuICAgICAgICB9LFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgTW9kYWxBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBGYWRlTW9kYWxBbmltYXRvciBmcm9tICcuL2ZhZGUtYW5pbWF0b3InO1xuaW1wb3J0IExpZnRNb2RhbEFuaW1hdG9yIGZyb20gJy4vbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRGlhbG9nRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZGlhbG9nJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnbW9kYWwtLSonLFxuICAnbW9kYWxfX2NvbnRlbnQnOiAnbW9kYWwtLSpfX2NvbnRlbnQnXG59O1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ21vZGFsJztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiBNb2RhbEFuaW1hdG9yLFxuICAnZmFkZSc6IEZhZGVNb2RhbEFuaW1hdG9yLFxuICAnbGlmdCc6IExpZnRNb2RhbEFuaW1hdG9yLFxuICAnbm9uZSc6IE1vZGFsQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLW1vZGFsXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIE1vZGFsIGNvbXBvbmVudCB0aGF0IG1hc2tzIGN1cnJlbnQgc2NyZWVuLiBVbmRlcmx5aW5nIGNvbXBvbmVudHMgYXJlIG5vdCBzdWJqZWN0IHRvIGFueSBldmVudHMgd2hpbGUgdGhlIG1vZGFsIGNvbXBvbmVudCBpcyBzaG93bi5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gYmxvY2sgdXNlciBpbnB1dCB3aGlsZSBzb21lIG9wZXJhdGlvbiBpcyBydW5uaW5nIG9yIHRvIHNob3cgc29tZSBpbmZvcm1hdGlvbiB0byB0aGUgdXNlci5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIOeUu+mdouWFqOS9k+OCkuODnuOCueOCr+OBmeOCi+ODouODvOODgOODq+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguS4i+WBtOOBq+OBguOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBr+OAgVxuICogICAgIOODouODvOODgOODq+OBjOihqOekuuOBleOCjOOBpuOBhOOCi+mWk+OBr+OCpOODmeODs+ODiOmAmuefpeOBjOihjOOCj+OCjOOBvuOBm+OCk+OAglxuICogICBbL2phXVxuICogQHNlZWFsc28gb25zLWRpYWxvZ1xuICogICBbZW5dVGhlIGA8b25zLWRpYWxvZz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYSBtb2RhbCBkaWFsb2cuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBkZXZJZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvcmVmZXJlbmNlL21vZGFsXG4gKiBAZXhhbXBsZVxuICogPG9ucy1tb2RhbCBpZD1cIm1vZGFsXCI+XG4gKiAgIE1vZGFsIGNvbnRlbnRcbiAqIDwvb25zLW1vZGFsPlxuICogPHNjcmlwdD5cbiAqICAgdmFyIG1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vZGFsJyk7XG4gKiAgIG1vZGFsLnNob3coKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIG1vZGFsIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGFsXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBtb2RhbCBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBtb2RhbCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODouODvOODgOODq+OBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tb2RhbFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBtb2RhbCBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODouODvOODgOODq+OBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tb2RhbFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgbW9kYWwgZnJvbSBiZWluZyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44OA44Kk44Ki44Ot44Kw44Gu6Z2e6KGo56S644GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIG1vZGFsIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44Oi44O844OA44Or44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGFsXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IGRlZmF1bHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbmQgaGlkaW5nIHRoZSBtb2RhbC4gQ2FuIGJlIGVpdGhlciBgXCJub25lXCJgLCBgXCJmYWRlXCJgIG9yIGBcImxpZnRcImAuWy9lbl1cbiAgICogIFtqYV3jg6Ljg7zjg4Djg6vjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIuOCguOBl+OBj+OBr1wiZmFkZVwiLFwibGlmdFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fZGVmYXVsdERCQiA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogTW9kYWxBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdNb2RhbEFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLm1vZGFsX19jb250ZW50JykpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnbW9kYWxfX2NvbnRlbnQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5jaGlsZE5vZGVzWzBdO1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICBjb250ZW50Lmluc2VydEJlZm9yZShub2RlLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICBfdG9nZ2xlU3R5bGUoc2hvdWxkU2hvdykge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IHNob3VsZFNob3cgPyAndGFibGUnIDogJ25vbmUnO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHN1cGVyLl9wcmV2ZW50U2Nyb2xsLCBmYWxzZSk7IC8vIGlPUyBmaXhcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBzdXBlci5fcHJldmVudFNjcm9sbCwgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIG1vZGFsIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG1vZGFsLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgbW9kYWwgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSBtb2RhbCB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OBruihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBtb2RhbCBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGFsQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgT25zTW9kYWxFbGVtZW50Lk1vZGFsQW5pbWF0b3InKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IE1vZGFsQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIE1vZGFsQW5pbWF0b3I7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLk1vZGFsID0gTW9kYWxFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbW9kYWwnLCBNb2RhbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi8uLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IHdpZHRoVG9QeCA9ICh3aWR0aCkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHB4XSA9IFtwYXJzZUludCh3aWR0aCwgMTApLCAvcHgvLnRlc3Qod2lkdGgpXTtcbiAgcmV0dXJuIHB4ID8gdmFsdWUgOiBNYXRoLnJvdW5kKGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggKiB2YWx1ZSAvIDEwMCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2lwZVJldmVhbCB7XG5cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgJ2VsZW1lbnQgaWdub3JlU3dpcGUgaXNJbml0aWFsU3RhdGUgb25EcmFnQ2FsbGJhY2sgc3dpcGVNYXggc3dpcGVNaW4gc3dpcGVNaWQnXG4gICAgICAuc3BsaXQoL1xccysvKS5mb3JFYWNoKGtleSA9PiB0aGlzW2tleV0gPSBwYXJhbXNba2V5XSk7XG5cbiAgICB0aGlzLmVsZW1lbnRIYW5kbGVyID0gcGFyYW1zLmVsZW1lbnRIYW5kbGVyIHx8IHBhcmFtcy5lbGVtZW50O1xuICAgIHRoaXMuZ2V0VGhyZXNob2xkID0gcGFyYW1zLmdldFRocmVzaG9sZCB8fCAoKCkgPT4gLjUpO1xuICAgIHRoaXMuZ2V0U2lkZSA9IHBhcmFtcy5nZXRTaWRlIHx8ICgoKSA9PiAnbGVmdCcpO1xuXG4gICAgdGhpcy5oYW5kbGVHZXN0dXJlID0gdGhpcy5oYW5kbGVHZXN0dXJlLmJpbmQodGhpcyk7XG4gIH1cblxuICB1cGRhdGUoc3dpcGVhYmxlID0gdGhpcy5lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc3dpcGVhYmxlJykpIHtcbiAgICBpZiAoIXRoaXMuZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICB0aGlzLmdlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5lbGVtZW50SGFuZGxlciwge2RyYWdNaW5EaXN0YW5jZTogMX0pO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGlvbiA9IHN3aXBlYWJsZSA/ICdvbicgOiAnb2ZmJztcbiAgICB0aGlzLmdlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnIGRyYWdzdGFydCBkcmFnZW5kJywgdGhpcy5oYW5kbGVHZXN0dXJlKTtcbiAgfVxuXG4gIGhhbmRsZUdlc3R1cmUoZSkge1xuICAgIGlmIChlLmdlc3R1cmUpIHtcbiAgICAgIGlmIChlLnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICAgIHRoaXMub25EcmFnU3RhcnQoZSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICAgIGUudHlwZSA9PT0gJ2RyYWdlbmQnID8gdGhpcy5vbkRyYWdFbmQoZSkgOiB0aGlzLm9uRHJhZyhlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkRyYWdTdGFydChldmVudCkge1xuICAgIGNvbnN0IGdldERpc3RhbmNlID0gKCkgPT4gdGhpcy5nZXRTaWRlKCkgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFggOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFg7XG4gICAgdGhpcy5faWdub3JlRHJhZyA9IGV2ZW50LmNvbnN1bWVkIHx8ICF1dGlsLmlzVmFsaWRHZXN0dXJlKGV2ZW50KSB8fCB0aGlzLmlnbm9yZVN3aXBlKGV2ZW50LCBnZXREaXN0YW5jZSgpKTtcblxuICAgIGlmICghdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgZXZlbnQuY29uc3VtZSAmJiBldmVudC5jb25zdW1lKCk7XG4gICAgICBldmVudC5jb25zdW1lZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGhUb1B4KHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCB8fCAnMTAwJScpO1xuICAgICAgdGhpcy5fc3RhcnREaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlID0gKCEodGhpcy5pc0luaXRpYWxTdGF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCB0aGlzLmlzSW5pdGlhbFN0YXRlKCkpID8gMCA6IHRoaXMuX3dpZHRoO1xuXG4gICAgICB1dGlsLnByZXZlbnRTY3JvbGwodGhpcy5nZXN0dXJlRGV0ZWN0b3IpO1xuICAgIH1cbiAgfVxuXG4gIG9uRHJhZyhldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5nZXRTaWRlKCkgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuZGVsdGFYIDogLWV2ZW50Lmdlc3R1cmUuZGVsdGFYO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5fd2lkdGgsIHRoaXMuX3N0YXJ0RGlzdGFuY2UgKyBkZWx0YSkpO1xuICAgIGlmIChkaXN0YW5jZSAhPT0gdGhpcy5fZGlzdGFuY2UpIHtcbiAgICAgIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICB0aGlzLnN3aXBlTWlkKHRoaXMuX2Rpc3RhbmNlLCB0aGlzLl93aWR0aCk7XG4gICAgfVxuICB9XG5cbiAgb25EcmFnRW5kKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb247XG4gICAgY29uc3QgaXNTd2lwZU1heCA9IHRoaXMuZ2V0U2lkZSgpICE9PSBkaXJlY3Rpb24gJiYgdGhpcy5fZGlzdGFuY2UgPiB0aGlzLl93aWR0aCAqIHRoaXMuZ2V0VGhyZXNob2xkKCk7XG4gICAgaXNTd2lwZU1heCA/IHRoaXMuc3dpcGVNYXgoKSA6IHRoaXMuc3dpcGVNaW4oKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3IgJiYgdGhpcy5nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgIHRoaXMuZ2VzdHVyZURldGVjdG9yID0gdGhpcy5lbGVtZW50ID0gdGhpcy5lbGVtZW50SGFuZGxlciA9IG51bGw7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHtcbiAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICBkdXJhdGlvbjogJzAuNCcsXG4gICAgICBkZWxheTogJzAnXG4gICAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgYmxvY2socGFnZSkge1xuICAgIGNvbnN0IGJsb2NrZXIgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDEwMDAwMFwiPjwvZGl2PlxuICAgIGApO1xuICAgIHBhZ2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChibG9ja2VyKTtcbiAgICByZXR1cm4gKCkgPT4gYmxvY2tlci5yZW1vdmUoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbi8qKlxuICogU2xpZGUgYW5pbWF0b3IgZm9yIG5hdmlnYXRvciB0cmFuc2l0aW9uIGxpa2UgaU9TJ3Mgc2NyZWVuIHNsaWRlIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoMC4zLCAuNCwgMCwgLjkpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuNH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGJsYWNrOyB6LWluZGV4OiAyXCI+PC9kaXY+XG4gICAgYCk7XG5cbiAgfVxuXG4gIF9kZWNvbXBvc2UocGFnZSkge1xuICAgIGNvbnN0IHRvb2xiYXIgPSBwYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpO1xuICAgIGNvbnN0IGxlZnQgPSB0b29sYmFyLl9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdG9vbGJhci5fZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50KCk7XG5cbiAgICBjb25zdCBleGNsdWRlQmFja0J1dHRvbiA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxlbWVudHNbaV0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1iYWNrLWJ1dHRvbicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgY29uc3Qgb3RoZXIgPSBbXVxuICAgICAgLmNvbmNhdChsZWZ0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IGxlZnQgOiBleGNsdWRlQmFja0J1dHRvbihsZWZ0LmNoaWxkcmVuKSlcbiAgICAgIC5jb25jYXQocmlnaHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gcmlnaHQgOiBleGNsdWRlQmFja0J1dHRvbihyaWdodC5jaGlsZHJlbikpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xiYXJDZW50ZXI6IHRvb2xiYXIuX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSxcbiAgICAgIGJhY2tCdXR0b25JY29uOiB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkljb25FbGVtZW50KCksXG4gICAgICBiYWNrQnV0dG9uTGFiZWw6IHRvb2xiYXIuX2dldFRvb2xiYXJCYWNrQnV0dG9uTGFiZWxFbGVtZW50KCksXG4gICAgICBvdGhlcjogb3RoZXIsXG4gICAgICBjb250ZW50OiBwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLFxuICAgICAgYmFja2dyb3VuZDogcGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSxcbiAgICAgIHRvb2xiYXI6IHRvb2xiYXIsXG4gICAgICBib3R0b21Ub29sYmFyOiBwYWdlLl9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCgpXG4gICAgfTtcbiAgfVxuXG4gIF9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xuICAgIGNvbnN0IGVudGVyVG9vbGJhciA9IGVudGVyUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBsZWF2ZVRvb2xiYXIgPSBsZWF2ZVBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCk7XG5cbiAgICBjb25zdCB0b29sYmFycyA9IGVudGVyUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKSAmJiBsZWF2ZVBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCk7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSB1dGlsLmhhc01vZGlmaWVyKGVudGVyVG9vbGJhciwgJ21hdGVyaWFsJykgfHwgdXRpbC5oYXNNb2RpZmllcihsZWF2ZVRvb2xiYXIsICdtYXRlcmlhbCcpO1xuICAgIGNvbnN0IHRyYW5zcGFyZW50ID0gdXRpbC5oYXNNb2RpZmllcihlbnRlclRvb2xiYXIsICd0cmFuc3BhcmVudCcpIHx8IHV0aWwuaGFzTW9kaWZpZXIobGVhdmVUb29sYmFyLCAndHJhbnNwYXJlbnQnKTtcblxuICAgIHJldHVybiB0b29sYmFycyAmJiAhbWF0ZXJpYWwgJiYgIXRyYW5zcGFyZW50O1xuICB9XG5cbiAgX2NhbGN1bGF0ZURlbHRhKGVsZW1lbnQsIGRlY29tcG9zaXRpb24pIHtcbiAgICBsZXQgdGl0bGUsIGxhYmVsO1xuXG4gICAgY29uc3QgcGFnZVJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2JhY2stYnV0dG9uX19sYWJlbCcpKSB7XG4gICAgICBjb25zdCBsYWJlbFJlY3QgPSBkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRpdGxlID0gTWF0aC5yb3VuZChwYWdlUmVjdC53aWR0aCAvIDIgLSBsYWJlbFJlY3Qud2lkdGggLyAyIC0gbGFiZWxSZWN0LmxlZnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZSA9IE1hdGgucm91bmQoKHBhZ2VSZWN0LndpZHRoIC8gMikgKiAwLjYpO1xuICAgIH1cblxuICAgIGlmIChkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25JY29uLmNsYXNzTGlzdC5jb250YWlucygnYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgbGFiZWwgPSBkZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25JY29uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0IC0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4ge3RpdGxlLCBsYWJlbH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgY29udGVudFJlYWR5KGVudGVyUGFnZSwgKCkgPT4ge1xuICAgICAgY29uc3QgZW50ZXJQYWdlVGFyZ2V0ID0gdXRpbC5maW5kVG9vbGJhclBhZ2UoZW50ZXJQYWdlKSB8fCBlbnRlclBhZ2U7XG4gICAgICBjb25zdCBsZWF2ZVBhZ2VUYXJnZXQgPSB1dGlsLmZpbmRUb29sYmFyUGFnZShsZWF2ZVBhZ2UpIHx8IGxlYXZlUGFnZTtcbiAgICAgIGNvbnN0IGVudGVyUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UoZW50ZXJQYWdlVGFyZ2V0KTtcbiAgICAgIGNvbnN0IGxlYXZlUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UobGVhdmVQYWdlVGFyZ2V0KTtcblxuICAgICAgY29uc3QgZGVsdGEgPSB0aGlzLl9jYWxjdWxhdGVEZWx0YShsZWF2ZVBhZ2UsIGVudGVyUGFnZURlY29tcG9zaXRpb24pO1xuXG4gICAgICBjb25zdCBzaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKGVudGVyUGFnZVRhcmdldCwgbGVhdmVQYWdlVGFyZ2V0KTtcblxuICAgICAgaWYgKHNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG5cbiAgICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0pXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEyNSUsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke2RlbHRhLnRpdGxlfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMS4wLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLm90aGVyKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtvcGFjaXR5OiAwfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgICB0aW1pbmc6ICdsaW5lYXInXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICAgICAgYW5pbWl0KFtsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9KSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLSR7ZGVsdGEudGl0bGV9cHgsIDAsIDApYCxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtJyArIGRlbHRhLmxhYmVsICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge29wYWNpdHk6IDB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiAnbGluZWFyJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuXG4gICAgICAgICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBjb25zdCBlbnRlclBhZ2VUYXJnZXQgPSB1dGlsLmZpbmRUb29sYmFyUGFnZShlbnRlclBhZ2UpIHx8IGVudGVyUGFnZTtcbiAgICBjb25zdCBsZWF2ZVBhZ2VUYXJnZXQgPSB1dGlsLmZpbmRUb29sYmFyUGFnZShsZWF2ZVBhZ2UpIHx8IGxlYXZlUGFnZTtcbiAgICBjb25zdCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGVudGVyUGFnZVRhcmdldCk7XG4gICAgY29uc3QgbGVhdmVQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShsZWF2ZVBhZ2VUYXJnZXQpO1xuXG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLl9jYWxjdWxhdGVEZWx0YShsZWF2ZVBhZ2UsIGxlYXZlUGFnZURlY29tcG9zaXRpb24pO1xuXG4gICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2VUYXJnZXQsIGxlYXZlUGFnZVRhcmdldCk7XG5cbiAgICBpZiAoc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KFtlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlcilcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0nICsgZGVsdGEudGl0bGUgKyAncHgsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjAsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucmVzdG9yZVN0eWxlKCksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLScgKyBkZWx0YS5sYWJlbCArICdweCwgMCwgMCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5vdGhlcilcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7b3BhY2l0eTogMX0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogJ2xpbmVhcidcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQoW2xlYXZlUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCgwKVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEyNSUsIDAsIDApJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyArIGRlbHRhLnRpdGxlICsgJ3B4LCAwLCAwKScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC0yNSUsIDBweCwgMHB4KScsXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgICB9KVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwcHgsIDBweCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vaW9zLXNsaWRlLWFuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogU3dpcGUgYW5pbWF0b3IgZm9yIGlPUyBuYXZpZ2F0b3IgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TU3dpcGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgZHVyYXRpb24gPSAwLjE1LCB0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwIH0gPSB7fSkge1xuICAgIHN1cGVyKHtkdXJhdGlvbiwgdGltaW5nLCBkZWxheX0pO1xuICAgIHRoaXMuZHVyYXRpb25SZXN0b3JlID0gMC4xO1xuXG4gICAgdGhpcy5zd2lwZVNoYWRvdyA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyBoZWlnaHQ6IDEwMCU7IHdpZHRoOiAxMnB4OyByaWdodDogMTAwJTsgdG9wOiAwOyBib3R0b206IDA7IHotaW5kZXg6IC0xO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHRyYW5zcGFyZW50IDAsIHJnYmEoMCwwLDAsLjA0KSA0MCUsIHJnYmEoMCwwLDAsLjEyKSA4MCUsIHJnYmEoMCwwLDAsLjE2KSAxMDAlKTtcIj48L2Rpdj5cbiAgICBgKTtcblxuICAgIHRoaXMuaXNEcmFnU3RhcnQgPSB0cnVlO1xuICB9XG5cbiAgX2RyYWdTdGFydFNldHVwKGVudGVyUGFnZSwgbGVhdmVQYWdlKSB7XG4gICAgdGhpcy5pc0RyYWdTdGFydCA9IGZhbHNlO1xuXG4gICAgLy8gQXZvaWQgY29udGVudCBjbGlja3NcbiAgICB0aGlzLnVuYmxvY2sgPSBzdXBlci5ibG9jayhsZWF2ZVBhZ2UpO1xuXG4gICAgLy8gTWFza1xuICAgIGVudGVyUGFnZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgLy8gRGVjb21wb3NpdGlvblxuICAgIHRoaXMudGFyZ2V0ID0ge1xuICAgICAgZW50ZXI6IHV0aWwuZmluZFRvb2xiYXJQYWdlKGVudGVyUGFnZSkgfHwgZW50ZXJQYWdlLFxuICAgICAgbGVhdmU6IHV0aWwuZmluZFRvb2xiYXJQYWdlKGxlYXZlUGFnZSkgfHwgbGVhdmVQYWdlLFxuICAgIH07XG4gICAgdGhpcy5kZWNvbXAgPSB7XG4gICAgICBlbnRlcjogdGhpcy5fZGVjb21wb3NlKHRoaXMudGFyZ2V0LmVudGVyKSxcbiAgICAgIGxlYXZlOiB0aGlzLl9kZWNvbXBvc2UodGhpcy50YXJnZXQubGVhdmUpXG4gICAgfTtcblxuICAgIC8vIEFuaW1hdGlvbiB2YWx1ZXNcbiAgICB0aGlzLmRlbHRhID0gdGhpcy5fY2FsY3VsYXRlRGVsdGEobGVhdmVQYWdlLCB0aGlzLmRlY29tcC5sZWF2ZSk7XG4gICAgdGhpcy5zaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG5cbiAgICAvLyBTaGFkb3cgJiYgc3R5bGVzXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIHRoaXMuc3dpcGVTaGFkb3cuc3R5bGUudG9wID0gdGhpcy5kZWNvbXAubGVhdmUudG9vbGJhci5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgdGhpcy50YXJnZXQubGVhdmUuYXBwZW5kQ2hpbGQodGhpcy5zd2lwZVNoYWRvdyk7XG4gICAgICB0aGlzLl9zYXZlU3R5bGUodGhpcy50YXJnZXQuZW50ZXIsIHRoaXMudGFyZ2V0LmxlYXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVhdmVQYWdlLmFwcGVuZENoaWxkKHRoaXMuc3dpcGVTaGFkb3cpO1xuICAgICAgdGhpcy5fc2F2ZVN0eWxlKGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcbiAgICB9XG4gICAgbGVhdmVQYWdlLmNsYXNzTGlzdC5hZGQoJ292ZXJmbG93LXZpc2libGUnKTtcbiAgICB0aGlzLm92ZXJmbG93RWxlbWVudCA9IGxlYXZlUGFnZTtcbiAgICB0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LmNsYXNzTGlzdC5hZGQoJ2NvbnRlbnQtc3dpcGluZycpO1xuXG4gIH1cblxuICB0cmFuc2xhdGUoZGlzdGFuY2UsIG1heFdpZHRoLCBlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xuICAgIGlmICh0aGlzLmlzRHJhZ1N0YXJ0KSB7XG4gICAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICB0aGlzLl9kcmFnU3RhcnRTZXR1cChlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3dpcGVSYXRpbyA9IChkaXN0YW5jZSAtIG1heFdpZHRoKSAvIG1heFdpZHRoO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcblxuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAvKiBFbnRlciBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5lbnRlci5jb250ZW50LCB0aGlzLmRlY29tcC5lbnRlci5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5lbnRlci5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtzd2lwZVJhdGlvICogMjV9JSwgMCwgMClgLFxuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gKiAxMCAvIDEwMCAvLyAwLjkgLT4gMVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMuZGVsdGEudGl0bGUgKiBzd2lwZVJhdGlvfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAvLyAwIC0+IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAqIDEwIC8gMTAwLCAvLyAwLjkgLT4gMVxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLmxhYmVsICogc3dpcGVSYXRpb31weCwgMCwgMClgXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLm90aGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAvLyAwIC0+IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICAvKiBMZWF2ZSBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LCB0aGlzLmRlY29tcC5sZWF2ZS5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5sZWF2ZS5iYWNrZ3JvdW5kLCB0aGlzLnN3aXBlU2hhZG93XSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtkaXN0YW5jZX1weCwgMHB4LCAwcHgpYFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS50b29sYmFyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7KDEgKyBzd2lwZVJhdGlvKSAqIDEyNX0lLCAwLCAwKWBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8sIC8vIDEgLT4gMFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLnRpdGxlICogKDEgKyBzd2lwZVJhdGlvKX1weCwgMCwgMClgXG4gICAgICAgICAgfSksXG5cblxuICAgICAgICAvKiBPdGhlciAqL1xuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cblxuICAgIH0gZWxzZSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke2Rpc3RhbmNlfXB4LCAwcHgsIDBweClgXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtzd2lwZVJhdGlvICogMjV9JSwgMCwgMClgLFxuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gKiAxMCAvIDEwMCAvLyAwLjkgLT4gMVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLnN3aXBlU2hhZG93KVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAtMSAqIHN3aXBlUmF0aW8gLy8gMSAtPiAwXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmVzdG9yZShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5pc0RyYWdTdGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG5cbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgLyogRW50ZXIgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAuZW50ZXIuY29udGVudCwgdGhpcy5kZWNvbXAuZW50ZXIuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAuZW50ZXIuYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC0yNSUsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLSR7dGhpcy5kZWx0YS50aXRsZX1weCwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9uUmVzdG9yZX1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvblJlc3RvcmV9cyAke3RoaXMudGltaW5nfWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoLSR7dGhpcy5kZWx0YS5sYWJlbH1weCwgMCwgMClgXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uUmVzdG9yZVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci5vdGhlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KSxcblxuICAgICAgICAvKiBMZWF2ZSBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LCB0aGlzLmRlY29tcC5sZWF2ZS5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5sZWF2ZS5iYWNrZ3JvdW5kLCB0aGlzLnN3aXBlU2hhZG93XSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMHB4LCAwcHgpYFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMCwgMClgXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uUmVzdG9yZVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb25SZXN0b3JlfXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9uUmVzdG9yZX1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgIH0pLFxuXG5cbiAgICAgICAgLyogT3RoZXIgKi9cblxuICAgICAgICBhbmltaXQodGhpcy5zd2lwZVNoYWRvdylcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG5cbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoLTI1JSwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblJlc3RvcmVcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0KGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmlzRHJhZ1N0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcblxuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAvKiBFbnRlciBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5lbnRlci5jb250ZW50LCB0aGlzLmRlY29tcC5lbnRlci5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5lbnRlci5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb259cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb259cyAke3RoaXMudGltaW5nfWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMCwgMClgXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLm90aGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgLyogTGVhdmUgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAubGVhdmUuY29udGVudCwgdGhpcy5kZWNvbXAubGVhdmUuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAubGVhdmUuYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDEwMCUsIDBweCwgMHB4KWBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25cbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvblxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgxMjUlLCAwLCAwKWBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25cbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLnRpdGxlfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb259cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb259cyAke3RoaXMudGltaW5nfWBcbiAgICAgICAgICB9KSxcblxuXG4gICAgICAgIC8qIE90aGVyICovXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuc3dpcGVTaGFkb3cpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWF4V2lkdGh9cHgsIDBweCwgMHB4KWBcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb25cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5fcmVzZXQoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBfc2F2ZVN0eWxlKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9zYXZlZFN0eWxlID0gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBzYXZlID0gZWwgPT4gdGhpcy5fc2F2ZWRTdHlsZS5zZXQoZWwsIGVsLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSk7XG4gICAgYXJncy5mb3JFYWNoKHNhdmUpO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5kZWNvbXApLmZvckVhY2gocCA9PiB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmRlY29tcFtwXSkuZm9yRWFjaChrID0+IHtcbiAgICAgICAgKHRoaXMuZGVjb21wW3BdW2tdIGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzLmRlY29tcFtwXVtrXSA6IFt0aGlzLmRlY29tcFtwXVtrXV0pLmZvckVhY2goc2F2ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9yZXN0b3JlU3R5bGUoLi4uYXJncykge1xuICAgIGNvbnN0IHJlc3RvcmUgPSBlbCA9PiB7XG4gICAgICB0aGlzLl9zYXZlZFN0eWxlLmdldChlbCkgPT09IG51bGwgPyBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJykgOiBlbC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5fc2F2ZWRTdHlsZS5nZXQoZWwpKVxuICAgICAgdGhpcy5fc2F2ZWRTdHlsZS5kZWxldGUoZWwpXG4gICAgfTtcbiAgICBhcmdzLmZvckVhY2gocmVzdG9yZSk7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLmRlY29tcCkuZm9yRWFjaChwID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGVjb21wW3BdKS5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAodGhpcy5kZWNvbXBbcF1ba10gaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuZGVjb21wW3BdW2tdIDogW3RoaXMuZGVjb21wW3BdW2tdXSkuZm9yRWFjaChyZXN0b3JlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Jlc2V0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9zYXZlZFN0eWxlICYmIHRoaXMuX3Jlc3RvcmVTdHlsZSguLi5hcmdzKTtcbiAgICB0aGlzLnVuYmxvY2sgJiYgdGhpcy51bmJsb2NrKCk7XG4gICAgdGhpcy5zd2lwZVNoYWRvdy5yZW1vdmUoKTtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIHRoaXMub3ZlcmZsb3dFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ292ZXJmbG93LXZpc2libGUnKTtcbiAgICB0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbnRlbnQtc3dpcGluZycpO1xuICAgIHRoaXMuZGVjb21wID0gdGhpcy50YXJnZXQgPSB0aGlzLm92ZXJmbG93RWxlbWVudCA9IHRoaXMuX3NhdmVkU3R5bGUgPSBudWxsO1xuICAgIHRoaXMuaXNEcmFnU3RhcnQgPSB0cnVlO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0xpZnROYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoYmxhY2ssIHdoaXRlKTtcIj48L2Rpdj5cbiAgICBgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAtMTAlLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIC00M3B4LCAwKScsIC8vIFNtYWxsZXIgdGhhbiBpT1MgdG9vbGJhciAtIGZpeGVzIGdsaXRjaFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIEZhZGUtaW4gc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU0ZhZGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChbZW50ZXJQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBlbnRlclBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICApO1xuXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChbbGVhdmVQYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBsZWF2ZVBhZ2UuX2dldEJhY2tncm91bmRFbGVtZW50KCldKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgei1pbmRleDogMjtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IG9wYWNpdHk6IDA7XCI+PC9kaXY+XG4gICAgYCk7XG4gICAgdGhpcy5ibGFja01hc2tPcGFjaXR5ID0gMC40O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGxlYXZlUGFnZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBsZWF2ZVBhZ2UubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmJsYWNrTWFza09wYWNpdHlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMTAwJSwgMCwgMCknLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKC00NSUsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC53YWl0KDAuMilcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZS5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLmJsYWNrTWFza09wYWNpdHksXG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtNDUlLCAwcHgsIDBweCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMHB4LCAwcHgsIDBweCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDEwMCUsIDBweCwgMHB4KSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4yKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURMaWZ0TmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLCBkZWxheSA9IDAuMDUsIGR1cmF0aW9uID0gMC40fSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcblxuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XCI+PC9kaXY+XG4gICAgYCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IG1hc2tDbGVhciA9IGFuaW1pdCh0aGlzLmJhY2tncm91bmRNYXNrKVxuICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgbWFza0NsZWFyLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDEwMCUsIDApJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAxMDAlLCAwKSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIEZhZGUtaW4gKyBMaWZ0IHNjcmVlbiB0cmFuc2l0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNREZhZGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllcigwLjQsIDAuMCwgMC4yLCAxKScsIHRpbWluZ09uUG9wID0gJ2N1YmljLWJlemllcigwLjQsIDAuMCwgMSwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoe3RpbWluZywgZGVsYXksIGR1cmF0aW9ufSk7XG4gICAgdGhpcy50aW1pbmdPblBvcCA9IHRpbWluZ09uUG9wO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgNDJweCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQoMC4xNSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDM4cHgsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdPblBvcCxcbiAgICAgICAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vbmVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uLy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBTd2lwZVJldmVhbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvc3dpcGUtcmV2ZWFsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3Mtc2xpZGUtYW5pbWF0b3InO1xuaW1wb3J0IElPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3Mtc3dpcGUtYW5pbWF0b3InO1xuaW1wb3J0IElPU0xpZnROYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2lvcy1saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3MtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTURTbGlkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbWQtc2xpZGUtYW5pbWF0b3InO1xuaW1wb3J0IE1ETGlmdE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbWQtbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9tZC1mYWRlLWFuaW1hdG9yJztcbmltcG9ydCBOb25lTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9ub25lLWFuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQge1BhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyLCBpbnN0YW50UGFnZUxvYWRlcn0gZnJvbSAnLi4vLi4vb25zL3BhZ2UtbG9hZGVyJztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZU5hdmlnYXRvckFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ3NsaWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNRFNsaWRlTmF2aWdhdG9yQW5pbWF0b3IgOiBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yLFxuICAnbGlmdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURMaWZ0TmF2aWdhdG9yQW5pbWF0b3IgOiBJT1NMaWZ0TmF2aWdhdG9yQW5pbWF0b3IsXG4gICdmYWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JBbmltYXRvciA6IElPU0ZhZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ3NsaWRlLWlvcyc6IElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdzbGlkZS1tZCc6IE1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ2xpZnQtaW9zJzogSU9TTGlmdE5hdmlnYXRvckFuaW1hdG9yLFxuICAnbGlmdC1tZCc6IE1ETGlmdE5hdmlnYXRvckFuaW1hdG9yLFxuICAnZmFkZS1pb3MnOiBJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdub25lJzogTm9uZU5hdmlnYXRvckFuaW1hdG9yXG59O1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbmF2aWdhdG9yU2lkZUVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KG5hdmlnYXRvckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbmF2aWdhdG9yXG4gKiBAY2F0ZWdvcnkgbmF2aWdhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBIGNvbXBvbmVudCB0aGF0IHByb3ZpZGVzIHBhZ2Ugc3RhY2sgbWFuYWdlbWVudCBhbmQgbmF2aWdhdGlvbi4gU3RhY2sgbmF2aWdhdGlvbiBpcyB0aGUgbW9zdCBjb21tb24gbmF2aWdhdGlvbiBwYXR0ZXJuIGZvciBtb2JpbGUgYXBwcy5cbiAqXG4gKiAgICAgV2hlbiBhIHBhZ2UgaXMgcHVzaGVkIG9uIHRvcCBvZiB0aGUgc3RhY2sgaXQgaXMgZGlzcGxheWVkIHdpdGggYSB0cmFuc2l0aW9uIGFuaW1hdGlvbi4gV2hlbiB0aGUgdXNlciByZXR1cm5zIHRvIHRoZSBwcmV2aW91cyBwYWdlIHRoZSB0b3AgcGFnZSB3aWxsIGJlIHBvcHBlZCBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIGFuZCBoaWRkZW4gd2l0aCBhbiBvcHBvc2l0ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbi5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB5cmh0dlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL25hdmlnYXRvclxuICogQGd1aWRlIGxpZmVjeWNsZS5odG1sI2V2ZW50c1xuICogICBbZW5dT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2VuXVxuICogICBbamFdT3ZlcnZpZXcgb2YgcGFnZSBldmVudHNbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRvb2xiYXIgb24gdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGNvbXBvbmVudCBsZXRzIHRoZSB1c2VyIHJldHVybiB0byB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLW5hdmlnYXRvciBpZD1cIm5hdmlnYXRvclwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgPG9ucy10b29sYmFyPlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBUaXRsZVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgPC9vbnMtdG9vbGJhcj5cbiAqICAgICA8cD5cbiAqICAgICAgIDxvbnMtYnV0dG9uXG4gKiAgICAgICAgIG9uY2xpY2s9XCJkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmF2aWdhdG9yJykucHVzaFBhZ2UoJ3BhZ2UuaHRtbCcpXCI+XG4gKiAgICAgICAgIFB1c2ggcGFnZVxuICogICAgICAgPC9vbnMtYnV0dG9uPlxuICogICAgIDwvcD5cbiAqICAgPC9vbnMtcGFnZT5cbiAqIDwvb25zLW5hdmlnYXRvcj5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwicGFnZS5odG1sXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICA8b25zLXRvb2xiYXI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgICAgIDwvZGl2PlxuICogICAgICAgPGRpdiBjbGFzcz1cImNlbnRlclwiPlxuICogICAgICAgICBBbm90aGVyIHBhZ2VcbiAqICAgICAgIDwvZGl2PlxuICogICAgIDwvb25zLXRvb2xiYXI+XG4gKiAgIDwvb25zLXBhZ2U+XG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyc3QgcGFnZSB0byBzaG93IHdoZW4gbmF2aWdhdG9yIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gICAqICAgW2phXeODiuODk+OCsuODvOOCv+ODvOOBjOWIneacn+WMluOBleOCjOOBn+aZguOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUVuYWJsZSBpT1MgXCJzd2lwZSB0byBwb3BcIiBmZWF0dXJlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRhcmdldC13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAyMHB4XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgd2lkdGggb2Ygc3dpcGVhYmxlIGFyZWEgY2FsY3VsYXRlZCBmcm9tIHRoZSBlZGdlIChpbiBwaXhlbHMpLiBVc2UgdGhpcyB0byBlbmFibGUgc3dpcGUgb25seSB3aGVuIHRoZSBmaW5nZXIgdG91Y2ggb24gdGhlIHNjcmVlbiBlZGdlLlsvZW5dXG4gICAqICAgW2phXeOCueODr+OCpOODl+OBruWIpOWumumgmOWfn+OCkuODlOOCr+OCu+ODq+WNmOS9jeOBp+aMh+WumuOBl+OBvuOBmeOAgueUu+mdouOBruerr+OBi+OCieaMh+WumuOBl+OBn+i3nembouOBq+mBlOOBmeOCi+OBqOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRocmVzaG9sZFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBob3cgbXVjaCB0aGUgcGFnZSBuZWVkcyB0byBiZSBzd2lwZWQgYmVmb3JlIHBvcHBpbmcuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwdXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcHVzaC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwdXNo5Yem55CG44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwb3BcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY3VycmVudFBhZ2VcbiAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHBvcC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwYWdl44GucG9w44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cHVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC5LqG44GX44Gm44GL44KJ55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cbiAgICogICBbamFdcHVzaOOBleOCjOOBn3BhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubGVhdmVQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ku6XliY3jga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cG9wXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOBpuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOe1guOCj+OBo+OBn+W+jOOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZW50ZXJQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgbmV4dCBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpuihqOekuuOBleOCjOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpua2iOOBiOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIGdldCBhbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdG9yRmFjdG9yeTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbiAgICB0aGlzLl9wYWdlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlTG9hZGVyXG4gICAqIEB0eXBlIHtQYWdlTG9hZGVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZUxvYWRlciBpbnN0YW5jZS4gSXQgY2FuIGJlIG92ZXJyaWRlbiB0byBjaGFuZ2UgdGhlIHdheSBwYWdlcyBhcmUgbG9hZGVkIGJ5IHRoaXMgZWxlbWVudC4gVXNlZnVsIGZvciBsaWIgZGV2ZWxvcGVycy5bL2VuXVxuICAgKiAgIFtqYV1QYWdlTG9hZGVy44Kk44Oz44K544K/44Oz44K544KS5qC857SN44GX44Gm44GE44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIocGFnZUxvYWRlcikge1xuICAgIGlmICghKHBhZ2VMb2FkZXIgaW5zdGFuY2VvZiBQYWdlTG9hZGVyKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFBhZ2VMb2FkZXIuJyk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyO1xuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIHBhZ2UgdG8gYmUgbG9hZGVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gVGhpcyB2YWx1ZSB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhlIGBwYWdlYCBhdHRyaWJ1dGUuIFVzZWZ1bCBmb3IgbGliIGRldmVsb3BlcnMuWy9lbl1cbiAgICogICBbamFd5Yid5pyf5YyW5pmC44Gr6Kqt44G/6L6844KA44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCYHBhZ2Vg5bGe5oCn44Gn5oyH5a6a44GX44Gf5YCk44KI44KK44KCYHBhZ2Vg44OX44Ot44OR44OG44Kj44Gr5oyH5a6a44GX44Gf5YCk44KS5YSq5YWI44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5vbkRldmljZUJhY2tCdXR0b24gPSB0aGlzLl9vbkRldmljZUJhY2tCdXR0b24uYmluZCh0aGlzKTtcblxuICAgIGlmICghcGxhdGZvcm0uaXNBbmRyb2lkKCkgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpID09PSAnZm9yY2UnKSB7XG4gICAgICB0aGlzLl9zd2lwZUFuaW1hdG9yID0gbmV3IElPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IoKTtcbiAgICAgIGNvbnN0IHB1c2hBbmltYXRpb24gPSB7IGR1cmF0aW9uOiB0aGlzLl9zd2lwZUFuaW1hdG9yLmR1cmF0aW9uLCB0aW1pbmc6IHRoaXMuX3N3aXBlQW5pbWF0b3IudGltaW5nIH07XG4gICAgICBjb25zdCBwb3BBbmltYXRpb24gPSB7IGR1cmF0aW9uOiB0aGlzLl9zd2lwZUFuaW1hdG9yLmR1cmF0aW9uUmVzdG9yZSwgdGltaW5nOiB0aGlzLl9zd2lwZUFuaW1hdG9yLnRpbWluZyB9O1xuXG4gICAgICB0aGlzLl9zd2lwZSA9IG5ldyBTd2lwZVJldmVhbCh7XG4gICAgICAgIGVsZW1lbnQ6IHRoaXMsXG4gICAgICAgIHN3aXBlTWF4OiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKDEsIHB1c2hBbmltYXRpb24pO1xuICAgICAgICAgIHRoaXNbdGhpcy5zd2lwZU1heCA/ICdzd2lwZU1heCcgOiAncG9wUGFnZSddKHsgYW5pbWF0b3I6IHRoaXMuX3N3aXBlQW5pbWF0b3IgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN3aXBlTWlkOiAoZGlzdGFuY2UsIHdpZHRoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKGRpc3RhbmNlL3dpZHRoKTtcbiAgICAgICAgICB0aGlzLl9zd2lwZUFuaW1hdG9yLnRyYW5zbGF0ZShkaXN0YW5jZSwgd2lkdGgsIHRoaXMudG9wUGFnZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLCB0aGlzLnRvcFBhZ2UpO1xuICAgICAgICB9LFxuICAgICAgICBzd2lwZU1pbjogKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSgwLCBwb3BBbmltYXRpb24pO1xuICAgICAgICAgIHRoaXMuX3N3aXBlQW5pbWF0b3IucmVzdG9yZSh0aGlzLnRvcFBhZ2UucHJldmlvdXNFbGVtZW50U2libGluZywgdGhpcy50b3BQYWdlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGhyZXNob2xkOiAoKSA9PiBNYXRoLm1heCgwLjIsIHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlLXRocmVzaG9sZCcpKSB8fCAwKSxcbiAgICAgICAgaWdub3JlU3dpcGU6IChldmVudCwgZGlzdGFuY2UpID0+IHtcbiAgICAgICAgICBpZiAoL29ucy1iYWNrLWJ1dHRvbi9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpIHx8IHV0aWwuZmluZFBhcmVudChldmVudC50YXJnZXQsICdvbnMtYmFjay1idXR0b24nLCBwID0+IC9vbnMtcGFnZS9pLnRlc3QocC50YWdOYW1lKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhcmVhID0gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlLXRhcmdldC13aWR0aCcpIHx8IDI1LCAxMCk7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uICE9PSAgJ3JpZ2h0JyB8fCBhcmVhIDw9IGRpc3RhbmNlIHx8IHRoaXMuX2lzUnVubmluZyB8fCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA8PSAxO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ3N3aXBlYWJsZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICAgIHRoaXMubG9hZGVkID0gZGVmZXJyZWQucHJvbWlzZTtcblxuICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGNvbnN0IHNob3cgPSAhdXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCh0aGlzKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IGFuaW1hdGlvbjogJ25vbmUnLCBzaG93IH07XG5cbiAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgICAgdGhpcy5wdXNoUGFnZSh0aGlzLl9nZXRQYWdlVGFyZ2V0KCksIG9wdGlvbnMpLnRoZW4oKCkgPT4gZGVmZXJyZWQucmVzb2x2ZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnBhZ2VzW2ldLm5vZGVOYW1lICE9PSAnT05TLVBBR0UnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjaGlsZHJlbiBvZiA8b25zLW5hdmlnYXRvcj4gbmVlZCB0byBiZSBvZiB0eXBlIDxvbnMtcGFnZT4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50b3BQYWdlKSB7XG4gICAgICAgICAgY29udGVudFJlYWR5KHRoaXMudG9wUGFnZSwgKCkgPT5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgIHNob3cgJiYgdGhpcy50b3BQYWdlLl9zaG93KCk7XG4gICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxhc3RQYWdlQmFja0J1dHRvbigpO1xuICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFBhZ2UodGhpcy5fZ2V0UGFnZVRhcmdldCgpLCBvcHRpb25zKS50aGVuKCgpID0+IGRlZmVycmVkLnJlc29sdmUoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogTmF2aWdhdG9yQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTmF2aWdhdG9yQW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgdGhpcy5fc3dpcGUgJiYgdGhpcy5fc3dpcGUuZGlzcG9zZSgpO1xuICAgIHRoaXMuX3N3aXBlID0gdGhpcy5fc3dpcGVBbmltYXRvciA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydhbmltYXRpb24nLCAnc3dpcGVhYmxlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaChuYW1lKSB7XG4gICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzd2lwZWFibGUnOlxuICAgICAgICB0aGlzLl9zd2lwZSAmJiB0aGlzLl9zd2lwZS51cGRhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcG9wUGFnZVxuICAgKiBAc2lnbmF0dXJlIHBvcFBhZ2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZGF0YV1cbiAgICogICBbZW5dQ3VzdG9tIGRhdGEgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXZlYWxlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaYjuOCieOBi+OBq+OBl+OBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUG9wcyB0aGUgY3VycmVudCBwYWdlIGZyb20gdGhlIHBhZ2Ugc3RhY2suIFRoZSBwcmV2aW91cyBwYWdlIHdpbGwgYmUgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOihqOekuuS4reOBruODmuODvOOCuOOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBi+OCieWPluOCiumZpOOBjeOBvuOBmeOAguS4gOOBpOWJjeOBruODmuODvOOCuOOBq+aIu+OCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuICBwb3BQYWdlKG9wdGlvbnMgPSB7fSkge1xuICAgICh7b3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMobnVsbCwgb3B0aW9ucykpO1xuXG4gICAgY29uc3QgcG9wVXBkYXRlID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5fcG9wUGFnZShvcHRpb25zLCBwb3BVcGRhdGUpO1xuICB9XG5cbiAgX3BvcFBhZ2Uob3B0aW9ucywgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3BvcFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ29ucy1uYXZpZ2F0b3JcXCdzIHBhZ2Ugc3RhY2sgaXMgZW1wdHkuJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQb3BFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXBvcCBldmVudC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLnBhZ2VzLmxlbmd0aDtcblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLnBhZ2VzW2xlbmd0aCAtIDJdLnVwZGF0ZUJhY2tCdXR0b24oKGxlbmd0aCAtIDIpID4gMCk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBsZWF2ZVBhZ2UgPSB0aGlzLnBhZ2VzW2xlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgZW50ZXJQYWdlID0gdGhpcy5wYWdlc1tsZW5ndGggLSAyXTtcblxuICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbiB8fCAobGVhdmVQYWdlLnB1c2hlZE9wdGlvbnMgPyBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucy5hbmltYXRpb24gOiB1bmRlZmluZWQpO1xuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zID0gdXRpbC5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucyA/IGxlYXZlUGFnZS5wdXNoZWRPcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgOiB7fSxcbiAgICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9XG4gICAgICApO1xuXG4gICAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAgIGVudGVyUGFnZS5kYXRhID0gdXRpbC5leHRlbmQoe30sIGVudGVyUGFnZS5kYXRhIHx8IHt9LCBvcHRpb25zLmRhdGEgfHwge30pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgdXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBlbnRlclBhZ2UuX3Nob3coKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3Rwb3AnLCB7bGVhdmVQYWdlLCBlbnRlclBhZ2UsIG5hdmlnYXRvcjogdGhpc30pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xuICAgICAgY29uc3QgYW5pbWF0b3IgPSBvcHRpb25zLmFuaW1hdG9yIHx8IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcbiAgICAgIGFuaW1hdG9yLnBvcCh0aGlzLnBhZ2VzW2xlbmd0aCAtIDJdLCB0aGlzLnBhZ2VzW2xlbmd0aCAtIDFdLCBjYWxsYmFjayk7XG4gICAgfSkuY2F0Y2goKCkgPT4gdGhpcy5faXNSdW5uaW5nID0gZmFsc2UpO1xuICB9XG5cblxuICAvKipcbiAgICogQG1ldGhvZCBwdXNoUGFnZVxuICAgKiBAc2lnbmF0dXJlIHB1c2hQYWdlKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYSBIVE1MIGRvY3VtZW50IG9yIGEgdGVtcGxhdGUgZGVmaW5lZCB3aXRoIHRoZSBgPG9ucy10ZW1wbGF0ZT5gIHRhZy5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CB44KC44GX44GP44Gvb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBhZ2VdXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBPbmx5IG5lY2Vzc2FyeSBpZiBgcGFnZWAgcGFyYW1ldGVyIGlzIG51bGwgb3IgdW5kZWZpbmVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlSFRNTF1cbiAgICogICBbZW5dSFRNTCBjb2RlIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBhcyBhIG5ldyBwYWdlLiBPdmVyd3JpdGVzIGBwYWdlYCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAgWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXXB1c2hQYWdlKCnjgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZGF0YV1cbiAgICogICBbZW5dQ3VzdG9tIGRhdGEgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBwdXNoZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ov73liqDjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVB1c2hlcyB0aGUgc3BlY2lmaWVkIHBhZ2UgaW50byB0aGUgc3RhY2suWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuaWsOOBl+OBhOODmuODvOOCuOOCueOCv+ODg+OCr+OBq+i/veWKoOOBl+OBvuOBmeOAguaWsOOBl+OBhOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBwdXNoUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGNvbnN0IHByZXBhcmUgPSBwYWdlRWxlbWVudCA9PiB7XG4gICAgICB0aGlzLl92ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgICB0aGlzLl9wYWdlTWFwLnNldChwYWdlRWxlbWVudCwgcGFnZSk7XG4gICAgICBwYWdlRWxlbWVudCA9IHV0aWwuZXh0ZW5kKHBhZ2VFbGVtZW50LCB7XG4gICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YVxuICAgICAgfSk7XG4gICAgICBwYWdlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLnBhZ2VIVE1MKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGluc3RhbnRQYWdlTG9hZGVyLmxvYWQoe3BhZ2U6IG9wdGlvbnMucGFnZUhUTUwsIHBhcmVudDogdGhpcywgcGFyYW1zOiBvcHRpb25zLmRhdGF9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgICAgcHJlcGFyZShwYWdlRWxlbWVudCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucywgKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpcywgcGFyYW1zOiBvcHRpb25zLmRhdGF9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIHByZXBhcmUocGFnZUVsZW1lbnQpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cblxuICBfcHVzaFBhZ2Uob3B0aW9ucyA9IHt9LCB1cGRhdGUgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKSkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncHVzaFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0UHJlUHVzaEV2ZW50KCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQ2FuY2VsZWQgaW4gcHJlcHVzaCBldmVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpO1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCB7YW5pbWF0aW9uT3B0aW9uc30sIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdXBkYXRlKCkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBwYWdlTGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICAgIGNvbnN0IGVudGVyUGFnZSAgPSB0aGlzLnBhZ2VzW3BhZ2VMZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGxlYXZlUGFnZSA9IG9wdGlvbnMubGVhdmVQYWdlIHx8IHRoaXMucGFnZXNbcGFnZUxlbmd0aCAtIDJdO1xuXG4gICAgICBpZiAoZW50ZXJQYWdlLm5vZGVOYW1lICE9PSAnT05TLVBBR0UnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBlbGVtZW50cyBvZiB0eXBlIDxvbnMtcGFnZT4gY2FuIGJlIHB1c2hlZCB0byB0aGUgbmF2aWdhdG9yJyk7XG4gICAgICB9XG5cbiAgICAgIGVudGVyUGFnZS51cGRhdGVCYWNrQnV0dG9uKHBhZ2VMZW5ndGggPiAob3B0aW9ucy5fcmVwbGFjZVBhZ2UgPyAyIDogMSkpO1xuXG4gICAgICBlbnRlclBhZ2UucHVzaGVkT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UucHVzaGVkT3B0aW9ucyB8fCB7fSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICBlbnRlclBhZ2UuZGF0YSA9IHV0aWwuZXh0ZW5kKHt9LCBlbnRlclBhZ2UuZGF0YSB8fCB7fSwgb3B0aW9ucy5kYXRhIHx8IHt9KTtcbiAgICAgIGVudGVyUGFnZS51bmxvYWQgPSBlbnRlclBhZ2UudW5sb2FkIHx8IG9wdGlvbnMudW5sb2FkO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICBvcHRpb25zLnNob3cgIT09IGZhbHNlICYmIHNldEltbWVkaWF0ZSgoKSA9PiBlbnRlclBhZ2UuX3Nob3coKSk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cHVzaCcsIHtsZWF2ZVBhZ2UsIGVudGVyUGFnZSwgbmF2aWdhdG9yOiB0aGlzfSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZW50ZXJQYWdlLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgaWYgKGxlYXZlUGFnZSkge1xuICAgICAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xuICAgICAgICAgIGFuaW1hdG9yLnB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGRvbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVwbGFjZVBhZ2VcbiAgICogQHNpZ25hdHVyZSByZXBsYWNlUGFnZShwYWdlLCBbb3B0aW9uc10pXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVwbGFjZXMgdGhlIGN1cnJlbnQgdG9wIHBhZ2Ugd2l0aCB0aGUgc3BlY2lmaWVkIG9uZS4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjooajnpLrkuK3jga7jg5rjg7zjgrjjgpLjgpLmjIflrprjgZfjgZ/jg5rjg7zjgrjjgavnva7jgY3mj5vjgYjjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcmVwbGFjZVBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UocGFnZSwgb3B0aW9ucylcbiAgICAgIC50aGVuKHJlc29sdmVkVmFsdWUgPT4ge1xuICAgICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDJdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc29sdmVkVmFsdWUpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpbnNlcnRQYWdlXG4gICAqIEBzaWduYXR1cmUgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dVGhlIGluZGV4IHdoZXJlIGl0IHNob3VsZCBiZSBpbnNlcnRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jg4Pjgq/jgavmjL/lhaXjgZnjgovkvY3nva7jga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBpbnNlcnRlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSW5zZXJ0IHRoZSBzcGVjaWZpZWQgcGFnZSBpbnRvIHRoZSBzdGFjayB3aXRoIGF0IGEgcG9zaXRpb24gZGVmaW5lZCBieSB0aGUgYGluZGV4YCBhcmd1bWVudC4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9wYWdl44KS44Oa44O844K444K544K/44OD44Kv44GuaW5kZXjjgafmjIflrprjgZfjgZ/kvY3nva7jgavov73liqDjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaW5zZXJ0UGFnZShpbmRleCwgcGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG4gICAgaW5kZXggPSB0aGlzLl9ub3JtYWxpemVJbmRleChpbmRleCk7XG5cbiAgICBpZiAoaW5kZXggPj0gdGhpcy5wYWdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHBhZ2UgPSB0eXBlb2Ygb3B0aW9ucy5wYWdlSFRNTCA9PT0gJ3N0cmluZycgPyBvcHRpb25zLnBhZ2VIVE1MIDogcGFnZTtcbiAgICBjb25zdCBsb2FkZXIgPSB0eXBlb2Ygb3B0aW9ucy5wYWdlSFRNTCA9PT0gJ3N0cmluZycgPyBpbnN0YW50UGFnZUxvYWRlciA6IHRoaXMuX3BhZ2VMb2FkZXI7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICB0aGlzLl92ZXJpZnlQYWdlRWxlbWVudChwYWdlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3BhZ2VNYXAuc2V0KHBhZ2VFbGVtZW50LCBwYWdlKTtcbiAgICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSxcbiAgICAgICAgICBwdXNoZWRPcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpLFxuICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKHBhZ2VFbGVtZW50LCB0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgIHRoaXMudG9wUGFnZS51cGRhdGVCYWNrQnV0dG9uKHRydWUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHBhZ2VFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlKHRoaXMucGFnZXNbaW5kZXhdKTtcbiAgICAgICAgfSwgMTAwMCAvIDYwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcmVtb3ZlUGFnZVxuICAgKiBAc2lnbmF0dXJlIHJlbW92ZVBhZ2UoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgcmVtb3ZlZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jg4Pjgq/jgYvjgonliYrpmaTjgZnjgovjg5rjg7zjgrjjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSByZXZlYWxlZCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeWJiumZpOOBq+OCiOOBo+OBpuihqOekuuOBleOCjOOBn+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVtb3ZlIHRoZSBzcGVjaWZpZWQgcGFnZSBhdCBhIHBvc2l0aW9uIGluIHRoZSBzdGFjayBkZWZpbmVkIGJ5IHRoZSBgaW5kZXhgIGFyZ3VtZW50LiBFeHRlbmRzIGBwb3BQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Kk44Oz44OH44OD44Kv44K544Gr44GC44KL44Oa44O844K444KS5YmK6Zmk44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlbW92ZVBhZ2UoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgoaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4IDwgdGhpcy5wYWdlcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IGxlYXZlUGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xuICAgICAgICBjb25zdCBlbnRlclBhZ2UgPSB0aGlzLnRvcFBhZ2U7XG5cbiAgICAgICAgdGhpcy5fcGFnZU1hcC5kZWxldGUobGVhdmVQYWdlKTtcbiAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQobGVhdmVQYWdlKTtcbiAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID09PSAxKSB7IC8vIGVkZ2UgY2FzZVxuICAgICAgICAgIHRoaXMudG9wUGFnZS51cGRhdGVCYWNrQnV0dG9uKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoZW50ZXJQYWdlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wb3BQYWdlKG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlc2V0VG9QYWdlXG4gICAqIEBzaWduYXR1cmUgcmVzZXRUb1BhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgdG9wIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5paw44GX44GE44OI44OD44OX44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbGVhcnMgcGFnZSBzdGFjayBhbmQgYWRkcyB0aGUgc3BlY2lmaWVkIHBhZ2UgdG8gdGhlIHN0YWNrLiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOCueOCv+ODg+OCr+OCkuODquOCu+ODg+ODiOOBl+OAgeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZXNldFRvUGFnZShwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICAoe3BhZ2UsIG9wdGlvbnN9ID0gdGhpcy5fcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMpKTtcblxuICAgIGlmICghb3B0aW9ucy5hbmltYXRvciAmJiAhb3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcblxuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICB3aGlsZSAodGhpcy5wYWdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhZ2VzWzBdLnVwZGF0ZUJhY2tCdXR0b24oZmFsc2UpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRpb25zLnBhZ2UgJiYgIW9wdGlvbnMucGFnZUhUTUwgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlID0gdGhpcy5fZ2V0UGFnZVRhcmdldCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnJpbmdQYWdlVG9wXG4gICAqIEBzaWduYXR1cmUgYnJpbmdQYWdlVG9wKGl0ZW0sIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpdGVtXG4gICAqICAgW2VuXVBhZ2UgVVJMIG9yIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UgaW4gbmF2aWdhdG9yJ3Mgc3RhY2suWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GuVVJM44GL44KC44GX44GP44Gvb25zLW5hdmlnYXRvcuOBruODmuODvOOCuOOCueOCv+ODg+OCr+OBruOCpOODs+ODh+ODg+OCr+OCueWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg4jjg4Pjg5fjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJyaW5ncyB0aGUgZ2l2ZW4gcGFnZSB0byB0aGUgdG9wIG9mIHRoZSBwYWdlIHN0YWNrIGlmIGl0IGFscmVhZHkgZXhpc3RzIG9yIHB1c2hlcyBpdCBpbnRvIHRoZSBzdGFjayBpZiBkb2Vzbid0LiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBruS4gOeVquS4iuOBq+enu+WLleOBl+OBvuOBmeOAguOCguOBl+aMh+WumuOBl+OBn+ODmuODvOOCuOOBjOeEoeOBi+OBo+OBn+WgtOWQiOaWsOOBl+OBj3B1c2jjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgYnJpbmdQYWdlVG9wKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChbJ251bWJlcicsICdzdHJpbmcnXS5pbmRleE9mKHR5cGVvZiBpdGVtKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHBhZ2UgbmFtZSBvciB0aGUgaW5kZXggb2YgYW4gZXhpc3RpbmcgcGFnZS4gWW91IHN1cHBsaWVkICcgKyBpdGVtKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgPyB0aGlzLl9ub3JtYWxpemVJbmRleChpdGVtKSA6IHRoaXMuX2xhc3RJbmRleE9mUGFnZShpdGVtKTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlc1tpbmRleF07XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShpdGVtLCBvcHRpb25zKTtcbiAgICB9XG4gICAgKHtvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoaW5kZXggPT09IHRoaXMucGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWdlKTtcbiAgICB9XG4gICAgaWYgKCFwYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmaW5kIGl0ZW0gJyArIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3B1c2hQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2VtaXRQcmVQdXNoRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwdXNoIGV2ZW50LicpO1xuICAgIH1cblxuICAgIHBhZ2Uuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIHBhZ2UucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChwYWdlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaFBhZ2Uob3B0aW9ucyk7XG4gIH1cblxuICBfcHJlcGFyZVBhZ2VBbmRPcHRpb25zKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBZb3Ugc3VwcGxpZWQgJyArIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICgocGFnZSA9PT0gbnVsbCB8fCBwYWdlID09PSB1bmRlZmluZWQpICYmIG9wdGlvbnMucGFnZSkge1xuICAgICAgcGFnZSA9IG9wdGlvbnMucGFnZTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucywge3BhZ2V9KTtcblxuICAgIHJldHVybiB7cGFnZSwgb3B0aW9uc307XG4gIH1cblxuICBfdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnBhZ2VzW2luZGV4XS51cGRhdGVCYWNrQnV0dG9uKGluZGV4ID4gMCk7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZUluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IE1hdGguYWJzKHRoaXMucGFnZXMubGVuZ3RoICsgaW5kZXgpICUgdGhpcy5wYWdlcy5sZW5ndGg7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wb3BQYWdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG5cbiAgX2xhc3RJbmRleE9mUGFnZShwYWdlTmFtZSkge1xuICAgIGxldCBpbmRleDtcbiAgICBmb3IgKGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhZ2VNYXAuaGFzKHRoaXMucGFnZXNbaW5kZXhdKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignVGhpcyBpcyBidWcuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlTmFtZSA9PT0gdGhpcy5fcGFnZU1hcC5nZXQodGhpcy5wYWdlc1tpbmRleF0pKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBfZW1pdFByZUV2ZW50KG5hbWUsIGRhdGEgPSB7fSkge1xuICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3ByZScgKyBuYW1lLCB1dGlsLmV4dGVuZCh7XG4gICAgICBuYXZpZ2F0b3I6IHRoaXMsXG4gICAgICBjdXJyZW50UGFnZTogdGhpcy5wYWdlc1t0aGlzLnBhZ2VzLmxlbmd0aCAtIDFdLFxuICAgICAgY2FuY2VsOiAoKSA9PiBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgIH0sIGRhdGEpKTtcblxuICAgIHJldHVybiBpc0NhbmNlbGVkO1xuICB9XG5cbiAgX2VtaXRQcmVQdXNoRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRQcmVFdmVudCgncHVzaCcpO1xuICB9XG5cbiAgX2VtaXRQcmVQb3BFdmVudCgpIHtcbiAgICBjb25zdCBsID0gdGhpcy5wYWdlcy5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXRQcmVFdmVudCgncG9wJywge1xuICAgICAgbGVhdmVQYWdlOiB0aGlzLnBhZ2VzW2wgLSAxXSxcbiAgICAgIGVudGVyUGFnZTogdGhpcy5wYWdlc1tsIC0gMl1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRPRE86IOabuOOBjeebtOOBmVxuICBfY3JlYXRlUGFnZUVsZW1lbnQodGVtcGxhdGVIVE1MKSB7XG4gICAgY29uc3QgcGFnZUVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwodGVtcGxhdGVIVE1MKSk7XG4gICAgdGhpcy5fdmVyaWZ5UGFnZUVsZW1lbnQocGFnZUVsZW1lbnQpO1xuICAgIHJldHVybiBwYWdlRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIF92ZXJpZnlQYWdlRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1wYWdlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBzdXBwbHkgYW4gXCJvbnMtcGFnZVwiIGVsZW1lbnQgdG8gXCJvbnMtbmF2aWdhdG9yXCIuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHRvcFBhZ2VcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgdG9wIHBhZ2UgZWxlbWVudC4gVXNlIHRoaXMgbWV0aG9kIHRvIGFjY2VzcyBvcHRpb25zIHBhc3NlZCBieSBgcHVzaFBhZ2UoKWAtbGlrZSBtZXRob2RzLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODmuODvOOCuOOCkuWPluW+l+OBl+OBvuOBmeOAgnB1c2hQYWdlKCnjgoRyZXNldFRvUGFnZSgp44Oh44K944OD44OJ44Gu5byV5pWw44KS5Y+W5b6X44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCB0b3BQYWdlKCkge1xuICAgIGxldCBsYXN0ID0gdGhpcy5sYXN0RWxlbWVudENoaWxkO1xuICAgIHdoaWxlIChsYXN0ICYmIGxhc3QudGFnTmFtZSAhPT0gJ09OUy1QQUdFJykgeyBsYXN0ID0gbGFzdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nOyB9XG4gICAgcmV0dXJuIGxhc3Q7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VzXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db3B5IG9mIHRoZSBuYXZpZ2F0b3IncyBwYWdlIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZXMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pXG4gICAgICAuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudC50YWdOYW1lID09PSAnT05TLVBBR0UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25Td2lwZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBzbGlkZXMgdGhlIG5hdmlnYXRvciAoc3dpcGUtdG8tcG9wKS4gSXQgZ2V0cyBhIGRlY2ltYWwgcmF0aW8gKDAtMSkgYW5kIGFuIGFuaW1hdGlvbk9wdGlvbnMgb2JqZWN0IGFzIGFyZ3VtZW50cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IG9uU3dpcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uU3dpcGU7XG4gIH1cblxuICBzZXQgb25Td2lwZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdvblN3aXBlJyBtdXN0IGJlIGEgZnVuY3Rpb24uYClcbiAgICB9XG4gICAgdGhpcy5fb25Td2lwZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1EZWZhdWx0IG9wdGlvbnMgb2JqZWN0LiBBdHRyaWJ1dGVzIGhhdmUgcHJpb3JpdHkgb3ZlciB0aGlzIHByb3BlcnR5LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuY2FsbGJhY2tcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9iamVjdCkge1xuICAgIHRoaXMuX29wdGlvbnMgPSBvYmplY3Q7XG4gIH1cblxuICBzZXQgX2lzUnVubmluZyh2YWx1ZSkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycsIHZhbHVlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gIH1cbiAgZ2V0IF9pc1J1bm5pbmcoKSB7XG4gICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnX2lzLXJ1bm5pbmcnKSk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICB0aGlzLmxvYWRlZC50aGVuKCgpID0+IHRoaXMudG9wUGFnZSAmJiB0aGlzLnRvcFBhZ2UuX3Nob3coKSlcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHRoaXMudG9wUGFnZSAmJiB0aGlzLnRvcFBhZ2UuX2hpZGUoKVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMucGFnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgTmF2aWdhdG9yQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgTmF2aWdhdG9yRWxlbWVudC5OYXZpZ2F0b3JBbmltYXRvcicpO1xuICAgIH1cblxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBOYXZpZ2F0b3JBbmltYXRvcigpIHtcbiAgICByZXR1cm4gTmF2aWdhdG9yQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwcmVwdXNoJywgJ3Bvc3RwdXNoJywgJ3ByZXBvcCcsICdwb3N0cG9wJ107XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuTmF2aWdhdG9yID0gTmF2aWdhdG9yRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLW5hdmlnYXRvcicsIE5hdmlnYXRvckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0b29sYmFyJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3Rvb2xiYXItLSonLFxuICAnLnRvb2xiYXJfX2xlZnQnOiAndG9vbGJhci0tKl9fbGVmdCcsXG4gICcudG9vbGJhcl9fY2VudGVyJzogJ3Rvb2xiYXItLSpfX2NlbnRlcicsXG4gICcudG9vbGJhcl9fcmlnaHQnOiAndG9vbGJhci0tKl9fcmlnaHQnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10b29sYmFyXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gdG9vbGJhci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dVHJhbnNwYXJlbnQgdG9vbGJhci5bL2VuXVxuICogICBbamFd6YCP5piO44Gq6IOM5pmv44KS5oyB44Gk44OE44O844Or44OQ44O844KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBjb3Zlci1jb250ZW50XG4gKiAgIFtlbl1EaXNwbGF5cyB0aGUgdG9vbGJhciBvbiB0b3Agb2YgdGhlIHBhZ2UncyBjb250ZW50LiBTaG91bGQgYmUgY29tYmluZWQgd2l0aCBgdHJhbnNwYXJlbnRgIG1vZGlmaWVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG5vc2hhZG93XG4gKiAgIFtlbl1Ub29sYmFyIHdpdGhvdXQgc2hhZG93LlsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjgavlvbHjgpLku5jjgZHjgZrjgavooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUb29sYmFyIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggbmF2aWdhdGlvbi5cbiAqXG4gKiAgICAgTGVmdCwgY2VudGVyIGFuZCByaWdodCBjb250YWluZXIgY2FuIGJlIHNwZWNpZmllZCBieSBjbGFzcyBuYW1lcy5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXlzIGFzIGEgTWF0ZXJpYWwgRGVzaWduIHRvb2xiYXIgd2hlbiBydW5uaW5nIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODiuODk+OCsuODvOOCt+ODp+ODs+OBp+S9v+eUqOOBmeOCi+ODhOODvOODq+ODkOODvOeUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOCr+ODqeOCueWQjeOBq+OCiOOCiuOAgeW3puOAgeS4reWkruOAgeWPs+OBruOCs+ODs+ODhuODiuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcbiAqIEBndWlkZSBjb21waWxhdGlvbi5odG1sI3Rvb2xiYXItY29tcGlsYXRpb24gW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLWJvdHRvbS10b29sYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtYm90dG9tLXRvb2xiYXI+YCBkaXNwbGF5cyBhIHRvb2xiYXIgb24gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdb25zLWJvdHRvbS10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW5zaWRlIHRoZSB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXItYnV0dG9uXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhci1idXR0b24+YCBjb21wb25lbnQgZGlzcGxheXMgYSB0b29sYmFyIGJ1dHRvbiBpbnNpZGUgdGhlIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFyLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+XG4gKiAgICAgICAgIEJhY2tcbiAqICAgICAgIDwvb25zLWJhY2stYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICAgIFRpdGxlXG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKiA8L29ucy1wYWdlPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlubGluZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXkgdGhlIHRvb2xiYXIgYXMgYW4gaW5saW5lIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844KS44Kk44Oz44Op44Kk44Oz44Gr572u44GN44G+44GZ44CC44K544Kv44Ot44O844Or6aCY5Z+f5YaF44Gr44Gd44Gu44G+44G+6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0b29sYmFyLlsvZW5dXG4gICAqICAgW2phXeODhOODvOODq+ODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJMZWZ0SXRlbXNFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5sZWZ0JykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckNlbnRlckl0ZW1zRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcuY2VudGVyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5yaWdodCcpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2dldFRvb2xiYXJCYWNrQnV0dG9uTGFiZWxFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbiAuYmFjay1idXR0b25fX2xhYmVsJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckJhY2tCdXR0b25JY29uRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdvbnMtYmFjay1idXR0b24gLmJhY2stYnV0dG9uX19pY29uJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgdGhpcy5fZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cygpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwIDsgaS0tKSB7XG4gICAgICAvLyBjYXNlIG9mIG5vdCBlbGVtZW50XG4gICAgICBpZiAodGhpcy5jaGlsZE5vZGVzW2ldLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuX2Vuc3VyZVRvb2xiYXJFbGVtZW50KCdjZW50ZXInKTtcbiAgICBjZW50ZXIuY2xhc3NMaXN0LmFkZCgndG9vbGJhcl9fdGl0bGUnKTtcblxuICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCAhdGhpcy5jaGlsZHJlblswXS5jbGFzc0xpc3QuY29udGFpbnMoJ2NlbnRlcicpKSB7XG4gICAgICBjb25zdCBsZWZ0ID0gdGhpcy5fZW5zdXJlVG9vbGJhckVsZW1lbnQoJ2xlZnQnKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5fZW5zdXJlVG9vbGJhckVsZW1lbnQoJ3JpZ2h0Jyk7XG5cbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuWzBdICE9PSBsZWZ0IHx8IHRoaXMuY2hpbGRyZW5bMV0gIT09IGNlbnRlciB8fCB0aGlzLmNoaWxkcmVuWzJdICE9PSByaWdodCkge1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGxlZnQpO1xuICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGNlbnRlcik7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQocmlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9lbnN1cmVUb29sYmFyRWxlbWVudChuYW1lKSB7XG4gICAgaWYgKHV0aWwuZmluZENoaWxkKHRoaXMsICcudG9vbGJhcl9fJyArIG5hbWUpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50b29sYmFyX18nICsgbmFtZSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy4nICsgbmFtZSkgfHwgdXRpbC5jcmVhdGUoJy4nICsgbmFtZSk7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0b29sYmFyX18nICsgbmFtZSk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuVG9vbGJhciA9IFRvb2xiYXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdG9vbGJhcicsIFRvb2xiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uL29ucy9pbnRlcm5hbC9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuaW1wb3J0ICcuL29ucy10b29sYmFyJzsgLy8gZW5zdXJlcyB0aGF0ICdvbnMtdG9vbGJhcicgZWxlbWVudCBpcyByZWdpc3RlcmVkXG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAncGFnZSc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAncGFnZS0tKicsXG4gICcucGFnZV9fY29udGVudCc6ICdwYWdlLS0qX19jb250ZW50JyxcbiAgJy5wYWdlX19iYWNrZ3JvdW5kJzogJ3BhZ2UtLSpfX2JhY2tncm91bmQnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wYWdlXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGVmaW5lcyB0aGUgcm9vdCBvZiBlYWNoIHBhZ2UuIElmIHRoZSBjb250ZW50IGlzIGxhcmdlIGl0IHdpbGwgYmVjb21lIHNjcm9sbGFibGUuXG4gKlxuICogICAgIEEgbmF2aWdhdGlvbiBiYXIgY2FuIGJlIGFkZGVkIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UgdXNpbmcgdGhlIGA8b25zLXRvb2xiYXI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFd44Oa44O844K45a6a576p44Gu44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu5YaF5a6544Gv44K544Kv44Ot44O844Or44GM6Kix5Y+v44GV44KM44G+44GZ44CCWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wYWdlXG4gKiBAZ3VpZGUgbGlmZWN5Y2xlLmh0bWwjZXZlbnRzXG4gKiAgIFtlbl1PdmVydmlldyBvZiBwYWdlIGV2ZW50c1svZW5dXG4gKiAgIFtqYV1PdmVydmlldyBvZiBwYWdlIGV2ZW50c1svamFdXG4gKiBAZ3VpZGUgZnVuZGFtZW50YWxzLmh0bWwjbWFuYWdpbmctcGFnZXNcbiAqICAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1Vc2UgdGhlIGA8b25zLXRvb2xiYXI+YCBlbGVtZW50IHRvIGFkZCBhIG5hdmlnYXRpb24gYmFyIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5UaXRsZTwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgICAgPG9ucy1pY29uIGljb249XCJtZC1tZW51XCI+PC9vbnMtaWNvbj5cbiAqICAgICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICpcbiAqICAgPHA+UGFnZSBjb250ZW50PC9wPlxuICogPC9vbnMtcGFnZT5cbiAqXG4gKiBAZXhhbXBsZVxuICogPHNjcmlwdD5cbiAqICAgbXlBcHAuaGFuZGxlciA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAqICAgICBsb2FkTW9yZSgpLnRoZW4oZG9uZSk7XG4gKiAgIH1cbiAqIDwvc2NyaXB0PlxuICpcbiAqIDxvbnMtcGFnZSBvbi1pbmZpbml0ZS1zY3JvbGw9XCJteUFwcC5oYW5kbGVyXCI+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+TGlzdDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICpcbiAqICAgPG9ucy1saXN0PlxuICogICAgIDxvbnMtbGlzdC1pdGVtPiMxPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIDxvbnMtbGlzdC1pdGVtPiMyPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIDxvbnMtbGlzdC1pdGVtPiMzPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIC4uLlxuICogICA8L29ucy1saXN0PlxuICogPC9vbnMtcGFnZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBpbml0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBhdHRhY2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzjgqLjgr/jg4Pjg4HjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIHNob3duLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOihqOekuuOBleOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgZGVzdHJveVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYmVmb3JlIHRoZSBwYWdlIGlzIGRlc3Ryb3llZC5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYznoLTmo4TjgZXjgozjgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBtb2RpZmllciBuYW1lIHRvIHNwZWNpZnkgY3VzdG9tIHN0eWxlcy5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jgqTjg6vlrprnvqnjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovjgZ/jgoHjga7lkI3liY3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvbi1pbmZpbml0ZS1zY3JvbGxcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhdGggb2YgdGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uIGluZmluaXRlIHNjcm9sbGluZy4gRXhhbXBsZTogYGFwcC5sb2FkRGF0YWAuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhIGRvbmUgY2FsbGJhY2sgdGhhdCBtdXN0IGJlIGNhbGxlZCB3aGVuIGl0J3MgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2Rlcml2ZUhvb2tzKCk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2NvbnRlbnRPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgIHRoaXMuX3RyeVRvU3VwcHJlc3NMYXllckNyZWF0aW9uKCk7XG4gICAgfSk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgICB0aGlzLl9jb250ZW50RWxlbWVudCA9IHRoaXMuX2dldENvbnRlbnRFbGVtZW50KCk7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kRWxlbWVudCA9IHRoaXMuX2dldEJhY2tncm91bmRFbGVtZW50KCk7XG5cbiAgICAgIHRoaXMuX2NvbnRlbnRPYnNlcnZlci5vYnNlcnZlKHRoaXMuX2NvbnRlbnRFbGVtZW50LCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICB0aGlzLl90cnlUb1N1cHByZXNzTGF5ZXJDcmVhdGlvbigpO1xuICAgIH0pO1xuICB9XG5cbiAgX3RyeVRvU3VwcHJlc3NMYXllckNyZWF0aW9uKCkge1xuICAgIGlmICghdGhpcy5fY29udGVudEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQ7XG4gICAgY29uc3Qgc2Nyb2xsZXJTZXQgPSBuZXcgU2V0KFtcbiAgICAgICdvbnMtbmF2aWdhdG9yJyxcbiAgICAgICdvbnMtcGFnZScsXG4gICAgICAnb25zLXRhYmJhcicsXG4gICAgICAnb25zLXNwbGl0dGVyJ1xuICAgIF0pO1xuXG4gICAgY29uc3Qgc2hvdWxkU3VwcHJlc3MgPSBjb250ZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBzY3JvbGxlclNldC5oYXMoY29udGVudC5jaGlsZHJlblswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcblxuICAgIC8vIElmIGNvbnRlbnQgZWxlbWVudCBoYXMgb25seSBvbmUgZWxlbWVudCBhbmQgdGhlIGVsZW1lbnQgaGFzIHNjcm9sbCBjb250ZW50LCB0aGVyZSBpcyBubyBuZWVkIGZvciBsYXllciBjcmVhdGlvbiBpbiB0aGlzIGNvbnRlbnQgZWxlbWVudC5cbiAgICBpZiAoc2hvdWxkU3VwcHJlc3MpIHtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgncGFnZV9fY29udGVudC0tc3VwcHJlc3MtbGF5ZXItY3JlYXRpb24nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdwYWdlX19jb250ZW50LS1zdXBwcmVzcy1sYXllci1jcmVhdGlvbicpO1xuICAgIH1cbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgY29uc3QgdG9vbGJhciA9IHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpO1xuXG4gICAgY29uc3QgYmFja2dyb3VuZCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fYmFja2dyb3VuZCcpIHx8IHV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFja2dyb3VuZCcpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhY2tncm91bmQuY2xhc3NMaXN0LmFkZCgncGFnZV9fYmFja2dyb3VuZCcpO1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGJhY2tncm91bmQsICF0b29sYmFyICYmIHRoaXMuZmlyc3RDaGlsZCB8fCB0b29sYmFyICYmIHRvb2xiYXIubmV4dFNpYmxpbmcpO1xuXG4gICAgY29uc3QgY29udGVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fY29udGVudCcpIHx8IHV0aWwuZmluZENoaWxkKHRoaXMsICcuY29udGVudCcpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgncGFnZV9fY29udGVudCcpO1xuICAgIGlmICghY29udGVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAxIHx8IHRoaXMuX2VsZW1lbnRTaG91bGRCZU1vdmVkKG5vZGUpKSB7XG4gICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlKTsgLy8gQ2FuIHRyaWdnZXIgZGV0YWNoZWQgY29ubmVjdGVkQ2FsbGJhY2tzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RyeVRvRmlsbFN0YXR1c0Jhcihjb250ZW50KTsgLy8gTXVzdCBydW4gYmVmb3JlIGNoaWxkIHBhZ2VzIHRyeSB0byBmaWxsIHN0YXR1cyBiYXIuXG4gICAgdGhpcy5pbnNlcnRCZWZvcmUoY29udGVudCwgYmFja2dyb3VuZC5uZXh0U2libGluZyk7IC8vIENhbiB0cmlnZ2VyIGF0dGFjaGVkIGNvbm5lY3RlZENhbGxiYWNrc1xuXG4gICAgLy8gTWFrZSB3cmFwcGVyIHBhZ2VzIHRyYW5zcGFyZW50IGZvciBhbmltYXRpb25zXG4gICAgaWYgKCFiYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvclxuICAgICAgJiYgKCF0b29sYmFyIHx8ICF1dGlsLmhhc01vZGlmaWVyKHRvb2xiYXIsICd0cmFuc3BhcmVudCcpKVxuICAgICAgJiYgY29udGVudC5jaGlsZHJlbi5sZW5ndGggPT09IDFcbiAgICAgICYmIHV0aWwuaXNQYWdlQ29udHJvbChjb250ZW50LmNoaWxkcmVuWzBdKVxuICAgICkge1xuICAgICAgICBiYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2VsZW1lbnRTaG91bGRCZU1vdmVkKGVsKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncGFnZV9fYmFja2dyb3VuZCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRhZ05hbWUgPT09ICdvbnMtZmFiJykge1xuICAgICAgcmV0dXJuICFlbC5oYXNBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGZpeGVkRWxlbWVudHMgPSBbJ3NjcmlwdCcsICdvbnMtdG9vbGJhcicsICdvbnMtYm90dG9tLXRvb2xiYXInLCAnb25zLW1vZGFsJywgJ29ucy1zcGVlZC1kaWFsJywgJ29ucy1kaWFsb2cnLCAnb25zLWFsZXJ0LWRpYWxvZycsICdvbnMtcG9wb3ZlcicsICdvbnMtYWN0aW9uLXNoZWV0J107XG4gICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJykgfHwgZml4ZWRFbGVtZW50cy5pbmRleE9mKHRhZ05hbWUpID09PSAtMTtcbiAgfVxuXG4gIF90cnlUb0ZpbGxTdGF0dXNCYXIoY29udGVudCA9IHRoaXMuX2NvbnRlbnRFbGVtZW50KSB7XG4gICAgaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwoKCkgPT4ge1xuICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N0YXR1cy1iYXItZmlsbCcsXG4gICAgICAgICF1dGlsLmZpbmRQYXJlbnQodGhpcywgZSA9PiBlLmhhc0F0dHJpYnV0ZSgnc3RhdHVzLWJhci1maWxsJykpIC8vIE5vdCBhbHJlYWR5IGZpbGxlZFxuICAgICAgICAmJiAodGhpcy5fY2FuQW5pbWF0ZVRvb2xiYXIoY29udGVudCkgfHwgIXV0aWwuZmluZENoaWxkKGNvbnRlbnQsIHV0aWwuaXNQYWdlQ29udHJvbCkpIC8vIEhhcyB0b29sYmFyIG9yIGNhbm5vdCBkZWxlZ2F0ZVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jYW5BbmltYXRlVG9vbGJhcihjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQpIHtcbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gISF1dGlsLmZpbmRDaGlsZChjb250ZW50LCBlbCA9PiB7XG4gICAgICByZXR1cm4gdXRpbC5tYXRjaChlbCwgJ29ucy10b29sYmFyJykgJiYgIWVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXV0aWwuaXNBdHRhY2hlZCh0aGlzKSkgeyAvLyBBdm9pZCBkZXRhY2hlZCBjYWxsc1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl90cnlUb0ZpbGxTdGF0dXNCYXIoKTsgLy8gRW5zdXJlIHN0YXR1cyBiYXIgd2hlbiB0aGUgZWxlbWVudCB3YXMgY29tcGlsZWQgYmVmb3JlIGNvbm5lY3RlZFxuXG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ29uLWluZmluaXRlLXNjcm9sbCcpKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdvbi1pbmZpbml0ZS1zY3JvbGwnLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMub25Jbml0ICYmIHRoaXMub25Jbml0KCk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdpbml0Jyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCh0aGlzKSkge1xuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUJhY2tCdXR0b24oc2hvdykge1xuICAgIGlmICh0aGlzLmJhY2tCdXR0b24pIHtcbiAgICAgIHNob3cgPyB0aGlzLmJhY2tCdXR0b24uc2hvdygpIDogdGhpcy5iYWNrQnV0dG9uLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBzZXQgbmFtZShzdHIpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsIHN0cik7XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgfVxuXG4gIGdldCBiYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkluZmluaXRlU2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gc2Nyb2xsaW5nIHRvIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhIGRvbmUgY2FsbGJhY2sgYXMgYW4gYXJndW1lbnQgdGhhdCBtdXN0IGJlIGNhbGxlZCB3aGVuIGl0J3MgZmluaXNoZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IG9uSW5maW5pdGVTY3JvbGwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbkluZmluaXRlU2Nyb2xsIG11c3QgYmUgYSBmdW5jdGlvbiBvciBudWxsJyk7XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9vbkluZmluaXRlU2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQgPSAwLjk7XG4gICAgICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fY29udGVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IG9uSW5maW5pdGVTY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uSW5maW5pdGVTY3JvbGw7XG4gIH1cblxuICBfb25TY3JvbGwoKSB7XG4gICAgY29uc3QgYyA9IHRoaXMuX2NvbnRlbnRFbGVtZW50LFxuICAgICAgb3ZlckxpbWl0ID0gKGMuc2Nyb2xsVG9wICsgYy5jbGllbnRIZWlnaHQpIC8gYy5zY3JvbGxIZWlnaHQgPj0gdGhpcy5faW5maW5pdGVTY3JvbGxMaW1pdDtcblxuICAgIGlmICh0aGlzLl9vbkluZmluaXRlU2Nyb2xsICYmICF0aGlzLl9sb2FkaW5nQ29udGVudCAmJiBvdmVyTGltaXQpIHtcbiAgICAgIHRoaXMuX2xvYWRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX29uSW5maW5pdGVTY3JvbGwoKCkgPT4gdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBnZXQgc2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICBzZXQgc2Nyb2xsVG9wKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fY29udGVudEVsZW1lbnQuc2Nyb2xsVG9wID0gbmV3VmFsdWU7XG4gIH1cblxuICBfZ2V0Q29udGVudEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19jb250ZW50Jyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoJ2ZhaWwgdG8gZ2V0IFwiLnBhZ2VfX2NvbnRlbnRcIiBlbGVtZW50LicpO1xuICB9XG5cbiAgX2dldEJhY2tncm91bmRFbGVtZW50KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucGFnZV9fYmFja2dyb3VuZCcpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdmYWlsIHRvIGdldCBcIi5wYWdlX19iYWNrZ3JvdW5kXCIgZWxlbWVudC4nKTtcbiAgfVxuXG4gIF9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1ib3R0b20tdG9vbGJhcicpIHx8IGludGVybmFsLm51bGxFbGVtZW50O1xuICB9XG5cbiAgX2dldFRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXRvb2xiYXInKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtdG9vbGJhcicpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnb24taW5maW5pdGUtc2Nyb2xsJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb24taW5maW5pdGUtc2Nyb2xsJzpcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IChkb25lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmID0gdXRpbC5maW5kRnJvbVBhdGgoY3VycmVudCk7XG4gICAgICAgICAgICB0aGlzLm9uSW5maW5pdGVTY3JvbGwgPSBmO1xuICAgICAgICAgICAgZihkb25lKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICghdGhpcy5faXNTaG93biAmJiB1dGlsLmlzQXR0YWNoZWQodGhpcykpIHtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgICAgdGhpcy5vblNob3cgJiYgdGhpcy5vblNob3coKTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnc2hvdycpO1xuICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19zaG93Jyk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMub25IaWRlICYmIHRoaXMub25IaWRlKCk7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2hpZGUnKTtcbiAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfaGlkZScpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuX2hpZGUoKTtcblxuICAgIHRoaXMub25EZXN0cm95ICYmIHRoaXMub25EZXN0cm95KCk7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdkZXN0cm95Jyk7XG5cbiAgICBpZiAodGhpcy5vbkRldmljZUJhY2tCdXR0b24pIHtcbiAgICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2Rlc3Ryb3knKTtcblxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBfZGVyaXZlSG9va3MoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICBjb25zdCBrZXkgPSAnb24nICsgZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzW2BfJHtrZXl9YF0sXG4gICAgICAgIHNldDogdmFsdWUgPT4ge1xuICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5fSBob29rIG11c3QgYmUgYSBmdW5jdGlvbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW2BfJHtrZXl9YF0gPSB2YWx1ZS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ2luaXQnLCAnc2hvdycsICdoaWRlJywgJ2Rlc3Ryb3knXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGF0YVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZXIncyBjdXN0b20gZGF0YSBwYXNzZWQgdG8gYHB1c2hQYWdlKClgLWxpa2UgbWV0aG9kcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbn1cblxub25zLmVsZW1lbnRzLlBhZ2UgPSBQYWdlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXBhZ2UnLCBQYWdlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgY2xhc3MgUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBoaWRlKHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIF9hbmltYXRlKGVsZW1lbnQsIHtmcm9tLCB0bywgb3B0aW9ucywgY2FsbGJhY2ssIHJlc3RvcmUgPSBmYWxzZSwgYW5pbWF0aW9ufSkge1xuICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgIGZyb20gPSBhbmltYXRpb24uZnJvbTtcbiAgICAgIHRvID0gYW5pbWF0aW9uLnRvO1xuICAgIH1cblxuICAgIGFuaW1hdGlvbiA9IGFuaW1pdChlbGVtZW50KTtcbiAgICBpZiAocmVzdG9yZSkge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnNhdmVTdHlsZSgpO1xuICAgIH1cbiAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucXVldWUoZnJvbSkud2FpdCh0aGlzLmRlbGF5KS5xdWV1ZSh7XG4gICAgICBjc3M6IHRvLFxuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgfSk7XG4gICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5yZXN0b3JlU3R5bGUoKTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucXVldWUoKGRvbmUpID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb247XG4gIH1cblxuICBfYW5pbWF0ZUFsbChlbGVtZW50LCBhbmltYXRpb25zKSB7XG4gICAgT2JqZWN0LmtleXMoYW5pbWF0aW9ucykuZm9yRWFjaChrZXkgPT4gdGhpcy5fYW5pbWF0ZShlbGVtZW50W2tleV0sIGFuaW1hdGlvbnNba2V5XSkucGxheSgpKTtcbiAgfVxuXG59XG5cbmNvbnN0IGZhZGUgPSB7XG4gIG91dDoge1xuICAgIGZyb206IHtvcGFjaXR5OiAxLjB9LFxuICAgIHRvOiB7b3BhY2l0eTogMH1cbiAgfSxcbiAgaW46IHtcbiAgICBmcm9tOiB7b3BhY2l0eTogMH0sXG4gICAgdG86IHtvcGFjaXR5OiAxLjB9XG4gIH1cbn07XG5cbmV4cG9ydCBjbGFzcyBNREZhZGVQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBQb3BvdmVyQW5pbWF0b3Ige1xuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5pbixcbiAgICAgIF9wb3BvdmVyOiB7YW5pbWF0aW9uOiBmYWRlLmluLCByZXN0b3JlOiB0cnVlLCBjYWxsYmFja31cbiAgICB9KTtcbiAgfVxuXG4gIGhpZGUocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hbmltYXRlQWxsKHBvcG92ZXIsIHtcbiAgICAgIF9tYXNrOiBmYWRlLm91dCxcbiAgICAgIF9wb3BvdmVyOiB7YW5pbWF0aW9uOiBmYWRlLm91dCwgcmVzdG9yZTogdHJ1ZSwgY2FsbGJhY2t9XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IgZXh0ZW5kcyBNREZhZGVQb3BvdmVyQW5pbWF0b3Ige1xuICBzaG93KHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5pbixcbiAgICAgIF9wb3BvdmVyOiB7XG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZTNkKDEuMywgMS4zLCAxLjApJyxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHRvOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjAsIDEuMCwgIDEuMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LFxuICAgICAgICByZXN0b3JlOiB0cnVlLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uLy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7IFBvcG92ZXJBbmltYXRvciwgSU9TRmFkZVBvcG92ZXJBbmltYXRvciwgTURGYWRlUG9wb3ZlckFuaW1hdG9yIH0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBpUGhvbmVYUGF0Y2ggZnJvbSAnLi4vLi4vb25zL2lwaG9uZXgtcGF0Y2gnO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wb3BvdmVyJzogJ3BvcG92ZXItLSonLFxuICAnLnBvcG92ZXItbWFzayc6ICdwb3BvdmVyLW1hc2stLSonLFxuICAnLnBvcG92ZXJfX2NvbnRlbnQnOiAncG9wb3Zlci0tKl9fY29udGVudCcsXG4gICcucG9wb3Zlcl9fYXJyb3cnOiAncG9wb3Zlci0tKl9fYXJyb3cnXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlUG9wb3ZlckFuaW1hdG9yIDogSU9TRmFkZVBvcG92ZXJBbmltYXRvcixcbiAgJ25vbmUnOiBQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLWlvcyc6IElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlUG9wb3ZlckFuaW1hdG9yXG59O1xuXG5jb25zdCBwb3NpdGlvbnMgPSB7XG4gIHVwOiAnYm90dG9tJyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgZG93bjogJ3RvcCcsXG4gIHJpZ2h0OiAnbGVmdCdcbn07XG5cbmNvbnN0IGRpcmVjdGlvbnMgPSBPYmplY3Qua2V5cyhwb3NpdGlvbnMpO1xuLyoqXG4gKiBAZWxlbWVudCBvbnMtcG9wb3ZlclxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHBvcG92ZXIgbmV4dCB0byBhbiBlbGVtZW50LiBUaGUgcG9wb3ZlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGV4dHJhIGluZm9ybWF0aW9uIGFib3V0IGEgY29tcG9uZW50IG9yIGEgdG9vbHRpcC5cbiAqXG4gKiAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVQb3BvdmVyKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8b25zLXRlbXBsYXRlPmAgdGFnLlxuICpcbiAqICAgIEFub3RoZXIgY29tbW9uIHdheSB0byB1c2UgdGhlIHBvcG92ZXIgaXMgdG8gZGlzcGxheSBhIG1lbnUgd2hlbiBhIGJ1dHRvbiBvbiB0aGUgc2NyZWVuIGlzIHRhcHBlZC4gRm9yIE1hdGVyaWFsIERlc2lnbiwgcG9wb3ZlciBsb29rcyBleGFjdGx5IGFzIGEgZHJvcGRvd24gbWVudS5cbiAqICBbL2VuXVxuICogIFtqYV3jgYLjgovopoHntKDjgpLlr77osaHjgajjgZnjgovjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQGNvZGVwZW4gWllZUktvXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcG9wb3ZlclxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1idXR0b24gb25jbGljaz1cInNob3dQb3BvdmVyKHRoaXMpXCI+XG4gKiAgIENsaWNrIG1lIVxuICogPC9vbnMtYnV0dG9uPlxuICpcbiAqIDxvbnMtcG9wb3ZlciBkaXJlY3Rpb249XCJkb3duXCIgaWQ9XCJwb3BvdmVyXCI+XG4gKiAgIDxwPlRoaXMgaXMgYSBwb3BvdmVyITwvcD5cbiAqIDwvb25zLXBvcG92ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNob3dQb3BvdmVyID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgIHZhciBwb3BvdmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvcG92ZXInKTtcbiAqICAgICBwb3BvdmVyLnNob3coZWxlbWVudCk7XG4gKiAgIH07XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9wb3ZlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBwb3BvdmVyIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOCi+WHpueQhuOCkuOCreODo+ODs+OCu+ODq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHBvcG92ZXIuWy9lbl1cbiAgICogIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXJlY3Rpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dXG4gICAqICAgIEEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZGlyZWN0aW9ucy4gSWYgbW9yZSB0aGFuIG9uZSBkaXJlY3Rpb24gaXMgc3BlY2lmaWVkLFxuICAgKiAgICBpdCB3aWxsIGJlIGNob3NlbiBhdXRvbWF0aWNhbGx5LiBWYWxpZCBkaXJlY3Rpb25zIGFyZSBgXCJ1cFwiYCwgYFwiZG93blwiYCwgYFwibGVmdFwiYCBhbmQgYFwicmlnaHRcImAuXG4gICAqICBbL2VuXVxuICAgKiAgW2phXVxuICAgKiAgICDjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovmlrnlkJHjgpLnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICAg5oyH5a6a44Gn44GN44KL5pa55ZCR44Gv44CBXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBrjTjgaTjgafjgZnjgILnqbrnmb3ljLrliIfjgorjgafopIfmlbDmjIflrprjgZnjgovjgZPjgajjgoLjgafjgY3jgb7jgZnjgIJcbiAgICogICAg6KSH5pWw5oyH5a6a44GV44KM44Gf5aC05ZCI44CB5a++6LGh44Go44GZ44KL6KaB57Sg44Gr5ZCI44KP44Gb44Gm5oyH5a6a44GX44Gf5YCk44GL44KJ6Ieq5YuV55qE44Gr6YG45oqe44GV44KM44G+44GZ44CCXG4gICAqICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHBvcG92ZXIgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIHjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgZ/mmYLjgavjgIHog4zmma/jgoTjg5Djg4Pjgq/jg5zjgr/jg7PjgpLjgr/jg4Pjg5fjgZfjgZ/mmYLjgavjgpLjg53jg4Pjg5fjgqrjg7zjg5Djg7zplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjb3Zlci10YXJnZXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHNldCB0aGUgcG9wb3ZlciB3aWxsIGNvdmVyIHRoZSB0YXJnZXQgb24gdGhlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW4gaGlkaW5nIHRoZSBwb3BvdmVyLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAsIGBcImRlZmF1bHRcImAsIGBcImZhZGUtaW9zXCJgIG9yIGBcImZhZGUtbWRcImAuWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBgXCJyZ2JhKDAsIDAsIDAsIDAuMilcImAuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu44Oe44K544Kv44Gu6Imy44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJyZ2JhKDAsIDAsIDAsIDAuMilcIuOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBvcG92ZXItbWFzaycpO1xuICB9XG5cbiAgZ2V0IF9wb3BvdmVyKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBvcG92ZXInKTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fcG9wb3ZlciwgJy5wb3BvdmVyX19jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgX2Fycm93KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2Fycm93Jyk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogUG9wb3ZlckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1BvcG92ZXJBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgfHwgJ2RlZmF1bHQnXG4gICAgfSk7XG4gIH1cblxuICBfdG9nZ2xlU3R5bGUoc2hvdWxkU2hvdywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHNob3VsZFNob3cpIHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgICB0aGlzLl9wb3NpdGlvblBvcG92ZXIob3B0aW9ucy50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLl9jbGVhclN0eWxlcygpO1xuICAgIH1cbiAgfVxuXG4gIF9wb3NpdGlvblBvcG92ZXIodGFyZ2V0KSB7XG4gICAgY29uc3Qge19yYWRpdXM6IHJhZGl1cywgX2NvbnRlbnQ6IGNvbnRlbnRFbGVtZW50LCBfbWFyZ2luOiBtYXJnaW59ID0gdGhpcztcbiAgICBjb25zdCBzYWZlQXJlYUxlbmd0aHMgPSBpUGhvbmVYUGF0Y2guZ2V0U2FmZUFyZWFMZW5ndGhzKCk7XG4gICAgY29uc3Qgc2FmZUFyZWFSZWN0ID0gaVBob25lWFBhdGNoLmdldFNhZmVBcmVhRE9NUmVjdCgpO1xuICAgIGNvbnN0IHRhcmdldFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgaXNNRCA9IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJyk7XG4gICAgY29uc3QgY292ZXIgPSBpc01EICYmIHRoaXMuaGFzQXR0cmlidXRlKCdjb3Zlci10YXJnZXQnKTtcblxuICAgIC8vIERpc3RhbmNlIGZyb20gZWFjaCBzaWRlIG9mIHRoZSBzYWZlIGFyZWEgKHdpdGggbWFyZ2luKSB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBjb25zdCB0YXJnZXREaXN0YW5jZSA9IHtcbiAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgLSAoc2FmZUFyZWFSZWN0LnRvcCArIG1hcmdpbiksXG4gICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgLSAoc2FmZUFyZWFSZWN0LmxlZnQgKyBtYXJnaW4pLFxuICAgICAgYm90dG9tOiAoc2FmZUFyZWFSZWN0LmJvdHRvbSAtIG1hcmdpbikgLSB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHJpZ2h0OiAoc2FmZUFyZWFSZWN0LnJpZ2h0IC0gbWFyZ2luKSAtIHRhcmdldFJlY3QucmlnaHRcbiAgICB9O1xuXG4gICAgLy8gRGlzdGFuY2UgZnJvbSBlYWNoIHNpZGUgb2YgdGhlIHNhZmUgYXJlYSAod2l0aCBtYXJnaW4pIHRvIHRoZSBnZW9tZXRyaWMgY2VudGVyIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgIGNvbnN0IHRhcmdldENlbnRlckRpc3RhbmNlRnJvbSA9IHtcbiAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3QuaGVpZ2h0IC8gMikgLSAoc2FmZUFyZWFSZWN0LnRvcCArIG1hcmdpbiksXG4gICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3Qud2lkdGggLyAyKSAtIChzYWZlQXJlYVJlY3QubGVmdCArIG1hcmdpbiksXG4gICAgICBib3R0b206IChzYWZlQXJlYVJlY3QuYm90dG9tIC0gbWFyZ2luKSAtIHRhcmdldFJlY3QuYm90dG9tICsgTWF0aC5yb3VuZCh0YXJnZXRSZWN0LmhlaWdodCAvIDIpLFxuICAgICAgcmlnaHQ6IChzYWZlQXJlYVJlY3QucmlnaHQgLSBtYXJnaW4pIC0gdGFyZ2V0UmVjdC5yaWdodCArIE1hdGgucm91bmQodGFyZ2V0UmVjdC53aWR0aCAvIDIpXG4gICAgfTtcblxuICAgIGNvbnN0IHt2ZXJ0aWNhbCwgcHJpbWFyeTogcHJpbWFyeURpcmVjdGlvbiwgc2Vjb25kYXJ5OiBzZWNvbmRhcnlEaXJlY3Rpb259ID0gdGhpcy5fY2FsY3VsYXRlRGlyZWN0aW9ucyh0YXJnZXREaXN0YW5jZSk7XG4gICAgdGhpcy5fY3VycmVudERpcmVjdGlvbiA9IHByaW1hcnlEaXJlY3Rpb247XG4gICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCBwcmltYXJ5RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IHNpemVOYW1lID0gdmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgLy8gR2V0IC5wb3BvdmVyX19jb250ZW50IHNpemVcbiAgICBjb25zdCBjb250ZW50U2l6ZSA9IChzdHlsZSA9PiAoe1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyksIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JyksIDEwKVxuICAgIH0pKSh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50RWxlbWVudCkpO1xuXG4gICAgLy8gU2V0dGluZyAucG9wb3ZlciBwb3NpdGlvbi5cbiAgICBjb25zdCB0YXJnZXRBbmRBcnJvd0xlbmd0aCA9IGNvdmVyID8gMCA6ICh2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuaGVpZ2h0IDogdGFyZ2V0UmVjdC53aWR0aCkgKyAoaXNNRCA/IDAgOiAxNCk7XG4gICAgY29uc3QgcHJpbWFyeU9mZnNldCA9IE1hdGgubWF4KFxuICAgICAgc2FmZUFyZWFMZW5ndGhzW3ByaW1hcnlEaXJlY3Rpb25dICsgbWFyZ2luLFxuICAgICAgc2FmZUFyZWFMZW5ndGhzW3ByaW1hcnlEaXJlY3Rpb25dICsgbWFyZ2luICsgdGFyZ2V0RGlzdGFuY2VbcHJpbWFyeURpcmVjdGlvbl0gKyB0YXJnZXRBbmRBcnJvd0xlbmd0aFxuICAgICk7XG4gICAgY29uc3Qgc2Vjb25kYXJ5T2Zmc2V0ID0gTWF0aC5tYXgoXG4gICAgICBzYWZlQXJlYUxlbmd0aHNbc2Vjb25kYXJ5RGlyZWN0aW9uXSArIG1hcmdpbixcbiAgICAgIHNhZmVBcmVhTGVuZ3Roc1tzZWNvbmRhcnlEaXJlY3Rpb25dICsgbWFyZ2luICsgdGFyZ2V0Q2VudGVyRGlzdGFuY2VGcm9tW3NlY29uZGFyeURpcmVjdGlvbl0gLSAoY29udGVudFNpemVbc2l6ZU5hbWVdIC8gMilcbiAgICApO1xuICAgIHRoaXMuX3BvcG92ZXIuc3R5bGVbcHJpbWFyeURpcmVjdGlvbl0gPSBwcmltYXJ5T2Zmc2V0ICsgJ3B4JztcbiAgICB0aGlzLl9wb3BvdmVyLnN0eWxlW3NlY29uZGFyeURpcmVjdGlvbl0gPSBzZWNvbmRhcnlPZmZzZXQgKyAncHgnO1xuXG4gICAgLy8gU2V0dGluZyAucG9wb3Zlcl9fYXJyb3cgcG9zaXRpb24uXG4gICAgdGhpcy5fYXJyb3cuc3R5bGVbc2Vjb25kYXJ5RGlyZWN0aW9uXSA9IE1hdGgubWF4KFxuICAgICAgcmFkaXVzLFxuICAgICAgKHNhZmVBcmVhTGVuZ3Roc1tzZWNvbmRhcnlEaXJlY3Rpb25dICsgbWFyZ2luKSArIHRhcmdldENlbnRlckRpc3RhbmNlRnJvbVtzZWNvbmRhcnlEaXJlY3Rpb25dIC0gc2Vjb25kYXJ5T2Zmc2V0XG4gICAgKSArICdweCc7XG4gIH1cblxuICBfY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpIHx8ICd1cCBkb3duIGxlZnQgcmlnaHQnKS5zcGxpdCgvXFxzKy8pLm1hcChlID0+IHBvc2l0aW9uc1tlXSk7XG4gICAgY29uc3QgcHJpbWFyeSA9IG9wdGlvbnMuc29ydCgoYSwgYikgPT4gZGlzdGFuY2VbYV0gLSBkaXN0YW5jZVtiXSlbMF07XG4gICAgY29uc3QgdmVydGljYWwgPSAndG9wJyA9PSBwcmltYXJ5IHx8ICdib3R0b20nID09IHByaW1hcnk7XG4gICAgbGV0IHNlY29uZGFyeTtcblxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UubGVmdCA8IGRpc3RhbmNlLnJpZ2h0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UudG9wIDwgZGlzdGFuY2UuYm90dG9tID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICB9XG5cbiAgICByZXR1cm4ge3ZlcnRpY2FsLCBwcmltYXJ5LCBzZWNvbmRhcnl9O1xuICB9XG5cbiAgX2NsZWFyU3R5bGVzKCkge1xuICAgIHRoaXMuX2N1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuX2Fycm93LnN0eWxlW2VdID0gdGhpcy5fY29udGVudC5zdHlsZVtlXSA9IHRoaXMuX3BvcG92ZXIuc3R5bGVbZV0gPSAnJztcbiAgICAgIHV0aWwucmVtb3ZlTW9kaWZpZXIodGhpcywgZSk7XG4gICAgfSk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uUG9wb3Zlcih0aGlzLl9jdXJyZW50VGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3BvcG92ZXIgJiYgdGhpcy5fbWFzaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc0RlZmF1bHRDb250YWluZXIgPSB0aGlzLl9wb3BvdmVyICYmIHRoaXMuX2NvbnRlbnQ7XG5cbiAgICBpZiAoaGFzRGVmYXVsdENvbnRhaW5lcikge1xuXG4gICAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItbWFzaycpO1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2Fycm93KSB7XG4gICAgICAgIGNvbnN0IGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFycm93LmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXJfX2Fycm93Jyk7XG4gICAgICAgIHRoaXMuX3BvcG92ZXIuYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB1dGlsLmNyZWF0ZUZyYWdtZW50KGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXItbWFza1wiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicG9wb3ZlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19jb250ZW50XCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXJfX2Fycm93XCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVtcGxhdGUucXVlcnlTZWxlY3RvcignLnBvcG92ZXJfX2NvbnRlbnQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FIVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgdGhpcy5fcG9wb3Zlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3codGFyZ2V0LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfEV2ZW50fEhUTUxFbGVtZW50fSB0YXJnZXRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuIENhbiBiZSBlaXRoZXIgYSBDU1Mgc2VsZWN0b3IsIGFuIGV2ZW50IG9iamVjdCBvciBhIERPTSBlbGVtZW50LiBJdCBjYW4gYmUgYWxzbyBwcm92aWRlZCBhcyAnb3B0aW9ucy50YXJnZXQnIGluc3RlYWQuIFsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruOCv+ODvOOCsuODg+ODiOOBqOOBquOCi+imgee0oOOCkuaMh+WumuOBl+OBvuOBmeOAgkNTU+OCu+ODrOOCr+OCv+OBi2V2ZW5044Kq44OW44K444Kn44Kv44OI44GLRE9N6KaB57Sg44Gu44GE44Ga44KM44GL44KS5rih44Gb44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBgXCJmYWRlLWlvc1wiYCwgYFwiZmFkZS1tZFwiYCwgYFwibm9uZVwiYCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVuIHRoZSBwb3BvdmVyIGFuZCBwb2ludCBpdCBhdCBhIHRhcmdldC4gVGhlIHRhcmdldCBjYW4gYmUgZWl0aGVyIGFuIGV2ZW50LCBhIENTUyBzZWxlY3RvciBvciBhIERPTSBlbGVtZW50Li5bL2VuXVxuICAgKiAgIFtqYV3lr77osaHjgajjgZnjgovopoHntKDjgavjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJ0YXJnZXTlvJXmlbDjgavjga/jgIEkZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgoRET03jgqjjg6zjg6Hjg7Pjg4jjgoRDU1Pjgrvjg6zjgq/jgr/jgpLmuKHjgZnjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIENvcHkgb3B0aW9ucyBhbmQgaW5jbHVkZSBvcHRpb25zLnRhcmdldFxuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudCkgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSB7IC4uLnRhcmdldCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0YXJnZXQgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucy50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvbnMudGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGFyZ2V0IGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQudGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50YXJnZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGFyZ2V0IG9yIG9wdGlvbnMudGFyZ2V0IGFyZ3VtZW50IG11c3QgYmUgZGVmaW5lZCBmb3IgdGhlIHBvcG92ZXIuJyk7XG4gICAgfVxuXG4gICAgaWYgKCEob3B0aW9ucy50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhcmdldCBmb3IgcG9wb3Zlci4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuc2hvdyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBgXCJmYWRlLWlvc1wiYCwgYFwiZmFkZS1tZFwiYCwgYFwibm9uZVwiYCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb25zIGlzIGNhbGxlZCBhZnRlciB0aGUgcG9wb3ZlciBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNsb3NlIHRoZSBwb3BvdmVyLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgQSBib29sZWFuIHZhbHVlIHRoYXQgc3BlY2lmaWVzIHdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgY2FuY2VsYWJsZSBvciBub3QuXG4gICAqXG4gICAqICAgICBXaGVuIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgaXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgdGhpcy5fbWFyZ2luID0gdGhpcy5fbWFyZ2luIHx8IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoJ3RvcCcpKTtcbiAgICB0aGlzLl9tYXJnaW4gPSB0aGlzLl9tYXJnaW4gfHwgNjsgLy8gRml4IGZvciBpZnJhbWVzXG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fcmFkaXVzID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fY29udGVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnYm9yZGVyLXRvcC1sZWZ0LXJhZGl1cycpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbLi4uc3VwZXIub2JzZXJ2ZWRBdHRyaWJ1dGVzLCAnZGlyZWN0aW9uJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnZGlyZWN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kT25DaGFuZ2UoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnREaXJlY3Rpb24gJiYgdXRpbC5hZGRNb2RpZmllcih0aGlzLCB0aGlzLl9jdXJyZW50RGlyZWN0aW9uKTtcbiAgICB9XG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7UG9wb3ZlckFuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBQb3BvdmVyQW5pbWF0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiQW5pbWF0b3JcIiBwYXJhbSBtdXN0IGluaGVyaXQgUG9wb3ZlckFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBQb3BvdmVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFBvcG92ZXJBbmltYXRvcjtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuUG9wb3ZlciA9IFBvcG92ZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcG9wb3ZlcicsIFBvcG92ZXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcucHJvZ3Jlc3MtYmFyJzogJ3Byb2dyZXNzLWJhci0tKicsXG4gICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWJhci0tKl9fcHJpbWFyeScsXG4gICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknOiAncHJvZ3Jlc3MtYmFyLS0qX19zZWNvbmRhcnknXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxkaXYgY2xhc3M9XCJwcm9ncmVzcy1iYXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnlcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyX19wcmltYXJ5XCI+PC9kaXY+XG4gIDwvZGl2PlxuYCk7XG5cbmNvbnN0IElOREVUID0gJ2luZGV0ZXJtaW5hdGUnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wcm9ncmVzcy1iYXJcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhlIGNvbXBvbmVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBsaW5lYXIgcHJvZ3Jlc3MgYmFyLiBJdCBjYW4gZWl0aGVyIGRpc3BsYXkgYSBwcm9ncmVzcyBiYXIgdGhhdCBzaG93cyB0aGUgdXNlciBob3cgbXVjaCBvZiBhIHRhc2sgaGFzIGJlZW4gY29tcGxldGVkLiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgcGVyY2VudGFnZSBpcyBub3Qga25vd24gaXQgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBhbiBhbmltYXRlZCBwcm9ncmVzcyBiYXIgc28gdGhlIHVzZXIgY2FuIHNlZSB0aGF0IGFuIG9wZXJhdGlvbiBpcyBpbiBwcm9ncmVzcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB6dlFiR2pcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wcm9ncmVzc1xuICogQHNlZWFsc28gb25zLXByb2dyZXNzLWNpcmN1bGFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBjaXJjdWxhciBwcm9ncmVzcyBpbmRpY2F0b3IuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wcm9ncmVzcy1iYXJcbiAqICB2YWx1ZT1cIjU1XCJcbiAqICBzZWNvbmRhcnktdmFsdWU9XCI4N1wiPlxuICogPC9vbnMtcHJvZ3Jlc3MtYmFyPlxuICpcbiAqIDxvbnMtcHJvZ3Jlc3MtYmFyXG4gKiAgaW5kZXRlcm1pbmF0ZT5cbiAqIDwvb25zLXByb2dyZXNzLWJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NCYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DaGFuZ2UgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICAgKiAgIFtqYV3jg5fjg63jgrDjg6zjgrnjgqTjg7PjgrjjgrHjg7zjgr/jga7opovjgZ/nm67jgpLlpInmm7TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB2YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlY29uZGFyeS12YWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbmRldGVybWluYXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc0NvbXBpbGVkKCkpIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtYmFyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWJhcl9fcHJpbWFyeScpO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5Jyk7XG5cbiAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3RlbXBsYXRlKTtcblxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9pc0NvbXBpbGVkKCkge1xuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1iYXInKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGJhckVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWJhcicpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZChiYXJFbGVtZW50LCAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKGJhckVsZW1lbnQsICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3ZhbHVlJywgJ3NlY29uZGFyeS12YWx1ZScsIElOREVUXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKG5hbWUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpICYmIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdzZWNvbmRhcnktdmFsdWUnKSB7XG4gICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gSU5ERVQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURldGVybWluYXRlKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB1dGlsLnRvZ2dsZU1vZGlmaWVyKHRoaXMsIElOREVULCB7IGZvcmNlOiB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCkgfSkpO1xuICB9XG5cbiAgX3VwZGF0ZVZhbHVlKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlLndpZHRoID0gKHRoaXMuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICsgJyUnIDogJzAlJztcbiAgICAgIHRoaXMuX3NlY29uZGFyeS5zdHlsZS53aWR0aCA9IHRoaXMuaGFzQXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSA/IHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSArICclJyA6ICcwJSc7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCB2YWx1ZSA+IDEwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHNlY29uZGFyeVZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgfHwgJzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaW5kZXRlcm1pbmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgLCBhbiBpbmZpbml0ZSBsb29waW5nIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODq+ODvOODl+OBmeOCi+OCouODi+ODoeODvOOCt+ODp+ODs+OBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuICBzZXQgaW5kZXRlcm1pbmF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoSU5ERVQsICcnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShJTkRFVCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKElOREVUKTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuUHJvZ3Jlc3NCYXIgPSBQcm9ncmVzc0JhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wcm9ncmVzcy1iYXInLCBQcm9ncmVzc0JhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcic6ICdwcm9ncmVzcy1jaXJjdWxhci0tKicsXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX2JhY2tncm91bmQnOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSpfX2JhY2tncm91bmQnLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyLS0qX19wcmltYXJ5JyxcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JzogJ3Byb2dyZXNzLWNpcmN1bGFyLS0qX19zZWNvbmRhcnknXG59O1xuXG5jb25zdCB0ZW1wbGF0ZSA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gIDxzdmcgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhclwiPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fYmFja2dyb3VuZFwiIC8+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnlcIiAvPlxuICAgIDxjaXJjbGUgY2xhc3M9XCJwcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeVwiIC8+XG4gIDwvc3ZnPlxuYCk7XG5cbmNvbnN0IElOREVUID0gJ2luZGV0ZXJtaW5hdGUnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyBhIGNpcmN1bGFyIHByb2dyZXNzIGluZGljYXRvci4gSXQgY2FuIGVpdGhlciBiZSB1c2VkIHRvIHNob3cgaG93IG11Y2ggb2YgYSB0YXNrIGhhcyBiZWVuIGNvbXBsZXRlZCBvciB0byBzaG93IGEgbG9vcGluZyBhbmltYXRpb24gdG8gaW5kaWNhdGUgdGhhdCBhbiBvcGVyYXRpb24gaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gRVZ6TWpSXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHJvZ3Jlc3NcbiAqIEBzZWVhbHNvIG9ucy1wcm9ncmVzcy1iYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1wcm9ncmVzcy1iYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBiYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICB2YWx1ZT1cIjU1XCJcbiAqICBzZWNvbmRhcnktdmFsdWU9XCI4N1wiPlxuICogPC9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+XG4gKlxuICogPG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogIGluZGV0ZXJtaW5hdGU+XG4gKiA8L29ucy1wcm9ncmVzcy1jaXJjdWxhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gICAqICAgW2phXeODl+ODreOCsOODrOOCueOCpOODs+OCuOOCseODvOOCv+OBruimi+OBn+ebruOCkuWkieabtOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2Vjb25kYXJ5LXZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluZGV0ZXJtaW5hdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICd2YWx1ZScsICdzZWNvbmRhcnktdmFsdWUnLCBJTkRFVF07XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKElOREVUKSAmJiB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IElOREVUKSB7XG4gICAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVEZXRlcm1pbmF0ZSgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdXRpbC50b2dnbGVNb2RpZmllcih0aGlzLCBJTkRFVCwgeyBmb3JjZTogdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpIH0pKTtcbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlciA9IE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAqIDI1MS4zMiAqIDAuMDEpO1xuICAgICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGVyID0gIE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLmRpc3BsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGVbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHBlciArICclLCAyNTEuMzIlJztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNlY29uZGFyeVZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuICBzZXQgc2Vjb25kYXJ5VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCB2YWx1ZSA8IDAgfHwgdmFsdWUgPiAxMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnLCBNYXRoLmZsb29yKHZhbHVlKSk7XG4gIH1cblxuICBnZXQgc2Vjb25kYXJ5VmFsdWUoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpbmRldGVybWluYXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWAsIGFuIGluZmluaXRlIGxvb3BpbmcgYW5pbWF0aW9uIHdpbGwgYmUgc2hvd24uWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Or44O844OX44GZ44KL44Ki44OL44Oh44O844K344On44Oz44GM6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNldCBpbmRldGVybWluYXRlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShJTkRFVCwgJycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKElOREVUKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzQ29tcGlsZWQoKSkge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWNpcmN1bGFyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaW1hcnkgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSwgJy5wcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeScpO1xuICAgIHRoaXMuX3NlY29uZGFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknKTtcblxuICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2lzQ29tcGlsZWQoKSB7XG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWNpcmN1bGFyJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdmcgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWNpcmN1bGFyJyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHN2ZywgJy5wcm9ncmVzcy1jaXJjdWxhcl9fc2Vjb25kYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHN2ZywgJy5wcm9ncmVzcy1jaXJjdWxhcl9fcHJpbWFyeScpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlByb2dyZXNzQ2lyY3VsYXIgPSBQcm9ncmVzc0NpcmN1bGFyRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXByb2dyZXNzLWNpcmN1bGFyJywgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uL29ucy9hbmltaXQnO1xuXG5jb25zdCBTVEFURV9JTklUSUFMID0gJ2luaXRpYWwnO1xuY29uc3QgU1RBVEVfUFJFQUNUSU9OID0gJ3ByZWFjdGlvbic7XG5jb25zdCBTVEFURV9BQ1RJT04gPSAnYWN0aW9uJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHVsbC1ob29rXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdGhhdCBhZGRzICoqUHVsbCB0byByZWZyZXNoKiogZnVuY3Rpb25hbGl0eSB0byBhbiBgPG9ucy1wYWdlPmAgZWxlbWVudC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBhIHRhc2sgd2hlbiB0aGUgdXNlciBwdWxscyBkb3duIGF0IHRoZSB0b3Agb2YgdGhlIHBhZ2UuIEEgY29tbW9uIHVzYWdlIGlzIHRvIHJlZnJlc2ggdGhlIGRhdGEgZGlzcGxheWVkIGluIGEgcGFnZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBXYkpvZ01cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wdWxsLWhvb2tcbiAqIEBleGFtcGxlXG4gKiA8b25zLXBhZ2U+XG4gKiAgIDxvbnMtcHVsbC1ob29rPlxuICogICAgIFJlbGVhc2UgdG8gcmVmcmVzaFxuICogICA8L29ucy1wdWxsLWhvb2s+XG4gKiA8L29ucy1wYWdlPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ29ucy1wdWxsLWhvb2snKS5vbkFjdGlvbiA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAqICAgICBzZXRUaW1lb3V0KGRvbmUsIDEwMDApO1xuICogICB9O1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1bGxIb29rRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IGNoYW5nZXN0YXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBzdGF0ZSBpcyBjaGFuZ2VkLiBUaGUgc3RhdGUgY2FuIGJlIGVpdGhlciBcImluaXRpYWxcIiwgXCJwcmVhY3Rpb25cIiBvciBcImFjdGlvblwiLlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBrueKtuaFi+OBjOWkieOCj+OBo+OBn+WgtOWQiOOBq+eZuueBq+OBl+OBvuOBmeOAgueKtuaFi+OBr+OAgVwiaW5pdGlhbFwiLCBcInByZWFjdGlvblwiLCBcImFjdGlvblwi44Gu44GE44Ga44KM44GL44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucHVsbEhvb2tcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQuc3RhdGVcbiAgICogICBbZW5dQ3VycmVudCBzdGF0ZS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7nirbmhYvlkI3jgpLlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBcInB1bGwtdG8tcmVmcmVzaFwiIGZ1bmN0aW9uYWxpdHkgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CBZGlzYWJsZWTnirbmhYvjgavjgarjgorjgqLjgq/jgrfjg6fjg7PjgYzlrp/ooYzjgZXjgozjgarjgY/jgarjgorjgb7jgZlbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBoZWlnaHRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50LiBXaGVuIHB1bGxlZCBkb3duIGZ1cnRoZXIgdGhhbiB0aGlzIHZhbHVlIGl0IHdpbGwgc3dpdGNoIHRvIHRoZSBcInByZWFjdGlvblwiIHN0YXRlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIjY0cHhcIi5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7pq5jjgZXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7pq5jjgZXku6XkuIrjgatwdWxsIGRvd27jgZnjgovjgahcInByZWFjdGlvblwi54q25oWL44Gr56e76KGM44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44Gu5YCk44GvXCI2NHB4XCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0aHJlc2hvbGQtaGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSB0aHJlc2hvbGQgaGVpZ2h0LiBUaGUgY29tcG9uZW50IGF1dG9tYXRpY2FsbHkgc3dpdGNoZXMgdG8gdGhlIFwiYWN0aW9uXCIgc3RhdGUgd2hlbiBwdWxsZWQgZnVydGhlciB0aGFuIHRoaXMgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIFwiOTZweFwiLiBBIG5lZ2F0aXZlIHZhbHVlIG9yIGEgdmFsdWUgbGVzcyB0aGFuIHRoZSBoZWlnaHQgd2lsbCBkaXNhYmxlIHRoaXMgcHJvcGVydHkuWy9lbl1cbiAgICogICBbamFd6Za+5YCk44Go44Gq44KL6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu5YCk44Gn5oyH5a6a44GX44Gf6auY44GV44KI44KK44KCcHVsbCBkb3du44GZ44KL44Go44CB44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gv6Ieq5YuV55qE44GrXCJhY3Rpb25cIueKtuaFi+OBq+enu+ihjOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZpeGVkLWNvbnRlbnRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY29udGVudCBvZiB0aGUgcGFnZSB3aWxsIG5vdCBtb3ZlIHdoZW4gcHVsbGluZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg5fjg6vjg5Xjg4Pjgq/jgYzlvJXjgY3lh7rjgZXjgozjgabjgYTjgovmmYLjgavjgoLjgrPjg7Pjg4bjg7Pjg4Tjga/li5XjgY3jgb7jgZvjgpPjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fb25EcmFnID0gdGhpcy5fb25EcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRHJhZ0VuZCA9IHRoaXMuX29uRHJhZ0VuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2Nyb2xsID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9wcmV2ZW50U2Nyb2xsID0gdGhpcy5fcHJldmVudFNjcm9sbC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCwgdHJ1ZSk7XG4gICAgdGhpcy5faGlkZSgpOyAvLyBGaXggZm9yIHRyYW5zcGFyZW50IHRvb2xiYXIgdHJhbnNpdGlvbnNcbiAgfVxuXG4gIF9zZXRTdHlsZSgpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCArICdweCc7XG4gICAgc3R5bGVyKHRoaXMsIHsgaGVpZ2h0LCBsaW5lSGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID09PSAnJyAmJiB0aGlzLl9zaG93KCk7XG4gIH1cblxuICBfb25TY3JvbGwoZXZlbnQpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fcGFnZUVsZW1lbnQ7XG5cbiAgICBpZiAoZWxlbWVudC5zY3JvbGxUb3AgPCAwKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IDA7XG4gICAgfVxuICB9XG5cbiAgX2NhbkNvbnN1bWVHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICByZXR1cm4gZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICd1cCcgfHwgZ2VzdHVyZS5kaXJlY3Rpb24gPT09ICdkb3duJztcbiAgfVxuXG4gIF9vbkRyYWdTdGFydChldmVudCkge1xuICAgIGlmICghZXZlbnQuZ2VzdHVyZSB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faWdub3JlRHJhZyA9IGV2ZW50LmNvbnN1bWVkO1xuXG4gICAgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICBjb25zdCBjb25zdW1lID0gZXZlbnQuY29uc3VtZTtcbiAgICAgIGV2ZW50LmNvbnN1bWUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN1bWUgJiYgY29uc3VtZSgpO1xuICAgICAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTtcbiAgICAgICAgLy8gVGhpcyBlbGVtZW50cyByZXNpemVzIC5wYWdlX19jb250ZW50IHNvIGl0IGlzIHNhZmVyXG4gICAgICAgIC8vIHRvIGhpZGUgaXQgd2hlbiBvdGhlciBjb21wb25lbnRzIGFyZSBkcmFnZ2VkLlxuICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fY2FuQ29uc3VtZUdlc3R1cmUoZXZlbnQuZ2VzdHVyZSkpIHtcbiAgICAgICAgY29uc3VtZSAmJiBjb25zdW1lKCk7XG4gICAgICAgIGV2ZW50LmNvbnN1bWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2hvdygpOyAvLyBOb3QgZW5vdWdoIGR1ZSB0byAnZHJhZ0xvY2tBeGlzJ1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXJ0U2Nyb2xsID0gdGhpcy5fcGFnZUVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG5cbiAgX29uRHJhZyhldmVudCkge1xuICAgIGlmICghZXZlbnQuZ2VzdHVyZSB8fCB0aGlzLmRpc2FibGVkIHx8IHRoaXMuX2lnbm9yZURyYWcgfHwgIXRoaXMuX2NhbkNvbnN1bWVHZXN0dXJlKGV2ZW50Lmdlc3R1cmUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTmVjZXNzYXJ5IGR1ZSB0byAnZHJhZ0xvY2tBeGlzJyAoMjVweClcbiAgICBpZiAodGhpcy5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIHRoaXMuX3Nob3coKTtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIC8vIEhhY2sgdG8gbWFrZSBpdCB3b3JrIG9uIEFuZHJvaWQgNC40IFdlYlZpZXcgYW5kIGlPUyBVSVdlYlZpZXcuIFNjcm9sbHMgbWFudWFsbHlcbiAgICAvLyBuZWFyIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc28gdGhlcmUgd2lsbCBiZSBubyBpbmVydGlhbCBzY3JvbGwgd2hlbiBzY3JvbGxpbmcgZG93bi5cbiAgICAvLyBBbGxvd2luZyBkZWZhdWx0IHNjcm9sbGluZyB3aWxsIGtpbGwgYWxsICd0b3VjaG1vdmUnIGV2ZW50cy5cbiAgICB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9zdGFydFNjcm9sbCAtIGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuICAgIGlmICh0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3AgPCB3aW5kb3cuaW5uZXJIZWlnaHQgJiYgZXZlbnQuZ2VzdHVyZS5kaXJlY3Rpb24gIT09ICd1cCcpIHtcbiAgICAgIGV2ZW50Lmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGwgPSBNYXRoLm1heChldmVudC5nZXN0dXJlLmRlbHRhWSAtIHRoaXMuX3N0YXJ0U2Nyb2xsLCAwKTtcbiAgICBpZiAoc2Nyb2xsICE9PSB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24pIHtcbiAgICAgIGlmICh0aGlzLl90aHJlc2hvbGRIZWlnaHRFbmFibGVkKCkgJiYgc2Nyb2xsID49IHRoaXMudGhyZXNob2xkSGVpZ2h0KSB7XG4gICAgICAgIGV2ZW50Lmdlc3R1cmUuc3RvcERldGVjdCgpO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fZmluaXNoKCkpO1xuXG4gICAgICB9IGVsc2UgaWYgKHNjcm9sbCA+PSB0aGlzLmhlaWdodCkge1xuICAgICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9QUkVBQ1RJT04pO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHVsbGluZyA9IHRydWU7XG4gICAgICB0aGlzLl90cmFuc2xhdGVUbyhzY3JvbGwpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWdFbmQoZXZlbnQpIHtcbiAgICB0aGlzLl9wdWxsaW5nID0gZmFsc2U7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA+IDApIHtcbiAgICAgIGNvbnN0IHNjcm9sbCA9IHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbjtcblxuICAgICAgaWYgKHNjcm9sbCA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlVG8oMCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfcHJldmVudFNjcm9sbChldmVudCkge1xuICAgIC8vIEZpeCBmb3IgQW5kcm9pZCAmIGlPUyB3aGVuIHN0YXJ0aW5nIGZyb20gc2Nyb2xsVG9wID4gMCBvciBwdWxsaW5nIGJhY2tcbiAgICB0aGlzLl9wdWxsaW5nICYmIGV2ZW50LmNhbmNlbGFibGUgJiYgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25BY3Rpb25cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgYGFjdGlvbmAgc3RhdGUgaWYgaXQgZXhpc3RzLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBnaXZlbiBhIGBkb25lYCBjYWxsYmFjayBhcyBpdCdzIGZpcnN0IGFyZ3VtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uQWN0aW9uO1xuICB9XG5cbiAgc2V0IG9uQWN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ29uQWN0aW9uJyBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgbnVsbGApO1xuICAgIH1cbiAgICB0aGlzLl9vbkFjdGlvbiA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblB1bGxcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSG9vayBjYWxsZWQgd2hlbmV2ZXIgdGhlIHVzZXIgcHVsbHMgdGhlIGVsZW1lbnQuIEl0IGdldHMgdGhlIHB1bGxlZCBkaXN0YW5jZSByYXRpbyAoc2Nyb2xsIC8gaGVpZ2h0KSBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25QdWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9vblB1bGw7XG4gIH1cblxuICBzZXQgb25QdWxsKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ29uUHVsbCcgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIG51bGwuYClcbiAgICB9XG4gICAgdGhpcy5fb25QdWxsID0gdmFsdWU7XG4gIH1cblxuICBfZmluaXNoKCkge1xuICAgIHRoaXMuX3NldFN0YXRlKFNUQVRFX0FDVElPTik7XG4gICAgdGhpcy5fdHJhbnNsYXRlVG8odGhpcy5oZWlnaHQsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5vbkFjdGlvbiB8fCAoZG9uZSA9PiBkb25lKCkpO1xuICAgIGFjdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLl90cmFuc2xhdGVUbygwLCB7YW5pbWF0ZTogdHJ1ZX0pO1xuICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDY0cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGhlaWdodCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnNjQnLCAxMCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHRocmVzaG9sZEhlaWdodFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHRocmVzaG9sZEhlaWdodCBvZiB0aGUgcHVsbCBob29rIGluIHBpeGVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgYDk2cHhgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXQgdGhyZXNob2xkSGVpZ2h0KHZhbHVlKSB7XG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcih2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRocmVzaG9sZCBoZWlnaHQgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnLCBgJHt2YWx1ZX1weGApO1xuICB9XG5cbiAgZ2V0IHRocmVzaG9sZEhlaWdodCgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3RocmVzaG9sZC1oZWlnaHQnKSB8fCAnOTYnLCAxMCk7XG4gIH1cblxuICBfdGhyZXNob2xkSGVpZ2h0RW5hYmxlZCgpIHtcbiAgICBjb25zdCB0aCA9IHRoaXMudGhyZXNob2xkSGVpZ2h0O1xuICAgIHJldHVybiB0aCA+IDAgJiYgdGggPj0gdGhpcy5oZWlnaHQ7XG4gIH1cblxuICBfc2V0U3RhdGUoc3RhdGUsIG5vRXZlbnQpIHtcbiAgICBjb25zdCBsYXN0U3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXRlJywgc3RhdGUpO1xuXG4gICAgaWYgKCFub0V2ZW50ICYmIGxhc3RTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjaGFuZ2VzdGF0ZScsIHtcbiAgICAgICAgcHVsbEhvb2s6IHRoaXMsXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgbGFzdFN0YXRlOiBsYXN0U3RhdGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc3RhdGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdzdGF0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwdWxsRGlzdGFuY2VcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBudW1iZXIgb2YgcGl4ZWxzIHRoZSBwdWxsIGhvb2sgaGFzIG1vdmVkLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODl+ODq+ODleODg+OCr+OBjOW8leOBjeWHuuOBleOCjOOBn+i3nembouOCkuODlOOCr+OCu+ODq+aVsOOAglsvamFdXG4gICAqL1xuICBnZXQgcHVsbERpc3RhbmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgLy8gUnVuIGFzeW5jcmhvbm91c2x5IHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIEFuaW1pdCdzIHN0eWxlIGNsZWFuXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgaWYgKHRoaXMuX3BhZ2VFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3BhZ2VFbGVtZW50LnN0eWxlLm1hcmdpblRvcCA9IGAtJHt0aGlzLmhlaWdodH1weGA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWYgKHRoaXMuX3BhZ2VFbGVtZW50KSB7XG4gICAgICB0aGlzLl9wYWdlRWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSAnJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNjcm9sbFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICovXG4gIF90cmFuc2xhdGVUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPT0gMCAmJiBzY3JvbGwgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IHNjcm9sbDtcbiAgICBjb25zdCBvcHQgPSBvcHRpb25zLmFuaW1hdGUgPyB7IGR1cmF0aW9uOiAuMywgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJyB9IDoge307XG4gICAgdGhpcy5fb25QdWxsICYmIHRoaXMuX29uUHVsbCgoc2Nyb2xsIC8gdGhpcy5oZWlnaHQpLnRvRml4ZWQoMiksIG9wdCk7XG4gICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9ICB0aGlzLmhhc0F0dHJpYnV0ZSgnZml4ZWQtY29udGVudCcpID8gdGhpcyA6IHRoaXMuX3BhZ2VFbGVtZW50O1xuXG4gICAgYW5pbWl0KHNjcm9sbEVsZW1lbnQpXG4gICAgICAucXVldWUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwcHgsICR7c2Nyb2xsfXB4LCAwcHgpYCB9LCBvcHQpXG4gICAgICAucGxheSgoKSA9PiB7XG4gICAgICAgIHNjcm9sbCA9PT0gMCAmJiBzdHlsZXIuY2xlYXIoc2Nyb2xsRWxlbWVudCwgJ3RyYW5zaXRpb24gdHJhbnNmb3JtJyk7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvcHRpb25zLmNhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICBfZGlzYWJsZURyYWdMb2NrKCkgeyAvLyBlMmUgdGVzdHMgbmVlZCBpdFxuICAgIHRoaXMuX2RyYWdMb2NrRGlzYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKHRydWUpO1xuICB9XG5cbiAgX3NldHVwTGlzdGVuZXJzKGFkZCkge1xuICAgIGNvbnN0IHNjcm9sbFRvZ2dsZSA9IGFjdGlvbiA9PiB0aGlzLl9wYWdlRWxlbWVudFtgJHthY3Rpb259RXZlbnRMaXN0ZW5lcmBdKCdzY3JvbGwnLCB0aGlzLl9vblNjcm9sbCwgZmFsc2UpO1xuICAgIGNvbnN0IGdkVG9nZ2xlID0gYWN0aW9uID0+IHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZ2VuZCcsIHRoaXMuX29uRHJhZ0VuZCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgndG91Y2htb3ZlJywgdGhpcy5fcHJldmVudFNjcm9sbCk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIGdkVG9nZ2xlKCdvZmYnKTtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBudWxsO1xuICAgIH1cbiAgICBzY3JvbGxUb2dnbGUoJ3JlbW92ZScpO1xuXG4gICAgaWYgKGFkZCkge1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbmV3IEdlc3R1cmVEZXRlY3Rvcih0aGlzLl9wYWdlRWxlbWVudCwge1xuICAgICAgICBkcmFnTWluRGlzdGFuY2U6IDEsXG4gICAgICAgIGRyYWdEaXN0YW5jZUNvcnJlY3Rpb246IGZhbHNlLFxuICAgICAgICBkcmFnTG9ja1RvQXhpczogIXRoaXMuX2RyYWdMb2NrRGlzYWJsZWRcbiAgICAgIH0pO1xuXG4gICAgICBnZFRvZ2dsZSgnb24nKTtcbiAgICAgIHNjcm9sbFRvZ2dsZSgnYWRkJyk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID0gMDtcbiAgICB0aGlzLl9wYWdlRWxlbWVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKHRydWUpO1xuICAgIHRoaXMuX3NldFN0eWxlKCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9oaWRlKCk7XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnMoZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnaGVpZ2h0J107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnaGVpZ2h0JyAmJiB0aGlzLl9wYWdlRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydjaGFuZ2VzdGF0ZSddXG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlB1bGxIb29rID0gUHVsbEhvb2tFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHVsbC1ob29rJywgUHVsbEhvb2tFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgQmFzZUlucHV0RWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1pbnB1dCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdyYW5nZS0tKicsXG4gICcucmFuZ2VfX2lucHV0JzogJ3JhbmdlLS0qX19pbnB1dCcsXG4gICcucmFuZ2VfX2ZvY3VzLXJpbmcnOiAncmFuZ2UtLSpfX2ZvY3VzLXJpbmcnXG59O1xuXG5jb25zdCBhY3RpdmVDbGFzc1Rva2VuID0gJ3JhbmdlX19pbnB1dC0tYWN0aXZlJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmFuZ2VcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzbGlkZXJbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgUmFuZ2UgaW5wdXQgY29tcG9uZW50LiBVc2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgc2xpZGVyLlxuICpcbiAqICAgICBXb3JrcyB2ZXJ5IHNpbWlsYXIgdG8gdGhlIGA8aW5wdXQgdHlwZT1cInJhbmdlXCI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhaUW9tTVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3JhbmdlXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLWlucHV0PmAgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSB0ZXh0IGlucHV0cywgcmFkaW8gYnV0dG9ucyBhbmQgY2hlY2tib3hlcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXJhbmdlIHZhbHVlPVwiMjBcIj48L29ucy1yYW5nZT5cbiAqIDxvbnMtcmFuZ2UgbW9kaWZpZXI9XCJtYXRlcmlhbFwiIHZhbHVlPVwiMTBcIj48L3JhbmdlPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhbmdlRWxlbWVudCBleHRlbmRzIEJhc2VJbnB1dEVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9ib3VuZE9uTW91c2VEb3duID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uTW91c2VVcCA9IHRoaXMuX29uTW91c2VVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25Ub3VjaFN0YXJ0ID0gdGhpcy5fb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fYm91bmRPblRvdWNoRW5kID0gdGhpcy5fb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25JbnB1dCA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnc3RhcnQgPSB0aGlzLl9vbkRyYWdzdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnZW5kID0gdGhpcy5fb25EcmFnZW5kLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBzdXBlci5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKTtcbiAgfVxuXG4gIC8qIEluaGVyaXRlZCBwcm9wcyAqL1xuXG4gIF91cGRhdGUoKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICBjb25zdCBmb2N1c1JpbmcgPSB0aGlzLl9mb2N1c1Jpbmc7XG5cbiAgICBpbnB1dC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGAkezEwMCAqIHRoaXMuX3JhdGlvfSUgMnB4YDtcbiAgICBmb2N1c1JpbmcudmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgLy8gTk9URTogXCJfemVyb1wiIGF0dHJpYnV0ZSBpcyB1c2VkIGZvciBDU1Mgc3R5bGluZy5cbiAgICBpZiAoKGlucHV0Lm1pbiA9PT0gJycgJiYgaW5wdXQudmFsdWUgPT09ICcwJykgfHwgaW5wdXQubWluID09PSBpbnB1dC52YWx1ZSkge1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdfemVybycsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdfemVybycpO1xuICAgIH1cblxuICAgIFsnbWluJywgJ21heCddLmZvckVhY2goYXR0ciA9PiBmb2N1c1JpbmdbYXR0cl0gPSBpbnB1dFthdHRyXSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2lucHV0XCI+XG4gICAgICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJyYW5nZV9fZm9jdXMtcmluZ1wiIHRhYkluZGV4PVwiLTFcIj5cbiAgICBgO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAncmFuZ2UnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdyYW5nZSc7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBfb25Nb3VzZURvd24oZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoYWN0aXZlQ2xhc3NUb2tlbik7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2lucHV0LmZvY3VzKCkpO1xuICB9XG5cbiAgX29uVG91Y2hTdGFydChlKSB7XG4gICAgdGhpcy5fb25Nb3VzZURvd24oKTtcbiAgfVxuXG4gIF9vbk1vdXNlVXAoZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlQ2xhc3NUb2tlbik7XG4gIH1cblxuICBfb25Ub3VjaEVuZChlKSB7XG4gICAgdGhpcy5fb25Nb3VzZVVwKGUpO1xuICB9XG5cbiAgX29uRHJhZ3N0YXJ0KGUpIHtcbiAgICBlLmNvbnN1bWVkID0gdHJ1ZTtcbiAgICBlLmdlc3R1cmUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZChhY3RpdmVDbGFzc1Rva2VuKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIF9vbkRyYWdlbmQoZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlQ2xhc3NUb2tlbik7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgfVxuXG4gIGdldCBfZm9jdXNSaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzFdO1xuICB9XG5cbiAgZ2V0IF9yYXRpbygpIHtcbiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhdGlvLlxuICAgIGNvbnN0IG1pbiA9IHRoaXMuX2lucHV0Lm1pbiA9PT0gJycgPyAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWluKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9pbnB1dC5tYXggPT09ICcnID8gMTAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWF4KTtcblxuICAgIHJldHVybiAodGhpcy52YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2Rpc2FibGVkJywgLi4uQmFzZUlucHV0RWxlbWVudC5vYnNlcnZlZEF0dHJpYnV0ZXNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoY3VycmVudCk7XG4gICAgfVxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICBfdXBkYXRlRGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncmFuZ2UtLWRpc2FibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UtLWRpc2FibGVkJyk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9ib3VuZE9uTW91c2VEb3duKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9ib3VuZE9uTW91c2VVcCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fYm91bmRPblRvdWNoU3RhcnQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ib3VuZE9uVG91Y2hFbmQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fYm91bmRPbkRyYWdzdGFydCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdlbmQpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9ib3VuZE9uTW91c2VEb3duKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9ib3VuZE9uTW91c2VVcCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fYm91bmRPblRvdWNoU3RhcnQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ib3VuZE9uVG91Y2hFbmQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fYm91bmRPbkRyYWdzdGFydCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpcy5fYm91bmRPbkRyYWdlbmQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9ib3VuZE9uSW5wdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xufVxuXG5vbnMuZWxlbWVudHMuUmFuZ2UgPSBSYW5nZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yYW5nZScsIFJhbmdlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNiBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcblxuLyoqXG4gKiBAY2xhc3MgQW5pbWF0b3JDU1MgLSBpbXBsZW1lbnRhdGlvbiBvZiBBbmltYXRvciBjbGFzcyB1c2luZyBjc3MgdHJhbnNpdGlvbnNcbiAqL1xuY2xhc3MgQW5pbWF0b3JDU1Mge1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGFuaW1hdGVcbiAgICogQGRlc2MgbWFpbiBhbmltYXRpb24gZnVuY3Rpb25cbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmaW5hbENTU1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF0gLSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7T2JqZWN0fSByZXN1bHRcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC50aGVuKGNhbGxiYWNrKSAtIHNldHMgYSBjYWxsYmFjayB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGhhcyBzdG9wcGVkXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3RvcChvcHRpb25zKSAtIHN0b3BzIHRoZSBhbmltYXRpb247IGlmIG9wdGlvbnMuc3RvcE5leHQgaXMgdHJ1ZSB0aGVuIGl0IGRvZXNuJ3QgY2FsbCB0aGUgY2FsbGJhY2tcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5maW5pc2gobXMpIC0gZmluaXNoZXMgdGhlIGFuaW1hdGlvbiBpbiB0aGUgc3BlY2lmaWVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSByZXN1bHQuc3BlZWQobXMpIC0gc2V0cyB0aGUgYW5pbWF0aW9uIHNwZWVkIHNvIHRoYXQgaXQgZmluaXNoZXMgYXMgaWYgdGhlIG9yaWdpbmFsIGR1cmF0aW9uIHdhcyB0aGUgb25lIHNwZWNpZmllZCBoZXJlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGBcbiAgICogIHZhciByZXN1bHQgPSBhbmltYXRvci5hbmltYXRlKGVsLCB7b3BhY2l0eTogMC41fSwgMTAwMCk7XG4gICAqXG4gICAqICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgKiAgICByZXN1bHQuc3BlZWQoMjAwKS50aGVuKGZ1bmN0aW9uKCl7XG4gICAqICAgICAgY29uc29sZS5sb2coJ2RvbmUnKTtcbiAgICogICAgfSk7XG4gICAqICB9LCAzMDApO1xuICAgKiBgYGBgXG4gICAqL1xuICBhbmltYXRlKGVsLCBmaW5hbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICB2YXIgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICBpbml0aWFsID0ge30sXG4gICAgICAgIHN0b3BwZWQgPSBmYWxzZSxcbiAgICAgICAgbmV4dCA9IGZhbHNlLFxuICAgICAgICB0aW1lb3V0ID0gZmFsc2UsXG4gICAgICAgIHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhmaW5hbCk7XG5cbiAgICB2YXIgdXBkYXRlU3R5bGVzID0gKCkgPT4ge1xuICAgICAgbGV0IHMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICBwcm9wZXJ0aWVzLmZvckVhY2gocy5nZXRQcm9wZXJ0eVZhbHVlLmJpbmQocykpO1xuICAgICAgcyA9IGVsLm9mZnNldEhlaWdodDtcbiAgICB9O1xuXG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgIHN0b3A6IChvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHZhciBrID0gTWF0aC5taW4oMSwgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSBzdGFydCkgLyBkdXJhdGlvbik7XG4gICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICBlbC5zdHlsZVtpXSA9ICgxIC0gaykgKiBpbml0aWFsW2ldICsgayAqIGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuc3RvcE5leHQpIHtcbiAgICAgICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0b3BwZWQpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHRoZW46IChjYikgPT4ge1xuICAgICAgICBuZXh0ID0gY2I7XG4gICAgICAgIGlmIChzdG9wcGVkKSB7XG4gICAgICAgICAgbmV4dCAmJiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBzcGVlZDogKG5ld0R1cmF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChpbnRlcm5hbC5jb25maWcuYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gICAgICAgICAgbmV3RHVyYXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgIHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXG4gICAgICAgICAgY29uc3QgcGFzc2VkID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0O1xuICAgICAgICAgIGNvbnN0ICBrID0gcGFzc2VkIC8gZHVyYXRpb247XG4gICAgICAgICAgY29uc3QgcmVtYWluaW5nID0gbmV3RHVyYXRpb24gKiAoMSAtIGspO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgICAgZWwuc3R5bGVbaV0gPSAoMSAtIGspICogaW5pdGlhbFtpXSArIGsgKiBmaW5hbFtpXSArIChpID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB1cGRhdGVTdHlsZXMoKTtcblxuICAgICAgICAgIHN0YXJ0ID0gZWwuc3BlZWRVcFRpbWU7XG4gICAgICAgICAgZHVyYXRpb24gPSByZW1haW5pbmc7XG5cbiAgICAgICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZVtpXSA9IGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc3VsdC5zdG9wLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgZmluaXNoOiAobWlsbGlzZWNvbmRzID0gNTApID0+IHtcbiAgICAgICAgdmFyIGsgPSAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uO1xuXG4gICAgICAgIHJlc3VsdC5zcGVlZChtaWxsaXNlY29uZHMgLyAoMSAtIGspKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBzdG9wcGVkIHx8IGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgIGNvbnN0IHYgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoZSkpO1xuICAgICAgaW5pdGlhbFtlXSA9IGlzTmFOKHYpID8gMCA6IHY7XG4gICAgfSk7XG5cblxuICAgIGlmICghc3RvcHBlZCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gcHJvcGVydGllcy5qb2luKCcsJyk7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cbiAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgZWwuc3R5bGVbZV0gPSBmaW5hbFtlXSArIChlID09ICdvcGFjaXR5JyA/ICcnIDogJ3B4Jyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChyZXN1bHQuc3RvcCwgZHVyYXRpb24pO1xuICAgIHRoaXMuX29uU3RvcEFuaW1hdGlvbnMoZWwsIHJlc3VsdC5zdG9wKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2luZGV4ID0gMDtcbiAgfVxuXG4gIF9vblN0b3BBbmltYXRpb25zKGVsLCBsaXN0ZW5lcikge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIHZhciBpID0gdGhpcy5faW5kZXgrKztcbiAgICBxdWV1ZVtlbF0gPSBxdWV1ZVtlbF0gfHwgW107XG4gICAgcXVldWVbZWxdW2ldID0gKG9wdGlvbnMpID0+IHtcbiAgICAgIGRlbGV0ZSBxdWV1ZVtlbF1baV07XG4gICAgICBpZiAocXVldWVbZWxdICYmIHF1ZXVlW2VsXS5sZW5ndGggPT0gMCkge1xuICAgICAgICBkZWxldGUgcXVldWVbZWxdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpc3RlbmVyKG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIHN0b3BBbmltYXRpb25zXG4gICogQGRlc2Mgc3RvcHMgYWN0aXZlIGFuaW1hdGlvbnMgb24gYSBzcGVjaWZpZWQgZWxlbWVudFxuICAqIEBwYXJhbSB7RWxlbWVudHxBcnJheX0gZWxlbWVudCAtIGVsZW1lbnQgb3IgYXJyYXkgb2YgZWxlbWVudHNcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dXG4gICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdG9wTmV4dF0gLSB0aGUgY2FsbGJhY2tzIGFmdGVyIHRoZSBhbmltYXRpb25zIHdvbid0IGJlIGNhbGxlZCBpZiB0aGlzIG9wdGlvbiBpcyB0cnVlXG4gICovXG4gIHN0b3BBbmltYXRpb25zKGVsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbCkpIHtcbiAgICAgIHJldHVybiBlbC5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9ucyhlbCwgb3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAodGhpcy5fcXVldWVbZWxdIHx8IFtdKS5mb3JFYWNoKGUgPT4geyBlKG9wdGlvbnMgfHwge30pOyB9KTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2Qgc3RvcEFsbFxuICAqIEBkZXNjIHN0b3BzIGFsbCBhY3RpdmUgYW5pbWF0aW9uc1xuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcbiAgKi9cbiAgc3RvcEFsbChvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLnN0b3BBbmltYXRpb25zKE9iamVjdC5rZXlzKHRoaXMuX3F1ZXVlKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgKiBAbWV0aG9kIGZhZGVcbiAgKiBAZGVzYyBmYWRlcyB0aGUgZWxlbWVudCAoc2hvcnQgdmVyc2lvbiBmb3IgYW5pbWF0ZShlbCwge29wYWNpdHk6IDB9KSlcbiAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgKiBAcGFyYW0ge251bWJlcn0gW2R1cmF0aW9uPTIwMF1cbiAgKi9cbiAgZmFkZShlbCwgZHVyYXRpb24gPSAyMDApIHtcbiAgICByZXR1cm4gdGhpcy5hbmltYXRlKGVsLCB7b3BhY2l0eTogMH0sIGR1cmF0aW9uKTtcbiAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEFuaW1hdG9yQ1NTO1xuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uLy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci1jc3MnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdyaXBwbGUnO1xuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3JpcHBsZS0tKicsXG4gICcucmlwcGxlX193YXZlJzogJ3JpcHBsZS0tKl9fd2F2ZScsXG4gICcucmlwcGxlX19iYWNrZ3JvdW5kJzogJ3JpcHBsZS0tKl9fYmFja2dyb3VuZCcsXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yaXBwbGVcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWRkcyBhIE1hdGVyaWFsIERlc2lnbiBcInJpcHBsZVwiIGVmZmVjdCB0byBhbiBlbGVtZW50LiBUaGUgcmlwcGxlIGVmZmVjdCB3aWxsIHNwcmVhZCBmcm9tIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgdXNlciB0YXBzLlxuICpcbiAqICAgICBTb21lIGVsZW1lbnRzIHN1Y2ggYXMgYDxvbnMtYnV0dG9uPmAgYW5kIGA8b25zLWZhYj5gICBzdXBwb3J0IGEgYHJpcHBsZWAgYXR0cmlidXRlLlxuICogICBbL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oq44OD44OX44Or5Yq55p6c44KSRE9N6KaB57Sg44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHdLUVdkWlxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3JpcHBsZVxuICogQG1vZGlmaWVyIGxpZ2h0LWdyYXlcbiAqICAgW2VuXUNoYW5nZSB0aGUgY29sb3Igb2YgZWZmZWN0cyB0byBsaWdodCBncmF5LlsvZW5dXG4gKiAgIFtqYV3jgqjjg5Xjgqfjgq/jg4jjga7oibLjgYzmmI7jgovjgYTngbDoibLjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nXG4gKiAgW2VuXUNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVxuICogIFtqYV1Dcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8ZGl2IGNsYXNzPVwibXktZGl2XCI+XG4gKiAgPG9ucy1yaXBwbGU+PC9vbnMtcmlwcGxlPlxuICogPC9kaXY+XG4gKlxuICogQGV4YW1wbGVcbiAqIDxvbnMtYnV0dG9uIHJpcHBsZT5DbGljayBtZSE8L29ucy1idXR0b24+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJpcHBsZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvbG9yIG9mIHRoZSByaXBwbGUgZWZmZWN0LlsvZW5dXG4gICAqICAgW2phXeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqjjg5Xjgqfjgq/jg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBiYWNrZ3JvdW5kXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZC5bL2VuXVxuICAgKiAgIFtqYV3og4zmma/jga7oibLjgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaXppbmcgb2YgdGhlIHdhdmUgb24gcmlwcGxlIGVmZmVjdC4gU2V0IFwiY292ZXJcIiBvciBcImNvbnRhaW5cIi4gRGVmYXVsdCBpcyBcImNvdmVyXCIuWy9lbl1cbiAgICogICBbamFd44Ko44OV44Kn44Kv44OI44Gu44K144Kk44K644KS5oyH5a6a44GX44G+44GZ44CCXCJjb3Zlclwi44KC44GX44GP44GvXCJjb250YWluXCLjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cImNvdmVyXCLjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjZW50ZXJcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBwcmVzZW50cywgY2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB3YXZlIGVmZmVjdCB0byBjZW50ZXIgb2YgdGhlIHRhcmdldCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOCkuioreWumuOBmeOCi+OBqOOAgeOCqOODleOCp+OCr+ODiOOBruS9jee9ruOBjOimgee0oOOBruecn+OCk+S4reOBi+OCieWni+OBvuOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQsIHRoZSByaXBwbGUgZWZmZWN0IHdpbGwgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5aC05ZCI44CB44Oq44OD44OX44Or44Ko44OV44Kn44Kv44OI44Gv54Sh5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuICAgIFsnY29sb3InLCAnY2VudGVyJywgJ3N0YXJ0LXJhZGl1cycsICdiYWNrZ3JvdW5kJywgJ21vZGlmaWVyJ10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGUsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIHRoaXMuX3dhdmUgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpcHBsZV9fd2F2ZScpWzBdO1xuICAgIHRoaXMuX2JhY2tncm91bmQgPSB0aGlzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JpcHBsZV9fYmFja2dyb3VuZCcpWzBdO1xuXG4gICAgaWYgKCEodGhpcy5fYmFja2dyb3VuZCAmJiB0aGlzLl93YXZlKSkge1xuICAgICAgdGhpcy5fd2F2ZSA9IHV0aWwuY3JlYXRlKCcucmlwcGxlX193YXZlJyk7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gdXRpbC5jcmVhdGUoJy5yaXBwbGVfX2JhY2tncm91bmQnKTtcblxuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl93YXZlKTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2dldEVmZmVjdFNpemUoKSB7XG4gICAgY29uc3Qgc2l6ZXMgPSBbJ2NvdmVyJywgJ2NvbnRhaW4nXTtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3NpemUnKSkge1xuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzaXplJyk7XG4gICAgICBpZiAoc2l6ZXMuaW5kZXhPZihzaXplKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICdjb3Zlcic7XG4gIH1cblxuICBfY2FsY3VsYXRlQ29vcmRzKGUpIHtcbiAgICBsZXQgeCwgeSwgaCwgdywgcjtcbiAgICBjb25zdCBiID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0RWZmZWN0U2l6ZSgpO1xuXG4gICAgaWYgKHRoaXMuX2NlbnRlcikge1xuICAgICAgeCA9IGIud2lkdGggLyAyO1xuICAgICAgeSA9IGIuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKHNpemUgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIHIgPSBNYXRoLm1pbih4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHN0YXRlLiBJZiB0aGlzIGVycm9ycyBpcyBzaG93biwgbGVwb3J0IHRvIEdpdEh1YiBpc3N1ZXMuJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAodHlwZW9mIGUuY2xpZW50WCA9PT0gJ251bWJlcicgPyBlLmNsaWVudFggOiBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgpIC0gYi5sZWZ0O1xuICAgICAgeSA9ICh0eXBlb2YgZS5jbGllbnRZID09PSAnbnVtYmVyJyA/IGUuY2xpZW50WSA6IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSkgLSBiLnRvcDtcbiAgICAgIGggPSBNYXRoLm1heCh5LCBiLmhlaWdodCAtIHkpO1xuICAgICAgdyA9IE1hdGgubWF4KHgsIGIud2lkdGggLSB4KTtcblxuICAgICAgaWYgKHNpemUgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgciA9IE1hdGguc3FydChoICogaCArIHcgKiB3KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIHIgPSBNYXRoLm1pbihNYXRoLnJvdW5kKGggLyAyKSwgTWF0aC5yb3VuZCh3IC8gMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgc3RhdGUuIElmIHRoaXMgZXJyb3JzIGlzIHNob3duLCBsZXBvcnQgdG8gR2l0SHViIGlzc3Vlcy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge3gsIHksIHJ9O1xuICB9XG5cbiAgX3JpcHBsZUFuaW1hdGlvbihlLCBkdXJhdGlvbiA9IDMwMCkge1xuICAgIGNvbnN0IHtfYW5pbWF0b3IsIF93YXZlLCBfYmFja2dyb3VuZCwgX21pblJ9ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeSwgcn0gPSB0aGlzLl9jYWxjdWxhdGVDb29yZHMoZSk7XG5cbiAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IDF9KTtcbiAgICBfYW5pbWF0b3IuYW5pbWF0ZShfYmFja2dyb3VuZCwge29wYWNpdHk6IDF9LCBkdXJhdGlvbik7XG5cbiAgICB1dGlsLmV4dGVuZChfd2F2ZS5zdHlsZSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRvcDogeSAtIF9taW5SICsgJ3B4JyxcbiAgICAgIGxlZnQ6IHggLSBfbWluUiArICdweCcsXG4gICAgICB3aWR0aDogMiAqIF9taW5SICsgJ3B4JyxcbiAgICAgIGhlaWdodDogMiAqIF9taW5SICsgJ3B4J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9hbmltYXRvci5hbmltYXRlKF93YXZlLCB7XG4gICAgICB0b3A6IHkgLSByLFxuICAgICAgbGVmdDogeCAtIHIsXG4gICAgICBoZWlnaHQ6IDIgKiByLFxuICAgICAgd2lkdGg6IDIgKiByXG4gICAgfSwgZHVyYXRpb24pO1xuICB9XG5cbiAgX3VwZGF0ZVBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudFVwZGF0ZWQgJiYgdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfb25UYXAoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50KS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl93YXZlKTtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IuZmFkZSh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkhvbGQoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlUGFyZW50KCk7XG4gICAgICB0aGlzLl9ob2xkaW5nID0gdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCwgMjAwMCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICB0aGlzLl9ob2xkaW5nLnNwZWVkKDMwMCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLnN0b3BBbGwoe3N0b3BOZXh0OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5faG9sZGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG4gIH1cblxuICBfb25EcmFnU3RhcnQoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25SZWxlYXNlKGUpO1xuICAgIH1cbiAgICBpZiAoWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSAhPSAtMSkge1xuICAgICAgdGhpcy5fb25UYXAoZSk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICB0aGlzLl9ib3VuZE9uVGFwID0gdGhpcy5fb25UYXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uSG9sZCA9IHRoaXMuX29uSG9sZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25SZWxlYXNlID0gdGhpcy5fb25SZWxlYXNlLmJpbmQodGhpcyk7XG5cbiAgICBpZiAoaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2hvbGQnLCB0aGlzLl9ib3VuZE9uSG9sZCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX2JvdW5kT25EcmFnU3RhcnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnN0IHBuID0gdGhpcy5fcGFyZW50Tm9kZSB8fCB0aGlzLnBhcmVudE5vZGU7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fYm91bmRPblRhcCk7XG4gICAgcG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX2JvdW5kT25Ib2xkKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9ib3VuZE9uRHJhZ1N0YXJ0KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N0YXJ0LXJhZGl1cycsICdjb2xvcicsICdiYWNrZ3JvdW5kJywgJ2NlbnRlcicsICdjbGFzcycsICdtb2RpZmllciddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcblxuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0YXJ0LXJhZGl1cyc6XG4gICAgICAgIHRoaXMuX21pblIgPSBNYXRoLm1heCgwLCBwYXJzZUZsb2F0KGN1cnJlbnQpIHx8IDApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93YXZlLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZSgnYmFja2dyb3VuZCcpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JhY2tncm91bmQnOlxuICAgICAgICBpZiAoY3VycmVudCB8fCBsYXN0KSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09ICdub25lJykge1xuICAgICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2JhY2tncm91bmQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgaWYgKG5hbWUgPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGhpcy5fY2VudGVyID0gY3VycmVudCAhPSBudWxsICYmIGN1cnJlbnQgIT0gJ2ZhbHNlJztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlJpcHBsZSA9IFJpcHBsZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yaXBwbGUnLCBSaXBwbGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcm93XG4gKiBAY2F0ZWdvcnkgZ3JpZFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXByZXNlbnRzIGEgcm93IGluIHRoZSBncmlkIHN5c3RlbS4gVXNlIHdpdGggYDxvbnMtY29sPmAgdG8gbGF5b3V0IGNvbXBvbmVudHMuWy9lbl1cbiAqICAgW2phXeOCsOODquODg+ODieOCt+OCueODhuODoOOBq+OBpuihjOOCkuWumue+qeOBl+OBvuOBmeOAgm9ucy1jb2zjgajjgajjgoLjgavkvb/nlKjjgZfjgIHjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7phY3nva7jgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gR2d1akMge3dpZGV9XG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sXG4gKiAgIFtlbl1MYXlvdXRpbmcgZ3VpZGVbL2VuXVxuICogICBbamFd44Os44Kk44Ki44Km44OI6Kq/5pW0Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jb2xcbiAqICAgW2VuXVRoZSBgPG9ucy1jb2w+YCBjb21wb25lbnQgaXMgdXNlZCBhcyBjaGlsZHJlbiBvZiBgPG9ucy1yb3c+YC5bL2VuXVxuICogICBbamFdb25zLWNvbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgdmVydGljYWwtYWxpZ24uWy9lbl1cbiAqICAgW2phXUFuZHJvaWQgNC4z5Lul5YmN44CB44KC44GX44GP44GvaU9TIDbku6XliY3jga5PU+OBruWgtOWQiOOAgW9ucy1yb3fjgahvbnMtY29s44KS57WE44G/5ZCI44KP44Gb44Gm44Gd44KM44Ge44KM44Gub25zLWNvbOimgee0oOOBrnZlcnRpY2FsLWFsaWdu5bGe5oCn44Gu5YCk44Gr5Yil44CF44Gu5YCk44KS5oyH5a6a44GZ44KL44Go44CB5o+P55S744GM5bSp44KM44KL5aC05ZCI44GM44GC44KK44G+44GZ44CCdmVydGljYWwtYWxpZ27lsZ7mgKfjga7lgKTjgavjga/kuIDjgaTjga7lgKTjgaDjgZHjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVNob3J0IGhhbmQgYXR0cmlidXRlIGZvciBhbGlnbmluZyB2ZXJ0aWNhbGx5LiBWYWxpZCB2YWx1ZXMgYXJlIHRvcCwgYm90dG9tLCBhbmQgY2VudGVyLlsvZW5dXG4gKiAgIFtqYV3nuKbjgavmlbTliJfjgZnjgovjgZ/jgoHjgavmjIflrprjgZfjgb7jgZnjgIJ0b3DjgIFib3R0b23jgIFjZW50ZXLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvd0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG59XG5cbm9ucy5lbGVtZW50cy5Sb3cgPSBSb3dFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcm93JywgUm93RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdzZWdtZW50JztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzZWdtZW50LS0qJyxcbiAgJy5zZWdtZW50X19pdGVtJzogJ3NlZ21lbnQtLSpfX2l0ZW0nLFxuICAnLnNlZ21lbnRfX2lucHV0JzogJ3NlZ21lbnQtLSpfX2lucHV0JyxcbiAgJy5zZWdtZW50X19idXR0b24nOiAnc2VnbWVudC0tKl9fYnV0dG9uJ1xufTtcblxuY29uc3QgZ2VuZXJhdGVJZCA9ICgoKSA9PiB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuICgpID0+ICdvbnMtc2VnbWVudC1nZW4tJyArIChpKyspO1xufSkoKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc2VnbWVudFxuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHNlZ21lbnRbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgU2VnbWVudCBjb21wb25lbnQuIFVzZSB0aGlzIGNvbXBvbmVudCB0byBoYXZlIGEgYnV0dG9uIGJhciB3aXRoIGF1dG9tYXRpYyBzdHlsZXMgdGhhdCBzd2l0Y2ggb24gY2xpY2sgb2YgYW5vdGhlciBidXR0b24uXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlZ21lbnQgb24gQW5kcm9pZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlZ21lbnRcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zZWdtZW50PlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAxPC9vbnMtYnV0dG9uPlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAyPC9vbnMtYnV0dG9uPlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAzPC9vbnMtYnV0dG9uPlxuICogPC9vbnMtc2VnbWVudD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWdtZW50RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGFmdGVyIHRoZSBhY3RpdmUgYnV0dG9uIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dVGFwcGVkIGJ1dHRvbiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2VnbWVudEl0ZW1cbiAgICogICBbZW5dU2VnbWVudCBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgc2VnbWVudC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhYmJhci1pZFxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSUQgb2YgdGhlIHRhYmJhciBlbGVtZW50IHRvIFwiY29ubmVjdFwiIHRvIHRoZSBzZWdtZW50LiBNdXN0IGJlIGluc2lkZSB0aGUgc2FtZSBwYWdlLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWluZGV4XG4gICAqIEBpbml0b25seVxuICAgKiBAZGVmYXVsdCAwXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUluZGV4IG9mIHRoZSBmaXJzdCBhY3RpdmUgYnV0dG9uLCBvbmx5IHdvcmtzIGlmIHRoZXJlIGlzIG5vIGNvbm5lY3RlZCB0YWJiYXIgKGluIHdoaWNoIGNhc2UgdGhlIGFjdGl2ZSB0YWIgc2V0cyB0aGUgYWN0aXZlIGJ1dHRvbikuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBzZWdtZW50IHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9zZWdtZW50SWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgdGhpcy5fdGFiYmFyID0gbnVsbDtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25UYWJiYXJQcmVDaGFuZ2UgPSB0aGlzLl9vblRhYmJhclByZUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKVxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IHRoaXMuX3RhYmJhciA/IHRoaXMuX3RhYmJhci5nZXRBY3RpdmVUYWJJbmRleCgpIDogdGhpcy5nZXRBY3RpdmVCdXR0b25JbmRleCgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3NlZ21lbnRfX2l0ZW0nKTtcblxuICAgICAgY29uc3QgaW5wdXQgPSB1dGlsLmZpbmRDaGlsZChpdGVtLCAnLnNlZ21lbnRfX2lucHV0JykgfHwgdXRpbC5jcmVhdGUoJ2lucHV0LnNlZ21lbnRfX2lucHV0Jyk7XG4gICAgICBpbnB1dC50eXBlID0gJ3JhZGlvJztcbiAgICAgIGlucHV0LnZhbHVlID0gaW5kZXg7XG4gICAgICBpbnB1dC5uYW1lID0gaW5wdXQubmFtZSB8fCB0aGlzLl9zZWdtZW50SWQ7XG4gICAgICBpbnB1dC5jaGVja2VkID0gIXRoaXMuaGFzQXR0cmlidXRlKCd0YWJiYXItaWQnKSAmJiBpbmRleCA9PT0gKHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUtaW5kZXgnKSkgfHwgMCk7XG5cbiAgICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKGl0ZW0sICcuc2VnbWVudF9fYnV0dG9uJykgfHwgdXRpbC5jcmVhdGUoJy5zZWdtZW50X19idXR0b24nKTtcbiAgICAgIGlmIChidXR0b24ucGFyZW50RWxlbWVudCAhPT0gaXRlbSkge1xuICAgICAgICB3aGlsZSAoaXRlbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGl0ZW0uZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlbS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICBpdGVtLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd0YWJiYXItaWQnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICAgICAgdGhpcy5fdGFiYmFyID0gcGFnZSAmJiBwYWdlLnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmJhci1pZCcpKTtcbiAgICAgICAgaWYgKCF0aGlzLl90YWJiYXIgfHwgdGhpcy5fdGFiYmFyLnRhZ05hbWUgIT09ICdPTlMtVEFCQkFSJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgPG9ucy1zZWdtZW50PiBlcnJvcjogbm8gdGFiYmFyIHdpdGggaWQgJHt0aGlzLmdldEF0dHJpYnV0ZSgndGFiYmFyLWlkJyl9IHdhcyBmb3VuZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RhYmJhci5zZXRBdHRyaWJ1dGUoJ2hpZGUtdGFicycsICcnKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3NldENoZWNrZWQodGhpcy5fdGFiYmFyLmdldEFjdGl2ZVRhYkluZGV4KCkpKTtcblxuICAgICAgICB0aGlzLl90YWJiYXIuYWRkRXZlbnRMaXN0ZW5lcigncHJlY2hhbmdlJywgdGhpcy5fb25UYWJiYXJQcmVDaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3RhYmJhcikge1xuICAgICAgICB0aGlzLl90YWJiYXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlY2hhbmdlJywgdGhpcy5fb25UYWJiYXJQcmVDaGFuZ2UpO1xuICAgICAgICB0aGlzLl90YWJiYXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICB9XG5cbiAgX3NldENoZWNrZWQoaW5kZXgpIHtcbiAgICB0aGlzLmNoaWxkcmVuW2luZGV4XS5maXJzdEVsZW1lbnRDaGlsZC5jaGVja2VkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZUJ1dHRvblxuICAgKiBAc2lnbmF0dXJlIHNldEFjdGl2ZUJ1dHRvbihpbmRleCwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogICBbZW5dQnV0dG9uIGluZGV4LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdCwgd29ya3Mgb25seSBpZiB0aGVyZSBpcyBhIGNvbm5lY3RlZCB0YWJiYXIuIFN1cHBvcnRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgYG9ucy10YWJiYXJgJ3MgYHNldEFjdGl2ZVRhYmAgbWV0aG9kLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1NYWtlIGJ1dHRvbiB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXggYWN0aXZlLiBJZiB0aGVyZSBpcyBhIGNvbm5lY3RlZCB0YWJiYXIgaXQgc2hvd3MgdGhlIGNvcnJlc3BvbmRpbmcgdGFiIHBhZ2UuIEluIHRoaXMgY2FzZSBhbmltYXRpb25zIGFuZCB0aGVpciBvcHRpb25zIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNlbGVjdGVkIGluZGV4IG9yIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50IGlmIHRoZXJlIGlzIGEgY29ubmVjdGVkIHRhYmJhci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0QWN0aXZlQnV0dG9uKGluZGV4LCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMuX3RhYmJhcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3RhYmJhci5zZXRBY3RpdmVUYWIoaW5kZXgsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldENoZWNrZWQoaW5kZXgpO1xuICAgIHRoaXMuX3Bvc3RDaGFuZ2UoaW5kZXgpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0QWN0aXZlQnV0dG9uSW5kZXhcbiAgICogQHNpZ25hdHVyZSBnZXRBY3RpdmVCdXR0b25JbmRleCgpXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogICBbZW5dVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyBidXR0b24gaW5kZXggb2YgY3VycmVudCBhY3RpdmUgYnV0dG9uLiBJZiBhY3RpdmUgYnV0dG9uIGlzIG5vdCBmb3VuZCwgcmV0dXJucyAtMS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlQnV0dG9uSW5kZXgoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHsgLy8gQXJyYXkuZmluZEluZGV4XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXS5maXJzdEVsZW1lbnRDaGlsZC5jaGVja2VkKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBfb25DaGFuZ2UoZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl90YWJiYXJcbiAgICAgID8gdGhpcy5fdGFiYmFyLnNldEFjdGl2ZVRhYih0aGlzLmdldEFjdGl2ZUJ1dHRvbkluZGV4KCksIHsgcmVqZWN0OiBmYWxzZSB9KVxuICAgICAgOiB0aGlzLl9wb3N0Q2hhbmdlKHRoaXMuZ2V0QWN0aXZlQnV0dG9uSW5kZXgoKSk7XG4gIH1cblxuICBfb25UYWJiYXJQcmVDaGFuZ2UoZXZlbnQpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgaWYgKCFldmVudC5kZXRhaWwuY2FuY2VsZWQpIHtcbiAgICAgICAgdGhpcy5fc2V0Q2hlY2tlZChldmVudC5pbmRleCk7XG4gICAgICAgIHRoaXMuX3Bvc3RDaGFuZ2UoZXZlbnQuaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX3Bvc3RDaGFuZ2UoaW5kZXgpIHtcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RjaGFuZ2UnLCB7XG4gICAgICBpbmRleCxcbiAgICAgIGFjdGl2ZUluZGV4OiBpbmRleCxcbiAgICAgIGxhc3RBY3RpdmVJbmRleDogdGhpcy5fbGFzdEFjdGl2ZUluZGV4LFxuICAgICAgc2VnbWVudEl0ZW06IHRoaXMuY2hpbGRyZW5baW5kZXhdXG4gICAgfSk7XG4gICAgdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc2VnbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnY2xhc3MnLCAnbW9kaWZpZXInXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncG9zdGNoYW5nZSddO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5TZWdtZW50ID0gU2VnbWVudEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zZWdtZW50JywgU2VnbWVudEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzZWxlY3QtKiBzZWxlY3QtLSonLFxuICAnLnNlbGVjdC1pbnB1dCc6ICdzZWxlY3QtaW5wdXQtLSonXG59O1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3NlbGVjdCc7XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvZm9jdXMnLFxuICAnZGlzYWJsZWQnLFxuICAnZm9ybScsXG4gICdtdWx0aXBsZScsXG4gICduYW1lJyxcbiAgJ3JlcXVpcmVkJyxcbiAgJ3NpemUnXG5dO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zZWxlY3RcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gc2VsZWN0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgdW5kZXJiYXJcbiAqICBbZW5dRGlzcGxheXMgYSBob3Jpem9udGFsIGxpbmUgdW5kZXJuZWF0aCBhIHNlbGVjdCBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBTZWxlY3QgY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBwbGFjZSBhIHNlbGVjdCB3aXRoIGFuIElEIG9mIGBteS1pZGAgb24gYSBwYWdlLCB1c2UgYDxvbnMtc2VsZWN0IHNlbGVjdC1pZD1cIm15LWlkXCI+YC5cbiAqXG4gKiAgICAgVGhlIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhcyBhIE1hdGVyaWFsIERlc2lnbiBzZWxlY3Qgb24gQW5kcm9pZC5cbiAqXG4gKiAgICAgTW9zdCBhdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGEgbm9ybWFsIGA8c2VsZWN0PmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFd44K744Os44Kv44OI44Oc44OD44Kv44K544KS6KGo56S644GZ44KL44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCYHNlbGVjdGAg6KaB57Sg44Gr5L2/55So44Gn44GN44KL5bGe5oCn44Gu5aSa44GP44GMIGBvbnMtc2VsZWN0YCDopoHntKDjgafjgoLliKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gaExheXhcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zZWxlY3RcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zZWxlY3Q+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIxXCI+MTwvb3B0aW9uPlxuICogICA8b3B0aW9uIHZhbHVlPVwiMlwiPjJuZDwvb3B0aW9uPlxuICogICA8b3B0aW9uIHZhbHVlPVwiM1wiPjNyZCBvcHRpb248L29wdGlvbj5cbiAqIDwvb25zLXNlbGVjdD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3RFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG9mb2N1c1xuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dRWxlbWVudCBhdXRvbWF0aWNhbGx5IGdhaW5zIGZvY3VzIG9uIHBhZ2UgbG9hZC5bL2VuXVxuICAgKiAgW2phXeODmuODvOOCuOODreODvOODieaZguOBq+OBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBq+ODleOCqeODvOOCq+OCueOBjOenu+OCi+OCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBzZWxlY3QgaW5wdXQgc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOCkueEoeWKueWMluOBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGZvcm1cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFzc29jaWF0ZSBhIHNlbGVjdCBlbGVtZW50IHRvIGFuIGV4aXN0aW5nIGZvcm0gb24gdGhlIHBhZ2UsIGV2ZW4gaWYgbm90IG5lc3RlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLjgIHmjIflrprjgZfjgZ8gYGZvcm1gIOimgee0oOOBq+e0kOS7mOOBkeOBvuOBmeOAguOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOCkiBgZm9ybWAg6KaB57Sg44Gu5aSW5YG044Gr6YWN572u44GZ44KL6Zqb44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbXVsdGlwbGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIG11bHRpcGxlIG9wdGlvbnMgY2FuIGJlIHNlbGVjdGVkIGF0IG9uY2UuWy9lbl1cbiAgICogIFtqYV3pgbjmip7ogqLjga7opIfmlbDpgbjmip7jgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBuYW1lXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1OYW1lIHRoZSBzZWxlY3QgZWxlbWVudCwgdXNlZnVsIGZvciBpbnN0YW5jZSBpZiBpdCBpcyBwYXJ0IG9mIGEgZm9ybS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjga7lkI3liY3jgpLmjIflrprjgZfjgb7jgZnjgILpgJrluLggYGZvcm1gIOimgee0oOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJlcXVpcmVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZSB0aGUgc2VsZWN0IGlucHV0IHJlcXVpcmVkIGZvciBzdWJtaXR0aW5nIHRoZSBmb3JtIGl0IGlzIHBhcnQgb2YuWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544KS5YWl5Yqb5b+F6aCI44Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CC6YCa5bi4IGBmb3JtYCDopoHntKDjgajlhbHjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzZWxlY3QtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlEIGdpdmVuIHRvIHRoZSBpbm5lciBzZWxlY3QsIHVzZWZ1bCBmb3IgZHluYW1pYyBtYW5pcHVsYXRpb24uWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544GM5YaF6YOo44Gr5oyB44GkIHNlbGVjdCDopoHntKDjgavkuI7jgYjjgosgSUQg44KS5oyH5a6a44GX44G+44GZ44CC44K744Os44Kv44OI44Oc44OD44Kv44K544Gu5YaF5a6544KS5YuV55qE44Gr5aSJ5pu044GZ44KL5b+F6KaB44GM44GC44KL5aC05ZCI44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2l6ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib3cgbWFueSBvcHRpb25zIGFyZSBkaXNwbGF5ZWQ7IGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gdGhlIHNpemUgdGhlbiBhIHNjcm9sbCBhcHBlYXJzIHRvIG5hdmlnYXRlIHRoZW0uWy9lbl1cbiAgICogICBbamFd5LiA5bqm44Gr6KGo56S644GZ44KL6YG45oqe6IKi44Gu5YCL5pWw44KS5oyH5a6a44GX44G+44GZ44CC6YG45oqe6IKi44GM44GT44Gu5bGe5oCn44Gn5oyH5a6a44GX44Gf5YCL5pWw44KI44KK44KC5aSa44GE5aC05ZCI44CB44K544Kv44Ot44O844Or44GM5pyJ5Yq544Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuXG4gICAgdGhpcy5fZGVyaXZlR2V0dGVycygpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnLCAuLi5JTlBVVF9BVFRSSUJVVEVTXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfc2VsZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCcpO1xuICB9XG5cbiAgX3VwZGF0ZUJvdW5kQXR0cmlidXRlcygpIHtcbiAgICBJTlBVVF9BVFRSSUJVVEVTLmZvckVhY2goKGF0dHIpID0+IHtcbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShhdHRyKSkge1xuICAgICAgICB0aGlzLl9zZWxlY3Quc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWxlY3QucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBsZW5ndGhcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU51bWJlciBvZiBvcHRpb25zIGluIHRoZSBzZWxlY3QgYm94LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBq+WQq+OBvuOCjOOCi+mBuOaKnuiCouOBruWAi+aVsOOCkui/lOOBl+OBvuOBmeOAgiBgc2VsZWN0YCDopoHntKBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNldmVyYWwgb3B0aW9ucyBmb3IgaGFuZGxpbmcgdGhlIHNlbGVjdCBET00gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBq+WQq+OBvuOCjOOCiyBgb3B0aW9uYCDopoHntKDjga7phY3liJfjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHNlbGVjdGVkSW5kZXhcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUluZGV4IG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOmBuOaKnuOBleOCjOOBpuOBhOOCi+mBuOaKnuiCouOBruOCpOODs+ODh+ODg+OCr+OCueOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVZhbHVlIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOmBuOaKnuOBleOCjOOBpuOBhOOCi+mBuOaKnuiCouOBruWApOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBjb25zdCBzZWwgPSB0aGlzLl9zZWxlY3QgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgaWYgKCFzZWwuaWQgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ3NlbGVjdC1pZCcpKSB7XG4gICAgICBzZWwuaWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc2VsZWN0LWlkJyk7XG4gICAgfVxuICAgIHNlbC5jbGFzc0xpc3QuYWRkKCdzZWxlY3QtaW5wdXQnKTtcbiAgICBpZiAoIXRoaXMuX3NlbGVjdCkge1xuICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4gc2VsLmFwcGVuZENoaWxkKGVsZW1lbnQpKTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc2VsKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZGVyaXZlR2V0dGVycygpIHtcbiAgICBbJ2Rpc2FibGVkJywgJ2xlbmd0aCcsICdtdWx0aXBsZScsICduYW1lJywgJ29wdGlvbnMnLCAnc2VsZWN0ZWRJbmRleCcsICdzaXplJywgJ3ZhbHVlJywgJ2Zvcm0nLCAndHlwZSddXG4gICAgICAuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6ICgpID0+IHRoaXMuX3NlbGVjdFtrZXldLFxuICAgICAgICAgIHNldDogWydmb3JtJywgJ3R5cGUnXS5pbmRleE9mKGtleSkgPT09IC0xXG4gICAgICAgICAgICA/IHZhbHVlID0+ICh0aGlzLl9zZWxlY3Rba2V5XSA9IHZhbHVlKVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGFkZChvcHRpb24sIGluZGV4ID0gbnVsbCkge1xuICAgIHRoaXMuX3NlbGVjdC5hZGQob3B0aW9uLCBpbmRleCk7XG4gIH1cblxuICByZW1vdmUoaW5kZXgpIHtcbiAgICB0aGlzLl9zZWxlY3QucmVtb3ZlKGluZGV4KTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuU2VsZWN0ID0gU2VsZWN0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNlbGVjdCcsIFNlbGVjdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdmYWIgZmFiLS1taW5pIHNwZWVkLWRpYWxfX2l0ZW0nO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnZmFiLS0qIHNwZWVkLWRpYWxfX2l0ZW0tLSonXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGVlZC1kaWFsLWl0ZW1cbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoaXMgY29tcG9uZW50IGRpc3BsYXlzIHRoZSBjaGlsZCBlbGVtZW50cyBvZiB0aGUgTWF0ZXJpYWwgRGVzaWduIFNwZWVkIGRpYWwgY29tcG9uZW50LlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAgTWF0ZXJpYWwgRGVzaWdu44GuU3BlZWQgZGlhbOOBruWtkOimgee0oOOCkuihqOePvuOBmeOCi+imgee0oOOBp+OBmeOAglxuICogICBbL2phXVxuICogQGNvZGVwZW4gZFlRWUxnXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BlZWQtZGlhbFxuICogQHNlZWFsc28gb25zLXNwZWVkLWRpYWxcbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsPmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1vbnMtc3BlZWQtZGlhbOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZmFiXG4gKiAgIFtlbl1vbnMtZmFiIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZmFi44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwZWVkLWRpYWwgcG9zaXRpb249XCJsZWZ0IGJvdHRvbVwiPlxuICogICA8b25zLWZhYj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPlxuICogICA8L29ucy1mYWI+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkM8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiA8L29ucy1zcGVlZC1kaWFsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVlZERpYWxJdGVtRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGNvbXBvbmVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByaXBwbGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgdGhlIGJ1dHRvbiB3aWxsIGhhdmUgYSByaXBwbGUgZWZmZWN0IHdoZW4gdGFwcGVkLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdyaXBwbGUnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCAnbWluaScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cblxuICBfb25DbGljayhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgZGVmYXVsdENsYXNzTmFtZS5zcGxpdCgvXFxzKy8pLmZvckVhY2godG9rZW4gPT4gdGhpcy5jbGFzc0xpc3QuYWRkKHRva2VuKSk7XG5cbiAgICB1dGlsLmFkZE1vZGlmaWVyKHRoaXMsICdtaW5pJyk7XG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlNwZWVkRGlhbEl0ZW0gPSBTcGVlZERpYWxJdGVtRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwZWVkLWRpYWwtaXRlbScsIFNwZWVkRGlhbEl0ZW1FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vb25zL3N0eWxlcic7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnc3BlZWQtZGlhbCc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnc3BlZWQtZGlhbC0tKicsXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGVlZC1kaWFsXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBFbGVtZW50IHRoYXQgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gU3BlZWQgRGlhbG9nIGNvbXBvbmVudC4gSXQgaXMgdXNlZnVsIHdoZW4gdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgcHJpbWFyeSBhY3Rpb24gdGhhdCBjYW4gYmUgcGVyZm9ybWVkIGluIGEgcGFnZS5cbiAqXG4gKiAgICAgVGhlIFNwZWVkIGRpYWwgbG9va3MgbGlrZSBhIGA8b25zLWZhYj5gIGVsZW1lbnQgYnV0IHdpbGwgZXhwYW5kIGEgbWVudSB3aGVuIHRhcHBlZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBkWVFZTGdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zcGVlZC1kaWFsXG4gKiBAc2VlYWxzbyBvbnMtc3BlZWQtZGlhbC1pdGVtXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbC1pdGVtPmAgcmVwcmVzZW50cyBhIG1lbnUgaXRlbS5bL2VuXVxuICogICBbamFdb25zLXNwZWVkLWRpYWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtZmFiXG4gKiAgIFtlbl1vbnMtZmFiIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZmFi44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwZWVkLWRpYWwgcG9zaXRpb249XCJsZWZ0IGJvdHRvbVwiPlxuICogICA8b25zLWZhYj5cbiAqICAgICA8b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPlxuICogICA8L29ucy1mYWI+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkE8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkI8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiAgIDxvbnMtc3BlZWQtZGlhbC1pdGVtPkM8L29ucy1zcGVlZC1kaWFsLWl0ZW0+XG4gKiA8L29ucy1zcGVlZC1kaWFsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGVlZERpYWxFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3BlblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgbWVudSBpdGVtcyBhcmUgc2hvd24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBjbG9zZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgbWVudSBpdGVtcyBhcmUgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTcGVjaWZ5IHRoZSB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgY29tcG9uZW50LlxuICAgKiAgICAgSS5lLiB0byBkaXNwbGF5IGl0IGluIHRoZSB0b3AgcmlnaHQgY29ybmVyIHNwZWNpZnkgXCJyaWdodCB0b3BcIi5cbiAgICogICAgIENob29zZSBmcm9tIFwicmlnaHRcIiwgXCJsZWZ0XCIsIFwidG9wXCIgYW5kIFwiYm90dG9tXCIuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgZPjga7opoHntKDjgpLooajnpLrjgZnjgovlt6blj7PjgajkuIrkuIvjga7kvY3nva7jgpLmjIflrprjgZfjgb7jgZnjgIJcbiAgICogICAgIOS+i+OBiOOBsOOAgeWPs+S4iuOBq+ihqOekuuOBmeOCi+WgtOWQiOOBq+OBr1wicmlnaHQgdG9wXCLjgpLmjIflrprjgZfjgb7jgZnjgIJcbiAgICogICAgIOW3puWPs+OBqOS4iuS4i+OBruS9jee9ruOBruaMh+WumuOBq+OBr+OAgXJpZ2h044GobGVmdOOAgXRvcOOBqGJvdHRvbeOBjOOBneOCjOOBnuOCjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgZGlyZWN0aW9uIHRoZSBpdGVtcyBhcmUgZGlzcGxheWVkLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwidXBcIiwgXCJkb3duXCIsIFwibGVmdFwiIGFuZCBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDopoHntKDjgYzooajnpLrjgZnjgovmlrnlkJHjgpLmjIflrprjgZfjgb7jgZnjgIJ1cCwgZG93biwgbGVmdCwgcmlnaHTjgYzmjIflrprjgafjgY3jgb7jgZnjgIJcbiAgICogICBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBidXR0b24gc2hvdWxkIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5faXRlbVNob3duID0gZmFsc2U7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGlyZWN0aW9uJykpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbih0aGlzLmdldEF0dHJpYnV0ZSgnZGlyZWN0aW9uJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oJ3VwJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2NsYXNzJywgJ21vZGlmaWVyJywgJ3JpcHBsZScsICdkaXJlY3Rpb24nLCAncG9zaXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUmlwcGxlKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RpcmVjdGlvbic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVEaXJlY3Rpb24oY3VycmVudCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Bvc2l0aW9uJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHRoaXMucXVlcnlTZWxlY3RvckFsbCgnb25zLXNwZWVkLWRpYWwtaXRlbScpKTtcbiAgfVxuXG4gIGdldCBfZmFiKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWZhYicpO1xuICB9XG5cbiAgX29uQ2xpY2soZSkge1xuICAgIGlmICh0aGlzLm9uQ2xpY2spIHtcbiAgICAgIHRoaXMub25DbGljay5hcHBseSh0aGlzKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlSXRlbXMoKTtcbiAgICB9XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuaW5saW5lKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93KCk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuaGlkZSgpLnRoZW4ocmVzb2x2ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIGlmICh0aGlzLl9mYWIpIHtcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCdyaXBwbGUnKSA/IHRoaXMuX2ZhYi5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKSA6IHRoaXMuX2ZhYi5yZW1vdmVBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0eWxlcihjaGlsZHJlbltpXSwge1xuICAgICAgICB0cmFuc2l0aW9uRGVsYXk6IDI1ICogaSArICdtcycsXG4gICAgICAgIGJvdHRvbTogJ2F1dG8nLFxuICAgICAgICByaWdodDogJ2F1dG8nLFxuICAgICAgICB0b3A6ICdhdXRvJyxcbiAgICAgICAgbGVmdDogJ2F1dG8nXG4gICAgICB9KTtcbiAgICB9XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgJ3VwJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmJvdHRvbSA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5yaWdodCA9ICc4cHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZG93bic6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9ICc4cHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS50b3AgPSAnOHB4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5yaWdodCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLmxlZnQgPSA3MiArIDU2ICogaSArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgb25lIG9mIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0LicpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXG4gICAgICAnZmFiLS1ib3R0b21fX3JpZ2h0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcbiAgICAgICdmYWItLXRvcF9fY2VudGVyJyxcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgc3dpdGNoKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AgcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AgbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgdG9wJzpcbiAgICAgIGNhc2UgJ3RvcCBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcbiAgICAgIGNhc2UgJ2JvdHRvbSBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBfZ2V0VHJhbnNsYXRlKCkge1xuICAgIGNvbnN0IGlzQm90dG9tID0gKHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpIHx8ICcnKS5pbmRleE9mKCdib3R0b20nKSA+PSAwO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGlzQm90dG9tID8gYHRyYW5zbGF0ZTNkKDBweCwgLSR7dXRpbC5nbG9iYWxzLmZhYk9mZnNldCB8fCAwfXB4LCAwcHgpIGAgOiAnJztcbiAgICByZXR1cm4gdHJhbnNsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgc3BlZWQgZGlhbC5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5fZmFiLnNob3coKTtcbiAgICBzdHlsZXIodGhpcywgeyB0cmFuc2Zvcm06IHRoaXMuX2dldFRyYW5zbGF0ZSB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBzcGVlZCBkaWFsLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaWRlSXRlbXMoKS50aGVuKCgpPT4gdGhpcy5fZmFiLmhpZGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93SXRlbXNcbiAgICogQHNpZ25hdHVyZSBzaG93SXRlbXMoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgc3BlZWQgZGlhbCBpdGVtcy5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNob3dJdGVtcygpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24odGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCd1cCcpO1xuICAgIH1cblxuICAgIGxldCB0b3RhbERlbGF5ID0gMDtcbiAgICBpZiAoIXRoaXMuX2l0ZW1TaG93bikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZWxheSA9IDI1ICogaTtcbiAgICAgICAgdG90YWxEZWxheSArPSBkZWxheTtcbiAgICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgICAgICAgIHRyYW5zaXRpb25EZWxheTogZGVsYXkgKyAnbXMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdG90YWxEZWxheSArPSA1MDtcblxuICAgICAgdGhpcy5faXRlbVNob3duID0gdHJ1ZTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnb3BlbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICAgIHNldFRpbWVvdXQoZGVmZXJyZWQucmVzb2x2ZSwgdG90YWxEZWxheSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlSXRlbXNcbiAgICogQHNpZ25hdHVyZSBoaWRlSXRlbXMoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgc3BlZWQgZGlhbCBpdGVtcy5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGhpZGVJdGVtcygpIHtcbiAgICBsZXQgdG90YWxEZWxheSA9IDA7XG4gICAgaWYgKHRoaXMuX2l0ZW1TaG93bikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZWxheSA9IDI1ICogKGNoaWxkcmVuLmxlbmd0aCAtIGkpO1xuICAgICAgICB0b3RhbERlbGF5ICs9IGRlbGF5O1xuICAgICAgICBzdHlsZXIoY2hpbGRyZW5baV0sIHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwKScsXG4gICAgICAgICAgdHJhbnNpdGlvbkRlbGF5OiBkZWxheSArICdtcydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0b3RhbERlbGF5ICs9IDUwO1xuXG4gICAgICB0aGlzLl9pdGVtU2hvd24gPSBmYWxzZTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2xvc2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICBzZXRUaW1lb3V0KGRlZmVycmVkLnJlc29sdmUsIHRvdGFsRGVsYXkpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuaGlkZUl0ZW1zKCk7XG4gICAgfVxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZSA9PiB7XG4gICAgICB1dGlsLm1hdGNoKGUsICcuZmFiJykgJiYgdXRpbC50b2dnbGVBdHRyaWJ1dGUoZSwgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGlubGluZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGlubGluZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd44Kk44Oz44Op44Kk44Oz6KaB57Sg44Gu5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBpbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmxpbmUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmFiLnZpc2libGUgJiYgdGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc09wZW5cbiAgICogQHNpZ25hdHVyZSBpc09wZW4oKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBtZW51IGlzIG9wZW4gb3Igbm90LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1TaG93bjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu6KGo56S66Z2e6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52aXNpYmxlID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZUl0ZW1zXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlSXRlbXMoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIGl0ZW0gdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44Gu6KGo56S66Z2e6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZUl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3BlbigpID8gdGhpcy5oaWRlSXRlbXMoKSA6IHRoaXMuc2hvd0l0ZW1zKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydvcGVuJywgJ2Nsb3NlJ107XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlNwZWVkRGlhbCA9IFNwZWVkRGlhbEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGVlZC1kaWFsJywgU3BlZWREaWFsRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IHtQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlcn0gZnJvbSAnLi4vb25zL3BhZ2UtbG9hZGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkoZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zcGxpdHRlci1jb250ZW50XG4gKiBAY2F0ZWdvcnkgbWVudVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBlbGVtZW50IGlzIHVzZWQgYXMgYSBjaGlsZCBlbGVtZW50IG9mIGA8b25zLXNwbGl0dGVyPmAuXG4gKlxuICogICAgSXQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZSB3aGlsZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29udGFpbnMgdGhlIGxpc3QuXG4gKiAgWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTopoHntKDjga/jgIFvbnMtc3BsaXR0ZXLopoHntKDjga7lrZDopoHntKDjgajjgZfjgabliKnnlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlcj5gIGNvbXBvbmVudCBpcyB0aGUgcGFyZW50IGVsZW1lbnQuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1zaWRlXG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1zaWRlPmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtZW51LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNwbGl0dGVyPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyQ29udGVudEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGUgdXJsIG9mIHRoZSBjb250ZW50IHBhZ2UuIElmIHRoaXMgYXR0cmlidXRlIGlzIHVzZWQgdGhlIGNvbnRlbnQgd2lsbCBiZSBsb2FkZWQgZnJvbSBhIGA8b25zLXRlbXBsYXRlPmAgdGFnIG9yIGEgcmVtb3RlIGZpbGUuXG4gICAqXG4gICAqICAgICBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHB1dCBgPG9ucy1wYWdlPmAgZWxlbWVudCBhcyBhIGNoaWxkIG9mIHRoZSBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXW9ucy1zcGxpdHRlci1jb250ZW506KaB57Sg44Gr6KGo56S644GZ44KL44Oa44O844K444GuVVJM44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3BhZ2UgPSBudWxsO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9nZXRQYWdlVGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICB0aGlzLmxvYWQocGFnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFwib25zLXNwbGl0dGVyLWNvbnRlbnRcIiBtdXN0IGhhdmUgXCJvbnMtc3BsaXR0ZXJcIiBhcyBwYXJlbnROb2RlLmApO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRQYWdlVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHt9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgcGFnZSB0byBsb2FkIGluIHRoZSBzcGxpdHRlciBjb250ZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOWGheOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IHBhZ2VcbiAgICovXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QYWdlIGVsZW1lbnQgbG9hZGVkIGluIHRoZSBzcGxpdHRlciBjb250ZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOWGheOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghKGxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlcicpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbG9hZFxuICAgKiBAc2lnbmF0dXJlIGxvYWQocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZSwgW29wdGlvbnNdXG4gICAqICAgW2VuXVBhZ2UgVVJMLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZG9jdW1lbnQgb3IgYW4gYDxvbnMtdGVtcGxhdGU+YCBpZC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CBb25zLXRlbXBsYXRl44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gYHBhZ2VgIGluIHRoZSBjb250ZW50LlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn1VSTOOCkuODoeOCpOODs+ODmuODvOOCuOOCkuiqreOBv+i+vOOBv+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgYDxvbnMtcGFnZT5gIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1gPG9ucy1wYWdlPmDopoHntKDjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGxvYWQocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgb2xkQ29udGVudCA9IHRoaXMuX2NvbnRlbnQgfHwgbnVsbDtcblxuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXN9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChvbGRDb250ZW50KSB7XG4gICAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQob2xkQ29udGVudCk7XG4gICAgICAgICAgb2xkQ29udGVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcblxuICAgICAgICBjYWxsYmFjayhwYWdlRWxlbWVudCk7XG4gICAgICAgIHJlc29sdmUocGFnZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudC5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMuX2NvbnRlbnQpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlNwbGl0dGVyQ29udGVudCA9IFNwbGl0dGVyQ29udGVudEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlci1jb250ZW50JywgU3BsaXR0ZXJDb250ZW50RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJNYXNrRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlLl9zaWRlcy5ldmVyeShzaWRlID0+IHNpZGUubW9kZSA9PT0gJ3NwbGl0JykpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmUgIWltcG9ydGFudCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX29uQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMub25DbGljaygpO1xuICAgIH0gZWxzZSBpZiAodXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhpcy5wYXJlbnROb2RlLl9zaWRlcy5mb3JFYWNoKHNpZGUgPT4gc2lkZS5jbG9zZSgnbGVmdCcpLmNhdGNoKCgpID0+IHt9KSk7XG4gICAgfVxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgX3ByZXZlbnRTY3JvbGwoZSkge1xuICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7IC8vIEZpeCBmb3IgaU9TLiBQcmV2ZW50cyBzY3JvbGxpbmcgY29udGVudCBiZWhpbmQgbWFzay5cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX3ByZXZlbnRTY3JvbGwpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9wcmV2ZW50U2Nyb2xsKTtcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuU3BsaXR0ZXJNYXNrID0gU3BsaXR0ZXJNYXNrRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLW1hc2snLCBTcGxpdHRlck1hc2tFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vLi4vb25zL3N0eWxlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BsaXR0ZXJBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuMSwgMSknLCBkdXJhdGlvbiA9IDAuMywgZGVsYXkgPSAwfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGR1cmF0aW9uLCBkZWxheSB9KTtcbiAgfVxuXG4gIHVwZGF0ZU9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgdXRpbC5leHRlbmQodGhpcywge1xuICAgICAgdGltaW5nOiB0aGlzLnRpbWluZywgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sIGRlbGF5OiB0aGlzLmRlbGF5XG4gICAgfSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzaWRlRWxlbWVudFxuICAgKi9cbiAgYWN0aXZhdGUoc2lkZUVsZW1lbnQpIHtcbiAgICBjb25zdCBzcGxpdHRlciA9IHNpZGVFbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICBjb250ZW50UmVhZHkoc3BsaXR0ZXIsICgpID0+IHtcbiAgICAgIHRoaXMuX3NpZGUgPSBzaWRlRWxlbWVudDtcbiAgICAgIHRoaXMuX29wcG9zaXRlU2lkZSA9IHNwbGl0dGVyLnJpZ2h0ICE9PSBzaWRlRWxlbWVudCAmJiBzcGxpdHRlci5yaWdodCB8fCBzcGxpdHRlci5sZWZ0ICE9PSBzaWRlRWxlbWVudCAmJiBzcGxpdHRlci5sZWZ0O1xuICAgICAgdGhpcy5fY29udGVudCA9IHNwbGl0dGVyLmNvbnRlbnQ7XG4gICAgICB0aGlzLl9tYXNrID0gc3BsaXR0ZXIubWFzaztcbiAgICB9KTtcbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5jbGVhclRyYW5zaXRpb24oKTtcbiAgICB0aGlzLl9tYXNrICYmIHRoaXMuY2xlYXJNYXNrKCk7XG4gICAgdGhpcy5fY29udGVudCA9IHRoaXMuX3NpZGUgPSB0aGlzLl9vcHBvc2l0ZVNpZGUgPSB0aGlzLl9tYXNrID0gbnVsbDtcbiAgfVxuXG4gIGdldCBtaW51cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lkZS5zaWRlID09PSAncmlnaHQnID8gJy0nIDogJyc7XG4gIH1cblxuICBjbGVhclRyYW5zaXRpb24oKSB7XG4gICAgJ3NpZGUgbWFzayBjb250ZW50Jy5zcGxpdCgvXFxzKy8pXG4gICAgICAuZm9yRWFjaChlID0+IHRoaXNbJ18nICsgZV0gJiYgc3R5bGVyLmNsZWFyKHRoaXNbJ18nICsgZV0sICd0cmFuc2Zvcm0gdHJhbnNpdGlvbicpKVxuICB9XG5cbiAgY2xlYXJNYXNrKCkge1xuICAgIC8vIENoZWNrIGlmIHRoZSBvdGhlciBzaWRlIG5lZWRzIHRoZSBtYXNrIGJlZm9yZSBjbGVhcmluZ1xuICAgIGlmICghdGhpcy5fb3Bwb3NpdGVTaWRlIHx8IHRoaXMuX29wcG9zaXRlU2lkZS5tb2RlID09PSAnc3BsaXQnIHx8ICF0aGlzLl9vcHBvc2l0ZVNpZGUuaXNPcGVuKSB7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICAgIHRoaXMuX21hc2suc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4gICAqL1xuICB0cmFuc2xhdGUoZGlzdGFuY2UpIHtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIG9wZW4oZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBjbG9zZShkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvci5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yIGV4dGVuZHMgU3BsaXR0ZXJBbmltYXRvciB7XG5cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG4gICAgdGhpcy5fbWFzay5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgLy8gQXZvaWQgY29udGVudCBjbGlja3NcblxuICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgZGlzdGFuY2V9cHgsIDBweCwgMHB4KWBcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIG9wZW4oZG9uZSkge1xuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXN9MTAwJSwgMHB4LCAwcHgpYFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogJzEnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgY2xvc2UoZG9uZSkge1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpJ1xuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBvcGFjaXR5OiAnMCdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogJ2xpbmVhcicsXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3IuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoU3BsaXR0ZXJBbmltYXRvciBleHRlbmRzIFNwbGl0dGVyQW5pbWF0b3Ige1xuXG4gIF9nZXRTbGlkaW5nRWxlbWVudHMoKSB7XG4gICAgY29uc3Qgc2xpZGluZ0VsZW1lbnRzID0gW3RoaXMuX3NpZGUsIHRoaXMuX2NvbnRlbnRdO1xuICAgIGlmICh0aGlzLl9vcHBvc2l0ZVNpZGUgJiYgdGhpcy5fb3Bwb3NpdGVTaWRlLm1vZGUgPT09ICdzcGxpdCcpIHtcbiAgICAgIHNsaWRpbmdFbGVtZW50cy5wdXNoKHRoaXMuX29wcG9zaXRlU2lkZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWRpbmdFbGVtZW50cztcbiAgfVxuXG4gIHRyYW5zbGF0ZShkaXN0YW5jZSkge1xuICAgIGlmICghdGhpcy5fc2xpZGluZ0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSB0aGlzLl9nZXRTbGlkaW5nRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAvLyBBdm9pZCBjb250ZW50IGNsaWNrc1xuXG4gICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIGRpc3RhbmNlfXB4LCAwcHgsIDBweClgXG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBvcGVuKGRvbmUpIHtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9zaWRlLm9mZnNldFdpZHRoO1xuICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgbWF4fXB4LCAwcHgsIDBweClgXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgY2xvc2UoZG9uZSkge1xuICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICBzdXBlci5jbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uLy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3IuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXZlYWxTcGxpdHRlckFuaW1hdG9yIGV4dGVuZHMgU3BsaXR0ZXJBbmltYXRvciB7XG5cbiAgX2dldFNsaWRpbmdFbGVtZW50cygpIHtcbiAgICBjb25zdCBzbGlkaW5nRWxlbWVudHMgPSBbdGhpcy5fY29udGVudCwgdGhpcy5fbWFza107XG4gICAgaWYgKHRoaXMuX29wcG9zaXRlU2lkZSAmJiB0aGlzLl9vcHBvc2l0ZVNpZGUubW9kZSA9PT0gJ3NwbGl0Jykge1xuICAgICAgc2xpZGluZ0VsZW1lbnRzLnB1c2godGhpcy5fb3Bwb3NpdGVTaWRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpZGluZ0VsZW1lbnRzO1xuICB9XG5cbiAgYWN0aXZhdGUoc2lkZUVsZW1lbnQpIHtcbiAgICBzdXBlci5hY3RpdmF0ZShzaWRlRWxlbWVudCk7XG4gICAgaWYgKHNpZGVFbGVtZW50Lm1vZGUgPT09ICdjb2xsYXBzZScpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlcyhzaWRlRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLl9zaWRlICYmIHRoaXMuX3Vuc2V0U3R5bGVzKHRoaXMuX3NpZGUpO1xuICAgIHN1cGVyLmRlYWN0aXZhdGUoKTtcbiAgfVxuXG4gIF9zZXRTdHlsZXMoc2lkZUVsZW1lbnQpIHtcbiAgICBzdHlsZXIoc2lkZUVsZW1lbnQsIHtcbiAgICAgIGxlZnQ6IHNpZGVFbGVtZW50LnNpZGUgPT09ICdyaWdodCcgPyAnYXV0bycgOiAwLFxuICAgICAgcmlnaHQ6IHNpZGVFbGVtZW50LnNpZGUgPT09ICdyaWdodCcgID8gMCA6ICdhdXRvJyxcbiAgICAgIHpJbmRleDogMCxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsYWNrJyxcbiAgICAgIHRyYW5zZm9ybTogdGhpcy5fZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUoMCkuY29udGFpbmVyLnRyYW5zZm9ybSxcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc3BsaXR0ZXIgPSBzaWRlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGNvbnRlbnRSZWFkeShzcGxpdHRlciwgKCkgPT4gc3BsaXR0ZXIuY29udGVudCAmJiBzdHlsZXIoc3BsaXR0ZXIuY29udGVudCwgeyBib3hTaGFkb3c6ICcwIDAgMTJweCAwIHJnYmEoMCwgMCwgMCwgMC4yKScgfSkpO1xuICB9XG5cbiAgX3Vuc2V0U3R5bGVzKHNpZGVFbGVtZW50KSB7XG4gICAgc3R5bGVyLmNsZWFyKHNpZGVFbGVtZW50LCAnbGVmdCByaWdodCB6SW5kZXggYmFja2dyb3VuZENvbG9yIGRpc3BsYXknKTtcbiAgICBpZiAoc2lkZUVsZW1lbnQuX2NvbnRlbnQpIHtcbiAgICAgIHNpZGVFbGVtZW50Ll9jb250ZW50LnN0eWxlLm9wYWNpdHkgPSAnJztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgb3RoZXIgc2lkZSBuZWVkcyB0aGUgY29tbW9uIHN0eWxlc1xuICAgIGlmICghdGhpcy5fb3Bwb3NpdGVTaWRlIHx8IHRoaXMuX29wcG9zaXRlU2lkZS5tb2RlID09PSAnc3BsaXQnKSB7XG4gICAgICBzaWRlRWxlbWVudC5wYXJlbnRFbGVtZW50LmNvbnRlbnQgJiYgc3R5bGVyLmNsZWFyKHNpZGVFbGVtZW50LnBhcmVudEVsZW1lbnQuY29udGVudCwgJ2JveFNoYWRvdycpO1xuICAgIH1cbiAgfVxuXG4gIF9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZShkaXN0YW5jZSkge1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4V2lkdGg7XG5cbiAgICBsZXQgYmVoaW5kRGlzdGFuY2UgPSAoZGlzdGFuY2UgLSBtYXgpIC8gbWF4ICogMTA7XG4gICAgYmVoaW5kRGlzdGFuY2UgPSBpc05hTihiZWhpbmREaXN0YW5jZSkgPyAwIDogTWF0aC5tYXgoTWF0aC5taW4oYmVoaW5kRGlzdGFuY2UsIDApLCAtMTApO1xuXG4gICAgY29uc3QgYmVoaW5kVHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7KHRoaXMubWludXMgPyAtMSA6IDEpICogYmVoaW5kRGlzdGFuY2V9JSwgMCwgMClgO1xuICAgIGNvbnN0IG9wYWNpdHkgPSAxICsgYmVoaW5kRGlzdGFuY2UgLyAxMDA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBvcGFjaXR5XG4gICAgICB9LFxuICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgIHRyYW5zZm9ybTogYmVoaW5kVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHRyYW5zbGF0ZShkaXN0YW5jZSkge1xuICAgIHRoaXMuX3NpZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHRoaXMuX3NpZGUuc3R5bGUuekluZGV4ID0gMTtcbiAgICB0aGlzLm1heFdpZHRoID0gdGhpcy5tYXhXaWR0aCB8fCB0aGlzLl9nZXRNYXhXaWR0aCgpO1xuICAgIGNvbnN0IG1lbnVTdHlsZSA9IHRoaXMuX2dlbmVyYXRlQmVoaW5kUGFnZVN0eWxlKE1hdGgubWluKGRpc3RhbmNlLCB0aGlzLm1heFdpZHRoKSk7XG5cbiAgICBpZiAoIXRoaXMuX3NsaWRpbmdFbGVtZW50cykge1xuICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzay5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgLy8gQXZvaWQgY29udGVudCBjbGlja3NcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2xpZGluZ0VsZW1lbnRzKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIGRpc3RhbmNlfXB4LCAwcHgsIDBweClgXG4gICAgICAgIH0pLFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUuX2NvbnRlbnQpXG4gICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGVudCksXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250YWluZXIpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBvcGVuKGRvbmUpIHtcbiAgICB0aGlzLl9zaWRlLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB0aGlzLl9zaWRlLnN0eWxlLnpJbmRleCA9IDE7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHRoaXMubWF4V2lkdGggfHwgdGhpcy5fZ2V0TWF4V2lkdGgoKTtcbiAgICBjb25zdCBtZW51U3R5bGUgPSB0aGlzLl9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZSh0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSB0aGlzLl9nZXRTbGlkaW5nRWxlbWVudHMoKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBGaXg6IFRpbWUgdG8gdXBkYXRlIHByZXZpb3VzIHRyYW5zbGF0ZTNkIGFmdGVyIGNoYW5naW5nIHN0eWxlLmRpc3BsYXlcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgdGhpcy5tYXhXaWR0aH1weCwgMHB4LCAwcHgpYFxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5fc2lkZS5fY29udGVudClcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGVudCwge1xuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRhaW5lciwge1xuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgfSwgMTAwMC82MCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgY2xvc2UoZG9uZSkge1xuICAgIGNvbnN0IG1lbnVTdHlsZSA9IHRoaXMuX2dlbmVyYXRlQmVoaW5kUGFnZVN0eWxlKDApO1xuICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMHB4LCAwcHgsIDBweCknXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlLl9jb250ZW50KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRlbnQsIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250YWluZXIsIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9zaWRlLnN0eWxlLnpJbmRleCA9IDA7XG4gICAgICAgICAgdGhpcy5fc2lkZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIHRoaXMuX3NpZGUuX2NvbnRlbnQuc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICBfZ2V0TWF4V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZGUub2Zmc2V0V2lkdGg7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9vdmVybGF5LWFuaW1hdG9yJztcbmltcG9ydCBQdXNoU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL3B1c2gtYW5pbWF0b3InO1xuaW1wb3J0IFJldmVhbFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9yZXZlYWwtYW5pbWF0b3InO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gIGRlZmF1bHQ6IE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yLFxuICBvdmVybGF5OiBPdmVybGF5U3BsaXR0ZXJBbmltYXRvcixcbiAgcHVzaDogUHVzaFNwbGl0dGVyQW5pbWF0b3IsXG4gIHJldmVhbDogUmV2ZWFsU3BsaXR0ZXJBbmltYXRvclxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXJcbiAqIEBjYXRlZ29yeSBtZW51XG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBBIGNvbXBvbmVudCB0aGF0IGVuYWJsZXMgcmVzcG9uc2l2ZSBsYXlvdXQgYnkgaW1wbGVtZW50aW5nIGJvdGggYSB0d28tY29sdW1uIGxheW91dCBhbmQgYSBzbGlkaW5nIG1lbnUgbGF5b3V0LlxuICpcbiAqICAgIEl0IGNhbiBiZSBjb25maWd1cmVkIHRvIGF1dG9tYXRpY2FsbHkgZXhwYW5kIGludG8gYSBjb2x1bW4gbGF5b3V0IG9uIGxhcmdlIHNjcmVlbnMgYW5kIGNvbGxhcHNlIHRoZSBtZW51IG9uIHNtYWxsZXIgc2NyZWVucy4gV2hlbiB0aGUgbWVudSBpcyBjb2xsYXBzZWQgdGhlIHVzZXIgY2FuIG9wZW4gaXQgYnkgc3dpcGluZy5cbiAqICBbL2VuXVxuICogIFtqYV1bL2phXVxuICogQGNvZGVwZW4gck9RT01MXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc3BsaXR0ZXJcbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItc2lkZVxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWVudS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlciBpZD1cInNwbGl0dGVyXCI+XG4gKiAgIDxvbnMtc3BsaXR0ZXItY29udGVudD5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItY29udGVudD5cbiAqXG4gKiAgIDxvbnMtc3BsaXR0ZXItc2lkZSBzaWRlPVwibGVmdFwiIHdpZHRoPVwiODAlXCIgY29sbGFwc2Ugc3dpcGVhYmxlPlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1zaWRlPlxuICogPC9vbnMtc3BsaXR0ZXI+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgdmFyIHNwbGl0dGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NwbGl0dGVyJyk7XG4gKiAgIHNwbGl0dGVyLmxlZnQub3BlbigpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBfZ2V0U2lkZShzaWRlKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsIGUgPT4ge1xuICAgICAgcmV0dXJuIHV0aWwubWF0Y2goZSwgJ29ucy1zcGxpdHRlci1zaWRlJykgJiYgZS5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSA9PT0gc2lkZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgbGVmdFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTGVmdCBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNpZGUoJ2xlZnQnKTtcbiAgfVxuICAvKipcbiAgICogQHByb3BlcnR5IHJpZ2h0XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SaWdodCBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTaWRlKCdyaWdodCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzaWRlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJzdCBgPG9ucy1zcGxpdHRlci1zaWRlPmAgZWxlbWVudCByZWdhcmRsZXNzIHRoZSBhY3R1YWwgc2lkZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHNpZGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItc2lkZScpO1xuICB9XG5cbiAgZ2V0IF9zaWRlcygpIHtcbiAgICByZXR1cm4gW3RoaXMubGVmdCwgdGhpcy5yaWdodF0uZmlsdGVyKGUgPT4gZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjb250ZW50XG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBjb250ZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXNwbGl0dGVyLWNvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCB0b3BQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuX2NvbnRlbnQ7XG4gIH1cblxuICBnZXQgbWFzaygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1tYXNrJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9vbkRldmljZUJhY2tCdXR0b24oZXZlbnQpIHtcbiAgICB0aGlzLl9zaWRlcy5zb21lKHMgPT4gcy5pc09wZW4gPyBzLmNsb3NlKCkgOiBmYWxzZSkgfHwgZXZlbnQuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgfVxuXG4gIF9vbk1vZGVDaGFuZ2UoZSkge1xuICAgIGlmIChlLnRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9sYXlvdXQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9sYXlvdXQoKSB7XG4gICAgdGhpcy5fc2lkZXMuZm9yRWFjaChzaWRlID0+IHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlW3NpZGUuc2lkZV0gPSBzaWRlLm1vZGUgPT09ICdzcGxpdCcgPyBzaWRlLnN0eWxlLndpZHRoIDogMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9vbk1vZGVDaGFuZ2UgPSB0aGlzLl9vbk1vZGVDaGFuZ2UuYmluZCh0aGlzKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAhdGhpcy5tYXNrICYmIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXNwbGl0dGVyLW1hc2snKSk7XG4gICAgICB0aGlzLl9sYXlvdXQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gdGhpcy5fb25EZXZpY2VCYWNrQnV0dG9uLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb2RlY2hhbmdlJywgdGhpcy5fb25Nb2RlQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX29uTW9kZUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHt9XG5cbiAgX3Nob3coKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19zaG93Jyk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfZGVzdHJveScpO1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yIGluc3RhbmNlb2YgU3BsaXR0ZXJBbmltYXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW5pbWF0b3IgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgU3BsaXR0ZXJBbmltYXRvci4nKTtcbiAgICB9XG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBTcGxpdHRlckFuaW1hdG9yKCkge1xuICAgIHJldHVybiBTcGxpdHRlckFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlNwbGl0dGVyID0gU3BsaXR0ZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXInLCBTcGxpdHRlckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi4vb25zL29yaWVudGF0aW9uJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL29ucy1zcGxpdHRlci9hbmltYXRvcic7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCBTd2lwZVJldmVhbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvc3dpcGUtcmV2ZWFsJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgeyBQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlcn0gZnJvbSAnLi4vb25zL3BhZ2UtbG9hZGVyJztcbmltcG9ydCBTcGxpdHRlckVsZW1lbnQgZnJvbSAnLi9vbnMtc3BsaXR0ZXInO1xuXG5jb25zdCBTUExJVF9NT0RFID0gJ3NwbGl0JztcbmNvbnN0IENPTExBUFNFX01PREUgPSAnY29sbGFwc2UnO1xuY29uc3QgQ0xPU0VEX1NUQVRFID0gJ2Nsb3NlZCc7XG5jb25zdCBPUEVOX1NUQVRFID0gJ29wZW4nO1xuY29uc3QgQ0hBTkdJTkdfU1RBVEUgPSAnY2hhbmdpbmcnO1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc3BsaXR0ZXJTaWRlRWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkoc3BsaXR0ZXJTaWRlRWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9XG59O1xuXG5jbGFzcyBDb2xsYXBzZURldGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHRhcmdldCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX29uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0YXJnZXQgJiYgdGhpcy5jaGFuZ2VUYXJnZXQodGFyZ2V0KTtcbiAgfVxuXG4gIGNoYW5nZVRhcmdldCh0YXJnZXQpIHtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBbJ3BvcnRyYWl0JywgJ2xhbmRzY2FwZSddLmluZGV4T2YodGFyZ2V0KSAhPT0gLTE7XG4gICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX21hdGNoKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0ID09PSAodmFsdWUuaXNQb3J0cmFpdCA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5tYXRjaGVzO1xuICB9XG5cbiAgX29uQ2hhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5fZWxlbWVudC5fdXBkYXRlTW9kZSh0aGlzLl9tYXRjaCh2YWx1ZSkgPyBDT0xMQVBTRV9NT0RFIDogU1BMSVRfTU9ERSk7XG4gIH1cblxuICBhY3RpdmF0ZSgpIHtcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIG9yaWVudGF0aW9uLm9uKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSh7aXNQb3J0cmFpdDogb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0ID0gd2luZG93Lm1hdGNoTWVkaWEodGhpcy5fdGFyZ2V0KTtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LmFkZExpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHRoaXMuX3F1ZXJ5UmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9xdWVyeVJlc3VsdCkge1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQucmVtb3ZlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCB3aWR0aFRvUHggPSAod2lkdGgsIHBhcmVudCkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHB4XSA9IFtwYXJzZUludCh3aWR0aCwgMTApLCAvcHgvLnRlc3Qod2lkdGgpXTtcbiAgcmV0dXJuIHB4ID8gdmFsdWUgOiBNYXRoLnJvdW5kKHBhcmVudC5vZmZzZXRXaWR0aCAqIHZhbHVlIC8gMTAwKTtcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyLXNpZGVcbiAqIEBjYXRlZ29yeSBtZW51XG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cbiAqXG4gKiAgICBJdCB3aWxsIGJlIGRpc3BsYXllZCBvbiBlaXRoZXIgdGhlIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiB0aGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQuXG4gKlxuICogICAgSXQgc3VwcG9ydHMgdHdvIG1vZGVzOiBjb2xsYXBzZWQgYW5kIHNwbGl0LiBXaGVuIGl0J3MgaW4gY29sbGFwc2VkIG1vZGUgaXQgd2lsbCBiZSBoaWRkZW4gZnJvbSB2aWV3IGFuZCBjYW4gYmUgZGlzcGxheWVkIHdoZW4gdGhlIHVzZXIgc3dpcGVzIHRoZSBzY3JlZW4gb3IgdGFwcyBhIGJ1dHRvbi4gSW4gc3BsaXQgbW9kZSB0aGUgZWxlbWVudCBpcyBhbHdheXMgc2hvd24uIEl0IGNhbiBiZSBjb25maWd1cmVkIHRvIGF1dG9tYXRpY2FsbHkgc3dpdGNoIGJldHdlZW4gdGhlIHR3byBtb2RlcyBkZXBlbmRpbmcgb24gdGhlIHNjcmVlbiBzaXplLlxuICogIFsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl6KaB57Sg44Gv44CBb25zLXNwbGl0dGVy6KaB57Sg44Gu5a2Q6KaB57Sg44Go44GX44Gm5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHJPUU9NTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwbGl0dGVyXG4gKiBAZ3VpZGUgZnVuZGFtZW50YWxzLmh0bWwjbWFuYWdpbmctcGFnZXNcbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBpcyB0aGUgcGFyZW50IGNvbXBvbmVudC5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlcj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlclNpZGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgbW9kZWNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgY29tcG9uZW50J3MgbW9kZSBjaGFuZ2VzLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBruODouODvOODieOBjOWkieWMluOBl+OBn+mam+OBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQubW9kZVxuICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBjdXJyZW50IG1vZGUuIENhbiBiZSBlaXRoZXIgYFwiY29sbGFwc2VcImAgb3IgYFwic3BsaXRcImAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oi44O844OJ44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgc2xpZGluZyBtZW51IGlzIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/liY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmcgbWVudS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/jga7jgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdG9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHNsaWRpbmcgbWVudSBpcyBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GE44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlY2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkaW5nIG1lbnUgaXMgY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0byBjYW5jZWwgb3BlbmluZyBzbGlkaW5nLW1lbnUuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44KL44Gu44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24uIFVzZSBvbmUgb2YgYG92ZXJsYXlgLCBgcHVzaGAsIGByZXZlYWxgIG9yICBgZGVmYXVsdGAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJcIm92ZXJsYXlcIiwgXCJwdXNoXCIsIFwicmV2ZWFsXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9wZW4tdGhyZXNob2xkXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0ICAwLjNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBob3cgbXVjaCB0aGUgbWVudSBuZWVkcyB0byBiZSBzd2lwZWQgYmVmb3JlIG9wZW5pbmcuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxYC5bL2VuXVxuICAgKiAgW2phXeOBqeOBruOBj+OCieOBhOOCueODr+OCpOODl+OBmeOCjOOBsOOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOCkumWi+OBj+OBi+OBqeOBhuOBi+OBruWJsuWQiOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokx44Gu6ZaT44Gu5pWw5YCk44KS5oyH5a6a44GX44G+44GZ44CC44K544Ov44Kk44OX44Gu6Led6Zui44GM44GT44GT44Gn5oyH5a6a44GX44Gf5pWw5YCk5o6b44GR44KL44GT44Gu6KaB57Sg44Gu5bmF44KI44KK44KC5aSn44GN44GR44KM44Gw44CB44K544Ov44Kk44OX44GM57WC44KP44Gj44Gf5pmC44Gr44GT44Gu6KaB57Sg44KS6ZaL44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvMC4z44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29sbGFwc2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgU3BlY2lmeSB0aGUgY29sbGFwc2UgYmVoYXZpb3IuIFZhbGlkIHZhbHVlcyBhcmUgYFwicG9ydHJhaXRcImAsIGBcImxhbmRzY2FwZVwiYCBvciBhIG1lZGlhIHF1ZXJ5LlxuICAgKiAgICAgVGhlIHN0cmluZ3MgYFwicG9ydHJhaXRcImAgYW5kIGBcImxhbmRzY2FwZVwiYCBtZWFucyB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gZGV2aWNlIGlzIGluIGxhbmRzY2FwZSBvciBwb3J0cmFpdCBvcmllbnRhdGlvbi5cbiAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBhIG1lZGlhIHF1ZXJ5LCB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gdGhlIG1lZGlhIHF1ZXJ5IHJlc29sdmVzIHRvIGB0cnVlYC5cbiAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBub3QgZGVmaW5lZCwgdGhlIHZpZXcgYWx3YXlzIGJlIGluIGBcImNvbGxhcHNlXCJgIG1vZGUuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDlt6blgbTjga7jg5rjg7zjgrjjgpLpnZ7ooajnpLrjgavjgZnjgovmnaHku7bjgpLmjIflrprjgZfjgb7jgZnjgIJwb3J0cmFpdCwgbGFuZHNjYXBl44CBd2lkdGggI3B444KC44GX44GP44Gv44Oh44OH44Kj44Ki44Kv44Ko44Oq44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCXG4gICAqICAgICBwb3J0cmFpdOOCguOBl+OBj+OBr2xhbmRzY2FwZeOCkuaMh+WumuOBmeOCi+OBqOOAgeODh+ODkOOCpOOCueOBrueUu+mdouOBjOe4puWQkeOBjeOCguOBl+OBj+OBr+aoquWQkeOBjeOBq+OBquOBo+OBn+aZguOBq+mBqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44Oh44OH44Kj44Ki44Kv44Ko44Oq44KS5oyH5a6a44GZ44KL44Go44CB5oyH5a6a44GX44Gf44Kv44Ko44Oq44Gr6YGp5ZCI44GX44Gm44GE44KL5aC05ZCI44Gr6YGp55So44GV44KM44G+44GZ44CCXG4gICAqICAgICDlgKTjgavkvZXjgoLmjIflrprjgZfjgarjgYTloLTlkIjjgavjga/jgIHluLjjgatjb2xsYXBzZeODouODvOODieOBq+OBquOCiuOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRhcmdldC13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHdpZHRoIG9mIHN3aXBlYWJsZSBhcmVhIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZWRnZSAoaW4gcGl4ZWxzKS4gVXNlIHRoaXMgdG8gZW5hYmxlIHN3aXBlIG9ubHkgd2hlbiB0aGUgZmluZ2VyIHRvdWNoIG9uIHRoZSBzY3JlZW4gZWRnZS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6/jgqTjg5fjga7liKTlrprpoJjln5/jgpLjg5Tjgq/jgrvjg6vljZjkvY3jgafmjIflrprjgZfjgb7jgZnjgILnlLvpnaLjga7nq6/jgYvjgonmjIflrprjgZfjgZ/ot53pm6LjgavpgZTjgZnjgovjgajjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB3aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2FuIGJlIHNwZWNpZmllZCBpbiBlaXRoZXIgcGl4ZWxzIG9yIGFzIGEgcGVyY2VudGFnZSwgZS5nLiBgOTAlYCBvciBgMjAwcHhgLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBruaoquW5heOCkuaMh+WumuOBl+OBvuOBmeOAgnB444GoJeOBp+OBruaMh+WumuOBjOWPr+iDveOBp+OBmeOAgmVnLiA5MCUsIDIwMHB4Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2lkZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBsZWZ0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoaWNoIHNpZGUgb2YgdGhlIHNjcmVlbiB0aGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgaXMgbG9jYXRlZC4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJsZWZ0XCJgIGFuZCBgXCJyaWdodFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjgYzlt6bjgYvlj7PjgYvjgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovlgKTjga9cImxlZnRcIuOBi1wicmlnaHRcIuOBruOBv+OBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgbW9kZS4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJjb2xsYXBzZVwiYCBvciBgXCJzcGxpdFwiYC4gVGhpcyBhdHRyaWJ1dGUgaXMgcmVhZCBvbmx5LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODouODvOODieOBjOioreWumuOBleOCjOOBvuOBmeOAglwiY29sbGFwc2VcIuOCguOBl+OBj+OBr1wic3BsaXRcIuOBjOaMh+WumuOBleOCjOOBvuOBmeOAguOBk+OBruWxnuaAp+OBr+iqreOBv+i+vOOBv+WwgueUqOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgVVJMIG9mIHRoZSBtZW51IHBhZ2UuWy9lbl1cbiAgICogICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZWFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRvIGVuYWJsZSBzd2lwZSBpbnRlcmFjdGlvbiBvbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAqICAgW2phXWNvbGxhcHNl44Oi44O844OJ5pmC44Gr44K544Ov44Kk44OX5pON5L2c44KS5pyJ5Yq544Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3BhZ2UgPSBudWxsO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0VEX1NUQVRFO1xuICAgIHRoaXMuX2xvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24gPSBuZXcgQ29sbGFwc2VEZXRlY3Rpb24odGhpcyk7XG5cbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogU3BsaXR0ZXJFbGVtZW50LmFuaW1hdG9ycyxcbiAgICAgIGJhc2VDbGFzczogU3BsaXR0ZXJBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdTcGxpdHRlckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIC8vIFRoZXNlIGF0dHJpYnV0ZXMgYXJlIHVzZWQgZWFybHkgYnkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnd2lkdGgnKTtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ3NpZGUnKSkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2lkZScsICdsZWZ0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFnZSA9IHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgICAgICAgcGFnZSAmJiB0aGlzLmxvYWQocGFnZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgbXVzdCBiZSBhbiBvbnMtc3BsaXR0ZXIgZWxlbWVudC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zd2lwZSA9IG5ldyBTd2lwZVJldmVhbCh7XG4gICAgICBlbGVtZW50OiB0aGlzLFxuICAgICAgZWxlbWVudEhhbmRsZXI6IHRoaXMucGFyZW50RWxlbWVudCxcbiAgICAgIHN3aXBlTWF4OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSgxLCB0aGlzLl9hbmltYXRpb25PcHQpO1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH0sXG4gICAgICBzd2lwZU1pZDogKGRpc3RhbmNlLCB3aWR0aCkgPT4ge1xuICAgICAgICB0aGlzLl9vblN3aXBlICYmIHRoaXMuX29uU3dpcGUoZGlzdGFuY2Uvd2lkdGgpO1xuICAgICAgICB0aGlzLl9hbmltYXRvci50cmFuc2xhdGUoZGlzdGFuY2UpO1xuICAgICAgfSxcbiAgICAgIHN3aXBlTWluOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSgwLCB0aGlzLl9hbmltYXRpb25PcHQpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9LFxuICAgICAgZ2V0VGhyZXNob2xkOiAoKSA9PiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdvcGVuLXRocmVzaG9sZCcpKSB8fCAwLjMpKSxcbiAgICAgIGdldFNpZGU6ICgpID0+IHRoaXMuc2lkZSxcbiAgICAgIGlzSW5pdGlhbFN0YXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb3NlZCA9IHRoaXMuX3N0YXRlID09PSBDTE9TRURfU1RBVEU7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG4gICAgICAgIHJldHVybiBjbG9zZWQ7XG4gICAgICB9LFxuICAgICAgaWdub3JlU3dpcGU6IChldmVudCwgZGlzdGFuY2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNPcGVuID0gdGhpcy5pc09wZW47XG4gICAgICAgIGNvbnN0IHZhbGlkRHJhZyA9IGQgPT4gdGhpcy5zaWRlID09PSAnbGVmdCdcbiAgICAgICAgICA/ICgoZCA9PT0gJ2xlZnQnICYmIGlzT3BlbikgfHwgKGQgPT09ICdyaWdodCcgJiYgIWlzT3BlbikpXG4gICAgICAgICAgOiAoKGQgPT09ICdsZWZ0JyAmJiAhaXNPcGVuKSB8fCAoZCA9PT0gJ3JpZ2h0JyAmJiBpc09wZW4pKTtcblxuICAgICAgICBjb25zdCBhcmVhID0gTWF0aC5tYXgoMCwgcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlLXRhcmdldC13aWR0aCcpLCAxMCkgfHwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGUgPT09IFNQTElUX01PREUgfHwgdGhpcy5fbG9jay5pc0xvY2tlZCgpIHx8IHRoaXMuX2lzT3RoZXJTaWRlT3BlbigpXG4gICAgICAgICAgfHwgIXZhbGlkRHJhZyhldmVudC5nZXN0dXJlLmRpcmVjdGlvbilcbiAgICAgICAgICB8fCAoIWlzT3BlbiAmJiBhcmVhICE9PSAwICYmIGRpc3RhbmNlID4gYXJlYSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnc3dpcGVhYmxlJyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5vYnNlcnZlZEF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgc2lkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSA9PT0gJ3JpZ2h0JyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9zd2lwZSAmJiB0aGlzLl9zd2lwZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRpb25PcHQgPSB0aGlzLl9zd2lwZSA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydhbmltYXRpb24nLCAnd2lkdGgnLCAnY29sbGFwc2UnLCAnc3dpcGVhYmxlJywgJ2FuaW1hdGlvbi1vcHRpb25zJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnc3dpcGVhYmxlJzpcbiAgICAgICAgdGhpcy5fc3dpcGUgJiYgdGhpcy5fc3dpcGUudXBkYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICB0aGlzLnN0eWxlLndpZHRoID0gL15cXGQrKHB4fCUpJC8udGVzdChjdXJyZW50KSA/IGN1cnJlbnQgOiAnODAlJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzW3V0aWwuY2FtZWxpemUoYF91cGRhdGUtJHtuYW1lfWApXShjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBfZW1pdEV2ZW50KG5hbWUpIHtcbiAgICBpZiAobmFtZS5zbGljZSgwLCAzKSAhPT0gJ3ByZScpIHtcbiAgICAgIHJldHVybiB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgbmFtZSwge3NpZGU6IHRoaXN9KTtcbiAgICB9XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCBuYW1lLCB7XG4gICAgICBzaWRlOiB0aGlzLFxuICAgICAgY2FuY2VsOiAoKSA9PiBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGlzQ2FuY2VsZWQ7XG4gIH1cblxuICBfaXNPdGhlclNpZGVPcGVuKCkge1xuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKHRoaXMucGFyZW50RWxlbWVudCxcbiAgICAgIGVsID0+IGVsIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciAmJiBlbCAhPT0gdGhpcyAmJiBlbC5fbW9kZSA9PT0gQ09MTEFQU0VfTU9ERSAmJiBlbC5pc09wZW5cbiAgICApO1xuICB9XG5cbiAgX3VwZGF0ZUNvbGxhcHNlKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NvbGxhcHNlJykpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICdzcGxpdCcpIHtcbiAgICAgIHRoaXMuX2NvbGxhcHNlRGV0ZWN0aW9uLmRpc2FibGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl91cGRhdGVNb2RlKFNQTElUX01PREUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAnY29sbGFwc2UnKSB7XG4gICAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTW9kZShDT0xMQVBTRV9NT0RFKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5jaGFuZ2VUYXJnZXQodmFsdWUpO1xuICB9XG5cbiAgX3VwZGF0ZU1vZGUobW9kZSkge1xuICAgIGlmIChtb2RlICE9PSB0aGlzLl9tb2RlKSB7XG4gICAgICB0aGlzLl9tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdtb2RlJywgbW9kZSk7IC8vIHJlYWRvbmx5IGF0dHJpYnV0ZSBmb3IgdGhlIHVzZXJzXG5cbiAgICAgIGlmIChtb2RlID09PSBTUExJVF9NT0RFKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yICYmIHRoaXMuX2FuaW1hdG9yLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBDTE9TRURfU1RBVEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hbmltYXRvciAmJiB0aGlzLl9hbmltYXRvci5hY3RpdmF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPT09IE9QRU5fU1RBVEUgJiYgdGhpcy5fYW5pbWF0b3Iub3BlbigpO1xuICAgICAgfVxuXG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ21vZGVjaGFuZ2UnLCB7IHNpZGU6IHRoaXMsIG1vZGUgfSk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbihhbmltYXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykpIHtcbiAgICB0aGlzLl9hbmltYXRvciAmJiB0aGlzLl9hbmltYXRvci5kZWFjdGl2YXRlKCk7XG4gICAgdGhpcy5fYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Ioe2FuaW1hdGlvbn0pO1xuICAgIHRoaXMuX2FuaW1hdG9yLmFjdGl2YXRlKHRoaXMpO1xuICAgIHRoaXMuX2FuaW1hdGlvbk9wdCA9IHtcbiAgICAgIHRpbWluZzogdGhpcy5fYW5pbWF0b3IuZHVyYXRpb24sXG4gICAgICBkdXJhdGlvbjogdGhpcy5fYW5pbWF0b3IuZHVyYXRpb25cbiAgICB9O1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdGlvbk9wdGlvbnModmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkge1xuICAgIHRoaXMuX2FuaW1hdG9yLnVwZGF0ZU9wdGlvbnMoQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZSBsb2NhdGlvbiB0byBsb2FkIGluIHRoZSBzcGxpdHRlciBzaWRlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOWGheOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXQgcGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IHBhZ2VcbiAgICovXG4gIHNldCBwYWdlKHBhZ2UpIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgfVxuXG4gIGdldCBfY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZUxvYWRlclxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHRocm93IEVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBQYWdlTG9hZGVyLicpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBtb2RlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwic3BsaXRcIiwgXCJjb2xsYXBzZVwiLCBcImNsb3NlZFwiLCBcIm9wZW5cIiBvciBcImNoYW5naW5nXCIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblN3aXBlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvb2sgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIHNsaWRlcyB0aGUgc3BsaXR0ZXIuIEl0IGdldHMgYSBkZWNpbWFsIHJhdGlvICgwLTEpIGFuZCBhbiBhbmltYXRpb25PcHRpb25zIG9iamVjdCBhcyBhcmd1bWVudHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvblN3aXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9vblN3aXBlO1xuICB9XG5cbiAgc2V0IG9uU3dpcGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnb25Td2lwZScgbXVzdCBiZSBhIGZ1bmN0aW9uLmApXG4gICAgfVxuICAgIHRoaXMuX29uU3dpcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaXNPcGVuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoaXMgdmFsdWUgaXMgYHRydWVgIHdoZW4gdGhlIG1lbnUgaXMgb3Blbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZSA9PT0gQ09MTEFQU0VfTU9ERSAmJiB0aGlzLl9zdGF0ZSAhPT0gQ0xPU0VEX1NUQVRFO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgb3BlblxuICAgKiBAc2lnbmF0dXJlIG9wZW4oW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gb3BlbmVkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWi+OBhOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVuIG1lbnUgaW4gY29sbGFwc2UgbW9kZS5bL2VuXVxuICAgKiAgIFtqYV1jb2xsYXBzZeODouODvOODieOBq+OBquOBo+OBpuOBhOOCi29ucy1zcGxpdHRlci1zaWRl6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBvcGVuKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGUob3B0aW9ucywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBjbG9zZVxuICAgKiBAc2lnbmF0dXJlIGNsb3NlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBtZW51IGhhcyBiZWVuIGNsb3NlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Hjg4vjg6Xjg7zjgYzplonjgZjjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2xvc2UgbWVudSBpbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAqICAgW2phXWNvbGxhcHNl44Oi44O844OJ44Gr44Gq44Gj44Gm44GE44KLb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGNsb3NlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGUob3B0aW9ucywgZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dT3BlbnMgaWYgaXQncyBjbG9zZWQuIENsb3NlcyBpZiBpdCdzIG9wZW4uWy9lbl1cbiAgICogICBbamFd6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaJ44GY44G+44GZ44Gd44GX44Gm6ZaL44GR44Gm44GE44KL5aC05ZCI44Gv6KaB57Sg44KS6ZaL44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIHNwbGl0dGVyIHNpZGUgZWxlbWVudCBvciBmYWxzZSBpZiBub3QgaW4gY29sbGFwc2UgbW9kZVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICB0b2dnbGUob3B0aW9ucyA9IHt9LCBmb3JjZSkge1xuICAgIGNvbnN0IHNob3VsZE9wZW4gPSB0eXBlb2YgZm9yY2UgPT09ICdib29sZWFuJyA/IGZvcmNlIDogIXRoaXMuaXNPcGVuO1xuICAgIGNvbnN0IGFjdGlvbiA9IHNob3VsZE9wZW4gPyAnb3BlbicgOiAnY2xvc2UnLFxuICAgICAgRklOQUxfU1RBVEUgPSBzaG91bGRPcGVuID8gT1BFTl9TVEFURSA6IENMT1NFRF9TVEFURTtcblxuICAgIGlmICh0aGlzLl9tb2RlID09PSBTUExJVF9NT0RFKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBGSU5BTF9TVEFURSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xvY2suaXNMb2NrZWQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBbm90aGVyIHNwbGl0dGVyLXNpZGUgYWN0aW9uIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZE9wZW4gJiYgdGhpcy5faXNPdGhlclNpZGVPcGVuKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnQW5vdGhlciBtZW51IGlzIGFscmVhZHkgb3Blbi4nKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2VtaXRFdmVudChgcHJlJHthY3Rpb259YCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChgQ2FuY2VsZWQgaW4gcHJlJHthY3Rpb259IGV2ZW50LmApO1xuICAgIH1cblxuICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2xvY2subG9jaygpO1xuICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRvclthY3Rpb25dKCgpID0+IHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBGSU5BTF9TVEFURTtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgIHRoaXMuX2VtaXRFdmVudChgcG9zdCR7YWN0aW9ufWApO1xuICAgICAgICBvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb3B0aW9ucy5jYWxsYmFjayh0aGlzKTtcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbG9hZFxuICAgKiBAc2lnbmF0dXJlIGxvYWQocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhbiBIVE1MIGRvY3VtZW50IG9yIGFuIDxvbnMtdGVtcGxhdGU+LlsvZW5dXG4gICAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIFvbnMtdGVtcGxhdGXjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHRoZSBwYWdlIHNwZWNpZmllZCBpbiBwYWdlVXJsIGluIHRoZSByaWdodCBzZWN0aW9uWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfVVJM44KS44Oh44Kk44Oz44Oa44O844K444KS6Kqt44G/6L6844G/44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgbG9hZChwYWdlLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9wYWdlID0gcGFnZTtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgKCgpID0+IHt9KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBvbGRDb250ZW50ID0gdGhpcy5fY29udGVudCB8fCBudWxsO1xuXG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKG9sZENvbnRlbnQpIHtcbiAgICAgICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZChvbGRDb250ZW50KTtcbiAgICAgICAgICBvbGRDb250ZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zaG93KCkpO1xuXG4gICAgICAgIGNhbGxiYWNrKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9zaG93KCk7XG4gICAgfVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuX2hpZGUoKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5fY29udGVudCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwcmVvcGVuJywgJ3Bvc3RvcGVuJywgJ3ByZWNsb3NlJywgJ3Bvc3RjbG9zZScsICdtb2RlY2hhbmdlJ107XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJld3JpdGFibGVzKCkge1xuICAgIHJldHVybiByZXdyaXRhYmxlcztcbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuU3BsaXR0ZXJTaWRlID0gU3BsaXR0ZXJTaWRlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLXNpZGUnLCBTcGxpdHRlclNpZGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlQ2hlY2tib3hFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWNoZWNrYm94JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzd2l0Y2gtLSonLFxuICAnLnN3aXRjaF9faW5wdXQnOiAnc3dpdGNoLS0qX19pbnB1dCcsXG4gICcuc3dpdGNoX19oYW5kbGUnOiAnc3dpdGNoLS0qX19oYW5kbGUnLFxuICAnLnN3aXRjaF9fdG9nZ2xlJzogJ3N3aXRjaC0tKl9fdG9nZ2xlJ1xufTtcblxuY29uc3QgbG9jYXRpb25zID0ge1xuICBpb3M6IFsxLCAyMV0sXG4gIG1hdGVyaWFsOiBbMCwgMTZdXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1zd2l0Y2hcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFN3aXRjaCBjb21wb25lbnQuIFRoZSBzd2l0Y2ggY2FuIGJlIHRvZ2dsZWQgYm90aCBieSBkcmFnZ2luZyBhbmQgdGFwcGluZy5cbiAqXG4gKiAgICAgV2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIHN3aXRjaCBvbiBBbmRyb2lkIGRldmljZXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgrnjgqTjg4Pjg4HjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3dpdGNoWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBMcFhaUVFcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9zd2l0Y2hcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3dpdGNoIGNoZWNrZWQ+PC9vbnMtc3dpdGNoPlxuICogPG9ucy1zd2l0Y2ggZGlzYWJsZWQ+PC9vbnMtc3dpdGNoPlxuICogPG9ucy1zd2l0Y2ggbW9kaWZpZXI9XCJtYXRlcmlhbFwiPjwvb25zLXN3aXRjaD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2l0Y2hFbGVtZW50IGV4dGVuZHMgQmFzZUNoZWNrYm94RWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnbW9kaWZpZXInLCBudWxsLCB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9ib3VuZE9uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9ib3VuZE9uUmVsZWFzZSA9IHRoaXMuX29uUmVsZWFzZS5iaW5kKHRoaXMpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJ3N3aXRjaCc7XG4gIH1cblxuICBnZXQgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8aW5wdXQgdHlwZT1cIiR7dGhpcy50eXBlfVwiIGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9faW5wdXRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X190b2dnbGVcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2hhbmRsZVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCIke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X190b3VjaFwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2NoZWNrYm94JztcbiAgfVxuXG4gIC8qIE93biBwcm9wcyAqL1xuXG4gIF9nZXRQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgbCA9IHRoaXMuX2xvY2F0aW9ucztcbiAgICByZXR1cm4gTWF0aC5taW4obFsxXSwgTWF0aC5tYXgobFswXSwgdGhpcy5fc3RhcnRYICsgZS5nZXN0dXJlLmRlbHRhWCkpO1xuICB9XG5cbiAgX2VtaXRDaGFuZ2VFdmVudCgpIHtcbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2NoYW5nZScsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmNoZWNrZWQsXG4gICAgICBzd2l0Y2g6IHRoaXMsXG4gICAgICBpc0ludGVyYWN0aXZlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBfb25DaGFuZ2UoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgfVxuXG4gIF9vbkNsaWNrKGV2KSB7XG4gICAgaWYgKGV2LnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoYCR7dGhpcy5kZWZhdWx0RWxlbWVudENsYXNzfV9fdG91Y2hgKSkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cblxuICBfb25Ib2xkKGUpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5hZGRNb2RpZmllcih0aGlzLCAnYWN0aXZlJyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWdTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihlLmdlc3R1cmUuZGlyZWN0aW9uKSA9PT0gLTEpIHtcbiAgICAgIE1vZGlmaWVyVXRpbC5yZW1vdmVNb2RpZmllcih0aGlzLCAnYWN0aXZlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5jb25zdW1lZCA9IHRydWU7XG5cbiAgICBNb2RpZmllclV0aWwuYWRkTW9kaWZpZXIodGhpcywgJ2FjdGl2ZScpO1xuICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX2xvY2F0aW9uc1t0aGlzLmNoZWNrZWQgPyAxIDogMF07Ly8gLSBlLmdlc3R1cmUuZGVsdGFYO1xuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fYm91bmRPblJlbGVhc2UpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBlLmdlc3R1cmUucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLl9oYW5kbGUuc3R5bGUubGVmdCA9IHRoaXMuX2dldFBvc2l0aW9uKGUpICsgJ3B4JztcbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9sb2NhdGlvbnM7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbihlKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5jaGVja2VkO1xuXG4gICAgdGhpcy5jaGVja2VkID0gcG9zaXRpb24gPj0gKGxbMF0gKyBsWzFdKSAvIDI7XG5cbiAgICBpZiAodGhpcy5jaGVja2VkICE9PSBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9ib3VuZE9uUmVsZWFzZSk7XG5cbiAgICB0aGlzLl9oYW5kbGUuc3R5bGUubGVmdCA9ICcnO1xuICAgIE1vZGlmaWVyVXRpbC5yZW1vdmVNb2RpZmllcih0aGlzLCAnYWN0aXZlJyk7XG4gIH1cblxuICBjbGljaygpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX2hhbmRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9faGFuZGxlYCk7XG4gIH1cblxuICBnZXQgY2hlY2tib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0O1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX2JvdW5kT25DaGFuZ2UpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHtkcmFnTWluRGlzdGFuY2U6IDEsIGhvbGRUaW1lb3V0OiAyNTF9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLmNsaWNrKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgaWYgKHRoaXMuX2dlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcywgJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBjb25zdCBtZCA9IChjdXJyZW50IHx8ICcnKS5pbmRleE9mKCdtYXRlcmlhbCcpICE9PSAtMTtcbiAgICAgIHRoaXMuX2xvY2F0aW9ucyA9IGxvY2F0aW9uc1ttZCA/ICdtYXRlcmlhbCcgOiAnaW9zJ107XG4gICAgfVxuXG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBldmVudCBjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHN3aXRjaCBpcyB0b2dnbGVkLlsvZW5dXG4gICAqICAgW2phXU9OL09GRuOBjOWkieOCj+OBo+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnN3aXRjaFxuICAgKiAgIFtlbl1Td2l0Y2ggb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn1N3aXRjaOOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQudmFsdWVcbiAgICogICBbZW5dQ3VycmVudCB2YWx1ZS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7lgKTjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzSW50ZXJhY3RpdmVcbiAgICogICBbZW5dVHJ1ZSBpZiB0aGUgY2hhbmdlIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHVzZXIgY2xpY2tpbmcgb24gdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgarjganjga7jg6bjg7zjgrbjga7mk43kvZzjgavjgojjgaPjgablpInjgo/jgaPjgZ/loLTlkIjjgavjga90cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgW2phXeOCueOCpOODg+ODgeOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzd2l0Y2ggaXMgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44KS54Sh5Yq544Gu54q25oWL44Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2hlY2tlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7nirbmhYvjgavjgZnjgovjgajjgY3jgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYGlkYCBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHZhbHVlIGlzIGB0cnVlYCBpZiB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7loLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tib3hcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB1bmRlcmx5aW5nIGNoZWNrYm94IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI5YaF6YOo44GuY2hlY2tib3jopoHntKDjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxufVxuXG5vbnMuZWxlbWVudHMuU3dpdGNoID0gU3dpdGNoRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXN3aXRjaCcsIFN3aXRjaEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9ucyBmcm9tICcuLi8uLi9vbnMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IFN3aXBlciBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvc3dpcGVyJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcudGFiYmFyX19jb250ZW50JzogJ3RhYmJhci0tKl9fY29udGVudCcsXG4gICcudGFiYmFyX19ib3JkZXInOiAndGFiYmFyLS0qX19ib3JkZXInLFxuICAnLnRhYmJhcic6ICd0YWJiYXItLSonXG59O1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gdGFiYmFyRWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkodGFiYmFyRWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59O1xuXG5jb25zdCBudWxsUGFnZSA9IGludGVybmFsLm51bGxFbGVtZW50O1xuY29uc3QgbGVycCA9ICh4MCwgeDEsIHQpID0+ICgxIC0gdCkgKiB4MCArIHQgKiB4MTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGFiYmFyXG4gKiBAY2F0ZWdvcnkgdGFiYmFyXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUEgY29tcG9uZW50IHRvIGRpc3BsYXkgYSB0YWIgYmFyIG9uIHRoZSBib3R0b20gb2YgYSBwYWdlLiBVc2VkIHdpdGggYDxvbnMtdGFiPmAgdG8gbWFuYWdlIHBhZ2VzIHVzaW5nIHRhYnMuWy9lbl1cbiAqICAgW2phXeOCv+ODluODkOODvOOCkuODmuODvOOCuOS4i+mDqOOBq+ihqOekuuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAgm9ucy10YWLjgajntYTjgb/lkIjjgo/jgZvjgabkvb/jgYbjgZPjgajjgafjgIHjg5rjg7zjgrjjgpLnrqHnkIbjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4gcEd1RExcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS90YWJiYXJcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dQSB0YWJiYXIgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIGF1dG9ncm93XG4gKiAgIFtlbl1UYWJzIGF1dG9tYXRpY2FsbHkgZ3JvdyBkZXBlbmRpbmcgb24gdGhlaXIgY29udGVudCBpbnN0ZWFkIG9mIGhhdmluZyBhIGZpeGVkIHdpZHRoLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHRvcC1ib3JkZXJcbiAqICAgW2VuXVNob3dzIGEgc3RhdGljIGJvcmRlci1ib3R0b20gaW4gdGFicyBmb3IgaU9TIHRvcCB0YWJiYXJzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIGZ1bmRhbWVudGFscy5odG1sI21hbmFnaW5nLXBhZ2VzXG4gKiAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiXG4gKiAgIFtlbl1UaGUgYDxvbnMtdGFiPmAgY29tcG9uZW50LlsvZW5dXG4gKiAgIFtqYV1vbnMtdGFi44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wYWdlXG4gKiAgIFtlbl1UaGUgYDxvbnMtcGFnZT5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXBhZ2XjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdGFiYmFyPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJob21lLmh0bWxcIlxuICogICAgIGxhYmVsPVwiSG9tZVwiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cInNldHRpbmdzLmh0bWxcIlxuICogICAgIGxhYmVsPVwiU2V0dGluZ3NcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogPC9vbnMtdGFiYmFyPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJob21lLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwic2V0dGluZ3MuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBqdXN0IGJlZm9yZSB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM5aSJ44KP44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgY2hhbmdlIGV2ZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBruWkieabtOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMganVzdCBhZnRlciB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM5aSJ44KP44Gj44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHJlYWN0aXZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBpZiB0aGUgYWxyZWFkeSBvcGVuIHRhYiBpcyB0YXBwZWQgYWdhaW4uWy9lbl1cbiAgICogICBbamFd44GZ44Gn44Gr44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44GM44KC44GG5LiA5bqm44K/44OD44OX44KE44Kv44Oq44OD44Kv44GV44KM44Gf5aC05ZCI44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgbm9uZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgYm90dG9tXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UYWJiYXIncyBwb3NpdGlvbi4gQXZhaWxhYmxlIHZhbHVlcyBhcmUgYFwiYm90dG9tXCJgIGFuZCBgXCJ0b3BcImAuIFVzZSBgXCJhdXRvXCJgIHRvIGNob29zZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gcGxhdGZvcm0gKGJvdHRvbSBmb3IgaU9TIGZsYXQgZGVzaWduLCB0b3AgZm9yIE1hdGVyaWFsIERlc2lnbikuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCXCJib3R0b21cIuOCguOBl+OBj+OBr1widG9wXCLjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cImJvdHRvbVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHRhYiBiYXIgY2FuIGJlIHNjcm9sbGVkIGJ5IGRyYWcgb3Igc3dpcGUuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OW44OQ44O844KS44K544Ov44Kk44OX44KE44OJ44Op44OD44Kw44Gn56e75YuV44Gn44GN44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWdub3JlLWVkZ2Utd2lkdGhcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMjBcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3RhbmNlIGluIHBpeGVscyBmcm9tIGJvdGggZWRnZXMuIFN3aXBpbmcgb24gdGhlc2UgYXJlYXMgd2lsbCBwcmlvcml0aXplIHBhcmVudCBjb21wb25lbnRzIHN1Y2ggYXMgYG9ucy1zcGxpdHRlcmAgb3IgYG9ucy1uYXZpZ2F0b3JgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGhpZGUtdGFic1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0byBoaWRlIHRoZSB0YWJzLlsvZW5dXG4gICAqICAgW2phXeOCv+ODluOCkumdnuihqOekuuOBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhYi1ib3JkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgdGFicyBzaG93IGEgZHluYW1pYyBib3R0b20gYm9yZGVyLiBPbmx5IHdvcmtzIGZvciBpT1MgZmxhdCBkZXNpZ24gc2luY2UgdGhlIGJvcmRlciBpcyBhbHdheXMgdmlzaWJsZSBpbiBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0YWJiYXIuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdGhpcy5fc3dpcGVyKSB7XG4gICAgICB0aGlzLl9zd2lwZXIgPSBuZXcgU3dpcGVyKHtcbiAgICAgICAgZ2V0RWxlbWVudDogKCkgPT4gdGhpcy5fY29udGVudEVsZW1lbnQsXG4gICAgICAgIGdldEluaXRpYWxJbmRleDogKCkgPT4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZUluZGV4JykgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2FjdGl2ZS1pbmRleCcpLFxuICAgICAgICBnZXRBdXRvU2Nyb2xsUmF0aW86IHRoaXMuX2dldEF1dG9TY3JvbGxSYXRpby5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRCdWJibGVXaWR0aDogKCkgPT4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ2lnbm9yZS1lZGdlLXdpZHRoJykgfHwgMjUsIDEwKSxcbiAgICAgICAgaXNBdXRvU2Nyb2xsYWJsZTogKCkgPT4gdHJ1ZSxcbiAgICAgICAgcHJlQ2hhbmdlSG9vazogdGhpcy5fb25QcmVDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgcG9zdENoYW5nZUhvb2s6IHRoaXMuX29uUG9zdENoYW5nZS5iaW5kKHRoaXMpLFxuICAgICAgICByZWZyZXNoSG9vazogdGhpcy5fb25SZWZyZXNoLmJpbmQodGhpcyksXG4gICAgICAgIHNjcm9sbEhvb2s6IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcylcbiAgICAgIH0pO1xuXG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl90YWJiYXJCb3JkZXIgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLl90YWJiYXJFbGVtZW50LCAnLnRhYmJhcl9fYm9yZGVyJyk7XG4gICAgICAgIHRoaXMuX3N3aXBlci5pbml0KHsgc3dpcGVhYmxlOiB0aGlzLmhhc0F0dHJpYnV0ZSgnc3dpcGVhYmxlJykgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fb25SZWZyZXNoKCksIDEwMDAvNjApOyAvLyBGaXggdGFiYmFyIGJvcmRlciBpbiBzb21lIGlmcmFtZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVQb3NpdGlvbigpKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9zd2lwZXIgJiYgdGhpcy5fc3dpcGVyLmluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLl9zd2lwZXIuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fc3dpcGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3RhYmJhckJvcmRlciA9IG51bGw7XG4gICAgICB0aGlzLl90YWJzUmVjdCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZUV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHsgLi4uZXZlbnQsIGluZGV4OiBldmVudC5hY3RpdmVJbmRleCwgdGFiSXRlbTogdGhpcy50YWJzW2V2ZW50LmFjdGl2ZUluZGV4XSB9O1xuICB9XG5cbiAgX29uUG9zdENoYW5nZShldmVudCkge1xuICAgIGV2ZW50ID0gdGhpcy5fbm9ybWFsaXplRXZlbnQoZXZlbnQpO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdGNoYW5nZScsIGV2ZW50KTtcbiAgICBjb25zdCBwYWdlID0gZXZlbnQudGFiSXRlbS5wYWdlRWxlbWVudDtcbiAgICBwYWdlICYmIHBhZ2UuX3Nob3coKTtcbiAgfVxuXG4gIF9vblByZUNoYW5nZShldmVudCkge1xuICAgIGV2ZW50ID0gdGhpcy5fbm9ybWFsaXplRXZlbnQoZXZlbnQpO1xuICAgIGV2ZW50LmNhbmNlbCA9ICgpID0+IGV2ZW50LmNhbmNlbGVkID0gdHJ1ZTtcblxuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncHJlY2hhbmdlJywgZXZlbnQpO1xuXG4gICAgaWYgKCFldmVudC5jYW5jZWxlZCkge1xuICAgICAgY29uc3QgeyBhY3RpdmVJbmRleCwgbGFzdEFjdGl2ZUluZGV4IH0gPSBldmVudDtcbiAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnM7XG5cbiAgICAgIHRhYnNbYWN0aXZlSW5kZXhdLnNldEFjdGl2ZSh0cnVlKTtcbiAgICAgIGlmIChsYXN0QWN0aXZlSW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBwcmV2VGFiID0gdGFic1tsYXN0QWN0aXZlSW5kZXhdO1xuICAgICAgICBwcmV2VGFiLnNldEFjdGl2ZShmYWxzZSk7XG4gICAgICAgIHByZXZUYWIucGFnZUVsZW1lbnQgJiYgcHJldlRhYi5wYWdlRWxlbWVudC5faGlkZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBldmVudC5jYW5jZWxlZFxuICB9XG5cbiAgX29uU2Nyb2xsKGluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5fdGFiYmFyQm9yZGVyKSB7XG4gICAgICB0aGlzLl90YWJiYXJCb3JkZXIuc3R5bGUudHJhbnNpdGlvbiA9IGBhbGwgJHtvcHRpb25zLmR1cmF0aW9uIHx8IDB9cyAke29wdGlvbnMudGltaW5nIHx8ICcnfWA7XG5cbiAgICAgIGlmICh0aGlzLl9hdXRvZ3JvdyAmJiB0aGlzLl90YWJzUmVjdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGEgPSBNYXRoLmZsb29yKGluZGV4KSwgYiA9IE1hdGguY2VpbChpbmRleCksIHIgPSBpbmRleCAlIDE7XG4gICAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS53aWR0aCA9IGxlcnAodGhpcy5fdGFic1JlY3RbYV0ud2lkdGgsIHRoaXMuX3RhYnNSZWN0W2JdLndpZHRoLCByKSArICdweCc7XG4gICAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtsZXJwKHRoaXMuX3RhYnNSZWN0W2FdLmxlZnQsIHRoaXMuX3RhYnNSZWN0W2JdLmxlZnQsIHIpfXB4LCAwLCAwKWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90YWJiYXJCb3JkZXIuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZTNkKCR7aW5kZXggKiAxMDB9JSwgMCwgMClgO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZShpbmRleCwgb3B0aW9ucyk7XG4gIH1cblxuICBfb25SZWZyZXNoKCkge1xuICAgIHRoaXMuX2F1dG9ncm93ID0gdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnYXV0b2dyb3cnKTtcbiAgICB0aGlzLl90YWJzUmVjdCA9IHRoaXMudGFicy5tYXAodGFiID0+IHRhYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgaWYgKHRoaXMuX3RhYmJhckJvcmRlcikge1xuICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLmRpc3BsYXkgPSB0aGlzLmhhc0F0dHJpYnV0ZSgndGFiLWJvcmRlcicpIHx8IHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJykgPyAnYmxvY2snIDogJ25vbmUnO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCk7XG4gICAgICBpZiAodGhpcy5fdGFic1JlY3QubGVuZ3RoID4gMCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS53aWR0aCA9IHRoaXMuX3RhYnNSZWN0W2luZGV4XS53aWR0aCArICdweCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2dldEF1dG9TY3JvbGxSYXRpbyhtYXRjaGVzLCB2ZWxvY2l0eSwgc2l6ZSkge1xuICAgIGNvbnN0IHJhdGlvID0gLjY7IC8vIEJhc2UgcmF0aW9cbiAgICBjb25zdCBtb2RpZmllciA9IHNpemUgLyAzMDAgKiAobWF0Y2hlcyA/IC0xIDogMSk7IC8vIEJhc2VkIG9uIHNjcmVlbiBzaXplXG4gICAgcmV0dXJuIE1hdGgubWluKDEsIE1hdGgubWF4KDAsIHJhdGlvICsgdmVsb2NpdHkgKiBtb2RpZmllcikpO1xuICB9XG5cbiAgZ2V0IF90YWJiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYmJhcicpO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy50YWJiYXJfX2NvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCBfdGFyZ2V0RWxlbWVudCgpIHtcbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIGNvbnRlbnQgJiYgY29udGVudC5jaGlsZHJlblswXSB8fCBudWxsO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQgfHwgdXRpbC5jcmVhdGUoJy50YWJiYXJfX2NvbnRlbnQnKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ29ucy10YWJiYXJfX2NvbnRlbnQnKTtcbiAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl90YWJiYXJFbGVtZW50IHx8IHV0aWwuY3JlYXRlKCcudGFiYmFyJyk7XG4gICAgdGFiYmFyLmNsYXNzTGlzdC5hZGQoJ29ucy10YWJiYXJfX2Zvb3RlcicpO1xuXG4gICAgaWYgKCF0YWJiYXIucGFyZW50Tm9kZSkge1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICB0YWJiYXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IE51bWJlcih0aGlzLmdldEF0dHJpYnV0ZSgnYWN0aXZlSW5kZXgnKSk7IC8vIDAgYnkgZGVmYXVsdFxuICAgIGlmICh0YWJiYXIuY2hpbGRyZW4ubGVuZ3RoID4gYWN0aXZlSW5kZXggJiYgIXV0aWwuZmluZENoaWxkKHRhYmJhciwgJ1thY3RpdmVdJykpIHtcbiAgICAgIHRhYmJhci5jaGlsZHJlblthY3RpdmVJbmRleF0uc2V0QXR0cmlidXRlKCdhY3RpdmUnLCAnJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGFiYmFyQm9yZGVyID0gdXRpbC5maW5kQ2hpbGQodGFiYmFyLCAnLnRhYmJhcl9fYm9yZGVyJykgfHwgdXRpbC5jcmVhdGUoJy50YWJiYXJfX2JvcmRlcicpO1xuICAgIHRhYmJhci5hcHBlbmRDaGlsZCh0aGlzLl90YWJiYXJCb3JkZXIpO1xuICAgIHRhYmJhci5jbGFzc0xpc3QuYWRkKCdvbnMtc3dpcGVyLXRhYmJhcicpOyAvLyBIaWRlcyBtYXRlcmlhbCBib3JkZXJcblxuICAgICFjb250ZW50LmNoaWxkcmVuWzBdICYmIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgICFjb250ZW50LmNoaWxkcmVuWzFdICYmIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQgPSBjb250ZW50LmFwcGVuZENoaWxkLmJpbmQoY29udGVudC5jaGlsZHJlblswXSk7XG4gICAgY29udGVudC5pbnNlcnRCZWZvcmUgPSBjb250ZW50Lmluc2VydEJlZm9yZS5iaW5kKGNvbnRlbnQuY2hpbGRyZW5bMF0pO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKHRhYmJhcik7IC8vIFRyaWdnZXJzIG9ucy10YWIgY29ubmVjdGVkQ2FsbGJhY2tcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbihwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpKSB7XG4gICAgY29uc3QgdG9wID0gdGhpcy5fdG9wID0gcG9zaXRpb24gPT09ICd0b3AnIHx8IChwb3NpdGlvbiA9PT0gJ2F1dG8nICYmIHV0aWwuaGFzTW9kaWZpZXIodGhpcywgJ21hdGVyaWFsJykpO1xuICAgIGNvbnN0IGFjdGlvbiA9IHRvcCA/IHV0aWwuYWRkTW9kaWZpZXIgOiB1dGlsLnJlbW92ZU1vZGlmaWVyO1xuXG4gICAgYWN0aW9uKHRoaXMsICd0b3AnKTtcblxuICAgIGNvbnN0IHBhZ2UgPSB1dGlsLmZpbmRQYXJlbnQodGhpcywgJ29ucy1wYWdlJyk7XG4gICAgaWYgKHBhZ2UpIHtcbiAgICAgIGNvbnRlbnRSZWFkeShwYWdlLCAoKSA9PiB7XG4gICAgICAgIGxldCBwID0gMDtcbiAgICAgICAgaWYgKHBhZ2UuY2hpbGRyZW5bMF0gJiYgdXRpbC5tYXRjaChwYWdlLmNoaWxkcmVuWzBdLCAnb25zLXRvb2xiYXInKSkge1xuICAgICAgICAgIGFjdGlvbihwYWdlLmNoaWxkcmVuWzBdLCAnbm9zaGFkb3cnKTtcbiAgICAgICAgICBwID0gMTsgLy8gVmlzdWFsIGZpeCBmb3Igc29tZSBkZXZpY2VzXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50ID0gcGFnZS5fZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLCBudWxsKVxuXG4gICAgICAgIHRoaXMuc3R5bGUudG9wID0gdG9wID8gcGFyc2VJbnQoY3MuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy10b3AnKSwgMTApIC0gcCArICdweCcgOiAnJztcblxuICAgICAgICAvLyBSZWZyZXNoIGNvbnRlbnQgdG9wIC0gRml4IGZvciBpT1MgOFxuICAgICAgICBjb250ZW50LnN0eWxlLnRvcCA9IGNzLnRvcDtcbiAgICAgICAgY29udGVudC5zdHlsZS50b3AgPSAnJztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsKCgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGxlZCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCBlID0+IGUuaGFzQXR0cmlidXRlKCdzdGF0dXMtYmFyLWZpbGwnKSk7XG4gICAgICB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3RhdHVzLWJhci1maWxsJywgdG9wICYmICFmaWxsZWQpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHRvcFBhZ2UoKSB7XG4gICAgY29uc3QgdGFicyA9IHRoaXMudGFicyxcbiAgICAgIGluZGV4ID0gdGhpcy5nZXRBY3RpdmVUYWJJbmRleCgpO1xuICAgIHJldHVybiB0YWJzW2luZGV4XVxuICAgICAgPyB0YWJzW2luZGV4XS5wYWdlRWxlbWVudCB8fCB0aGlzLnBhZ2VzWzBdIHx8IG51bGxcbiAgICAgIDogbnVsbDtcbiAgfVxuXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5fdGFyZ2V0RWxlbWVudC5jaGlsZHJlbik7XG4gIH1cblxuICBnZXQgdGFicygpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMuX3RhYmJhckVsZW1lbnQuY2hpbGRyZW4sIGUgPT4gZS50YWdOYW1lID09PSAnT05TLVRBQicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0QWN0aXZlVGFiXG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlVGFiKGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UYWIgaW5kZXguWy9lbl1cbiAgICogICBbamFd44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IHJ1bnMgd2hlbiB0aGUgbmV3IHBhZ2UgaGFzIGxvYWRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIG9wdGlvbiBpcyBcIm5vbmVcIiwgdGhlIHRyYW5zaXRpb24gd29uJ3Qgc2xpZGUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHNwZWNpZmllZCB0YWIgcGFnZS4gQW5pbWF0aW9ucyBhbmQgdGhlaXIgb3B0aW9ucyBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+OCpOODs+ODh+ODg+OCr+OCueOBruOCv+ODluOCkuihqOekuuOBl+OBvuOBmeOAguOCouODi+ODoeODvOOCt+ODp+ODs+OBquOBqeOBruOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXUEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRBY3RpdmVUYWIobmV4dEluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCk7XG4gICAgY29uc3QgcHJldlRhYiA9IHRoaXMudGFic1twcmV2SW5kZXhdLFxuICAgICAgbmV4dFRhYiA9IHRoaXMudGFic1tuZXh0SW5kZXhdO1xuXG4gICAgaWYgKCFuZXh0VGFiKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1NwZWNpZmllZCBpbmRleCBkb2VzIG5vdCBtYXRjaCBhbnkgdGFiLicpO1xuICAgIH1cblxuICAgIGlmIChuZXh0SW5kZXggPT09IHByZXZJbmRleCkge1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWFjdGl2ZScsIHsgaW5kZXg6IG5leHRJbmRleCwgYWN0aXZlSW5kZXg6IG5leHRJbmRleCwgdGFiSXRlbTogbmV4dFRhYiB9KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV4dFRhYi5wYWdlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IG5leHRUYWIubG9hZGVkIGlzIGJyb2tlbiBpbiBab25lLmpzIHByb21pc2VzIChBbmd1bGFyMilcbiAgICBjb25zdCBuZXh0UGFnZSA9IG5leHRUYWIucGFnZUVsZW1lbnQ7XG4gICAgcmV0dXJuIChuZXh0UGFnZSA/IFByb21pc2UucmVzb2x2ZShuZXh0UGFnZSkgOiBuZXh0VGFiLmxvYWRlZClcbiAgICAgIC50aGVuKG5leHRQYWdlID0+IHRoaXMuX3N3aXBlci5zZXRBY3RpdmVJbmRleChuZXh0SW5kZXgsIHtcbiAgICAgICAgcmVqZWN0OiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBhbmltYXRpb246IHByZXZUYWIgJiYgbmV4dFBhZ2UgPyBvcHRpb25zLmFuaW1hdGlvbiB8fCB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgOiAnbm9uZScsXG4gICAgICAgIGFuaW1hdGlvbk9wdGlvbnM6IHV0aWwuZXh0ZW5kKFxuICAgICAgICAgIHsgZHVyYXRpb246IC4zLCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjQsIC43LCAuNSwgMSknIH0sXG4gICAgICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykgPyB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSkgOiB7fSxcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICAgKVxuICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvcHRpb25zLmNhbGxiYWNrKG5leHRQYWdlKTtcbiAgICAgICAgcmV0dXJuIG5leHRQYWdlO1xuICAgICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2V0VGFiYmFyVmlzaWJpbGl0eVxuICAgKiBAc2lnbmF0dXJlIHNldFRhYmJhclZpc2liaWxpdHkodmlzaWJsZSlcbiAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIGhpZGUgb3Igc2hvdyB0aGUgdGFiIGJhci5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0VGFiYmFyVmlzaWJpbGl0eSh2aXNpYmxlKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbnRlbnRFbGVtZW50LnN0eWxlW3RoaXMuX3RvcCA/ICd0b3AnIDogJ2JvdHRvbSddID0gdmlzaWJsZSA/ICcnIDogJzBweCc7XG4gICAgICB0aGlzLl90YWJiYXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSB2aXNpYmxlID8gJycgOiAnbm9uZSc7XG4gICAgICB2aXNpYmxlICYmIHRoaXMuX29uUmVmcmVzaCgpO1xuICAgIH0pO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnNldFRhYmJhclZpc2liaWxpdHkodHJ1ZSk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIHRoaXMuc2V0VGFiYmFyVmlzaWJpbGl0eShmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgdGFiYmFyIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeOCv+ODluODkOODvOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFiYmFyRWxlbWVudC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUVuYWJsZSBzd2lwZSBpbnRlcmFjdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1zd2lwZWFibGXjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKTtcbiAgfVxuXG4gIHNldCBzd2lwZWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25Td2lwZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBzbGlkZXMgdGhlIHRhYmJhci4gSXQgZ2V0cyBhIGRlY2ltYWwgaW5kZXggYW5kIGFuIGFuaW1hdGlvbk9wdGlvbnMgb2JqZWN0IGFzIGFyZ3VtZW50cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IG9uU3dpcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uU3dpcGU7XG4gIH1cblxuICBzZXQgb25Td2lwZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdvblN3aXBlJyBtdXN0IGJlIGEgZnVuY3Rpb24uYClcbiAgICB9XG4gICAgdGhpcy5fb25Td2lwZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZ2V0QWN0aXZlVGFiSW5kZXhcbiAgICogQHNpZ25hdHVyZSBnZXRBY3RpdmVUYWJJbmRleCgpXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICogICBbZW5dVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRhYi5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovjgr/jg5bjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB0YWIgaW5kZXggb24gY3VycmVudCBhY3RpdmUgdGFiLiBJZiBhY3RpdmUgdGFiIGlzIG5vdCBmb3VuZCwgcmV0dXJucyAtMS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgovjgr/jg5bjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgILnj77lnKjjgqLjgq/jg4bjgqPjg5bjgarjgr/jg5bjgYzjgarjgYTloLTlkIjjgavjga8tMeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBnZXRBY3RpdmVUYWJJbmRleCgpIHtcbiAgICBmb3IgKGxldCB0YWJzID0gdGhpcy50YWJzLCBpID0gMDsgaSA8IHRhYnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0YWJzW2ldICYmIHRhYnNbaV0udGFnTmFtZSA9PT0gJ09OUy1UQUInICYmIHRhYnNbaV0uaXNBY3RpdmUoKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgdGhpcy5fc3dpcGVyLnNob3coKTtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy50YWJzLmxlbmd0aCA+IDAgJiYgdGhpcy50YWJzW3RoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKV0ubG9hZGVkLnRoZW4oZWwgPT4gZWwgJiYgc2V0SW1tZWRpYXRlKCgpID0+IGVsLl9zaG93KCkpKSk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLl9zd2lwZXIuaGlkZSgpO1xuICAgIGNvbnN0IHRvcFBhZ2UgPSB0aGlzLnRvcFBhZ2U7XG4gICAgdG9wUGFnZSAmJiB0b3BQYWdlLl9oaWRlKCk7XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLnRhYnMuZm9yRWFjaCh0YWIgPT4gdGFiLnJlbW92ZSgpKTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncG9zaXRpb24nLCAnc3dpcGVhYmxlJywgJ3RhYi1ib3JkZXInLCAnaGlkZS10YWJzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgIGNvbnN0IGlzVG9wID0gbSA9PiAvKF58XFxzKyl0b3AoJHxcXHMrKS9pLnRlc3QobSk7XG4gICAgICBpc1RvcChsYXN0KSAhPT0gaXNUb3AoY3VycmVudCkgJiYgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSAmJiB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3N3aXBlYWJsZScpIHtcbiAgICAgIHRoaXMuX3N3aXBlciAmJiB0aGlzLl9zd2lwZXIudXBkYXRlU3dpcGVhYmxlKHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnaGlkZS10YWJzJykge1xuICAgICAgdGhpcy5zZXRUYWJiYXJWaXNpYmlsaXR5KCF0aGlzLmhhc0F0dHJpYnV0ZSgnaGlkZS10YWJzJykgfHwgY3VycmVudCA9PT0gJ2ZhbHNlJyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwcmVjaGFuZ2UnLCAncG9zdGNoYW5nZScsICdyZWFjdGl2ZSddO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5UYWJiYXIgPSBUYWJiYXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdGFiYmFyJywgVGFiYmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgVGFiYmFyRWxlbWVudCBmcm9tICcuL29ucy10YWJiYXInO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgeyBQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlciB9IGZyb20gJy4uL29ucy9wYWdlLWxvYWRlcic7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAndGFiYmFyX19pdGVtJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3RhYmJhci0tKl9faXRlbScsXG4gICcudGFiYmFyX19idXR0b24nOiAndGFiYmFyLS0qX19idXR0b24nXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10YWJcbiAqIEBjYXRlZ29yeSB0YWJiYXJcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIHRhYiBpbnNpZGUgdGFiIGJhci4gRWFjaCBgPG9ucy10YWI+YCByZXByZXNlbnRzIGEgcGFnZS5bL2VuXVxuICogICBbamFdXG4gKiAgICAg44K/44OW44OQ44O844Gr6YWN572u44GV44KM44KL5ZCE44Ki44Kk44OG44Og44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44Gd44KM44Ge44KM44Gub25zLXRhYuOBr+ODmuODvOOCuOOCkuihqOOBl+OBvuOBmeOAglxuICogICAgIG9ucy10YWLopoHntKDjga7kuK3jgavjga/jgIHjgr/jg5bjgavooajnpLrjgZXjgozjgovjgrPjg7Pjg4bjg7Pjg4TjgpLnm7TmjqXoqJjov7DjgZnjgovjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIHBHdURMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdGFiYmFyXG4gKiBAZ3VpZGUgZnVuZGFtZW50YWxzLmh0bWwjbWFuYWdpbmctcGFnZXNcbiAqICAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzLlsvZW5dXG4gKiAgIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXV1cbiAqIEBndWlkZSBhcHBzaXplLmh0bWwjcmVtb3ZpbmctaWNvbi1wYWNrcyBbZW5dUmVtb3ZpbmcgaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQGd1aWRlIGZhcS5odG1sI2hvdy1jYW4taS11c2UtY3VzdG9tLWljb24tcGFja3MgW2VuXUFkZGluZyBjdXN0b20gaWNvbiBwYWNrcy5bL2VuXVtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXRhYmJhclxuICogICBbZW5db25zLXRhYmJhciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLXRhYmJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcGFnZVxuICogICBbZW5db25zLXBhZ2UgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pY29uXG4gKiAgIFtlbl1vbnMtaWNvbiBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWljb27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdGFiYmFyPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJob21lLmh0bWxcIlxuICogICAgIGxhYmVsPVwiSG9tZVwiXG4gKiAgICAgYWN0aXZlPlxuICogICA8L29ucy10YWI+XG4gKiAgIDxvbnMtdGFiXG4gKiAgICAgcGFnZT1cInNldHRpbmdzLmh0bWxcIlxuICogICAgIGxhYmVsPVwiU2V0dGluZ3NcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogPC9vbnMtdGFiYmFyPlxuICpcbiAqIDxvbnMtdGVtcGxhdGUgaWQ9XCJob21lLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L29ucy10ZW1wbGF0ZT5cbiAqXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwic2V0dGluZ3MuaHRtbFwiPlxuICogICAuLi5cbiAqIDwvb25zLXRlbXBsYXRlPlxuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwYWdlIHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYiBpcyB0YXBwZWQuWy9lbl1cbiAgICogICBbamFdb25zLXRhYuOBjOWPgueFp+OBmeOCi+ODmuODvOOCuOOBuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIGljb24gbmFtZSBmb3IgdGhlIHRhYi4gQ2FuIHNwZWNpZnkgdGhlIHNhbWUgaWNvbiBuYW1lIGFzIGA8b25zLWljb24+YC4gQ2hlY2sgW1NlZSBhbHNvXSgjc2VlYWxzbykgc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAgm9ucy1pY29u44Go5ZCM44GY44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgICDlgIvliKXjgavjgqLjgqTjgrPjg7PjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovloLTlkIjjga/jgIFiYWNrZ3JvdW5kLWltYWdl44Gq44Gp44GuQ1NT44K544K/44Kk44Or44KS55So44GE44Gm5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBuYW1lIG9mIHRoZSBpY29uIHdoZW4gdGhlIHRhYiBpcyBhY3RpdmUuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gu6Zqb44Gu44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbGFiZWxcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBsYWJlbCBvZiB0aGUgdGFiIGl0ZW0uWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz5LiL44Gr6KGo56S644GV44KM44KL44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYmFkZ2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXkgYSBub3RpZmljYXRpb24gYmFkZ2Ugb24gdG9wIG9mIHRoZSB0YWIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44K444Gr6KGo56S644GZ44KL5YaF5a6544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIGF0dHJpYnV0ZSBzaG91bGQgYmUgc2V0IHRvIHRoZSB0YWIgdGhhdCBpcyBhY3RpdmUgYnkgZGVmYXVsdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKFsnbGFiZWwnLCAnaWNvbicsICdiYWRnZSddLnNvbWUodGhpcy5oYXNBdHRyaWJ1dGUuYmluZCh0aGlzKSkpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuICAgIHRoaXMuX2JvdW5kT25DbGljayA9IHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKTtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghKGxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB0aHJvdyBFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlci4nKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKHRoaXMuX2J1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuY3JlYXRlKCdidXR0b24udGFiYmFyX19idXR0b24nKTtcbiAgICB3aGlsZSh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0ID0gdXRpbC5jcmVhdGUoJ2lucHV0JywgeyBkaXNwbGF5OiAnbm9uZScgfSk7XG4gICAgaW5wdXQudHlwZSA9ICdyYWRpbyc7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICB0aGlzLl91cGRhdGVCdXR0b25Db250ZW50KCk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB0aGlzLl9idXR0b24gJiYgdXRpbC51cGRhdGVSaXBwbGUodGhpcy5fYnV0dG9uLCB0aGlzLmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpO1xuICB9XG5cbiAgX3VwZGF0ZUJ1dHRvbkNvbnRlbnQoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy5fYnV0dG9uO1xuXG4gICAgbGV0IGljb25XcmFwcGVyID0gdGhpcy5faWNvbjtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2ljb24nKSkge1xuICAgICAgaWNvbldyYXBwZXIgPSBpY29uV3JhcHBlciB8fCB1dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXYgY2xhc3M9XCJ0YWJiYXJfX2ljb25cIj48b25zLWljb24+PC9vbnMtaWNvbj48L2Rpdj4nKTtcbiAgICAgIGNvbnN0IGljb24gPSBpY29uV3JhcHBlci5jaGlsZHJlblswXTtcbiAgICAgIGNvbnN0IGZpeCA9IChsYXN0ID0+ICgpID0+IGljb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdpY29uJywgbGFzdCwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKSkpKGljb24uZ2V0QXR0cmlidXRlKCdpY29uJykpO1xuICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoJ2ljb24nLCB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpKTtcbiAgICAgIGljb25XcmFwcGVyLnBhcmVudEVsZW1lbnQgIT09IGJ1dHRvbiAmJiBidXR0b24uaW5zZXJ0QmVmb3JlKGljb25XcmFwcGVyLCBidXR0b24uZmlyc3RDaGlsZCk7XG5cbiAgICAgIC8vIGRpcnR5IGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL09uc2VuVUkvT25zZW5VSS9pc3N1ZXMvMTY1NFxuICAgICAgaWNvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IGZpeCgpXG4gICAgICAgIDogc2V0SW1tZWRpYXRlKCgpID0+IGljb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgZml4KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpY29uV3JhcHBlciAmJiBpY29uV3JhcHBlci5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBbJ2xhYmVsJywgJ2JhZGdlJ10uZm9yRWFjaCgoYXR0ciwgaW5kZXgpID0+IHtcbiAgICAgIGxldCBwcm9wID0gdGhpcy5xdWVyeVNlbGVjdG9yKGAudGFiYmFyX18ke2F0dHJ9YCk7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgcHJvcCA9IHByb3AgfHwgdXRpbC5jcmVhdGUoYC50YWJiYXJfXyR7YXR0cn1gICsgKGF0dHIgPT09ICdiYWRnZScgPyAnIG5vdGlmaWNhdGlvbicgOiAnJykpO1xuICAgICAgICBwcm9wLnRleHRDb250ZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHByb3AucGFyZW50RWxlbWVudCAhPT0gYnV0dG9uICYmIGJ1dHRvbi5hcHBlbmRDaGlsZChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AgJiYgcHJvcC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldCBfaW5wdXQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xuICB9XG5cbiAgZ2V0IF9idXR0b24oKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiYmFyX19idXR0b24nKTtcbiAgfVxuXG4gIGdldCBfaWNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcudGFiYmFyX19pY29uJyk7XG4gIH1cblxuICBnZXQgX3RhYmJhcigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtdGFiYmFyJyk7XG4gIH1cblxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcy5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLCB0aGlzKTtcbiAgfVxuXG4gIF9vbkNsaWNrKCkge1xuICAgIGlmICh0aGlzLm9uQ2xpY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5vbkNsaWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RhYmJhci5zZXRBY3RpdmVUYWIodGhpcy5pbmRleCwgeyByZWplY3Q6IGZhbHNlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNldEFjdGl2ZShhY3RpdmUgPSB0cnVlKSB7XG4gICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IGFjdGl2ZTtcbiAgICB0aGlzLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScsIGFjdGl2ZSk7XG4gICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2FjdGl2ZScsIGFjdGl2ZSlcblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaWNvbicpICYmIHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUtaWNvbicpKSB7XG4gICAgICB0aGlzLl9pY29uLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZSgnaWNvbicsIHRoaXMuZ2V0QXR0cmlidXRlKGFjdGl2ZSA/ICdhY3RpdmUtaWNvbicgOiAnaWNvbicpKTtcbiAgICB9XG4gIH1cblxuICBfbG9hZFBhZ2VFbGVtZW50KHBhcmVudCwgcGFnZSkge1xuICAgIHRoaXMuX2hhc0xvYWRlZCA9IHRydWU7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHsgcGFyZW50LCBwYWdlIH0sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChwYWdlRWxlbWVudCwgcGFyZW50LmNoaWxkcmVuW3RoaXMuaW5kZXhdKTsgLy8gRW5zdXJlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBwYWdlRWxlbWVudDtcbiAgICAgICAgcmVzb2x2ZShwYWdlRWxlbWVudCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBwYWdlRWxlbWVudCgpIHtcbiAgICAvLyBJdCBoYXMgYmVlbiBsb2FkZWQgYnkgb25zLXRhYlxuICAgIGlmICh0aGlzLl9sb2FkZWRQYWdlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZGVkUGFnZTtcbiAgICB9XG4gICAgLy8gTWFudWFsbHkgYXR0YWNoZWQgdG8gRE9NLCAxIHBlciB0YWJcbiAgICBjb25zdCB0YWJiYXIgPSB0aGlzLl90YWJiYXI7XG4gICAgaWYgKHRhYmJhci5wYWdlcy5sZW5ndGggPT09IHRhYmJhci50YWJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRhYmJhci5wYWdlc1t0aGlzLmluZGV4XTtcbiAgICB9XG4gICAgLy8gTG9hZGVkIGluIGFub3RoZXIgd2F5XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmxvYWRlZCA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICAgIGlmICh0aGlzLl9sb2FkZWRQYWdlKSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLl9sb2FkZWRQYWdlKTtcbiAgICAgIHRoaXMuX2xvYWRlZFBhZ2UgPSBudWxsO1xuICAgICAgdGhpcy5faGFzTG9hZGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF1dGlsLmlzQXR0YWNoZWQodGhpcykgfHwgdGhpcy5sb2FkZWQpIHtcbiAgICAgIHJldHVybjsgLy8gb25zLXRhYmJhciBjb21waWxhdGlvbiBtYXkgdHJpZ2dlciB0aGlzXG4gICAgfVxuXG4gICAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgdGhpcy5sb2FkZWQgPSBkZWZlcnJlZC5wcm9taXNlO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX3RhYmJhcjtcbiAgICAgIGlmICghdGFiYmFyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBvbnMtdGFiIGVsZW1lbnQgbXVzdCBiZSBjaGlsZCBvZiBvbnMtdGFiYmFyIGVsZW1lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YWJiYXIuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpKSB7XG4gICAgICAgIHV0aWwuYWRkTW9kaWZpZXIodGhpcywgdGFiYmFyLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faGFzTG9hZGVkKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnYWN0aXZlJykpIHtcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZSh0cnVlKTtcbiAgICAgICAgICB0YWJiYXIuc2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcsIGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA9PT0gdGFiYmFyLnRhYnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRhYmJhci5fb25SZWZyZXNoKCk7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRhYmJhci5fb25SZWZyZXNoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgVGFiYmFyRWxlbWVudC5yZXdyaXRhYmxlcy5yZWFkeSh0YWJiYXIsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBwYWdlVGFyZ2V0ID0gdGhpcy5wYWdlIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwYWdlJyk7XG4gICAgICAgICAgaWYgKCF0aGlzLnBhZ2VFbGVtZW50ICYmIHBhZ2VUYXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFRhcmdldCA9IHRhYmJhci5fdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGR1bW15UGFnZSA9IHV0aWwuY3JlYXRlKCdkaXYnLCB7IGhlaWdodDogJzEwMCUnLCB3aWR0aDogJzEwMCUnLCBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcgfSk7XG4gICAgICAgICAgICBwYXJlbnRUYXJnZXQuaW5zZXJ0QmVmb3JlKGR1bW15UGFnZSwgcGFyZW50VGFyZ2V0LmNoaWxkcmVuW2luZGV4XSk7IC8vIEVuc3VyZSBwb3NpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRQYWdlRWxlbWVudChwYXJlbnRUYXJnZXQsIHBhZ2VUYXJnZXQpLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVzb2x2ZSh0aGlzLnBhZ2VFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ3JpcHBsZScsICdpY29uJywgJ2xhYmVsJywgJ3BhZ2UnLCAnYmFkZ2UnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaWNvbic6XG4gICAgICBjYXNlICdsYWJlbCc6XG4gICAgICBjYXNlICdiYWRnZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCdXR0b25Db250ZW50KCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BhZ2UnOlxuICAgICAgICB0aGlzLnBhZ2UgPSBjdXJyZW50IHx8ICcnO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zLmVsZW1lbnRzLlRhYiA9IFRhYkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10YWInLCBUYWJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb2FzdEFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudGltaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmRlbGF5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5cbi8qKlxuICogaU9TIHN0eWxlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVUb2FzdEFuaW1hdG9yIGV4dGVuZHMgVG9hc3RBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0KHRvYXN0KVxuICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgfSlcbiAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgLnF1ZXVlKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUodG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdCh0b2FzdClcbiAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgLnF1ZXVlKHtcbiAgICAgICAgb3BhY2l0eTogMVxuICAgICAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoe1xuICAgICAgICBvcGFjaXR5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICB9KVxuICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAucXVldWUoZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgaVBob25lWFBhdGNoIGZyb20gJy4uLy4uL29ucy9pcGhvbmV4LXBhdGNoJztcbmltcG9ydCBUb2FzdEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIEFzY2VuZCBUb2FzdCBBbmltYXRvci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXNjZW5kVG9hc3RBbmltYXRvciBleHRlbmRzIFRvYXN0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yNSB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5tZXNzYWdlRGVsYXkgPSB0aGlzLmR1cmF0aW9uICogMC40ICsgdGhpcy5kZWxheTsgLy8gRGVsYXkgbWVzc2FnZSBvcGFjaXR5IGNoYW5nZVxuICAgIGlmIChwbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgdGhpcy5hc2NlbnNpb24gPSA0ODsgLy8gVG9hc3RzIGFyZSBhbHdheXMgMSBsaW5lXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuYXNjZW5zaW9uID0gOTg7IC8vIDY0ICsgMzRcbiAgICAgIH0gZWxzZSBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5hc2NlbnNpb24gPSA4NTsgLy8gNjQgKyAyMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hc2NlbnNpb24gPSA2NDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3codG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG4gICAgdXRpbC5nbG9iYWxzLmZhYk9mZnNldCA9IHRoaXMuYXNjZW5zaW9uO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdClcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmFzY2Vuc2lvbn1weCwgMClgXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fZ2V0RmFicygpKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIC0ke3RoaXMuYXNjZW5zaW9ufXB4LCAwKSBzY2FsZSgxKWBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh1dGlsLmFycmF5RnJvbSh0b2FzdC5jaGlsZHJlbikpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5tZXNzYWdlRGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogMS4wXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZSh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICB0b2FzdCA9IHRvYXN0Ll90b2FzdDtcbiAgICB1dGlsLmdsb2JhbHMuZmFiT2Zmc2V0ID0gMDtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodG9hc3QpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5hc2NlbnNpb259cHgsIDApYFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX2dldEZhYnMoKSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSBzY2FsZSgxKSdcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh1dGlsLmFycmF5RnJvbSh0b2FzdC5jaGlsZHJlbikpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRGYWJzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdvbnMtZmFiW3Bvc2l0aW9ufj1ib3R0b21dLCBvbnMtc3BlZWQtZGlhbFtwb3NpdGlvbn49Ym90dG9tXScpKS5maWx0ZXIoZmFiID0+IGZhYi52aXNpYmxlKTtcbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IGlQaG9uZVhQYXRjaCBmcm9tICcuLi8uLi9vbnMvaXBob25leC1wYXRjaCc7XG5pbXBvcnQgVG9hc3RBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcblxuLyoqXG4gKiBMaWZ0LWZhZGUgVG9hc3QgQW5pbWF0b3JcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlmdFRvYXN0QW5pbWF0b3IgZXh0ZW5kcyBUb2FzdEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMzUgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgICB0aGlzLmJvZHlIZWlnaHQgPSBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodDsgLy8gYXZvaWQgRm9yY2VkIFN5bmNocm9ub3VzIExheW91dFxuICAgIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICB0aGlzLmxpZnRBbW91bnQgPSAnY2FsYygxMDAlICsgMzRweCknO1xuICAgIH0gZWxzZSBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICdjYWxjKDEwMCUgKyAyMXB4KSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICcxMDAlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3codG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0KVxuICAgICAgICAuc2F2ZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMubGlmdEFtb3VudH0sIDApYCxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgICAgICB9KVxuICAgICAgICAucmVzdG9yZVN0eWxlKClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZSh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICB0b2FzdCA9IHRvYXN0Ll90b2FzdDtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodG9hc3QpXG4gICAgICAgIC5zYXZlU3R5bGUoKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMubGlmdEFtb3VudH0sIDApYCxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMudGltaW5nXG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN0b3JlU3R5bGUoKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbih0b2FzdCkge1xuICAgIGlmIChwYXJzZUludCh0b2FzdC5zdHlsZS50b3AsIDEwKSA9PT0gMCkge1xuICAgICAgdG9hc3Quc3R5bGUudG9wID0gdG9hc3Quc3R5bGUuYm90dG9tID0gJyc7XG4gICAgfVxuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgaVBob25lWFBhdGNoIGZyb20gJy4uLy4uL29ucy9pcGhvbmV4LXBhdGNoJztcbmltcG9ydCBUb2FzdEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIEZhbGwtZmFkZSBUb2FzdCBBbmltYXRvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWxsVG9hc3RBbmltYXRvciBleHRlbmRzIFRvYXN0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zNSB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICAgIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICB0aGlzLmZhbGxBbW91bnQgPSAnY2FsYygtMTAwJSAtIDQ0cHgpJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWxsQW1vdW50ID0gJy0xMDAlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3codG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9hc3QpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdClcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmZhbGxBbW91bnR9LCAwKWAsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUodG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9hc3QpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdClcbiAgICAgICAgLnNhdmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLFxuICAgICAgICAgIG9wYWNpdHk6IDEuMFxuICAgICAgICB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5mYWxsQW1vdW50fSwgMClgLFxuICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy50aW1pbmdcbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3RvcmVTdHlsZSgpXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbih0b2FzdCwgdHJ1ZSk7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbih0b2FzdCwgY2xlYW5VcCkge1xuICAgIGxldCBjb3JyZWN0VG9wO1xuICAgIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICBjb3JyZWN0VG9wID0gJzQ0cHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3JyZWN0VG9wID0gJzAnO1xuICAgIH1cblxuICAgIGlmICh0b2FzdC5zdHlsZS50b3AgIT09IGNvcnJlY3RUb3ApIHtcbiAgICAgIHRvYXN0LnN0eWxlLnRvcCA9IGNvcnJlY3RUb3A7XG4gICAgICB0b2FzdC5zdHlsZS5ib3R0b20gPSAnaW5pdGlhbCc7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zIGZyb20gJy4uLy4uL29ucyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBUb2FzdEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEZhZGVUb2FzdEFuaW1hdG9yIGZyb20gJy4vZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgQXNjZW5kVG9hc3RBbmltYXRvciBmcm9tICcuL2FzY2VuZC1hbmltYXRvcic7XG5pbXBvcnQgTGlmdFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBGYWxsVG9hc3RBbmltYXRvciBmcm9tICcuL2ZhbGwtYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZURpYWxvZ0VsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWRpYWxvZyc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRvYXN0JzogJ3RvYXN0LS0qJyxcbiAgJy50b2FzdF9fbWVzc2FnZSc6ICd0b2FzdC0tKl9fbWVzc2FnZScsXG4gICcudG9hc3RfX2J1dHRvbic6ICd0b2FzdC0tKl9fYnV0dG9uJ1xufTtcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0b2FzdCc7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBc2NlbmRUb2FzdEFuaW1hdG9yIDogTGlmdFRvYXN0QW5pbWF0b3IsXG4gICdmYWRlJzogRmFkZVRvYXN0QW5pbWF0b3IsXG4gICdhc2NlbmQnOiBBc2NlbmRUb2FzdEFuaW1hdG9yLFxuICAnbGlmdCc6IExpZnRUb2FzdEFuaW1hdG9yLFxuICAnZmFsbCc6IEZhbGxUb2FzdEFuaW1hdG9yLFxuICAnbm9uZSc6IFRvYXN0QW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRvYXN0XG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBUb2FzdCBvciBTbmFja2JhciBjb21wb25lbnQgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIGRpc21pc3NhYmxlIGluZm9ybWF0aW9uIG9yIHNpbXBsZSBhY3Rpb25zIGF0IChub3JtYWxseSkgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZG9lcyBub3QgYmxvY2sgdXNlciBpbnB1dCwgYWxsb3dpbmcgdGhlIGFwcCB0byBjb250aW51ZSBpdHMgZmxvdy4gRm9yIHNpbXBsZSB0b2FzdHMsIGNvbnNpZGVyIGBvbnMubm90aWZpY2F0aW9uLnRvYXN0YCBpbnN0ZWFkLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9kaWFsb2dcbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBjb21wb25lbnQgaXMgcHJlZmVycmVkIGZvciBkaXNwbGF5aW5nIHVuZGlzbWlzc2FibGUgaW5mb3JtYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvYXN0RWxlbWVudCBleHRlbmRzIEJhc2VEaWFsb2dFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYW5pbWF0aW9uIHVzZWQgd2hlbiBzaG93aW5nIGFuZCBoaWRpbmcgdGhlIHRvYXN0LiBDYW4gYmUgZWl0aGVyIGBcImRlZmF1bHRcImAsIGBcImFzY2VuZFwiYCAoQW5kcm9pZCksIGBcImxpZnRcImAgKGlPUyksIGBcImZhbGxcImAsIGBcImZhZGVcImAgb3IgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2RlZmF1bHREQkIgPSBlID0+IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX3RvYXN0KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCBgLiR7ZGVmYXVsdENsYXNzTmFtZX1gKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgLy8gUmVzZXQgcG9zaXRpb24gc3R5bGVcbiAgICB0aGlzLl90b2FzdCAmJiAodGhpcy5fdG9hc3Quc3R5bGUudG9wID0gdGhpcy5fdG9hc3Quc3R5bGUuYm90dG9tID0gJycpO1xuXG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBUb2FzdEFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ1RvYXN0QW5pbWF0b3InLFxuICAgICAgZGVmYXVsdEFuaW1hdGlvbjogdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAwOyAvLyBMb3dlciB0aGFuIGRpYWxvZ3NcblxuICAgIGNvbnN0IG1lc3NhZ2VDbGFzc05hbWUgPSAndG9hc3RfX21lc3NhZ2UnO1xuICAgIGNvbnN0IGJ1dHRvbkNsYXNzTmFtZSA9ICd0b2FzdF9fYnV0dG9uJztcblxuICAgIGxldCB0b2FzdCA9IHV0aWwuZmluZENoaWxkKHRoaXMsIGAuJHtkZWZhdWx0Q2xhc3NOYW1lfWApO1xuICAgIGlmICghdG9hc3QpIHtcbiAgICAgIHRvYXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0b2FzdC5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICB0b2FzdC5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBidXR0b24gPSB1dGlsLmZpbmRDaGlsZCh0b2FzdCwgYC4ke2J1dHRvbkNsYXNzTmFtZX1gKTtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgYnV0dG9uID0gdXRpbC5maW5kQ2hpbGQodG9hc3QsIGUgPT4gdXRpbC5tYXRjaChlLCAnLmJ1dHRvbicpIHx8IHV0aWwubWF0Y2goZSwgJ2J1dHRvbicpKTtcbiAgICAgIGlmIChidXR0b24pIHtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChidXR0b25DbGFzc05hbWUpO1xuICAgICAgICB0b2FzdC5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodG9hc3QsIGAuJHttZXNzYWdlQ2xhc3NOYW1lfWApKSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IHV0aWwuZmluZENoaWxkKHRvYXN0LCAnLm1lc3NhZ2UnKTtcbiAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGZvciAobGV0IGkgPSB0b2FzdC5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKHRvYXN0LmNoaWxkTm9kZXNbaV0gIT09IGJ1dHRvbikge1xuICAgICAgICAgICAgbWVzc2FnZS5pbnNlcnRCZWZvcmUodG9hc3QuY2hpbGROb2Rlc1tpXSwgbWVzc2FnZS5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1lc3NhZ2UuY2xhc3NMaXN0LmFkZChtZXNzYWdlQ2xhc3NOYW1lKTtcblxuICAgICAgdG9hc3QuaW5zZXJ0QmVmb3JlKG1lc3NhZ2UsIHRvYXN0LmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmICh0b2FzdC5wYXJlbnROb2RlICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRvYXN0KTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImRlZmF1bHRcImAsIGBcImFzY2VuZFwiYCAoQW5kcm9pZCksIGBcImxpZnRcImAgKGlPUyksIGBcImZhbGxcImAsIGBcImZhZGVcImAgb3IgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGRpc3BsYXllZCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZGVmYXVsdFwiYCwgYFwiYXNjZW5kXCJgIChBbmRyb2lkKSwgYFwibGlmdFwiYCAoaU9TKSwgYFwiZmFsbFwiYCwgYFwiZmFkZVwiYCBvciBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRvYXN0IHZpc2liaWxpdHkuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJkZWZhdWx0XCJgLCBgXCJhc2NlbmRcImAgKEFuZHJvaWQpLCBgXCJsaWZ0XCJgIChpT1MpLCBgXCJmYWxsXCJgLCBgXCJmYWRlXCJgIG9yIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRvYXN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBoaWRkZW4gZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBUb2FzdEFuaW1hdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc1RvYXN0RWxlbWVudC5Ub2FzdEFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBUb2FzdEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBUb2FzdEFuaW1hdG9yO1xuICB9XG59XG5cbm9ucy5lbGVtZW50cy5Ub2FzdCA9IFRvYXN0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRvYXN0JywgVG9hc3RFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnMgZnJvbSAnLi4vb25zJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0b29sYmFyLWJ1dHRvbic7XG5cbmNvbnN0IHNjaGVtZSA9IHsnJzogJ3Rvb2xiYXItYnV0dG9uLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRvb2xiYXItYnV0dG9uXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gdG9vbGJhciBidXR0b24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgb3V0bGluZVxuICogICBbZW5dQSBidXR0b24gd2l0aCBhbiBvdXRsaW5lLlsvZW5dXG4gKiAgIFtqYV3jgqLjgqbjg4jjg6njgqTjg7PjgpLjgoLjgaPjgZ/jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1CdXR0b24gY29tcG9uZW50IGZvciBvbnMtdG9vbGJhciBhbmQgb25zLWJvdHRvbS10b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOBguOCi+OBhOOBr29ucy1ib3R0b20tdG9vbGJhcuOBq+ioree9ruOBp+OBjeOCi+ODnOOCv+ODs+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3BhZ2VcbiAqIEBndWlkZSBjb21waWxhdGlvbi5odG1sI3Rvb2xiYXItY29tcGlsYXRpb25cbiAqICAgW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6L+95YqgWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIG5hdmlnYXRpb24gYmFyIGF0IHRoZSB0b3Agb2YgYSBwYWdlLlsvZW5dXG4gKiAgIFtqYV1vbnMtdG9vbGJhcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtYmFjay1idXR0b25cbiAqICAgW2VuXVRoZSBgPG9ucy1iYWNrLWJ1dHRvbj5gIGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW4gdGhlIG5hdmlnYXRpb24gYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdG9vbGJhcj5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgQnV0dG9uXG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgVGl0bGVcbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICA8b25zLWljb24gaWNvbj1cImlvbi1uYXZpY29uXCIgc2l6ZT1cIjI4cHhcIj48L29ucy1pY29uPlxuICogICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLXRvb2xiYXI+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2xiYXJCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMsIHVuZGVmaW5lZCwge2NlbnRlcjogJycsICdzaXplJzogJ2NvbnRhaW4nLCAnYmFja2dyb3VuZCc6ICd0cmFuc3BhcmVudCd9KTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5vbnMuZWxlbWVudHMuVG9vbGJhckJ1dHRvbiA9IFRvb2xiYXJCdXR0b25FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdG9vbGJhci1idXR0b24nLCBUb29sYmFyQnV0dG9uRWxlbWVudCk7XG4iLCJpbXBvcnQgb25zIGZyb20gJy4vb25zJzsgLy8gQWRkIG9ucyBpbnRlcm5hbHNcbmltcG9ydCBzZXR1cCBmcm9tICcuL3NldHVwJzsgLy8gQWRkIHBvbHlmaWxcblxuLy8gQWRkIGFuZCByZWdpc3RlciBDdXN0b20gRWxlbWVudHNcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGVtcGxhdGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1pZic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFjdGlvbi1zaGVldCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFjdGlvbi1zaGVldC1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2cnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2ctYnV0dG9uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYmFjay1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1ib3R0b20tdG9vbGJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNhcmQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbC1pdGVtJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtY2Fyb3VzZWwnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jb2wnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1kaWFsb2cnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1mYWInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtaWNvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWxhenktcmVwZWF0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdC1oZWFkZXInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0LXRpdGxlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdC1pdGVtJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGlzdCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWlucHV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtY2hlY2tib3gnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yYWRpbyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNlYXJjaC1pbnB1dCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLW1vZGFsJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbmF2aWdhdG9yJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcGFnZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXBvcG92ZXInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXInO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1jaXJjdWxhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXB1bGwtaG9vayc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXJhbmdlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcmlwcGxlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcm93JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc2VnbWVudCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNlbGVjdCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwtaXRlbSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwZWVkLWRpYWwnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1jb250ZW50JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItbWFzayc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLXNpZGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXN3aXRjaCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRhYic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRhYmJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRvYXN0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdG9vbGJhci1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10b29sYmFyJztcblxuc2V0dXAob25zKTsgLy8gU2V0dXAgaW5pdGlhbCBsaXN0ZW5lcnNcbndpbmRvdy5fc3VwZXJTZWNyZXRPbnMgPSBvbnM7XG5cbmV4cG9ydCBkZWZhdWx0IG9ucztcbiJdLCJuYW1lcyI6WyJwcmVmaXgiLCJzdHlsZXMiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJBcnJheSIsInByb3RvdHlwZSIsInNsaWNlIiwiY2FsbCIsImpvaW4iLCJtYXRjaCIsIk9MaW5rIiwibmFtZSIsInV0aWwiLCJoeXBoZW5hdGUiLCJzdHlsZXIiLCJlbGVtZW50Iiwic3R5bGUiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIndhcm4iLCJjbGVhciIsImNsZWFybGlzdCIsInNwbGl0IiwicmVkdWNlIiwiciIsInMiLCJjb25jYXQiLCJpIiwibGVuZ3RoIiwic29tZSIsImluZGV4T2YiLCJwdXNoIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiTmF0aXZlSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsIlBsYXRmb3JtIiwiX3NlbGVjdGVkUGxhdGZvcm0iLCJfaWdub3JlUGxhdGZvcm1TZWxlY3QiLCJwbGF0Zm9ybSIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImZuIiwicmVzdWx0IiwicmVhZHlTdGF0ZSIsIkVycm9yIiwiY29yZG92YSIsInBob25lZ2FwIiwiUGhvbmVHYXAiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJUGhvbmUiLCJzY3JlZW4iLCJ3aWR0aCIsImhlaWdodCIsIl9nZXRTZWxlY3RlZFBsYXRmb3JtIiwiZGV2aWNlIiwicGFyc2VJbnQiLCJ2ZXJzaW9uIiwidmVyIiwicmVwbGFjZSIsInVhIiwiaXNJT1MiLCJzdGFuZGFsb25lIiwibHRlOSIsIndlYmtpdCIsIm1lc3NhZ2VIYW5kbGVycyIsImluZGV4ZWREQiIsImlzSU9TU2FmYXJpIiwiaXNXS1dlYlZpZXciLCJvcGVyYSIsIkluc3RhbGxUcmlnZ2VyIiwiT2JqZWN0IiwidG9TdHJpbmciLCJwIiwic2FmYXJpIiwicHVzaE5vdGlmaWNhdGlvbiIsImNocm9tZSIsImRvY3VtZW50TW9kZSIsImlzQW5kcm9pZCIsImlzV1AiLCJpc0lQYWQiLCJpc0lQb2QiLCJwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiIsInZhbHVlIiwib3ZlcndyaXRlIiwiX3ZhcmlhYmxlcyIsImhhc093blByb3BlcnR5IiwicGFydCIsImMiLCJpbkludGVycG9sYXRpb24iLCJjdXJyZW50SW5kZXgiLCJ0b2tlbnMiLCJjaGFyQXQiLCJ0b2tlbiIsInN1YnN0cmluZyIsInJlIiwidmFyaWFibGUiLCJnZXRWYXJpYWJsZSIsInJ2IiwibWFwIiwiX3JlcGxhY2VUb2tlbiIsImJpbmQiLCJleHByZXNzaW9uIiwiX3BhcnNlUGFydCIsIl9yZXBsYWNlVG9rZW5zIiwiX3BhcnNlRXhwcmVzc2lvbiIsImRlZmluZVZhcmlhYmxlIiwiZ2V0TW9iaWxlT1MiLCJnZXRJT1NEZXZpY2UiLCJpc1dlYlZpZXciLCJpbnRlcm5hbCIsImNvbmZpZyIsIm51bGxFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsIiwiYXV0b1N0YXR1c0JhckZpbGwiLCJub3JtYWxpemVQYWdlSFRNTCIsImh0bWwiLCJ3YWl0RE9NQ29udGVudExvYWRlZCIsIndyYXBwZWRDYWxsYmFjayIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FsbGJhY2siLCJvblJlYWR5Iiwic2hvdWxkRmlsbFN0YXR1c0JhciIsImlzSU9TN2Fib3ZlIiwiaXNJUGhvbmVYIiwiYm9keSIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZW1wbGF0ZVN0b3JlIiwiX3N0b3JhZ2UiLCJ0ZW1wbGF0ZSIsImUiLCJ0YXJnZXQiLCJub2RlTmFtZSIsInNldCIsInRlbXBsYXRlSWQiLCJyZWdpc3RlciIsInF1ZXJ5IiwidGVtcGxhdGVzIiwicXVlcnlTZWxlY3RvckFsbCIsInRleHRDb250ZW50IiwiY29udGVudCIsImdldFRlbXBsYXRlSFRNTEFzeW5jIiwicGFnZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY2FjaGUiLCJnZXQiLCJEb2N1bWVudEZyYWdtZW50IiwibG9jYWwiLCJnZXRFbGVtZW50QnlJZCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsIm9ubG9hZCIsInJlc3BvbnNlVGV4dCIsInN0YXR1cyIsImZyYWdtZW50IiwiY3JlYXRlRnJhZ21lbnQiLCJhcnJheUZyb20iLCJzY3JpcHQiLCJ0eXBlIiwiZWwiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwidGV4dCIsImlubmVySFRNTCIsInBhcmVudE5vZGUiLCJyZXBsYWNlQ2hpbGQiLCJvbmVycm9yIiwic2VuZCIsImdldFBhZ2VIVE1MQXN5bmMiLCJwYWdlcyIsImV2YWx1YXRlIiwiZ2V0UGFnZSIsImNhdGNoIiwiZXJyb3IiLCJzaGlmdCIsIkFuaW1hdG9yRmFjdG9yeSIsIm9wdHMiLCJfYW5pbWF0b3JzIiwiYW5pbWF0b3JzIiwiX2Jhc2VDbGFzcyIsImJhc2VDbGFzcyIsIl9iYXNlQ2xhc3NOYW1lIiwiYmFzZUNsYXNzTmFtZSIsIl9hbmltYXRpb24iLCJkZWZhdWx0QW5pbWF0aW9uIiwiX2FuaW1hdGlvbk9wdGlvbnMiLCJkZWZhdWx0QW5pbWF0aW9uT3B0aW9ucyIsIm9wdGlvbnMiLCJkZWZhdWx0QW5pbWF0b3IiLCJhbmltYXRvciIsImFuaW1hdGlvbiIsIkFuaW1hdG9yIiwiYW5pbWF0aW9uT3B0cyIsImV4dGVuZCIsImFuaW1hdGlvbk9wdGlvbnMiLCJhbmltYXRpb25zRGlzYWJsZWQiLCJkdXJhdGlvbiIsImRlbGF5IiwianNvblN0cmluZyIsImFuaW1hdGlvbk9wdGlvbnNQYXJzZSIsImF1dG9TdHlsZUVuYWJsZWQiLCJtb2RpZmllcnNNYXAiLCJwbGF0Zm9ybXMiLCJhbmRyb2lkIiwiZWxlbWVudE5hbWUiLCJ0YWdOYW1lIiwiaGFzTW9kaWZpZXIiLCJvbGRNb2RpZmllciIsIm5ld01vZGlmaWVyIiwidW5zaGlmdCIsInNldEF0dHJpYnV0ZSIsImVsZW1lbnRzIiwiaGFzQXR0cmlidXRlIiwiaW9zIiwicmVtb3ZlTW9kaWZpZXIiLCJhZGRNb2RpZmllciIsInVubG9ja2VkIiwiZ2V0UGxhdGZvcm0iLCJmb3JjZSIsIm1vYmlsZU9TIiwib25zUGxhdGZvcm0iLCJwcmVwYXJlIiwibWFwTW9kaWZpZXIiLCJtb2RpZmllciIsIm0iLCJyZXN0b3JlTW9kaWZpZXIiLCJNb2RpZmllclV0aWwiLCJsYXN0IiwiY3VycmVudCIsIm1ha2VEaWN0IiwicmVtb3ZlZCIsImFkZGVkIiwiZGljdCIsImRpZmYiLCJjbGFzc0xpc3QiLCJrbGFzcyIsImFkZCIsImsiLCJyZW1vdmUiLCJzY2hlbWUiLCJ0YXJnZXRFbGVtZW50cyIsInNlbGVjdG9yIiwiZmlsdGVyIiwiZmluZFBhcmVudCIsInRhcmdldEVsZW1lbnQiLCJwYXJlbnQiLCJhcHBseURpZmZUb0NsYXNzTGlzdCIsImFwcGx5RGlmZlRvRWxlbWVudCIsIm1vZGlmaWVyVG9rZW4iLCJpbmRleCIsInNwbGljZSIsIl9kb21Db250ZW50TG9hZGVkIiwiX3JlYWR5IiwiX29uRE9NQ29udGVudExvYWRlZCIsIkhhbmRsZXJSZXBvc2l0b3J5IiwiaGFuZGxlciIsImRhdGFzZXQiLCJkZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkIiwiaWQiLCJfZ2VuSWQiLCJfc3RvcmUiLCJ1bmRlZmluZWQiLCJEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciIsIl9pc0VuYWJsZWQiLCJfYm91bmRDYWxsYmFjayIsIl9jYWxsYmFjayIsImFkZEJhY2tCdXR0b25MaXN0ZW5lciIsInJlbW92ZUJhY2tCdXR0b25MaXN0ZW5lciIsImV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiX2Rpc3BhdGNoRGV2aWNlQmFja0J1dHRvbkV2ZW50IiwiRnVuY3Rpb24iLCJfZWxlbWVudCIsImVuYWJsZSIsInRyZWUiLCJfY2FwdHVyZVRyZWUiLCJfZmluZEhhbmRsZXJMZWFmRWxlbWVudCIsImNyZWF0ZVRyZWUiLCJhcHBseSIsImFycmF5T2YiLCJjaGlsZHJlbiIsImNoaWxkRWxlbWVudCIsImRpc3BsYXkiLCJfaXNTaG93biIsImhhcyIsInN1YlRyZWUiLCJmaW5kIiwibm9kZSIsImNoaWxkTm9kZSIsImxlZnQiLCJyaWdodCIsImxlZnRaIiwiekluZGV4IiwicmlnaHRaIiwiaXNOYU4iLCJkYmJEaXNwYXRjaGVyIiwiZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIiLCJzdGFydHNXaXRoIiwic3Vic3RyIiwiZW5kc1dpdGgiLCJ1bndyYXAiLCJpc09iamVjdFN0cmluZyIsImlzQXJyYXlTdHJpbmciLCJpc1F1b3RlZFN0cmluZyIsInN0cmluZyIsIm9yaWdpbmFsU3RyaW5nIiwicHJvY2Vzc1Rva2VuIiwicGFyc2VPYmplY3QiLCJwYXJzZUFycmF5IiwibmV4dFRva2VuIiwibGltaXQiLCJjaGFyQ29kZUF0IiwibmVzdGVkT2JqZWN0IiwiaXNWYWxpZEtleSIsIm9iamVjdCIsInJlYWRpbmdLZXkiLCJwcmV2aW91c1Rva2VuIiwiYXJyYXkiLCJwYXJzZSIsImdsb2JhbHMiLCJwcmVwYXJlUXVlcnkiLCJtYXRjaGVzIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJmaW5kQ2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwidW50aWwiLCJpc0F0dGFjaGVkIiwiY29udGFpbnMiLCJoYXNBbnlDb21wb25lbnRBc1BhcmVudCIsImlzUGFnZUNvbnRyb2wiLCJwcm9wYWdhdGVBY3Rpb24iLCJhY3Rpb24iLCJjaGlsZCIsImNhbWVsaXplIiwibCIsInRvVXBwZXJDYXNlIiwiY3JlYXRlIiwiY2xhc3NOYW1lIiwid3JhcHBlciIsImltcG9ydE5vZGUiLCJkc3QiLCJhcmdzIiwiaiIsImFycmF5TGlrZSIsInBhcnNlSlNPTk9iamVjdFNhZmVseSIsImZhaWxTYWZlIiwiSlNPTiIsImZpbmRGcm9tUGF0aCIsInBhdGgiLCJnZXRUb3BQYWdlIiwiY29udGFpbmVyIiwidG9wUGFnZSIsImZpbmRUb29sYmFyUGFnZSIsIl9jYW5BbmltYXRlVG9vbGJhciIsIl9jb250ZW50RWxlbWVudCIsIm5leHRQYWdlIiwidHJpZ2dlckVsZW1lbnRFdmVudCIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwibW9kaWZpZXJOYW1lIiwiUmVnRXhwIiwiYXV0b1N0eWxlIiwiZm9yY2VBdXRvU3R5bGUiLCJuZXdNb2RpZmllcnMiLCJ0b2dnbGVNb2RpZmllciIsInRvZ2dsZSIsInJlc3RvcmVDbGFzcyIsImRlZmF1bHRDbGFzcyIsInJlZnJlc2giLCJ1cGRhdGVQYXJlbnRQb3NpdGlvbiIsIl9wYXJlbnRVcGRhdGVkIiwicGFyZW50RWxlbWVudCIsImdldFByb3BlcnR5VmFsdWUiLCJwb3NpdGlvbiIsInRvZ2dsZUF0dHJpYnV0ZSIsImJpbmRMaXN0ZW5lcnMiLCJsaXN0ZW5lck5hbWVzIiwiYm91bmROYW1lIiwiZWFjaCIsIm9iaiIsImYiLCJ1cGRhdGVSaXBwbGUiLCJoYXNSaXBwbGUiLCJhdHRycyIsInJpcHBsZUVsZW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwiaXNJbnRlZ2VyIiwiaXNGaW5pdGUiLCJNYXRoIiwiZmxvb3IiLCJkZWZlciIsImRlZmVycmVkIiwicHJvbWlzZSIsIndhcm5pbmdzRGlzYWJsZWQiLCJwcmV2ZW50U2Nyb2xsIiwicHJldmVudCIsImNhbmNlbGFibGUiLCJwcmV2ZW50RGVmYXVsdCIsImNsZWFuIiwib2ZmIiwib24iLCJpc1ZhbGlkR2VzdHVyZSIsImdlc3R1cmUiLCJkaXN0YW5jZSIsImRlbHRhVGltZSIsIlRJTUVPVVRfUkFUSU8iLCJjYXBpdGFsaXplIiwic3RyIiwiYnVpbGRUcmFuc2l0aW9uVmFsdWUiLCJwYXJhbXMiLCJwcm9wZXJ0eSIsInRpbWluZyIsInByb3BzIiwicHJvcCIsIm9uY2VPblRyYW5zaXRpb25FbmQiLCJzdG9wUHJvcGFnYXRpb24iLCJyZW1vdmVMaXN0ZW5lcnMiLCJfdHJhbnNpdGlvbkVuZEV2ZW50cyIsInZlbmRvclByZWZpeCIsIl9jc3NQcm9wZXJ0eURpY3QiLCJhIiwieiIsInVwcGVyIiwiaGFzQ3NzUHJvcGVydHkiLCJwcmUiLCJmb3JjZUxheW91dEF0T25jZSIsImJhdGNoSW1tZWRpYXRlIiwib2Zmc2V0SGVpZ2h0IiwiY2FsbGJhY2tzIiwiY29uY3JlYXRlQ2FsbGJhY2tzIiwiYmF0Y2hBbmltYXRpb25GcmFtZSIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInRyYW5zaXRpb25Qcm9wZXJ0eU5hbWUiLCJBbmltaXQiLCJ0cmFuc2l0aW9uUXVldWUiLCJsYXN0U3R5bGVBdHRyaWJ1dGVEaWN0IiwiZG9uZSIsInN0YXJ0QW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsInF1ZXVlIiwiY3NzIiwiVHJhbnNpdGlvbiIsImJ1aWxkIiwic2Vjb25kcyIsInNlbGYiLCJ0cmFuc2l0aW9uTmFtZSIsInRyYW5zaXRpb25WYWx1ZSIsInRpbWVvdXRJZCIsImNsZWFyVHJhbnNpdGlvbiIsInNldFRpbWVvdXQiLCJsZW4iLCJyZXNldCIsIl9kZXF1ZXVlVHJhbnNpdGlvbiIsIl9jdXJyZW50VHJhbnNpdGlvbiIsImNhbGxlZCIsInJ1bkFsbCIsImFyZ3VtZW50cyIsInBsYXkiLCJjcmVhdGVBY3R1YWxDc3NQcm9wcyIsInRpbWVvdXQiLCJwcmVmaXhlZCIsIkV2ZW50IiwiVXRpbHMiLCJEZXRlY3Rpb24iLCJQb2ludGVyRXZlbnQiLCJHZXN0dXJlRGV0ZWN0b3IiLCJJbnN0YW5jZSIsImRlZmF1bHRzIiwiRE9DVU1FTlQiLCJIQVNfUE9JTlRFUkVWRU5UUyIsInBvaW50ZXJFbmFibGVkIiwibXNQb2ludGVyRW5hYmxlZCIsIkhBU19UT1VDSEVWRU5UUyIsIklTX01PQklMRSIsIk5PX01PVVNFRVZFTlRTIiwiQ0FMQ1VMQVRFX0lOVEVSVkFMIiwiRVZFTlRfVFlQRVMiLCJESVJFQ1RJT05fRE9XTiIsIkRJUkVDVElPTl9MRUZUIiwiRElSRUNUSU9OX1VQIiwiRElSRUNUSU9OX1JJR0hUIiwiUE9JTlRFUl9NT1VTRSIsIlBPSU5URVJfVE9VQ0giLCJQT0lOVEVSX1BFTiIsIkVWRU5UX1NUQVJUIiwiRVZFTlRfTU9WRSIsIkVWRU5UX0VORCIsIkVWRU5UX1JFTEVBU0UiLCJFVkVOVF9UT1VDSCIsIlJFQURZIiwicGx1Z2lucyIsImdlc3R1cmVzIiwic2V0dXAiLCJkZXRlcm1pbmVFdmVudFR5cGVzIiwib25Ub3VjaCIsImRldGVjdCIsInV0aWxzIiwiZGVzdCIsInNyYyIsIm1lcmdlIiwiaXRlcmF0b3IiLCJjb250ZXh0IiwiaW5TdHIiLCJpbkFycmF5IiwiZGVlcCIsImV2ZXJ5IiwidG9BcnJheSIsImhhc1BhcmVudCIsImdldENlbnRlciIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiY2xpZW50WCIsImNsaWVudFkiLCJtaW4iLCJtYXgiLCJ0b3VjaCIsImdldFZlbG9jaXR5IiwiZGVsdGFYIiwiZGVsdGFZIiwiYWJzIiwiZ2V0QW5nbGUiLCJ0b3VjaDEiLCJ0b3VjaDIiLCJ4IiwieSIsImF0YW4yIiwiUEkiLCJnZXREaXJlY3Rpb24iLCJnZXREaXN0YW5jZSIsInNxcnQiLCJnZXRTY2FsZSIsInN0YXJ0IiwiZW5kIiwiZ2V0Um90YXRpb24iLCJpc1ZlcnRpY2FsIiwiZGlyZWN0aW9uIiwic2V0UHJlZml4ZWRDc3MiLCJwcmVmaXhlcyIsInRvQ2FtZWxDYXNlIiwidG9nZ2xlQmVoYXZpb3IiLCJmYWxzZUZuIiwidXNlclNlbGVjdCIsIm9uc2VsZWN0c3RhcnQiLCJ1c2VyRHJhZyIsIm9uZHJhZ3N0YXJ0IiwiaG9vayIsInR5cGVzIiwiZXZlbnRUeXBlIiwib25Ub3VjaEhhbmRsZXIiLCJldiIsInNyY1R5cGUiLCJpc1BvaW50ZXIiLCJpc01vdXNlIiwidHJpZ2dlclR5cGUiLCJwcmV2ZW50TW91c2VFdmVudHMiLCJidXR0b24iLCJzaG91bGREZXRlY3QiLCJidXR0b25zIiwibWF0Y2hUeXBlIiwidXBkYXRlUG9pbnRlciIsImRvRGV0ZWN0IiwidG91Y2hMaXN0IiwiZ2V0VG91Y2hMaXN0IiwidG91Y2hMaXN0TGVuZ3RoIiwidHJpZ2dlckNoYW5nZSIsInRyaWdnZXIiLCJjaGFuZ2VkTGVuZ3RoIiwiY2hhbmdlZFRvdWNoZXMiLCJzdGFydGVkIiwiZXZEYXRhIiwiY29sbGVjdEV2ZW50RGF0YSIsImlkZW50aWZpZXJzIiwiaWRlbnRpZmllciIsInBvaW50ZXJUeXBlIiwiRGF0ZSIsIm5vdyIsInNyY0V2ZW50IiwicHJldmVudE1hbmlwdWxhdGlvbiIsInN0b3BEZXRlY3QiLCJ0b3VjaGxpc3QiLCJwb2ludGVycyIsInBvaW50ZXIiLCJwb2ludGVyRXZlbnQiLCJwb2ludGVySWQiLCJwdCIsIk1TUE9JTlRFUl9UWVBFX01PVVNFIiwiTVNQT0lOVEVSX1RZUEVfVE9VQ0giLCJNU1BPSU5URVJfVFlQRV9QRU4iLCJyZXNldExpc3QiLCJkZXRlY3Rpb24iLCJzdGFydERldGVjdCIsImluc3QiLCJldmVudERhdGEiLCJzdG9wcGVkIiwiZXh0ZW5kRXZlbnREYXRhIiwiaW5zdE9wdGlvbnMiLCJ0cmlnZ2VyR2VzdHVyZSIsImVuYWJsZWQiLCJsYXN0RXZlbnQiLCJwcmV2aW91cyIsImdldENhbGN1bGF0ZWREYXRhIiwiY2VudGVyIiwiY3VyIiwicmVjYWxjIiwiY2FsY0V2IiwibGFzdENhbGNFdmVudCIsImNhbGNEYXRhIiwibGFzdENhbGNEYXRhIiwidGltZVN0YW1wIiwiZnV0dXJlQ2FsY0V2ZW50IiwidmVsb2NpdHkiLCJhbmdsZSIsInZlbG9jaXR5WCIsInZlbG9jaXR5WSIsImludGVyaW1BbmdsZSIsImludGVyaW1EaXJlY3Rpb24iLCJzdGFydEV2Iiwic3RhcnRFdmVudCIsImxhc3RFdiIsInNvcnQiLCJiIiwiYmVoYXZpb3IiLCJldmVudFN0YXJ0SGFuZGxlciIsImV2ZW50SGFuZGxlcnMiLCJvbkV2ZW50Iiwib2ZmRXZlbnQiLCJ0cmlnZ2VyRXZlbnQiLCJzdGF0ZSIsImRpc3Bvc2UiLCJlaCIsInRyaWdnZXJlZCIsImRyYWdHZXN0dXJlIiwiZHJhZ01heFRvdWNoZXMiLCJkcmFnTWluRGlzdGFuY2UiLCJzdGFydENlbnRlciIsImRyYWdEaXN0YW5jZUNvcnJlY3Rpb24iLCJmYWN0b3IiLCJkcmFnTG9ja1RvQXhpcyIsImRyYWdMb2NrTWluRGlzdGFuY2UiLCJsYXN0RGlyZWN0aW9uIiwiZHJhZ0Jsb2NrVmVydGljYWwiLCJkcmFnQmxvY2tIb3Jpem9udGFsIiwiRHJhZyIsIkdlc3R1cmUiLCJyZWxlYXNlR2VzdHVyZSIsInRpbWVyIiwiaG9sZEdlc3R1cmUiLCJob2xkVGltZW91dCIsImhvbGRUaHJlc2hvbGQiLCJIb2xkIiwiUmVsZWFzZSIsIkluZmluaXR5IiwiU3dpcGUiLCJzd2lwZUdlc3R1cmUiLCJzd2lwZU1pblRvdWNoZXMiLCJzd2lwZU1heFRvdWNoZXMiLCJzd2lwZVZlbG9jaXR5WCIsInN3aXBlVmVsb2NpdHlZIiwiaGFzTW92ZWQiLCJ0YXBHZXN0dXJlIiwicHJldiIsInNpbmNlUHJldiIsImRpZERvdWJsZVRhcCIsInRhcE1heERpc3RhbmNlIiwidGFwTWF4VGltZSIsImRvdWJsZVRhcEludGVydmFsIiwiZG91YmxlVGFwRGlzdGFuY2UiLCJ0YXBBbHdheXMiLCJUYXAiLCJUb3VjaCIsInRvdWNoR2VzdHVyZSIsInByZXZlbnRNb3VzZSIsInRyYW5zZm9ybUdlc3R1cmUiLCJzY2FsZVRocmVzaG9sZCIsInNjYWxlIiwicm90YXRpb25UaHJlc2hvbGQiLCJyb3RhdGlvbiIsInRyYW5zZm9ybU1pblNjYWxlIiwidHJhbnNmb3JtTWluUm90YXRpb24iLCJUcmFuc2Zvcm0iLCJyZWFkeU1hcCIsIldlYWtNYXAiLCJxdWV1ZU1hcCIsImlzQ29udGVudFJlYWR5Iiwic2V0Q29udGVudFJlYWR5IiwiYWRkQ2FsbGJhY2siLCJjb25zdW1lUXVldWUiLCJkZWxldGUiLCJjb250ZW50UmVhZHkiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsIlRvYXN0UXVldWUiLCJ0aGVuIiwiX3NldEF0dHJpYnV0ZXMiLCJub3RpZmljYXRpb24iLCJfY3JlYXRlQWxlcnREaWFsb2ciLCJpbnB1dFN0cmluZyIsImlzUHJvbXB0IiwiaW5wdXRUeXBlIiwicGxhY2Vob2xkZXIiLCJkZWZhdWx0VmFsdWUiLCJidXR0b25MYWJlbHMiLCJsYWJlbCIsInByaW1hcnlCdXR0b25JbmRleCIsIl9kZXN0cm95RGlhbG9nIiwiZGlhbG9nIiwib25EaWFsb2dDYW5jZWwiLCJkZXN0cm95IiwidGl0bGUiLCJtZXNzYWdlIiwibWVzc2FnZUhUTUwiLCJzdWJtaXRPbkVudGVyIiwiaW5wdXQiLCJvbmtleXByZXNzIiwia2V5Q29kZSIsImhpZGUiLCJyZXNvbHZlVmFsdWUiLCJmb290ZXIiLCJidXR0b25FbGVtZW50Iiwib25jbGljayIsImNvbXBpbGUiLCJzaG93IiwiYXV0b2ZvY3VzIiwiZm9jdXMiLCJfbm9ybWFsaXplQXJndW1lbnRzIiwiYnV0dG9uTGFiZWwiLCJpc0FycmF5IiwicGFyYW0iLCJhbGVydCIsImNvbmZpcm0iLCJwcm9tcHQiLCJ0b2FzdCIsIl90b2FzdCIsImNoZWNrT3B0aW9ucyIsImFjdGlvblNoZWV0IiwibWFza0NvbG9yIiwiY2xhc3MiLCJyZXNvbHZlciIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJpdGVtIiwiYnV0dG9uT3B0aW9ucyIsImRlc3RydWN0aXZlIiwiaWNvbiIsIk1pY3JvRXZlbnQiLCJmY3QiLCJfZXZlbnRzIiwiX2ZjdCIsIm1peGluIiwiZGVzdE9iamVjdCIsIl9pc1BvcnRyYWl0IiwiaXNQb3J0cmFpdCIsIl9vbk9yaWVudGF0aW9uQ2hhbmdlIiwiX29uUmVzaXplIiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwiX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24iLCJlbWl0Iiwib3JpZW50YXRpb24iLCJuSXRlciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ3IiwiaCIsIl9pbml0IiwibW9kaWZpZXJzIiwic29mdHdhcmVLZXlib2FyZCIsIl92aXNpYmxlIiwib25TaG93Iiwib25IaWRlIiwiYmluZEV2ZW50cyIsIktleWJvYXJkIiwib25zaG93Iiwib25oaWRlIiwidmlzaWJsZSIsImlzVmlzaWJsZSIsIm5vUGx1Z2luRXJyb3IiLCJnZW5lcmF0ZUlkIiwiRG9vckxvY2siLCJfbG9ja0xpc3QiLCJfd2FpdExpc3QiLCJfbG9nIiwibG9nIiwidW5sb2NrIiwiX3VubG9jayIsIl90cnlUb0ZyZWVXYWl0TGlzdCIsImlzTG9ja2VkIiwibG9hZFBhZ2UiLCJwYWdlRWxlbWVudCIsInVubG9hZFBhZ2UiLCJfZGVzdHJveSIsIlBhZ2VMb2FkZXIiLCJsb2FkZXIiLCJ1bmxvYWRlciIsIl9sb2FkZXIiLCJfdW5sb2FkZXIiLCJFbGVtZW50IiwiZGVmYXVsdFBhZ2VMb2FkZXIiLCJpbnN0YW50UGFnZUxvYWRlciIsIm9ucyIsInNlbGVjdCIsImxvY2F0aW9uIiwic2VhcmNoIiwid2FpdERldmljZVJlYWR5IiwiaXNSZWFkeSIsIl9yZWFkeUxvY2siLCJyZWFkeSIsIndhaXRVbmxvY2siLCJzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyIiwibGlzdGVuZXIiLCJfZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyIiwic2V0TGlzdGVuZXIiLCJkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJkaXNhYmxlIiwiZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJmaXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50IiwiZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJtb2NrU3RhdHVzQmFyIiwibW9jayIsImRpc2FibGVBbmltYXRpb25zIiwiZW5hYmxlQW5pbWF0aW9ucyIsIl9kaXNhYmxlV2FybmluZ3MiLCJfZW5hYmxlV2FybmluZ3MiLCJkaXNhYmxlQXV0b1N0eWxpbmciLCJlbmFibGVBdXRvU3R5bGluZyIsImRpc2FibGVJY29uQXV0b1ByZWZpeCIsIkljb24iLCJzZXRBdXRvUHJlZml4IiwiZm9yY2VQbGF0Zm9ybVN0eWxpbmciLCJuZXdQbGF0Zm9ybSIsIl91dGlsIiwiX3BsYXRmb3JtVXBkYXRlIiwiX3VwZGF0ZVBvc2l0aW9uIiwicHJlbG9hZCIsImFsbCIsImFwcGVuZCIsImxpbmsiLCJjcmVhdGVQb3BvdmVyIiwiY3JlYXRlRGlhbG9nIiwiY3JlYXRlQWxlcnREaWFsb2ciLCJvcGVuQWN0aW9uU2hlZXQiLCJyZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyIiwiX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIiLCJfc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzIiwicmVtb3ZlQ2hpbGQiLCJ1bmxvY2tEZXZpY2VSZWFkeSIsImxvY2siLCJnZXRDUyIsImN1cnJlbnRTY3JpcHQiLCJzY3JpcHRzIiwiZ2V0U2NyaXB0UGFnZSIsImN1c3RvbUVsZW1lbnRzIiwiZm9yY2VQb2x5ZmlsbCIsImdsb2JhbCIsIm1vZHVsZSIsIl9fZyIsImNvcmUiLCJfX2UiLCJpdCIsImlzT2JqZWN0IiwiVHlwZUVycm9yIiwiZXhlYyIsInJlcXVpcmUkJDAiLCJkZWZpbmVQcm9wZXJ0eSIsImlzIiwicmVxdWlyZSQkMSIsInJlcXVpcmUkJDIiLCJTIiwidmFsIiwidmFsdWVPZiIsImRQIiwiTyIsIlAiLCJBdHRyaWJ1dGVzIiwidG9QcmltaXRpdmUiLCJJRThfRE9NX0RFRklORSIsImJpdG1hcCIsImNyZWF0ZURlc2MiLCJweCIsInJhbmRvbSIsIlNSQyIsIlRPX1NUUklORyIsIiR0b1N0cmluZyIsIlRQTCIsImluc3BlY3RTb3VyY2UiLCJzYWZlIiwiaXNGdW5jdGlvbiIsIlN0cmluZyIsInRoYXQiLCJQUk9UT1RZUEUiLCIkZXhwb3J0Iiwic291cmNlIiwiSVNfRk9SQ0VEIiwiRiIsIklTX0dMT0JBTCIsIkciLCJJU19TVEFUSUMiLCJJU19QUk9UTyIsIklTX0JJTkQiLCJCIiwiZXhwb3J0cyIsImV4cFByb3RvIiwib3duIiwib3V0IiwiZXhwIiwiY3R4IiwicmVkZWZpbmUiLCJVIiwiVyIsIlIiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNvZiIsIklPYmplY3QiLCJkZWZpbmVkIiwiZ09QRCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInRvSU9iamVjdCIsInBJRSIsImNoZWNrIiwicHJvdG8iLCJzZXRQcm90b3R5cGVPZiIsImJ1Z2d5IiwiX19wcm90b19fIiwiU0hBUkVEIiwic3RvcmUiLCJTeW1ib2wiLCJVU0VfU1lNQk9MIiwiJGV4cG9ydHMiLCJ1aWQiLCJUQUciLCJBUkciLCJ0cnlHZXQiLCJUIiwiY2FsbGVlIiwiY2xhc3NvZiIsImNlaWwiLCJwb3MiLCJ0b0ludGVnZXIiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZnJvbUluZGV4IiwidG9MZW5ndGgiLCJ0b0Fic29sdXRlSW5kZXgiLCJzaGFyZWQiLCJhcnJheUluZGV4T2YiLCJJRV9QUk9UTyIsIm5hbWVzIiwiJGtleXMiLCJlbnVtQnVnS2V5cyIsImRlZmluZVByb3BlcnRpZXMiLCJQcm9wZXJ0aWVzIiwiZ2V0S2V5cyIsIkVtcHR5IiwiY3JlYXRlRGljdCIsImlmcmFtZSIsImx0IiwiZ3QiLCJpZnJhbWVEb2N1bWVudCIsImNvbnRlbnRXaW5kb3ciLCJ3cml0ZSIsImNsb3NlIiwiYW5PYmplY3QiLCJkUHMiLCJkZWYiLCJ0YWciLCJzdGF0IiwiY29uZmlndXJhYmxlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJDb25zdHJ1Y3RvciIsIk5BTUUiLCJuZXh0IiwiZGVzY3JpcHRvciIsIk9iamVjdFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJ0b09iamVjdCIsImNvbnN0cnVjdG9yIiwiSVRFUkFUT1IiLCJCVUdHWSIsIkZGX0lURVJBVE9SIiwiS0VZUyIsIlZBTFVFUyIsInJldHVyblRoaXMiLCJCYXNlIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsImdldE1ldGhvZCIsImtpbmQiLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiREVGX1ZBTFVFUyIsIlZBTFVFU19CVUciLCIkbmF0aXZlIiwiJGRlZmF1bHQiLCIkZW50cmllcyIsIiRhbnlOYXRpdmUiLCJtZXRob2RzIiwiTElCUkFSWSIsIiRhdCIsIml0ZXJhdGVkIiwiX3QiLCJfaSIsInBvaW50IiwiVU5TQ09QQUJMRVMiLCJBcnJheVByb3RvIiwiX2siLCJzdGVwIiwiSXRlcmF0b3JzIiwiQXJndW1lbnRzIiwiYWRkVG9VbnNjb3BhYmxlcyIsIndrcyIsIlRPX1NUUklOR19UQUciLCJBcnJheVZhbHVlcyIsIkRPTUl0ZXJhYmxlcyIsImNvbGxlY3Rpb25zIiwiZXhwbGljaXQiLCJDb2xsZWN0aW9uIiwiJGl0ZXJhdG9ycyIsImZvcmJpZGRlbkZpZWxkIiwicmV0IiwiZ2V0SXRlcmF0b3JNZXRob2QiLCJCUkVBSyIsIlJFVFVSTiIsIml0ZXJhYmxlIiwiaXRlckZuIiwiZ2V0SXRlckZuIiwiaXNBcnJheUl0ZXIiLCJTUEVDSUVTIiwiS0VZIiwiQyIsIkRFU0NSSVBUT1JTIiwiTUVUQSIsInNldERlc2MiLCJpc0V4dGVuc2libGUiLCJGUkVFWkUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNldE1ldGEiLCJmYXN0S2V5IiwiZ2V0V2VhayIsIm9uRnJlZXplIiwibWV0YSIsIk5FRUQiLCJUWVBFIiwiU0laRSIsImdldEVudHJ5IiwiZW50cnkiLCJfZiIsIm4iLCJJU19NQVAiLCJBRERFUiIsIl9sIiwiZm9yT2YiLCJ2YWxpZGF0ZSIsImRhdGEiLCJjYWxsYmFja2ZuIiwidiIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwic2tpcENsb3NpbmciLCJhcnIiLCJpdGVyIiwiY29tbW9uIiwiSVNfV0VBSyIsImZpeE1ldGhvZCIsImZhaWxzIiwiZ2V0Q29uc3RydWN0b3IiLCJpbnN0YW5jZSIsIkhBU05UX0NIQUlOSU5HIiwiVEhST1dTX09OX1BSSU1JVElWRVMiLCJBQ0NFUFRfSVRFUkFCTEVTIiwiJGl0ZXJEZXRlY3QiLCJCVUdHWV9aRVJPIiwiJGluc3RhbmNlIiwiaW5oZXJpdElmUmVxdWlyZWQiLCJzZXRTdHJvbmciLCJTRVQiLCJTZXQiLCJzdHJvbmciLCJ0b0pTT04iLCJmcm9tIiwiQ09MTEVDVElPTiIsIm9mIiwiQSIsIm1hcEZuIiwibWFwcGluZyIsImNiIiwiYUZ1bmN0aW9uIiwibmV4dEl0ZW0iLCJyZXF1aXJlJCQ3IiwiTUFQIiwiTWFwIiwicmVzZXJ2ZWRUYWdMaXN0IiwiaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lIiwibG9jYWxOYW1lIiwicmVzZXJ2ZWQiLCJ2YWxpZEZvcm0iLCJpc0Nvbm5lY3RlZCIsIm5hdGl2ZVZhbHVlIiwiX19DRV9pc0ltcG9ydERvY3VtZW50IiwiRG9jdW1lbnQiLCJTaGFkb3dSb290IiwiaG9zdCIsIm5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmciLCJyb290IiwibmV4dFNpYmxpbmciLCJuZXh0Tm9kZSIsIndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzIiwidmlzaXRlZEltcG9ydHMiLCJpbXBvcnQiLCJzaGFkb3dSb290IiwiX19DRV9zaGFkb3dSb290Iiwic2V0UHJvcGVydHlVbmNoZWNrZWQiLCJkZXN0aW5hdGlvbiIsIkN1c3RvbUVsZW1lbnRTdGF0ZSIsIkN1c3RvbUVsZW1lbnRJbnRlcm5hbHMiLCJfbG9jYWxOYW1lVG9EZWZpbml0aW9uIiwiX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uIiwiX3BhdGNoZXMiLCJfaGFzUGF0Y2hlcyIsImRlZmluaXRpb24iLCJwYXRjaCIsIl9fQ0VfcGF0Y2hlZCIsIl9fQ0Vfc3RhdGUiLCJDRVN0YXRlIiwiY3VzdG9tIiwiVXRpbGl0aWVzIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJ1cGdyYWRlRWxlbWVudCIsImRpc2Nvbm5lY3RlZENhbGxiYWNrIiwiZ2F0aGVyRWxlbWVudHMiLCJfX0NFX2hhc1JlZ2lzdHJ5IiwiX19DRV9kb2N1bWVudExvYWRIYW5kbGVkIiwicGF0Y2hBbmRVcGdyYWRlVHJlZSIsImN1cnJlbnRTdGF0ZSIsImxvY2FsTmFtZVRvRGVmaW5pdGlvbiIsImNvbnN0cnVjdGlvblN0YWNrIiwicG9wIiwiZmFpbGVkIiwiX19DRV9kZWZpbml0aW9uIiwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIiwib2JzZXJ2ZWRBdHRyaWJ1dGVzIiwiX19DRV9pc0Nvbm5lY3RlZENhbGxiYWNrQ2FsbGVkIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsIm5hbWVzcGFjZSIsIkRvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIiLCJpbnRlcm5hbHMiLCJkb2MiLCJfaW50ZXJuYWxzIiwiX2RvY3VtZW50IiwiX29ic2VydmVyIiwiX2hhbmRsZU11dGF0aW9ucyIsImRpc2Nvbm5lY3QiLCJtdXRhdGlvbnMiLCJhZGRlZE5vZGVzIiwiRGVmZXJyZWQiLCJfdmFsdWUiLCJfcmVzb2x2ZSIsIl9wcm9taXNlIiwiQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IiwiX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nIiwiX3doZW5EZWZpbmVkRGVmZXJyZWQiLCJfZmx1c2hDYWxsYmFjayIsIl9mbHVzaFBlbmRpbmciLCJfdW5mbHVzaGVkTG9jYWxOYW1lcyIsIl9kb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIiwiU3ludGF4RXJyb3IiLCJhZG9wdGVkQ2FsbGJhY2siLCJnZXRDYWxsYmFjayIsImNhbGxiYWNrVmFsdWUiLCJzZXREZWZpbml0aW9uIiwiX2ZsdXNoIiwicHJpb3IiLCJ0b1Byb21pc2UiLCJvdXRlciIsImlubmVyIiwiZmx1c2giLCJkZWZpbmUiLCJ3aGVuRGVmaW5lZCIsInBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2siLCJjcmVhdGVFbGVtZW50TlMiLCJjbG9uZU5vZGUiLCJnZXRBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIiLCJjb25zdHJ1Y3RvclRvRGVmaW5pdGlvbiIsIk5hdGl2ZSIsIkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQiLCJsYXN0SW5kZXgiLCJidWlsdEluIiwibm9kZXMiLCJjb25uZWN0ZWRCZWZvcmUiLCJwcmVwZW5kIiwiZGlzY29ubmVjdFRyZWUiLCJjb25uZWN0VHJlZSIsImNsb25lIiwiRG9jdW1lbnRfaW1wb3J0Tm9kZSIsInBhdGNoVHJlZSIsIk5TX0hUTUwiLCJEb2N1bWVudF9jcmVhdGVFbGVtZW50TlMiLCJEb2N1bWVudF9wcmVwZW5kIiwiRG9jdW1lbnRfYXBwZW5kIiwicmVmTm9kZSIsImluc2VydGVkTm9kZXMiLCJuYXRpdmVSZXN1bHQiLCJOb2RlX2luc2VydEJlZm9yZSIsIm5vZGVXYXNDb25uZWN0ZWQiLCJOb2RlX2FwcGVuZENoaWxkIiwiTm9kZV9jbG9uZU5vZGUiLCJvd25lckRvY3VtZW50IiwiTm9kZV9yZW1vdmVDaGlsZCIsIm5vZGVUb0luc2VydCIsIm5vZGVUb1JlbW92ZSIsIk5vZGVfcmVwbGFjZUNoaWxkIiwibm9kZVRvSW5zZXJ0V2FzQ29ubmVjdGVkIiwidGhpc0lzQ29ubmVjdGVkIiwicGF0Y2hfdGV4dENvbnRlbnQiLCJiYXNlRGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJhc3NpZ25lZFZhbHVlIiwiVEVYVF9OT0RFIiwicmVtb3ZlZE5vZGVzIiwiY2hpbGROb2Rlc0xlbmd0aCIsIk5vZGVfdGV4dENvbnRlbnQiLCJhZGRQYXRjaCIsInBhcnRzIiwiYmVmb3JlIiwiYWZ0ZXIiLCJ3YXNDb25uZWN0ZWQiLCJyZXBsYWNlV2l0aCIsIkVsZW1lbnRfYXR0YWNoU2hhZG93IiwiaW5pdCIsInBhdGNoX2lubmVySFRNTCIsImh0bWxTdHJpbmciLCJyZW1vdmVkRWxlbWVudHMiLCJFbGVtZW50X2lubmVySFRNTCIsIkhUTUxFbGVtZW50X2lubmVySFRNTCIsInJhd0RpdiIsIkVsZW1lbnRfc2V0QXR0cmlidXRlIiwiRWxlbWVudF9nZXRBdHRyaWJ1dGUiLCJFbGVtZW50X3NldEF0dHJpYnV0ZU5TIiwiRWxlbWVudF9nZXRBdHRyaWJ1dGVOUyIsIkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlIiwiRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUyIsInBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudCIsImJhc2VNZXRob2QiLCJ3aGVyZSIsImluc2VydGVkRWxlbWVudCIsIkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCIsIkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiRWxlbWVudF9wcmVwZW5kIiwiRWxlbWVudF9hcHBlbmQiLCJFbGVtZW50X2JlZm9yZSIsIkVsZW1lbnRfYWZ0ZXIiLCJFbGVtZW50X3JlcGxhY2VXaXRoIiwiRWxlbWVudF9yZW1vdmUiLCJwcmlvckN1c3RvbUVsZW1lbnRzIiwiY291bnRlciIsIkpzTXV0YXRpb25PYnNlcnZlciIsInJlZ2lzdHJhdGlvbnNUYWJsZSIsInNldEltbWVkaWF0ZSIsInNldEltbWVkaWF0ZVF1ZXVlIiwic2VudGluZWwiLCJmdW5jIiwicG9zdE1lc3NhZ2UiLCJpc1NjaGVkdWxlZCIsInNjaGVkdWxlZE9ic2VydmVycyIsInNjaGVkdWxlQ2FsbGJhY2siLCJkaXNwYXRjaENhbGxiYWNrcyIsIndyYXBJZk5lZWRlZCIsIlNoYWRvd0RPTVBvbHlmaWxsIiwib2JzZXJ2ZXJzIiwibzEiLCJvMiIsInVpZF8iLCJhbnlOb25FbXB0eSIsInRha2VSZWNvcmRzIiwiY2FsbGJhY2tfIiwicmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yIiwibm9kZXNfIiwicmVnaXN0cmF0aW9ucyIsInJlZ2lzdHJhdGlvbiIsInJlbW92ZVRyYW5zaWVudE9ic2VydmVycyIsImZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCIsInN1YnRyZWUiLCJyZWNvcmQiLCJlbnF1ZXVlIiwidWlkQ291bnRlciIsInJlY29yZHNfIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZU9sZFZhbHVlIiwiYXR0cmlidXRlRmlsdGVyIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiUmVnaXN0cmF0aW9uIiwiYWRkTGlzdGVuZXJzIiwiY29weU9mUmVjb3JkcyIsIk11dGF0aW9uUmVjb3JkIiwicHJldmlvdXNTaWJsaW5nIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZU5hbWVzcGFjZSIsImNvcHlNdXRhdGlvblJlY29yZCIsIm9yaWdpbmFsIiwiY3VycmVudFJlY29yZCIsInJlY29yZFdpdGhPbGRWYWx1ZSIsImdldFJlY29yZCIsImdldFJlY29yZFdpdGhPbGRWYWx1ZSIsImNsZWFyUmVjb3JkcyIsInJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24iLCJzZWxlY3RSZWNvcmQiLCJsYXN0UmVjb3JkIiwibmV3UmVjb3JkIiwidHJhbnNpZW50T2JzZXJ2ZWROb2RlcyIsInJlY29yZHMiLCJyZWNvcmRUb1JlcGxhY2VMYXN0IiwiYWRkTGlzdGVuZXJzXyIsInJlbW92ZUxpc3RlbmVyc18iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJhdHRyTmFtZSIsInJlbGF0ZWROb2RlIiwibmFtZXNwYWNlVVJJIiwiYXR0ckNoYW5nZSIsIk11dGF0aW9uRXZlbnQiLCJBRERJVElPTiIsInByZXZWYWx1ZSIsImFkZFRyYW5zaWVudE9ic2VydmVyIiwiY2hhbmdlZE5vZGUiLCJfaXNQb2x5ZmlsbGVkIiwibmV4dEhhbmRsZSIsInRhc2tzQnlIYW5kbGUiLCJjdXJyZW50bHlSdW5uaW5nQVRhc2siLCJhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzIiwicGFydGlhbGx5QXBwbGllZCIsInJ1bklmUHJlc2VudCIsImhhbmRsZSIsInRhc2siLCJjbGVhckltbWVkaWF0ZSIsImluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uIiwibmV4dFRpY2siLCJjYW5Vc2VQb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwicHJvY2VzcyIsIkZhc3RDbGljayIsImxheWVyIiwib2xkT25DbGljayIsInRyYWNraW5nQ2xpY2siLCJ0cmFja2luZ0NsaWNrU3RhcnQiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoU3RhcnRZIiwibGFzdFRvdWNoSWRlbnRpZmllciIsInRvdWNoQm91bmRhcnkiLCJ0YXBEZWxheSIsInRhcFRpbWVvdXQiLCJub3ROZWVkZWQiLCJtZXRob2QiLCJkZXZpY2VJc0FuZHJvaWQiLCJvbk1vdXNlIiwib25DbGljayIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaEVuZCIsIm9uVG91Y2hDYW5jZWwiLCJjYXB0dXJlIiwicm12IiwiaGlqYWNrZWQiLCJhZHYiLCJwcm9wYWdhdGlvblN0b3BwZWQiLCJkZXZpY2VJc1dpbmRvd3NQaG9uZSIsImRldmljZUlzSU9TIiwiZGV2aWNlSXNJT1M0IiwiZGV2aWNlSXNJT1NXaXRoQmFkVGFyZ2V0IiwiZGV2aWNlSXNCbGFja0JlcnJ5MTAiLCJuZWVkc0NsaWNrIiwiZGlzYWJsZWQiLCJuZWVkc0ZvY3VzIiwicmVhZE9ubHkiLCJzZW5kQ2xpY2siLCJjbGlja0V2ZW50IiwiYWN0aXZlRWxlbWVudCIsImJsdXIiLCJpbml0TW91c2VFdmVudCIsImRldGVybWluZUV2ZW50VHlwZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiZm9yd2FyZGVkVG91Y2hFdmVudCIsInNldFNlbGVjdGlvblJhbmdlIiwidXBkYXRlU2Nyb2xsUGFyZW50Iiwic2Nyb2xsUGFyZW50IiwiZmFzdENsaWNrU2Nyb2xsUGFyZW50Iiwic2Nyb2xsSGVpZ2h0IiwiZmFzdENsaWNrTGFzdFNjcm9sbFRvcCIsInNjcm9sbFRvcCIsImdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQiLCJldmVudFRhcmdldCIsInNlbGVjdGlvbiIsInRhcmdldFRvdWNoZXMiLCJpc0NvbnRlbnRFZGl0YWJsZSIsImdldFNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJpc0NvbGxhcHNlZCIsImxhc3RDbGlja1RpbWUiLCJ0b3VjaEhhc01vdmVkIiwiYm91bmRhcnkiLCJmaW5kQ29udHJvbCIsImxhYmVsRWxlbWVudCIsImNvbnRyb2wiLCJodG1sRm9yIiwiZm9yRWxlbWVudCIsInRhcmdldFRhZ05hbWUiLCJjYW5jZWxOZXh0Q2xpY2siLCJlbGVtZW50RnJvbVBvaW50IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsInRvcCIsInBlcm1pdHRlZCIsIm1ldGFWaWV3cG9ydCIsImNocm9tZVZlcnNpb24iLCJibGFja2JlcnJ5VmVyc2lvbiIsImZpcmVmb3hWZXJzaW9uIiwib250b3VjaHN0YXJ0Iiwic2Nyb2xsV2lkdGgiLCJvdXRlcldpZHRoIiwibXNUb3VjaEFjdGlvbiIsInRvdWNoQWN0aW9uIiwiYXR0YWNoIiwiREVGQVVMVF9WSUVXUE9SVCIsIlZpZXdwb3J0Iiwidmlld3BvcnRFbGVtZW50IiwiaGVhZCIsImVuc3VyZVZpZXdwb3J0RWxlbWVudCIsImZhc3RDbGljayIsInN1cHBvcnRUb3VjaEFjdGlvbiIsIl9ydW5PbkFjdHVhbFBsYXRmb3JtIiwiX2ludGVybmFsIiwiY3JlYXRlSGFuZGxlciIsImFwcCIsImV4aXRBcHAiLCJfZ2VzdHVyZURldGVjdG9yIiwiZ2V0RWxlbWVudENsYXNzIiwiQmFzZUVsZW1lbnQiLCJUZW1wbGF0ZUVsZW1lbnQiLCJvdXRlckhUTUwiLCJidWJibGVzIiwiVGVtcGxhdGUiLCJJZkVsZW1lbnQiLCJfaXNBbGxvd2VkUGxhdGZvcm0iLCJjb25kaXRpb25hbE9yaWVudGF0aW9uIiwiY3VycmVudE9yaWVudGF0aW9uIiwiSWYiLCJCYXNlQW5pbWF0b3IiLCJwcm9wZXJ0aWVzIiwiZXh0ZW5kZWRBbmltYXRvciIsIm5ld0FuaW1hdG9yIiwiaVBob25lWFBhdGNoIiwiaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSIsImlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlIiwiZ2V0U2FmZUFyZWFMZW5ndGhzIiwic2FmZUFyZWFMZW5ndGhzIiwiZ2V0U2FmZUFyZWFET01SZWN0Iiwic2FmZUFyZWFSZWN0IiwiQWN0aW9uU2hlZXRBbmltYXRvciIsIk1EQWN0aW9uU2hlZXRBbmltYXRvciIsIm1hc2tUaW1pbmciLCJtYXNrRHVyYXRpb24iLCJhbmltaXQiLCJfbWFzayIsIndhaXQiLCJfc2hlZXQiLCJzYXZlU3R5bGUiLCJyZXN0b3JlU3R5bGUiLCJJT1NBY3Rpb25TaGVldEFuaW1hdG9yIiwibGlmdEFtb3VudCIsImNsaWVudEhlaWdodCIsIkJhc2VEaWFsb2dFbGVtZW50Iiwic2hvdWxkU2hvdyIsIl9kb29yTG9jayIsIl9jYW5jZWwiLCJfc2VsZkNhbWVsTmFtZSIsIl9kZWZhdWx0REJCIiwiY2FsbFBhcmVudEhhbmRsZXIiLCJfYW5pbWF0b3JGYWN0b3J5IiwiX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSIsIl9ydW5uaW5nIiwiX3NldFZpc2libGUiLCJwYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmciLCJjYW5jZWxlZCIsIl90b2dnbGVTdHlsZSIsImJhY2tncm91bmRDb2xvciIsIm9uRGV2aWNlQmFja0J1dHRvbiIsIl9wcmV2ZW50U2Nyb2xsIiwiX2JhY2tCdXR0b25IYW5kbGVyIiwib25Nb2RpZmllckNoYW5nZWQiLCJfc2NoZW1lIiwiX3VwZGF0ZU1hc2siLCJfYW5pbWF0b3JEaWN0IiwiQWN0aW9uU2hlZXRFbGVtZW50IiwiX2NvbXBpbGUiLCJzaGVldCIsIl90aXRsZSIsIm1hc2siLCJpbml0TW9kaWZpZXIiLCJfdXBkYXRlVGl0bGUiLCJBY3Rpb25TaGVldCIsImRlZmF1bHRDbGFzc05hbWUiLCJBY3Rpb25TaGVldEJ1dHRvbkVsZW1lbnQiLCJfaWNvbiIsIl91cGRhdGVJY29uIiwiQWN0aW9uU2hlZXRCdXR0b24iLCJBbGVydERpYWxvZ0FuaW1hdG9yIiwiQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IiLCJfZGlhbG9nIiwiSU9TQWxlcnREaWFsb2dBbmltYXRvciIsIkFsZXJ0RGlhbG9nRWxlbWVudCIsIkFsZXJ0RGlhbG9nIiwiQWxlcnREaWFsb2dCdXR0b25FbGVtZW50IiwiQWxlcnREaWFsb2dCdXR0b24iLCJCYWNrQnV0dG9uRWxlbWVudCIsIl9vcHRpb25zIiwiX2JvdW5kT25DbGljayIsIl9vbkNsaWNrIiwibWRCYWNrQnV0dG9uSWNvbiIsImlvc0JhY2tCdXR0b25JY29uIiwicG9wUGFnZSIsIkJhY2tCdXR0b24iLCJCb3R0b21Ub29sYmFyRWxlbWVudCIsIkJvdHRvbVRvb2xiYXIiLCJCdXR0b25FbGVtZW50IiwiX3VwZGF0ZVJpcHBsZSIsIkJ1dHRvbiIsIkNhcmRFbGVtZW50IiwiQ2FyZCIsIkNhcm91c2VsSXRlbUVsZW1lbnQiLCJDYXJvdXNlbEl0ZW0iLCJkaXJlY3Rpb25NYXAiLCJTd2lwZXIiLCJGQUxTRSIsImdldEVsZW1lbnQiLCJzY3JvbGxIb29rIiwiaXRlbVNpemUiLCJnZXRBdXRvU2Nyb2xsUmF0aW8iLCJyYXRpbyIsInNob3VsZEJsb2NrIiwib25EcmFnU3RhcnQiLCJvbkRyYWciLCJvbkRyYWdFbmQiLCJvblJlc2l6ZSIsInN3aXBlYWJsZSIsImF1dG9SZWZyZXNoIiwiaW5pdGlhbGl6ZWQiLCJibG9ja2VyIiwiX211dGF0aW9uT2JzZXJ2ZXIiLCJ1cGRhdGVTd2lwZWFibGUiLCJ1cGRhdGVBdXRvUmVmcmVzaCIsIl9zY3JvbGwiLCJfb2Zmc2V0IiwiX2xhc3RBY3RpdmVJbmRleCIsIl91cGRhdGVMYXlvdXQiLCJfc2V0dXBJbml0aWFsSW5kZXgiLCJzZXR1cFJlc2l6ZSIsInRhcmdldFNpemUiLCJfcmVzZXQiLCJzZXRBY3RpdmVJbmRleCIsInJvdW5kIiwiTnVtYmVyIiwiZ2V0SW5pdGlhbEluZGV4IiwiaXRlbUNvdW50IiwiaXRlbU51bVNpemUiLCJfc2Nyb2xsVG8iLCJzY3JvbGwiLCJtYXhTY3JvbGwiLCJpc1VJV2ViVmlldyIsImFycmF5T2ZBcnJheSIsImNvbnRlbnRzIiwiX2NoYW5nZVRvIiwiY291bnQiLCJzaXplIiwic2hvdWxkVXBkYXRlIiwic2hvdWxkV2F0Y2giLCJuZXdTaXplIiwiYmxvY2siLCJwb2ludGVyRXZlbnRzIiwiZCIsImlzRmlyc3QiLCJpc092ZXJTY3JvbGxhYmxlIiwiaXNMYXN0IiwiX2lnbm9yZURyYWciLCJjb25zdW1lZCIsImNvbnN1bWUiLCJfY2FuQ29uc3VtZUdlc3R1cmUiLCJzdGFydFgiLCJkaXN0RnJvbUVkZ2UiLCJnZXRCdWJibGVXaWR0aCIsIl9zdGFydGVkIiwidG9nZ2xlQmxvY2tlciIsIl9jb250aW51ZWQiLCJfZ2V0RGVsdGEiLCJ0aHJvdHRsZSIsIm5vcm1hbGl6ZWRTY3JvbGwiLCJfbm9ybWFsaXplU2Nyb2xsIiwiX3N0YXJ0TW9tZW50dW1TY3JvbGwiLCJfa2lsbE92ZXJTY3JvbGwiLCJfZ2V0VmVsb2NpdHkiLCJtYXRjaGVzRGlyZWN0aW9uIiwiZE0iLCJkaXIiLCJuZXh0U2Nyb2xsIiwiX2dldEF1dG9TY3JvbGwiLCJzd2lwZSIsImtpbGxPdmVyU2Nyb2xsIiwib3ZlclNjcm9sbEhvb2siLCJhY3RpdmVJbmRleCIsImdldEFjdGl2ZUluZGV4IiwibGFzdEFjdGl2ZUluZGV4IiwiY2hhbmdlIiwicHJlQ2hhbmdlSG9vayIsInBvc3RDaGFuZ2VIb29rIiwib3B0IiwidG9GaXhlZCIsInRyYW5zZm9ybSIsIl9nZXRUcmFuc2Zvcm0iLCJvZmZzZXQiLCJpc0F1dG9TY3JvbGxhYmxlIiwibGFzdFNjcm9sbCIsInNjcm9sbFJhdGlvIiwiX3RhcmdldFNpemUiLCJfaXRlbU51bVNpemUiLCJyZWZyZXNoSG9vayIsImF4aXMiLCJ0M2QiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJpc0NlbnRlcmVkIiwiX2NhbGN1bGF0ZUl0ZW1TaXplIiwiQ2Fyb3VzZWxFbGVtZW50IiwiX3N3aXBlciIsImF1dG9TY3JvbGxSYXRpbyIsInZlcnRpY2FsIiwib3ZlcnNjcm9sbGFibGUiLCJjZW50ZXJlZCIsImF1dG9TY3JvbGwiLCJfb25PdmVyU2Nyb2xsIiwiX29uQ2hhbmdlIiwiX29uUmVmcmVzaCIsIl9vblN3aXBlIiwidXBkYXRlSXRlbVNpemUiLCJ3YWl0Rm9yQWN0aW9uIiwiY2Fyb3VzZWwiLCJpdGVtU2l6ZUF0dHIiLCJwYXJzZUZsb2F0IiwiQ2Fyb3VzZWwiLCJDb2xFbGVtZW50IiwiX3VwZGF0ZVdpZHRoIiwiQ29sIiwiRGlhbG9nQW5pbWF0b3IiLCJBbmRyb2lkRGlhbG9nQW5pbWF0b3IiLCJJT1NEaWFsb2dBbmltYXRvciIsImJvZHlIZWlnaHQiLCJTbGlkZURpYWxvZ0FuaW1hdG9yIiwiRGlhbG9nRWxlbWVudCIsIkRpYWxvZyIsIkZhYkVsZW1lbnQiLCJpc0JvdHRvbSIsInRyYW5zbGF0ZSIsImZhYk9mZnNldCIsIkZhYiIsIkdlc3R1cmVEZXRlY3RvckVsZW1lbnQiLCJhdXRvUHJlZml4IiwiSWNvbkVsZW1lbnQiLCJfY2xlYW5DbGFzc0F0dHJpYnV0ZSIsIl91cGRhdGUiLCJfYnVpbGRDbGFzc0FuZFN0eWxlIiwiX3BhcnNlQXR0ciIsImF0dHIiLCJtZCIsImxhc3RJY29uIiwibGFzdE1vZGlmaWVyIiwiX3ByZWZpeEljb24iLCJjdXN0b21QcmVmaXhSRSIsImljb25OYW1lIiwicmVtb3ZlUHJvcGVydHkiLCJmb250U2l6ZSIsIkxhenlSZXBlYXREZWxlZ2F0ZSIsInVzZXJEZWxlZ2F0ZSIsInRlbXBsYXRlRWxlbWVudCIsIl91c2VyRGVsZWdhdGUiLCJfdGVtcGxhdGVFbGVtZW50IiwiX3JlbmRlciIsImxvYWRJdGVtRWxlbWVudCIsImNyZWF0ZUl0ZW1Db250ZW50IiwiY291bnRJdGVtcyIsInVwZGF0ZUl0ZW1Db250ZW50IiwiY2FsY3VsYXRlSXRlbUhlaWdodCIsImRlc3Ryb3lJdGVtIiwiaXRlbUhlaWdodCIsIkxhenlSZXBlYXRQcm92aWRlciIsIndyYXBwZXJFbGVtZW50IiwiZGVsZWdhdGUiLCJfd3JhcHBlckVsZW1lbnQiLCJfZGVsZWdhdGUiLCJfaW5zZXJ0SW5kZXgiLCJfcGFnZUNvbnRlbnQiLCJfZmluZFBhZ2VDb250ZW50RWxlbWVudCIsImxhc3RTY3JvbGxUb3AiLCJwYWRkaW5nIiwiX3RvcFBvc2l0aW9ucyIsIl9yZW5kZXJlZEl0ZW1zIiwiX3Vua25vd25JdGVtSGVpZ2h0IiwiX2FkZEV2ZW50TGlzdGVuZXJzIiwicGFnZUNvbnRlbnQiLCJfaXRlbUhlaWdodCIsInZpc2liaWxpdHkiLCJzdGF0aWNJdGVtSGVpZ2h0IiwiX2dldEl0ZW1IZWlnaHQiLCJmb3JjZVJlbmRlciIsImZvcmNlU2Nyb2xsRG93biIsImxhc3RJdGVtSW5kZXgiLCJfbGFzdEl0ZW1SZW5kZXJlZCIsIl9jb3VudEl0ZW1zIiwiZmlyc3RJdGVtSW5kZXgiLCJfZmlyc3RJdGVtUmVuZGVyZWQiLCJmb3JjZUxhc3RJbmRleCIsIl9jYWxjdWxhdGVSZW5kZXJlZEhlaWdodCIsImZvcmNlRmlyc3RJbmRleCIsIl9yZW1vdmVBbGxFbGVtZW50cyIsIl9jaGVja0l0ZW1IZWlnaHQiLCJpc1Njcm9sbFVwIiwia2VlcCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIl9jYWxjdWxhdGVTdGFydEluZGV4IiwiaGFzUmVuZGVyRnVuY3Rpb24iLCJfcmVuZGVyRWxlbWVudCIsIl9yZW1vdmVFbGVtZW50IiwidXBkYXRlSXRlbSIsIl9yZWNhbGN1bGF0ZVRvcFBvc2l0aW9ucyIsIm1pZGRsZSIsImltbWVkaWF0ZSIsImNhbGxOb3ciLCJfZGVib3VuY2UiLCJfYm91bmRPbkNoYW5nZSIsIl9ib3VuZERvdWJsZUZpcmVPblRvdWNoZW5kIiwiX3BhcmVudEVsZW1lbnQiLCJfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJwYWRkaW5nVG9wIiwiTGF6eVJlcGVhdEVsZW1lbnQiLCJfbGF6eVJlcGVhdFByb3ZpZGVyIiwiTGF6eVJlcGVhdCIsIkxpc3RIZWFkZXJFbGVtZW50IiwiTGlzdEhlYWRlciIsIkxpc3RUaXRsZUVsZW1lbnQiLCJMaXN0VGl0bGUiLCJMaXN0SXRlbUVsZW1lbnQiLCJfc2V0dXBMaXN0ZW5lcnMiLCJfb3JpZ2luYWxCYWNrZ3JvdW5kQ29sb3IiLCJ0YXBwZWQiLCJfb25EcmFnIiwiX29uVG91Y2giLCJfb25SZWxlYXNlIiwidG91Y2hTdHlsZSIsImJveFNoYWRvdyIsIkxpc3RJdGVtIiwiTGlzdEVsZW1lbnQiLCJMaXN0IiwiSU5QVVRfQVRUUklCVVRFUyIsIkJhc2VJbnB1dEVsZW1lbnQiLCJfYm91bmREZWxlZ2F0ZUV2ZW50IiwiX2RlbGVnYXRlRXZlbnQiLCJfZGVmYXVsdENsYXNzTmFtZSIsIl90ZW1wbGF0ZSIsIl9zZXRJbnB1dElkIiwiX3VwZGF0ZUJvdW5kQXR0cmlidXRlcyIsIl9pbnB1dCIsInRvSVNPU3RyaW5nIiwiSW5wdXRFbGVtZW50IiwiX2JvdW5kT25JbnB1dCIsIl9ib3VuZE9uRm9jdXNpbiIsIl91cGRhdGVMYWJlbCIsIl91cGRhdGVMYWJlbENsYXNzIiwiX2hlbHBlciIsImlubmVyVGV4dCIsIklucHV0IiwiQmFzZUNoZWNrYm94RWxlbWVudCIsImNoZWNrZWQiLCJDaGVja2JveEVsZW1lbnQiLCJDaGVja2JveCIsIlJhZGlvRWxlbWVudCIsIlJhZGlvIiwiU2VhcmNoSW5wdXRFbGVtZW50IiwiU2VhcmNoSW5wdXQiLCJNb2RhbEFuaW1hdG9yIiwibW9kYWwiLCJGYWRlTW9kYWxBbmltYXRvciIsIkxpZnRNb2RhbEFuaW1hdG9yIiwiTW9kYWxFbGVtZW50IiwiTW9kYWwiLCJ3aWR0aFRvUHgiLCJvZmZzZXRXaWR0aCIsIlN3aXBlUmV2ZWFsIiwiZWxlbWVudEhhbmRsZXIiLCJnZXRUaHJlc2hvbGQiLCJnZXRTaWRlIiwiaGFuZGxlR2VzdHVyZSIsImdlc3R1cmVEZXRlY3RvciIsImlnbm9yZVN3aXBlIiwiX3dpZHRoIiwiX3N0YXJ0RGlzdGFuY2UiLCJfZGlzdGFuY2UiLCJpc0luaXRpYWxTdGF0ZSIsImRlbHRhIiwic3dpcGVNaWQiLCJpc1N3aXBlTWF4Iiwic3dpcGVNYXgiLCJzd2lwZU1pbiIsIk5hdmlnYXRvckFuaW1hdG9yIiwiZW50ZXJQYWdlIiwibGVhdmVQYWdlIiwiSU9TU2xpZGVOYXZpZ2F0b3JBbmltYXRvciIsImJhY2tncm91bmRNYXNrIiwidG9vbGJhciIsIl9nZXRUb29sYmFyRWxlbWVudCIsIl9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCIsIl9nZXRUb29sYmFyUmlnaHRJdGVtc0VsZW1lbnQiLCJleGNsdWRlQmFja0J1dHRvbiIsIm90aGVyIiwiX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQiLCJfZ2V0VG9vbGJhckJhY2tCdXR0b25JY29uRWxlbWVudCIsIl9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCIsIl9nZXRDb250ZW50RWxlbWVudCIsIl9nZXRCYWNrZ3JvdW5kRWxlbWVudCIsIl9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCIsImVudGVyVG9vbGJhciIsImxlYXZlVG9vbGJhciIsInRvb2xiYXJzIiwibWF0ZXJpYWwiLCJ0cmFuc3BhcmVudCIsImRlY29tcG9zaXRpb24iLCJwYWdlUmVjdCIsImJhY2tCdXR0b25MYWJlbCIsImxhYmVsUmVjdCIsImJhY2tCdXR0b25JY29uIiwidW5ibG9jayIsImVudGVyUGFnZVRhcmdldCIsImxlYXZlUGFnZVRhcmdldCIsImVudGVyUGFnZURlY29tcG9zaXRpb24iLCJfZGVjb21wb3NlIiwibGVhdmVQYWdlRGVjb21wb3NpdGlvbiIsIl9jYWxjdWxhdGVEZWx0YSIsInNob3VsZEFuaW1hdGVUb29sYmFyIiwiX3Nob3VsZEFuaW1hdGVUb29sYmFyIiwiYm90dG9tVG9vbGJhciIsImJhY2tncm91bmQiLCJ0b29sYmFyQ2VudGVyIiwib3BhY2l0eSIsIklPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IiLCJkdXJhdGlvblJlc3RvcmUiLCJzd2lwZVNoYWRvdyIsImlzRHJhZ1N0YXJ0IiwiZGVjb21wIiwiZW50ZXIiLCJsZWF2ZSIsIl9zYXZlU3R5bGUiLCJvdmVyZmxvd0VsZW1lbnQiLCJtYXhXaWR0aCIsIl9kcmFnU3RhcnRTZXR1cCIsInN3aXBlUmF0aW8iLCJfc2F2ZWRTdHlsZSIsInNhdmUiLCJyZXN0b3JlIiwiX3Jlc3RvcmVTdHlsZSIsIklPU0xpZnROYXZpZ2F0b3JBbmltYXRvciIsIklPU0ZhZGVOYXZpZ2F0b3JBbmltYXRvciIsIk1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvciIsImJsYWNrTWFza09wYWNpdHkiLCJNRExpZnROYXZpZ2F0b3JBbmltYXRvciIsIm1hc2tDbGVhciIsIk1ERmFkZU5hdmlnYXRvckFuaW1hdG9yIiwidGltaW5nT25Qb3AiLCJOb25lTmF2aWdhdG9yQW5pbWF0b3IiLCJyZXdyaXRhYmxlcyIsIm5hdmlnYXRvckVsZW1lbnQiLCJOYXZpZ2F0b3JFbGVtZW50IiwiX2lzUnVubmluZyIsIl9pbml0aWFsaXplZCIsIl9wYWdlTG9hZGVyIiwiX3BhZ2VNYXAiLCJfcGFnZSIsIl9vbkRldmljZUJhY2tCdXR0b24iLCJfc3dpcGVBbmltYXRvciIsInB1c2hBbmltYXRpb24iLCJwb3BBbmltYXRpb24iLCJfc3dpcGUiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwiYXJlYSIsImxvYWRlZCIsIl9nZXRQYWdlVGFyZ2V0IiwicHVzaFBhZ2UiLCJfc2hvdyIsIl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24iLCJ1cGRhdGUiLCJfcHJlcGFyZVBhZ2VBbmRPcHRpb25zIiwicG9wVXBkYXRlIiwidW5sb2FkIiwiX3BvcFBhZ2UiLCJfZW1pdFByZVBvcEV2ZW50IiwidXBkYXRlQmFja0J1dHRvbiIsInB1c2hlZE9wdGlvbnMiLCJfaGlkZSIsIl92ZXJpZnlQYWdlRWxlbWVudCIsInBhZ2VIVE1MIiwiX3B1c2hQYWdlIiwibG9hZCIsIl9lbWl0UHJlUHVzaEV2ZW50IiwicGFnZUxlbmd0aCIsIl9yZXBsYWNlUGFnZSIsInJlc29sdmVkVmFsdWUiLCJfbm9ybWFsaXplSW5kZXgiLCJfbGFzdEluZGV4T2ZQYWdlIiwicGFnZU5hbWUiLCJpc0NhbmNlbGVkIiwiX2VtaXRQcmVFdmVudCIsInRlbXBsYXRlSFRNTCIsInBhZ2VMb2FkZXIiLCJsYXN0RWxlbWVudENoaWxkIiwiTmF2aWdhdG9yIiwiVG9vbGJhckVsZW1lbnQiLCJfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cyIsIl9lbnN1cmVUb29sYmFyRWxlbWVudCIsIlRvb2xiYXIiLCJQYWdlRWxlbWVudCIsIl9kZXJpdmVIb29rcyIsIl9jb250ZW50T2JzZXJ2ZXIiLCJfdHJ5VG9TdXBwcmVzc0xheWVyQ3JlYXRpb24iLCJfYmFja2dyb3VuZEVsZW1lbnQiLCJzY3JvbGxlclNldCIsInNob3VsZFN1cHByZXNzIiwiX2VsZW1lbnRTaG91bGRCZU1vdmVkIiwiX3RyeVRvRmlsbFN0YXR1c0JhciIsImZpeGVkRWxlbWVudHMiLCJvbkluaXQiLCJiYWNrQnV0dG9uIiwib3ZlckxpbWl0IiwiX2luZmluaXRlU2Nyb2xsTGltaXQiLCJfb25JbmZpbml0ZVNjcm9sbCIsIl9sb2FkaW5nQ29udGVudCIsIm9uSW5maW5pdGVTY3JvbGwiLCJvbkRlc3Ryb3kiLCJldmVudHMiLCJfYm91bmRPblNjcm9sbCIsIl9vblNjcm9sbCIsIlBhZ2UiLCJQb3BvdmVyQW5pbWF0b3IiLCJwb3BvdmVyIiwidG8iLCJhbmltYXRpb25zIiwiX2FuaW1hdGUiLCJmYWRlIiwiTURGYWRlUG9wb3ZlckFuaW1hdG9yIiwiX2FuaW1hdGVBbGwiLCJpbiIsIklPU0ZhZGVQb3BvdmVyQW5pbWF0b3IiLCJwb3NpdGlvbnMiLCJQb3BvdmVyRWxlbWVudCIsIl9jdXJyZW50VGFyZ2V0IiwiX3Bvc2l0aW9uUG9wb3ZlciIsIl9jbGVhclN0eWxlcyIsInJhZGl1cyIsIl9yYWRpdXMiLCJjb250ZW50RWxlbWVudCIsIl9jb250ZW50IiwibWFyZ2luIiwiX21hcmdpbiIsInRhcmdldFJlY3QiLCJpc01EIiwiY292ZXIiLCJ0YXJnZXREaXN0YW5jZSIsImJvdHRvbSIsInRhcmdldENlbnRlckRpc3RhbmNlRnJvbSIsIl9jYWxjdWxhdGVEaXJlY3Rpb25zIiwicHJpbWFyeURpcmVjdGlvbiIsInByaW1hcnkiLCJzZWNvbmRhcnlEaXJlY3Rpb24iLCJzZWNvbmRhcnkiLCJfY3VycmVudERpcmVjdGlvbiIsInNpemVOYW1lIiwiY29udGVudFNpemUiLCJ0YXJnZXRBbmRBcnJvd0xlbmd0aCIsInByaW1hcnlPZmZzZXQiLCJzZWNvbmRhcnlPZmZzZXQiLCJfcG9wb3ZlciIsIl9hcnJvdyIsImhhc0RlZmF1bHRDb250YWluZXIiLCJhcnJvdyIsIlBvcG92ZXIiLCJJTkRFVCIsIlByb2dyZXNzQmFyRWxlbWVudCIsIl9pc0NvbXBpbGVkIiwiX3ByaW1hcnkiLCJfc2Vjb25kYXJ5IiwiX3VwZGF0ZURldGVybWluYXRlIiwiX3VwZGF0ZVZhbHVlIiwiYmFyRWxlbWVudCIsIlByb2dyZXNzQmFyIiwiUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQiLCJwZXIiLCJzdmciLCJQcm9ncmVzc0NpcmN1bGFyIiwiU1RBVEVfSU5JVElBTCIsIlNUQVRFX1BSRUFDVElPTiIsIlNUQVRFX0FDVElPTiIsIlB1bGxIb29rRWxlbWVudCIsIl9vbkRyYWdTdGFydCIsIl9vbkRyYWdFbmQiLCJfc2V0U3RhdGUiLCJsaW5lSGVpZ2h0IiwiX3BhZ2VFbGVtZW50IiwiX3N0YXJ0U2Nyb2xsIiwiX2N1cnJlbnRUcmFuc2xhdGlvbiIsIl90aHJlc2hvbGRIZWlnaHRFbmFibGVkIiwidGhyZXNob2xkSGVpZ2h0IiwiX2ZpbmlzaCIsIl9wdWxsaW5nIiwiX3RyYW5zbGF0ZVRvIiwiYW5pbWF0ZSIsIm9uQWN0aW9uIiwidGgiLCJub0V2ZW50IiwibGFzdFN0YXRlIiwibWFyZ2luVG9wIiwiX29uUHVsbCIsInNjcm9sbEVsZW1lbnQiLCJfZHJhZ0xvY2tEaXNhYmxlZCIsInNjcm9sbFRvZ2dsZSIsImdkVG9nZ2xlIiwiX3NldFN0eWxlIiwiX29uQWN0aW9uIiwiUHVsbEhvb2siLCJhY3RpdmVDbGFzc1Rva2VuIiwiUmFuZ2VFbGVtZW50IiwiX2JvdW5kT25Nb3VzZURvd24iLCJfb25Nb3VzZURvd24iLCJfYm91bmRPbk1vdXNlVXAiLCJfb25Nb3VzZVVwIiwiX2JvdW5kT25Ub3VjaFN0YXJ0IiwiX29uVG91Y2hTdGFydCIsIl9ib3VuZE9uVG91Y2hFbmQiLCJfb25Ub3VjaEVuZCIsIl9ib3VuZE9uRHJhZ3N0YXJ0IiwiX29uRHJhZ3N0YXJ0IiwiX2JvdW5kT25EcmFnZW5kIiwiX29uRHJhZ2VuZCIsIl91cGRhdGVEaXNhYmxlZCIsImZvY3VzUmluZyIsIl9mb2N1c1JpbmciLCJiYWNrZ3JvdW5kU2l6ZSIsIl9yYXRpbyIsIlJhbmdlIiwiQW5pbWF0b3JDU1MiLCJmaW5hbCIsImdldFRpbWUiLCJpbml0aWFsIiwidXBkYXRlU3R5bGVzIiwiY2xlYXJUaW1lb3V0IiwidHJhbnNpdGlvbkR1cmF0aW9uIiwic3RvcE5leHQiLCJuZXdEdXJhdGlvbiIsInBhc3NlZCIsInJlbWFpbmluZyIsInNwZWVkVXBUaW1lIiwic3RvcCIsIm1pbGxpc2Vjb25kcyIsInNwZWVkIiwidHJhbnNpdGlvblByb3BlcnR5IiwiX29uU3RvcEFuaW1hdGlvbnMiLCJfcXVldWUiLCJfaW5kZXgiLCJzdG9wQW5pbWF0aW9ucyIsIlJpcHBsZUVsZW1lbnQiLCJfYW5pbWF0b3IiLCJfd2F2ZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJfYmFja2dyb3VuZCIsInNpemVzIiwiX2dldEVmZmVjdFNpemUiLCJfY2VudGVyIiwiX21pblIiLCJfY2FsY3VsYXRlQ29vcmRzIiwic3RvcEFsbCIsImNvbXB1dGVkU3R5bGUiLCJfdXBkYXRlUGFyZW50IiwiX3JpcHBsZUFuaW1hdGlvbiIsIl9ob2xkaW5nIiwiX2JvdW5kT25SZWxlYXNlIiwiX29uVGFwIiwiX3BhcmVudE5vZGUiLCJfYm91bmRPblRhcCIsIl9ib3VuZE9uSG9sZCIsIl9vbkhvbGQiLCJfYm91bmRPbkRyYWdTdGFydCIsInBuIiwiUmlwcGxlIiwiUm93RWxlbWVudCIsIlJvdyIsIlNlZ21lbnRFbGVtZW50IiwiX3NlZ21lbnRJZCIsIl90YWJiYXIiLCJfb25UYWJiYXJQcmVDaGFuZ2UiLCJnZXRBY3RpdmVUYWJJbmRleCIsImdldEFjdGl2ZUJ1dHRvbkluZGV4IiwiX3NldENoZWNrZWQiLCJmaXJzdEVsZW1lbnRDaGlsZCIsInNldEFjdGl2ZVRhYiIsIl9wb3N0Q2hhbmdlIiwiU2VnbWVudCIsIlNlbGVjdEVsZW1lbnQiLCJfZGVyaXZlR2V0dGVycyIsIl9zZWxlY3QiLCJzZWwiLCJvcHRpb24iLCJTZWxlY3QiLCJTcGVlZERpYWxJdGVtRWxlbWVudCIsIlNwZWVkRGlhbEl0ZW0iLCJTcGVlZERpYWxFbGVtZW50IiwiX2l0ZW1TaG93biIsIl91cGRhdGVEaXJlY3Rpb24iLCJ0b2dnbGVJdGVtcyIsImlubGluZSIsIl9mYWIiLCJpdGVtcyIsIl9nZXRUcmFuc2xhdGUiLCJoaWRlSXRlbXMiLCJ0b3RhbERlbGF5IiwiaXNPcGVuIiwic2hvd0l0ZW1zIiwiU3BlZWREaWFsIiwiU3BsaXR0ZXJDb250ZW50RWxlbWVudCIsIm9sZENvbnRlbnQiLCJTcGxpdHRlckNvbnRlbnQiLCJTcGxpdHRlck1hc2tFbGVtZW50IiwiX3NpZGVzIiwic2lkZSIsIm1vZGUiLCJTcGxpdHRlck1hc2siLCJTcGxpdHRlckFuaW1hdG9yIiwic2lkZUVsZW1lbnQiLCJzcGxpdHRlciIsIl9zaWRlIiwiX29wcG9zaXRlU2lkZSIsImNsZWFyTWFzayIsIk92ZXJsYXlTcGxpdHRlckFuaW1hdG9yIiwibWludXMiLCJQdXNoU3BsaXR0ZXJBbmltYXRvciIsInNsaWRpbmdFbGVtZW50cyIsIl9zbGlkaW5nRWxlbWVudHMiLCJfZ2V0U2xpZGluZ0VsZW1lbnRzIiwiUmV2ZWFsU3BsaXR0ZXJBbmltYXRvciIsIl9zZXRTdHlsZXMiLCJfdW5zZXRTdHlsZXMiLCJfZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUiLCJiZWhpbmREaXN0YW5jZSIsImJlaGluZFRyYW5zZm9ybSIsIl9nZXRNYXhXaWR0aCIsIm1lbnVTdHlsZSIsIlNwbGl0dGVyRWxlbWVudCIsIl9sYXlvdXQiLCJfZ2V0U2lkZSIsIl9vbk1vZGVDaGFuZ2UiLCJTcGxpdHRlciIsIlNQTElUX01PREUiLCJDT0xMQVBTRV9NT0RFIiwiQ0xPU0VEX1NUQVRFIiwiT1BFTl9TVEFURSIsIkNIQU5HSU5HX1NUQVRFIiwic3BsaXR0ZXJTaWRlRWxlbWVudCIsIkNvbGxhcHNlRGV0ZWN0aW9uIiwiY2hhbmdlVGFyZ2V0IiwiX3RhcmdldCIsIl9vcmllbnRhdGlvbiIsImFjdGl2YXRlIiwiX3VwZGF0ZU1vZGUiLCJfbWF0Y2giLCJfcXVlcnlSZXN1bHQiLCJtYXRjaE1lZGlhIiwiYWRkTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsIlNwbGl0dGVyU2lkZUVsZW1lbnQiLCJfc3RhdGUiLCJfbG9jayIsIl9jb2xsYXBzZURldGVjdGlvbiIsIl9hbmltYXRpb25PcHQiLCJjbG9zZWQiLCJ2YWxpZERyYWciLCJfbW9kZSIsIl9pc090aGVyU2lkZU9wZW4iLCJkZWFjdGl2YXRlIiwidXBkYXRlT3B0aW9ucyIsInNob3VsZE9wZW4iLCJGSU5BTF9TVEFURSIsIl9lbWl0RXZlbnQiLCJTcGxpdHRlclNpZGUiLCJsb2NhdGlvbnMiLCJTd2l0Y2hFbGVtZW50IiwiX2xvY2F0aW9ucyIsIl9zdGFydFgiLCJfZW1pdENoYW5nZUV2ZW50IiwiZGVmYXVsdEVsZW1lbnRDbGFzcyIsIl9oYW5kbGUiLCJfZ2V0UG9zaXRpb24iLCJwcmV2aW91c1ZhbHVlIiwiY2xpY2siLCJTd2l0Y2giLCJ0YWJiYXJFbGVtZW50IiwibGVycCIsIngwIiwieDEiLCJ0IiwiVGFiYmFyRWxlbWVudCIsIl9nZXRBdXRvU2Nyb2xsUmF0aW8iLCJfb25QcmVDaGFuZ2UiLCJfb25Qb3N0Q2hhbmdlIiwiX3RhYmJhckJvcmRlciIsIl90YWJiYXJFbGVtZW50IiwiX3RhYnNSZWN0IiwidGFiSXRlbSIsInRhYnMiLCJfbm9ybWFsaXplRXZlbnQiLCJjYW5jZWwiLCJzZXRBY3RpdmUiLCJwcmV2VGFiIiwiX2F1dG9ncm93IiwidGFiIiwidGFiYmFyIiwiX3RvcCIsImNzIiwiZmlsbGVkIiwibmV4dEluZGV4IiwicHJldkluZGV4IiwibmV4dFRhYiIsInNldFRhYmJhclZpc2liaWxpdHkiLCJpc0FjdGl2ZSIsImlzVG9wIiwiX3RhcmdldEVsZW1lbnQiLCJUYWJiYXIiLCJUYWJFbGVtZW50IiwiX2J1dHRvbiIsIl91cGRhdGVCdXR0b25Db250ZW50IiwiaWNvbldyYXBwZXIiLCJmaXgiLCJhY3RpdmUiLCJfaGFzTG9hZGVkIiwiX2xvYWRlZFBhZ2UiLCJwYWdlVGFyZ2V0IiwicGFyZW50VGFyZ2V0IiwiZHVtbXlQYWdlIiwiX2xvYWRQYWdlRWxlbWVudCIsIlRhYiIsIlRvYXN0QW5pbWF0b3IiLCJGYWRlVG9hc3RBbmltYXRvciIsIkFzY2VuZFRvYXN0QW5pbWF0b3IiLCJtZXNzYWdlRGVsYXkiLCJhc2NlbnNpb24iLCJfZ2V0RmFicyIsImZhYiIsIkxpZnRUb2FzdEFuaW1hdG9yIiwiRmFsbFRvYXN0QW5pbWF0b3IiLCJmYWxsQW1vdW50IiwiY2xlYW5VcCIsImNvcnJlY3RUb3AiLCJUb2FzdEVsZW1lbnQiLCJtZXNzYWdlQ2xhc3NOYW1lIiwiYnV0dG9uQ2xhc3NOYW1lIiwiVG9hc3QiLCJUb29sYmFyQnV0dG9uRWxlbWVudCIsIlRvb2xiYXJCdXR0b24iLCJfc3VwZXJTZWNyZXRPbnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLEFBRUE7Ozs7OztBQU1BLElBQU1BLFNBQVUsWUFBVztNQUNuQkMsU0FBU0MsT0FBT0MsZ0JBQVAsQ0FBd0JDLFNBQVNDLGVBQWpDLEVBQWtELEVBQWxELENBQWY7TUFDTUwsU0FBUyxDQUFDTSxNQUFNQyxTQUFOLENBQWdCQyxLQUFoQixDQUNiQyxJQURhLENBQ1JSLE1BRFEsRUFFYlMsSUFGYSxDQUVSLEVBRlEsRUFHYkMsS0FIYSxDQUdQLG1CQUhPLEtBR2tCVixPQUFPVyxLQUFQLEtBQWlCLEVBQWpCLElBQXVCLENBQUMsRUFBRCxFQUFLLEdBQUwsQ0FIMUMsRUFJYixDQUphLENBQWY7O1NBTU8sVUFBU0MsSUFBVCxFQUFlO1dBQ2IsTUFBTWIsTUFBTixHQUFlLEdBQWYsR0FBcUJjLEtBQUtDLFNBQUwsQ0FBZUYsSUFBZixDQUE1QjtHQURGO0NBUmEsRUFBZjs7Ozs7Ozs7OztBQXNCQSxJQUFNRyxTQUFTLFNBQVRBLE1BQVMsQ0FBU0MsT0FBVCxFQUFrQkMsS0FBbEIsRUFBeUI7U0FDL0JDLElBQVAsQ0FBWUQsS0FBWixFQUFtQkUsT0FBbkIsQ0FBMkIsVUFBU0MsR0FBVCxFQUFjO1FBQ25DQSxPQUFPSixRQUFRQyxLQUFuQixFQUEwQjtjQUNoQkEsS0FBUixDQUFjRyxHQUFkLElBQXFCSCxNQUFNRyxHQUFOLENBQXJCO0tBREYsTUFFTyxJQUFJckIsT0FBT3FCLEdBQVAsS0FBZUosUUFBUUMsS0FBM0IsRUFB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\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/onsenui/js/onsenui.js\n// module id = 3\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/timers-browserify/main.js\n// module id = 4\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 5\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 6\n// module chunks = 0","import List from './List';\n\nexport default class ListWords extends List\n{\n    constructor (page)\n    {\n        super(page);\n\n        this.plusButton = '#plus-word';\n        this.changeForm = 'change-words-form';\n\n        this.titleOfNewForm = 'New word';\n        this.titleOfEditForm = 'Edit word';\n\n        this.selectorOfList = '#change-words-items';\n        this.selectorOfChangeItem = `${this.selectorOfList} ons-list-item`;\n\n        this.ajaxOfGetAll = {\n            url: `${this.URL_OF_WORD_METHODS}/`,\n            method: 'GET'\n        };\n\n        this.init();\n    }\n\n    init ()\n    {\n        this.initOfPushToForm();\n        this.showItems();\n    }\n\n    /**\n     * @desc Define html each element\n     */\n    showItems ()\n    {\n        super.showItems({\n            showableHtml: (word) =>\n            {\n                const id = word._id;\n                const native = word.native;\n                const learnable = word.learnable;\n\n                return this.createOnsElement(id, native, learnable);\n            },\n            store: this.WINDOW_NAME_OF_WORDS\n        });\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/List/ListWords.js","import Global from './../Global';\n\nexport default class List extends Global\n{\n\tconstructor (page)\n\t{\n\t\tsuper(page);\n\n\t\t/**\n\t\t * @property plusButton\n\t\t * @desc Push to newItem page when click it\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis.plusButton = String;\n\t\t/**\n\t\t * @property changeForm\n\t\t * @desc newItem or editItem page,\n\t\t *       next page can be: onsen/partials/change-labels-form.pug, onsen/partials/change-words-form.\n\t\t *       value is an ID of template\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis.changeForm = String;\n\n\t\t/**\n\t\t * @property titleOfNewForm\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis.titleOfNewForm = String;\n\t\t/**\n\t\t * @property titleOfEditForm\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis.titleOfEditForm = String;\n\n\t\t/**\n\t\t * @property selectorOfList\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis.selectorOfList = String;\n\t\t/**\n\t\t * @property selectorOfChangeItem\n\t\t * @type {String}\n\t\t * @protected\n\t\t */\n\t\tthis.selectorOfChangeItem = String;\n\n\t\t/**\n\t\t * @property ajaxOfGetAll\n\t\t * @type {{url: String, method: string}}\n\t\t * @protected\n\t\t */\n\t\tthis.ajaxOfGetAll = {\n\t\t\turl: String,\n\t\t\tmethod: 'GET'\n\t\t};\n\t}\n\n\n\t/**\n\t * @desc Call Global.downAndShow() after that add click event\n\t *       listener each showed element what'll pass to changeForm\n\t *\n\t * @param {function} showableHtml\n\t * @param {string} store\n\t */\n\tshowItems ({ showableHtml, store })\n\t{\n\t\tthis.downAndShow({\n\t\t\tmethod: this.ajaxOfGetAll.method,\n\t\t\turl: this.ajaxOfGetAll.url,\n\t\t\tshowWhere: this.selectorOfList,\n\t\t\tshowableHtml: showableHtml,\n\t\t\tstore: store,\n\t\t\tafter: () =>\n\t\t\t{\n\t\t\t\tlet clickableItems = this.qAll(this.selectorOfChangeItem);\n\t\t\t\tfor (let clickableItem of clickableItems)\n\t\t\t\t{\n\t\t\t\t\tclickableItem.addEventListener('click', () =>\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.pushPage(this.changeForm, {\n\t\t\t\t\t\t\ttitle: this.titleOfEditForm,\n\t\t\t\t\t\t\titem: window[store].find((item) => item._id == clickableItem.dataset.id),\n\t\t\t\t\t\t}, 'lift');\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @desc Add a click event listener to plusButton for push page to form\n\t *       Not called basically\n\t */\n\tinitOfPushToForm ()\n\t{\n\t\tthis.page.querySelector(this.plusButton)\n\t\t\t.addEventListener('click', () =>\n\t\t\t{\n\t\t\t\tthis.pushPage(this.changeForm, { title: this.titleOfNewForm });\n\t\t\t});\n\t}\n\n\t/**\n\t * @desc Send 'titleOfNewForm' and 'titleOfEditForm' arguments to next page automatically\n\t *       as titleOfNew and titleOfEdit\n\t *\n\t * @param {string} where\n\t * @param {object} data\n\t * @param {string} animation\n\t */\n\tpushPage (where, data = {}, animation = '')\n\t{\n\t\tdata.titleOfNew = this.titleOfNewForm;\n\t\tdata.titleOfEdit = this.titleOfEditForm;\n\n\t\tsuper.pushPage(where, data, animation);\n\t}\n\n\tpostPushBack (page)\n\t{\n\t\tsuper.postPushBack(page);\n\n\t\tconst data = page.data;\n\n\t\tswitch (data.event)\n\t\t{\n\t\t\tcase this.EVENT_ADD_NEW_ITEM:\n\t\t\t{\n\t\t\t\tconst { id, native, learnable } = data.newItem;\n\t\t\t\tthis.setDomElement({ where: this.selectorOfList, html: this.createOnsElement(id, native, learnable) });\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase this.EVENT_REMOVE_AN_ITEM:\n\t\t\t{\n\t\t\t\tthis.q(`${this.selectorOfChangeItem}[data-id=\"${data.removedId}\"]`).remove();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase this.EVENT_EDIT_AN_ITEM:\n\t\t\t{\n\t\t\t\tconst {id,native,learnable,labelId,photo} = data.editedItem;\n\n\t\t\t\tconst edited = this.q(`${this.selectorOfChangeItem}[data-id=\"${id}\"]`);\n\t\t\t\tedited.querySelector('.left').innerHTML = native;\n\t\t\t\tedited.querySelector('.right').innerHTML = learnable;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\n\t/**\n\t * @param {string} id\n\t * @param {string} native\n\t * @param {string} learnable\n\t */\n\tcreateOnsElement(id, native, learnable)\n\t{\n\t\treturn super.createOnsElement(\n\t\t    `<ons-list-item data-id=${id} tappable modifier=\"longdivider\">\n                <div class=\"left\">${native}</div>\n                <div class=\"center\"><ons-icon icon=\"arrows-h\"></ons-icon></div>\n                <div class=\"right\">${learnable}</div>\n\t\t\t</ons-list-item>`\n        );\n\t}\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/List/List.js","import Form from './Form';\n\nexport default class WordsForm extends Form\n{\n    constructor(page)\n    {\n        super(page);\n\n        /**\n         * @property SELECTOR_OF_NATIVE\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_NATIVE = '#native';\n        /**\n         * @property SELECTOR_OF_LEARNABLE\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_LEARNABLE = '#learnable';\n        /**\n         * @property SELECTOR_OF_UPLOAD_FILE\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_UPLOAD_FILE = '#upload-file'\n        /**\n         * @property SELECTOR_OF_SHOWED_UPLOAD_INPUT\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_SHOWED_UPLOAD_INPUT = '#file-upload-input';\n        /**\n         * @property SELECTOR_OF_PHOTO_PREVIEW\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_PHOTO_PREVIEW = '.photo-preview';\n        /**\n         * @property SELECTOR_OF_SAVE_BUTTON\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_SAVE_BUTTON = '#save';\n        /**\n         * @property SELECTOR_OF_LABEL\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_LABEL = '#label-input';\n\n\n        this.ajaxOfSaveOne = {\n            url: `${this.URL_OF_WORD_METHODS}/`,\n            method: 'POST'\n        };\n        this.ajaxOfEditOne = {\n            url: `${this.URL_OF_WORD_METHODS}/`,\n            method: 'PUT'\n        };\n        this.ajaxOfDeleteOne = {\n            url: `${this.URL_OF_WORD_METHODS}/`,\n            method: 'DELETE'\n        };\n\n        this.ajaxOfSavePhoto = {\n            url: `/files/photo/`,\n            method: 'POST'\n        };\n        this.ajaxOfEditPhoto = {\n            url: `/files/photo/`,\n            method: 'PUT'\n        };\n\n        this.init();\n    }\n\n    init ()\n    {\n        super.init();\n\n        this.getLabelsForSelect();\n        this.handlingOfUploadFile();\n    }\n\n    /**\n     * @desc Call super function and pass default selectors\n     *\n     * @param {function} callback\n     */\n    validate (callback)\n    {\n        super.validate([this.SELECTOR_OF_NATIVE, this.SELECTOR_OF_LEARNABLE], callback);\n    }\n\n    setNewItem ()\n    {\n        this.validate(() =>\n        {\n            const file = this.getFile();\n            let data = {\n                native: this.getNative(),\n                learnable: this.getLearnable(),\n                label: this.getLabel()\n            };\n\n\n            if (file)\n            {\n                return this.ajax({\n                    method: this.ajaxOfSavePhoto.method,\n                    url: this.ajaxOfSavePhoto.url,\n                    data: file,\n                    file: true,\n                    success: (photo) =>\n                    {\n                        data.photo = photo;\n                        super.setNewItem({data: data});\n                    }\n                });\n            }\n\n            return super.setNewItem({data});\n        });\n    }\n\n\n    showLabelsInInput ()\n    {\n        super.showLabelsInInput(this.SELECTOR_OF_LABEL);\n    }\n\n    setValues ()\n    {\n        const word = this.page.data.item;\n\n        this.q(this.SELECTOR_OF_NATIVE).value = word.native;\n        this.q(this.SELECTOR_OF_LEARNABLE).value = word.learnable;\n        this.showPhoto(word.photo);\n        this.q(this.SELECTOR_OF_LABEL).value = word.labelId;\n    }\n\n    editItem ()\n    {\n        this.validate(() =>\n        {\n            const file = this.getFile();\n            const oldPhoto = this.page.data.item.photo;\n            let data = {\n                id: this.page.data.item._id,\n                native: this.getNative(),\n                learnable: this.getLearnable(),\n                label: this.getLabel(),\n            };\n\n            if (file)\n            {\n                return this.ajax({\n                    method: this.ajaxOfEditPhoto.method,\n                    url: this.ajaxOfEditPhoto.url,\n                    file: true,\n                    data: file,\n                    success: (photo) =>\n                    {\n                        data.photo = photo;\n                        super.editItem(data, this.WINDOW_NAME_OF_WORDS);\n                    }\n                });\n            }\n\n            super.editItem(data, this.WINDOW_NAME_OF_WORDS);\n        });\n    }\n\n\n    /**\n     * @desc Change event listener of file upload input\n     */\n    handlingOfUploadFile ()\n    {\n        this.q(this.SELECTOR_OF_UPLOAD_FILE).addEventListener('change', (event) =>\n        {\n            let files = event.target.files;\n\n            if (files && files.length > 0)\n            {\n                const file = files[0];\n                const showedUploadInput = document.querySelector(this.SELECTOR_OF_SHOWED_UPLOAD_INPUT);\n\n\n                showedUploadInput.value = file.name;\n\n                if (file.type.split('/')[0] !== 'image')\n                {\n                    this.q(this.SELECTOR_OF_PHOTO_PREVIEW).removeAttribute('src');\n                    showedUploadInput.dataset.error = 'Images upload only';\n                    this.q(this.SELECTOR_OF_SAVE_BUTTON).disabled = true;\n                }\n                else\n                {\n                    this.preShowPhoto(file);\n                    delete showedUploadInput.dataset.error;\n                    this.q(this.SELECTOR_OF_SAVE_BUTTON).disabled = false;\n                }\n            }\n        });\n    }\n\n    /**\n     * @desc Programmatically basic if show photo, it call this.showPhoto()\n     * @param {File} file\n     */\n    preShowPhoto (file)\n    {\n        const reader = new FileReader();\n        reader.onload = (e) =>\n        {\n            this.showPhoto(e.target.result);\n        };\n        reader.readAsDataURL(file);\n    }\n\n    /**\n     * @desc Actually show the photo\n     * @param {string} photo - Name of photo or a whole photo hashed by base64\n     */\n    showPhoto (photo)\n    {\n        if (photo)\n        {\n            photo = (photo.search('base64') > -1) ? photo : `${this.DIRECTORY_OF_PHOTOS}/${photo}`;\n            this.q(this.SELECTOR_OF_PHOTO_PREVIEW).setAttribute('src', photo);\n        }\n    }\n\n\n\n    getNative ()\n    {\n        return this.q(this.SELECTOR_OF_NATIVE).value;\n    }\n\n    getLearnable ()\n    {\n        return this.q(this.SELECTOR_OF_LEARNABLE).value\n    }\n\n    getLabel ()\n    {\n        return this.q(this.SELECTOR_OF_LABEL).value\n    }\n\n    getFile ()\n    {\n        return this.q(this.SELECTOR_OF_UPLOAD_FILE).files[0];\n    }\n\n    /*initInputs ()\n    {\n        const native = this.datasForInputs.native;\n        const learnable = this.datasForInputs.learnable;\n\n        this.addPlusEvent(native.selectorOfPlus, native.selectorOfList, native.whichLanguage);\n        this.addPlusEvent(learnable.selectorOfPlus, learnable.selectorOfList, learnable.whichLanguage);\n    }\n\n\n    addPlusEvent (selectorOfPlus, selectorOfList, whichLanguage)\n    {\n        this.q(selectorOfPlus).parentNode.addEventListener(\n            'click',\n            () => this.plus(selectorOfList, whichLanguage),\n            false\n        );\n    };\n\n    plus (selectorOfList, whichLanguage)\n    {\n        const numberOfInput = this.qAll(selectorOfList + ' ons-input').length + 1;\n\n\n        let inputWrapper = document.createElement('div');\n        inputWrapper.className = 'input-wrapper';\n\n        inputWrapper.appendChild(this.createOnsElement(\n            `<ons-input \n                modifier=\"underbar\" \n                placeholder=\"#${numberOfInput}\" \n                float \n                id=\"${whichLanguage}-${numberOfInput}\">\n            </ons-input>`\n        ));\n        inputWrapper.appendChild(this.createOnsElement(\n            `<ons-icon icon=\"ion-minus-round\"></ons-icon>`\n        ));\n\n        this.q(selectorOfList).appendChild(inputWrapper);\n\n        this.addMinusEvent();\n    };\n\n    addMinusEvent ()\n    {\n        let minusIcons = this.qAll('.input-wrapper ons-icon');\n        const numberOfMinusIcons = minusIcons.length;\n\n        for (let index = 0; index < numberOfMinusIcons; index++)\n        {\n            minusIcons[index].addEventListener('click', this.minus);\n        }\n    };\n\n    minus (event)\n    {\n        let deletable = event.target.parentNode;\n        deletable.parentNode.removeChild(deletable);\n    };*/\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/Form/WordsForm.js","import Global from './../Global';\n\nexport default class Form extends Global\n{\n    constructor (page)\n    {\n        super(page);\n\n        /**\n         * @property SELECTORS\n         * @type {{SAVE_BUTTON: string, DELETE_BUTTON: string, DELETE_WRAPPER: string}}\n         * @const\n         */\n        this.SELECTORS = {\n            SAVE_BUTTON: '#save',\n            DELETE_BUTTON: '#delete',\n            DELETE_WRAPPER: '#delete-wrapper'\n        };\n\n        /**\n         * @property ajaxOfSaveOne\n         * @type {{url: String, method: string}}\n         * @protected\n         */\n        this.ajaxOfSaveOne = {\n            url: String,\n            method: 'POST'\n        };\n        /**\n         * @property ajaxOfEditOne\n         * @type {{url: String, method: string}}\n         * @protected\n         */\n        this.ajaxOfEditOne = {\n            url: String,\n            method: 'PUT'\n        };\n        /**\n         * @property ajaxOfDeleteOne\n         * @type {{url: String, method: string}}\n         * @protected\n         */\n        this.ajaxOfDeleteOne = {\n            url: String,\n            method: 'DELETE'\n        };\n    }\n\n\n    /**\n     * @desc Mainly look and choose setNewItem or editItem\n     */\n    init ()\n    {\n        this.q(this.SELECTOR_OF_TITLE).innerHTML = this.page.data.title;\n\n        let listenerOfSaveButtonClick = this.setNewItem.bind(this); //this is default\n        if (this.page.data.title === this.page.data.titleOfEdit && typeof this.page.data.item === 'object')\n        {\n            this.setValues();\n            listenerOfSaveButtonClick = this.editItem.bind(this); //if wanna\n\n            this.setUpDeleteButton();\n        }\n\n\n        this.q(this.SELECTORS.SAVE_BUTTON).addEventListener('click', () => listenerOfSaveButtonClick());\n    }\n\n    /**\n     * @desc Show error and return false in callback if now valid otherwise return true\n     *\n     * @param {array} selectors\n     * @param {function} callback\n     * @return {boolean|function}\n     */\n    validate (selectors, callback)\n    {\n        let valid = true;\n\n        for (const selector of selectors)\n        {\n            let input = this.q(selector);\n\n            if (input.value)\n            {\n                delete input.dataset.error;\n            }\n            else\n            {\n                input.dataset.error = 'Have to be filled';\n                valid = false;\n            }\n        }\n\n        if (valid)\n        {\n            return callback(valid);\n        }\n\n        return false;\n    }\n\n    /**\n     * @param {object} data\n     * @param {string} store\n     */\n    setNewItem ({data, store})\n    {\n        this.ajax({\n            method: this.ajaxOfSaveOne.method,\n            url: this.ajaxOfSaveOne.url,\n            data: data,\n            success: (response) =>\n            {\n                if (response && response.success && response.insertedId && response.userId)\n\t\t\t\t{\n\t\t\t\t\tdata._id = response.insertedId;\n\t\t\t\t\tdata.userId = response.userId;\n\t\t\t\t\twindow[store].push(data);\n\n\t\t\t\t\tthis.pushBack({refresh: true, data: { event: this.EVENT_ADD_NEW_ITEM, newItem: data } });\n\t\t\t\t}\n            }\n        });\n    }\n\n    /**\n     * @desc Default values\n     */\n    setValues () {}\n\n    /**\n     * @param {object} data\n     * @param {string} store\n     */\n    editItem (data, store)\n\t{\n\t\tthis.ajax({\n\t\t\tmethod: this.ajaxOfEditOne.method,\n\t\t\turl: this.ajaxOfEditOne.url,\n\t\t\tdata: data,\n\t\t\tsuccess: (response) =>\n\t\t\t{\n\t\t\t\tif (response)\n\t\t\t\t{\n\t\t\t\t\tconsole.log(window[store], data);\n\t\t\t\t\tconst index = window[store].find(item => item._id === data.id);\n\t\t\t\t\tconsole.log(index);\n\t\t\t\t\tif (index)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata._id = data.id;\n\n\t\t\t\t\t\twindow[store][index] = data;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.pushBack({ data: { event: this.EVENT_EDIT_AN_ITEM, editedItem: data } });\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n    setUpDeleteButton ()\n    {\n        this.setDomElement({\n            where: this.SELECTORS.DELETE_WRAPPER,\n            html: '<ons-button modifier=\"large\" id=\"delete\" class=\"red\">Delete</ons-button>',\n            callback: () =>\n            {\n                this.q(this.SELECTORS.DELETE_BUTTON).addEventListener('click', this.deleteItem.bind(this));\n            }\n        });\n    }\n\n    deleteItem ()\n    {\n        const id = this.page.data.item._id;\n\n        this.ajax({\n            method: this.ajaxOfDeleteOne.method,\n            url: this.ajaxOfDeleteOne.url,\n            data: {id: id},\n            success: () =>\n\t\t\t{\n\t\t\t\tthis.pushBack({ data: { event: this.EVENT_REMOVE_AN_ITEM, removedId: id } });\n\t\t\t}\n        });\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/Form/Form.js","import List from './List';\n\nexport default class ListLabels extends List\n{\n    constructor(page)\n    {\n        super(page);\n\n        this.plusButton = '#plus-label';\n        this.changeForm = 'change-label-form';\n\n        this.titleOfNewForm = 'New label';\n        this.titleOfEditForm = 'Edit label';\n\n        this.selectorOfList = '#change-labels-items';\n        this.selectorOfChangeItem = `${this.selectorOfList} ons-list-item`;\n\n        this.ajaxOfGetAll = {\n            url: `${this.URL_OF_LABEL_METHODS}/`,\n            method: 'GET'\n        };\n\n        this.init();\n    }\n\n    init ()\n    {\n        this.showItems();\n        this.initOfPushToForm();\n    }\n\n    /**\n     * @desc Define html each element\n     */\n    showItems ()\n    {\n        super.showItems({\n            showableHtml: (label) =>\n            {\n                const id = label._id;\n                const name = label.name;\n\n                return this.createOnsElement(\n                    `<ons-list-item data-id=\"${id}\" tappable modifier=\"longdivider\">` +\n                        `<div class=\"center\">${name}</div>` +\n                        `<div class=\"right\"><ons-icon icon=\"ion-edit\"></ons-icon></div>` +\n                    `</ons-list-item>`\n                );\n            },\n            store: 'labels'\n        });\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/List/ListLabels.js","import Form from './Form';\n\nexport default class LabelsForm extends Form\n{\n    constructor(page)\n    {\n\n        super(page);\n\n        this.SELECTOR_OF_LABEL_INPUT = '#label';\n\n        //CHECK @define in jsdoc\n        this.ajaxOfSaveOne = {\n            url: `${this.URL_OF_LABEL_METHODS}/`,\n            method: 'POST'\n        };\n        this.ajaxOfEditOne = {\n            url: `${this.URL_OF_LABEL_METHODS}/`,\n            method: 'PUT'\n        };\n        this.ajaxOfDeleteOne = {\n            url: `${this.URL_OF_LABEL_METHODS}/`,\n            method: 'DELETE'\n        };\n\n\n        this.init();\n    }\n\n    /**\n     * @desc Call super function and pass default selectors\n     *\n     * @param {function} callback\n     */\n    validate (callback)\n    {\n        super.validate([this.SELECTOR_OF_LABEL_INPUT], callback);\n    }\n\n    setNewItem ()\n    {\n        this.validate(() =>\n        {\n            super.setNewItem({\n                data:{\n                    label: this.getLabelFromInput()\n                }\n            });\n        });\n    }\n\n    setValues ()\n    {\n        this.q(this.SELECTOR_OF_LABEL_INPUT).value = this.page.data.item.name;\n    }\n\n    editItem ()\n    {\n        this.validate(() =>\n        {\n            super.editItem({\n                userId: this.page.data.item.userId,\n                oldLabel: this.page.data.item.name,\n                newLabel: this.getLabelFromInput()\n            }, tihs.WINDOW_NAME_OF_WORDS);\n        });\n    }\n\n    getLabelFromInput ()\n    {\n        return this.q(this.SELECTOR_OF_LABEL_INPUT).value;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/Form/LabelsForm.js","import GameSettings from './GameSettings';\nimport * as Cookies from 'js-cookie';\n\nexport default class SettingsLearn extends GameSettings\n{\n    constructor (page)\n    {\n        super(page);\n\n        this.nextButton = '#go-learn';\n        this.changeForm = 'learn';\n\n        /**\n         * @property SELECTOR_OF_SORT\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_SORT = '#sort';\n        /**\n         * @property SELECTOR_OF_LABEL\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_LABEL = '#label';\n        /**\n         * @property SELECTOR_OF_SHOW_BOTH\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_SHOW_BOTH = '#show-both';\n        /**\n         * @property SELECTOR_OF_WHICH_SHOW_FIRST\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_WHICH_SHOW_FIRST = '#show-first';\n        /**\n         * @property SELECTOR_OF_LOOP\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_LOOP = '#loop';\n\n        this.init();\n    }\n\n    /**\n     * @param {function} callback\n     */\n    getValue (callback)\n    {\n        const data = {\n            sort: this.q(this.SELECTOR_OF_SORT).value,\n            label: this.q(this.SELECTOR_OF_LABEL).value,\n            showBoth: this.q(this.SELECTOR_OF_SHOW_BOTH).checked,\n            showFirst: this.q(this.SELECTOR_OF_WHICH_SHOW_FIRST).value,\n            loop: this.q(this.SELECTOR_OF_LOOP).checked\n        };\n\n        return callback(data);\n    }\n\n    setDefaultValue ()\n    {\n        let data = Cookies.get('learn-settings');\n        data = (data) ? JSON.parse(data) : {};\n\n        this.q(this.SELECTOR_OF_SORT).value = data.sort || 0;\n        this.q(this.SELECTOR_OF_SHOW_BOTH).checked = data.showBoth || false;\n        this.q(this.SELECTOR_OF_WHICH_SHOW_FIRST).value = data.showFirst || 0;\n        this.q(this.SELECTOR_OF_LABEL).value = data.label || 0;\n        this.q(this.SELECTOR_OF_LOOP).checked =\n            (data.loop == true || data.loop == false)\n                ? data.loop\n                : true; //default value want to be true\n    }\n\n    saveAsDefaultValues (data)\n    {\n        this.setCookie('learn-settings', JSON.stringify(data));\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/GameSettings/SettingsLearn.js","import Global from './../Global';\n\nexport default class GameSettings extends Global\n{\n    constructor (page)\n    {\n        super(page);\n\n        /**\n         * @property nextButton\n         * @type {String}\n         * @protected\n         */\n        this.nextButton = String;\n        /**\n         * @property changeForm\n         * @type {String}\n         * @protected\n         */\n        this.changeForm = String;\n\n        /**\n         * @property SELECTOR_OF_LABEL_INPUT\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_LABEL_INPUT = '#label';\n    }\n\n\n    init ()\n    {\n        this.getLabelsForSelect(this.SELECTOR_OF_LABEL_INPUT, this.setDefaultValue.bind(this));\n        this.initOfPushToGame();\n\n    }\n\n\n    initOfPushToGame ()\n    {\n        this.q(this.nextButton).addEventListener('click', () =>\n        {\n            this.getValue((data) =>\n            {\n                this.pushPage(this.changeForm, { data: data });\n                this.saveAsDefaultValues(data);\n            });\n        });\n    }\n\n    /**\n     * @param {function} callback\n     */\n    getValue (callback = new Function())\n    {\n        return callback();\n    }\n\n    saveAsDefaultValues () {}\n\n    setDefaultValue () {}\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/GameSettings/GameSettings.js","/*!\n * JavaScript Cookie v2.2.0\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n * Released under the MIT license\n */\n;(function (factory) {\n\tvar registeredInModuleLoader = false;\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(factory);\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (typeof exports === 'object') {\n\t\tmodule.exports = factory();\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (!registeredInModuleLoader) {\n\t\tvar OldCookies = window.Cookies;\n\t\tvar api = window.Cookies = factory();\n\t\tapi.noConflict = function () {\n\t\t\twindow.Cookies = OldCookies;\n\t\t\treturn api;\n\t\t};\n\t}\n}(function () {\n\tfunction extend () {\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (; i < arguments.length; i++) {\n\t\t\tvar attributes = arguments[ i ];\n\t\t\tfor (var key in attributes) {\n\t\t\t\tresult[key] = attributes[key];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction init (converter) {\n\t\tfunction api (key, value, attributes) {\n\t\t\tvar result;\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Write\n\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tattributes = extend({\n\t\t\t\t\tpath: '/'\n\t\t\t\t}, api.defaults, attributes);\n\n\t\t\t\tif (typeof attributes.expires === 'number') {\n\t\t\t\t\tvar expires = new Date();\n\t\t\t\t\texpires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);\n\t\t\t\t\tattributes.expires = expires;\n\t\t\t\t}\n\n\t\t\t\t// We're using \"expires\" because \"max-age\" is not supported by IE\n\t\t\t\tattributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';\n\n\t\t\t\ttry {\n\t\t\t\t\tresult = JSON.stringify(value);\n\t\t\t\t\tif (/^[\\{\\[]/.test(result)) {\n\t\t\t\t\t\tvalue = result;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\n\t\t\t\tif (!converter.write) {\n\t\t\t\t\tvalue = encodeURIComponent(String(value))\n\t\t\t\t\t\t.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n\t\t\t\t} else {\n\t\t\t\t\tvalue = converter.write(value, key);\n\t\t\t\t}\n\n\t\t\t\tkey = encodeURIComponent(String(key));\n\t\t\t\tkey = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);\n\t\t\t\tkey = key.replace(/[\\(\\)]/g, escape);\n\n\t\t\t\tvar stringifiedAttributes = '';\n\n\t\t\t\tfor (var attributeName in attributes) {\n\t\t\t\t\tif (!attributes[attributeName]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstringifiedAttributes += '; ' + attributeName;\n\t\t\t\t\tif (attributes[attributeName] === true) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tstringifiedAttributes += '=' + attributes[attributeName];\n\t\t\t\t}\n\t\t\t\treturn (document.cookie = key + '=' + value + stringifiedAttributes);\n\t\t\t}\n\n\t\t\t// Read\n\n\t\t\tif (!key) {\n\t\t\t\tresult = {};\n\t\t\t}\n\n\t\t\t// To prevent the for loop in the first place assign an empty array\n\t\t\t// in case there are no cookies at all. Also prevents odd result when\n\t\t\t// calling \"get()\"\n\t\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\t\t\tvar rdecode = /(%[0-9A-Z]{2})+/g;\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < cookies.length; i++) {\n\t\t\t\tvar parts = cookies[i].split('=');\n\t\t\t\tvar cookie = parts.slice(1).join('=');\n\n\t\t\t\tif (!this.json && cookie.charAt(0) === '\"') {\n\t\t\t\t\tcookie = cookie.slice(1, -1);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tvar name = parts[0].replace(rdecode, decodeURIComponent);\n\t\t\t\t\tcookie = converter.read ?\n\t\t\t\t\t\tconverter.read(cookie, name) : converter(cookie, name) ||\n\t\t\t\t\t\tcookie.replace(rdecode, decodeURIComponent);\n\n\t\t\t\t\tif (this.json) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcookie = JSON.parse(cookie);\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key === name) {\n\t\t\t\t\t\tresult = cookie;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!key) {\n\t\t\t\t\t\tresult[name] = cookie;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\tapi.set = api;\n\t\tapi.get = function (key) {\n\t\t\treturn api.call(api, key);\n\t\t};\n\t\tapi.getJSON = function () {\n\t\t\treturn api.apply({\n\t\t\t\tjson: true\n\t\t\t}, [].slice.call(arguments));\n\t\t};\n\t\tapi.defaults = {};\n\n\t\tapi.remove = function (key, attributes) {\n\t\t\tapi(key, '', extend(attributes, {\n\t\t\t\texpires: -1\n\t\t\t}));\n\t\t};\n\n\t\tapi.withConverter = init;\n\n\t\treturn api;\n\t}\n\n\treturn init(function () {});\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/js-cookie/src/js.cookie.js\n// module id = 15\n// module chunks = 0","import Game from './Game';\n\nexport default class Learn extends Game\n{\n    constructor (page)\n    {\n        super(page);\n\n        /**\n         * @property AJAX_OF_GET_WORDS_FOR_LEARN\n         * @type {{URL: string, METHOD: string}}\n         * @const\n         */\n        this.AJAX_OF_GET_WORDS_FOR_LEARN = {\n            URL: `${this.URL_OF_GAME_METHODS}/:label/:sort/:first`,\n            METHOD: 'GET'\n        };\n\n        /**\n         * @property CURRENT_PAGE_NAME\n         * @type {string}\n         * @const\n         */\n        this.CURRENT_PAGE_NAME = 'learn';\n        /**\n         * @property SELECTOR_OF_PROGRESS_BAR\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_PROGRESS_BAR = '#progress';\n        /**\n         * @property SELECTOR_OF_PROGRAM_AREA\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_PROGRAM_AREA = '#learn-area';\n        /**\n         * @property SELECTOR_OF_BACK_BUTTON_WHEN_NO_RESULT\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_BACK_BUTTON_WHEN_NO_RESULT = '#back-to-settings';\n        /**\n         * @property SELECTOR_OF_NEXT_BUTTON\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_NEXT_BUTTON = '#next';\n        /**\n         * @property LEARNABLE\n         * @type {{SELECTOR: string, SPACE_OF_WORD: string, IMAGE: string}}\n         * @const\n         */\n        this.LEARNABLE = {\n            SELECTOR: '#learnable',\n            SPACE_OF_WORD: '#learnable .card p',\n            IMAGE: '#learnable img'\n        };\n        /**\n         * @property NATIVE\n         * @type {{SELECTOR: string, SPACE_OF_WORD: string, IMAGE: string}}\n         * @const\n         */\n        this.NATIVE = {\n            SELECTOR: '#native',\n            SPACE_OF_WORD: '#native .card p',\n            IMAGE: '#native img'\n        };\n\n        /**\n         * @property animationDelay\n         * @desc In millisecond for setTimeout()\n         * @type {number}\n         * @default 400\n         */\n        this.animationDelay = 400;\n\n\n        //from previous page\n        const data = this.page.data.data;\n        this.label = data.label;\n        this.sort = data.sort;\n        this.showBoth = data.showBoth;\n        this.showFirst = Number(data.showFirst);\n        this.loop = data.loop;\n\n        //for learn\n        this.words = [];\n        this.index = 0;\n        this.progressRate = null;\n\n\n        this.getWords();\n        this.addLearnClassToContentWrapper();\n    }\n\n\n    getWords ()\n    {\n        this.ajax({\n            method: this.AJAX_OF_GET_WORDS_FOR_LEARN.METHOD,\n            url: `${this.AJAX_OF_GET_WORDS_FOR_LEARN.URL}/`,\n            data: {\n                label: this.label,\n                sort: this.sort,\n                first: this.showFirst\n            },\n            success: (response) =>\n            {\n                if (response && response.length > 0)\n                {\n                    this.words = response;\n                    this.progressRate = this._getProgressRate();\n                    this._startTheLearn();\n                }\n                else\n                {\n                    this._setNoResult();\n                }\n            }\n        })\n    }\n\n    /**\n     * @return {*}\n     * @private\n     */\n    _startTheLearn ()\n    {\n        if (this.words.length <= 0)\n        {\n            return this._setNoResult();\n        }\n\n        this.first();\n    }\n\n    first ()\n    {\n        this._setProgressValue();\n\n        this._setLearnContentTemplate(this.getLearnContentSelector(), () =>\n        {\n            setTimeout(this._nextWord.bind(this), 300);\n            this._setNextContent();\n        });\n\n\n        this.q(this.SELECTOR_OF_NEXT_BUTTON).addEventListener('click', this.next.bind(this));\n    }\n\n    /**\n     * Event listener of next button\n     */\n    next ()\n    {\n        this.disableNextButton();\n\n        this.index++;\n\n        this._setProgressValue();\n\n        this._deletePreviousContent();\n        this._setCurrentContent();\n\n        if (this.words[this.index+1])\n        {\n            this._setNextContent();\n        }\n        else\n        {\n            if (this.loop)\n            {\n                this.index = -1;\n                this._setNextContent();\n            }\n            else\n            {\n                this.hideNextButton();\n            }\n        }\n    }\n\n    _deletePreviousContent ()\n    {\n        let previous = this.q(this.getLearnContentSelector(false));\n        previous.classList.add('go-away');\n\n        setTimeout(() =>\n        {\n            previous.parentNode.removeChild(previous);\n        }, this.animationDelay)\n    }\n\n    _setCurrentContent ()\n    {\n        this._nextWord();\n\n        let currentContent = this.q(this.getLearnContentSelector());\n        currentContent.classList.remove('hidden');\n        currentContent.classList.add('come-here');\n\n        setTimeout(() =>\n        {\n            this.enableNextButton();\n\n            currentContent.classList.remove('come-here');\n        }, this.animationDelay);\n    }\n\n    _setNextContent ()\n    {\n        this._setLearnContentTemplate(this.getLearnContentSelector(true) + ' hidden');\n    }\n\n    /**\n     * @private\n     */\n    _nextWord ()\n    {\n        const word = this.words[this.index];\n        const native = word.NATIVE;\n        const learnable = word.LEARNABLE;\n        const photo = word.photo;\n\n        let currentContentSelector = this.getLearnContentSelector() + ' ';\n\n        this.q(currentContentSelector + this.NATIVE.SPACE_OF_WORD).innerText = native;\n        this.q(currentContentSelector + this.LEARNABLE.SPACE_OF_WORD).innerText = learnable;\n        if (photo)\n        {\n            let pathOfPhoto = `${this.DIRECTORY_OF_PHOTOS}/${photo}`;\n\n            if (this.showBoth)\n            {\n                if (Boolean(this.showFirst)) //true -> native\n                {\n                    this.q(currentContentSelector + this.NATIVE.IMAGE).src = pathOfPhoto;\n                }\n                else //false -> learnable\n                {\n                    this.q(currentContentSelector + this.LEARNABLE.IMAGE).src = pathOfPhoto;\n                }\n            }\n            else\n            {\n                this.q(currentContentSelector + this.NATIVE.IMAGE).src\n                    = this.q(currentContentSelector + this.LEARNABLE.IMAGE).src\n                    = pathOfPhoto;\n            }\n        }\n\t}\n\n\n    /**\n     * @private\n     */\n    _setNoResult ()\n    {\n        this.setDomElement({\n            where: this.SELECTOR_OF_PROGRAM_AREA,\n            html:   '<p>So sorry, but I didn\\'t find any words with those settings...</p>' +\n                    '<p>' +\n                        '<ons-button id=\"back-to-settings\">' +\n                            '<ons-icon icon=\"ion-arrow-left-c, material:md-arrow-left\"></ons-icon>' +\n                            'Back' +\n                        '</ons-button>' +\n                    '</p>',\n            callback: this._setBackButtonListener.bind(this)\n        });\n\n        this.q(this.SELECTOR_OF_NEXT_BUTTON).className = 'hidden';\n    }\n\n    /**\n     * @private\n     */\n    _setBackButtonListener ()\n    {\n        this.q(this.SELECTOR_OF_BACK_BUTTON_WHEN_NO_RESULT).addEventListener('click', () =>\n        {\n            this.pushBack();\n        });\n    }\n\n    /**\n     * progress bar will be closer to toolbar\n     */\n    addLearnClassToContentWrapper ()\n    {\n        const contentWrapper = '.page__content';\n\n        const learnClass = 'learn';\n\n\n        let wrapper = this.q(contentWrapper);\n        wrapper.classList.add(learnClass);\n\n        if (!this.showBoth)\n        {\n            const notShowBothClass = 'single';\n\n            wrapper.classList.add(notShowBothClass);\n        }\n    }\n\n    /**\n     * @param {boolean|null} index\n     *      false - previous index\n     *      null - current index\n     *      true - next index\n     * @return {string}\n     */\n    getLearnContentSelector (index = null)\n    {\n        const basic = '.tabbar-';\n\n        switch (index)\n        {\n            case null:\n            default:\n                return basic + this.index;\n                break;\n            case false:\n                let previousIndex = this.index - 1;\n                if (previousIndex < 0)\n                {\n                    previousIndex = this.words.length - 1;\n                }\n                return basic + previousIndex;\n                break;\n            case true:\n                let nextIndex = this.index + 1;\n                if (nextIndex >= this.words.length)\n                {\n                    nextIndex = 0;\n                }\n                return basic + nextIndex;\n                break;\n\n        }\n    }\n\n    /**\n     * @param {string} cssClass\n     * @param {function} [callback]\n     * @private\n     */\n    _setLearnContentTemplate (cssClass, callback = new Function())\n    {\n        cssClass = (cssClass.charAt(0) === '.') ? cssClass.substring(1) : cssClass;\n        let html = '';\n\n        if (this.showBoth)\n        {\n            html = this.createOnsElement(\n                `<div class=\"word-container ${cssClass}\">` +\n                    `<div id=\"${(this.showFirst === 0) ? 'native' : 'learnable'}\">` +\n                        `<div class=\"card\">` +\n                            `<p></p>` +\n                        `</div>` +\n                    `</div>` +\n                    `<div id=\"${(this.showFirst === 1) ? 'native' : 'learnable'}\">` +\n                        `<div class=\"card\">` +\n                            `<p></p>` +\n                        `</div>` +\n                        `<img>` +\n                    `</div>` +\n                `</div>`\n            );\n        }\n        else\n        {\n            html = this.createOnsElement(\n                `<ons-tabbar class=\"word-container ${cssClass}\" animation=\"fade\">` +\n                    `<ons-tab label=\"Native\" page=\"native\" ${(this.showFirst === 0) ? 'active' : ''}></ons-tab>` +\n                    `<ons-tab label=\"Learnable\" page=\"learnable\" ${(this.showFirst === 1) ? 'active' : ''}></ons-tab>` +\n                `</ons-tabbar>`\n            );\n        }\n\n        this.setDomElement({\n            where: this.SELECTOR_OF_PROGRAM_AREA,\n            html: html,\n            callback: callback\n        });\n    }\n\n    /**\n     * @return {number}\n     * @private\n     */\n    _getProgressRate ()\n    {\n        return 100 / this.words.length;\n    }\n\n    /**\n     * @private\n     */\n    _setProgressValue ()\n    {\n        let result = this.progressRate * (this.index + 1);\n        //TODO this is not working in firefox at !showBoth\n        this.q(this.SELECTOR_OF_PROGRESS_BAR).value = result;\n    }\n\n    /**\n     * @private\n     */\n    _hideNextButton ()\n    {\n        this.q(this.SELECTOR_OF_NEXT_BUTTON).className = 'hidden';\n    }\n\n    disableNextButton ()\n    {\n        this.q(this.SELECTOR_OF_NEXT_BUTTON).setAttribute('disabled', '');\n    }\n\n    enableNextButton ()\n    {\n        this.q(this.SELECTOR_OF_NEXT_BUTTON).removeAttribute('disabled');\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/Game/Learn.js","import Global from './../Global';\n\nexport default class Game extends Global\n{\n    constructor (page)\n    {\n        super(page);\n\n        /**\n         * @property URL_OF_GAME_METHODS\n         * @type {string}\n         * @const\n         */\n        this.URL_OF_GAME_METHODS = `${this.URL_OF_WORD_METHODS}/game`;\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/Game/Game.js","export default class Quiz\n{\n    constructor (page)\n    {\n\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/Game/Quiz.js","import Global from './Global';\n\n/**\n * @param {string} style - Can be: light (default), dark\n * @param {string} colour - Can be: red, orange, yellow, green, teal-blue, blue (default), purple, pink\n */\nexport default class Settings extends Global\n{\n    constructor (page)\n    {\n        super(page);\n\n        /**\n         * @property SELECTOR_OF_STYLE\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_STYLE = '#style';\n        /**\n         * @property SELECTOR_OF_COLOUR\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_COLOUR = '#colour';\n        /**\n         * @property SELECTOR_OF_SAVE_BUTTON\n         * @type {string}\n         * @const\n         */\n        this.SELECTOR_OF_SAVE_BUTTON = '#save';\n\n        this.init();\n    }\n\n    init ()\n    {\n        this.setDefaultValues();\n        this.styleChange();\n        this.colourChange();\n        this.save();\n        this.pushBack();\n    }\n\n\n    setDefaultValues ()\n    {\n        this.q(this.SELECTOR_OF_STYLE).value = Cookies.get(this.COOKIE_NAME_OF_STYLE);\n        this.q(this.SELECTOR_OF_COLOUR).value = Cookies.get(this.COOKIE_NAME_OF_COLOUR);\n    }\n\n    styleChange ()\n    {\n        this._addChangeListener(this.SELECTOR_OF_STYLE, 'style');\n    }\n\n    colourChange ()\n    {\n        this._addChangeListener(this.SELECTOR_OF_COLOUR, 'colour');\n    }\n\n    save ()\n    {\n        this.q(this.SELECTOR_OF_SAVE_BUTTON).addEventListener('click', () =>\n        {\n            this.setCookie(this.COOKIE_NAME_OF_STYLE, this.q(this.SELECTOR_OF_STYLE).value);\n            this.setCookie(this.COOKIE_NAME_OF_COLOUR, this.q(this.SELECTOR_OF_COLOUR).value);\n        });\n    }\n\n    pushBack ()\n    {\n        this.q(this.BACK_BUTTON).addEventListener('click', () =>\n        {\n            super.pushBackWithRefresh();\n        });\n    }\n\n    /**\n     * @param {string} selector\n     * @param {string} dataset\n     * @private\n     */\n    _addChangeListener (selector, dataset)\n    {\n        this.q(selector).addEventListener('change', (event) =>\n        {\n            document.querySelector('html').dataset[dataset] = event.target.value;\n        });\n    }\n}\n\n\n// WEBPACK FOOTER //\n// ./assets/javascripts/menu/Settings.js"],"sourceRoot":""}